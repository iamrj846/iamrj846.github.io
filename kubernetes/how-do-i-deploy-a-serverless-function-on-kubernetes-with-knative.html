
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TFCQEJR7TD');
</script>
            <title>How Do I Deploy a Serverless Function on Kubernetes with Knative?</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to deploy a serverless function on Kubernetes using Knative in our step-by-step guide. Boost your cloud skills today!">

            <div id="head-placeholder"></div>
            <script src="/assets/js/blog.js" defer></script>
            <link rel="stylesheet" href="/assets/css/post.css">
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Do I Deploy a Serverless Function on Kubernetes with Knative?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Deploying a serverless function on Kubernetes with Knative is not too
hard. We use Knative, which is an open-source tool. It helps Kubernetes
give serverless features. Knative allows us to deploy and manage
serverless workloads. This means our applications can grow automatically
and react to events. We do not have to worry about the infrastructure
under it.</p>
<p>In this article, we will learn how to deploy a serverless function on
Kubernetes using Knative. We will look at important topics like what
Knative is and its benefits. We will also see how to set up a Kubernetes
cluster, install Knative, create a simple serverless function, and set
up the files we need for deployment. We will also talk about how to
monitor and scale, real-life examples, and how to fix common problems
with Knative deployments.</p>
<ul>
<li>How Can I Deploy a Serverless Function on Kubernetes Using
Knative?</li>
<li>What is Knative and Why Use It for Serverless Functions?</li>
<li>How Do I Set Up a Kubernetes Cluster for Knative?</li>
<li>How Can I Install Knative on My Kubernetes Cluster?</li>
<li>How Do I Create a Simple Serverless Function with Knative?</li>
<li>What Configuration Files Do I Need for Knative Deployments?</li>
<li>How Can I Monitor and Scale My Serverless Functions in Knative?</li>
<li>What Are Some Real-Life Use Cases for Deploying Serverless Functions
with Knative?</li>
<li>How Do I Troubleshoot Issues with Knative Deployments?</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about Kubernetes, we can find these
articles useful: <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubernetes-and-how-does-it-simplify-container-management.html">What
is Kubernetes and How Does it Simplify Container Management?</a>, <a
href="https://bestonlinetutorial.com/kubernetes/why-should-i-use-kubernetes-for-my-applications.html">Why
Should I Use Kubernetes for My Applications?</a>, and <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-set-up-a-kubernetes-cluster-on-aws-eks.html">How
Do I Set Up a Kubernetes Cluster on AWS EKS?</a>.</p>
<h2 id="what-is-knative-and-why-use-it-for-serverless-functions">What is
Knative and Why Use It for Serverless Functions?</h2>
<p>Knative is a free platform. It helps us make it easier to deploy and
manage serverless tasks on Kubernetes. It adds important tools to
Kubernetes. This helps developers build, deploy, and manage serverless
apps.</p>
<h3 id="key-features-of-knative">Key Features of Knative:</h3>
<ul>
<li><strong>Serving</strong>: It scales our apps up and down. This
happens based on demand. It can even scale down to zero. So, we only pay
for what we use.</li>
<li><strong>Eventing</strong>: Knative works with many event sources.
This lets our apps respond to events from different systems easily.</li>
<li><strong>Build</strong>: It helps us create container images from
source code. This makes the CI/CD process smoother.</li>
</ul>
<h3 id="benefits-of-using-knative-for-serverless-functions">Benefits of
Using Knative for Serverless Functions:</h3>
<ol type="1">
<li><strong>Simplified Development</strong>: We can focus on writing
code. We don’t need to worry about the infrastructure.</li>
<li><strong>Autoscaling</strong>: Knative changes the number of running
instances based on traffic. This helps us use resources better and save
money.</li>
<li><strong>Flexible Event Handling</strong>: It connects with many
event sources. This makes it easier to build apps that react to
events.</li>
<li><strong>Kubernetes Native</strong>: It is built on Kubernetes. This
means it uses Kubernetes’s strong features while giving us a serverless
experience.</li>
<li><strong>Portability</strong>: We can run Knative apps anywhere we
have Kubernetes. This gives us more options for different
environments.</li>
</ol>
<p>Knative is great for groups that want to use serverless design but
still want control over their Kubernetes clusters. It brings together
the best of both worlds. We get the scalability and management of
Kubernetes along with the ease of serverless computing. This makes
Knative a good choice for running serverless functions in cloud-native
apps.</p>
<p>For more info on how to use Knative well, you can check out <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">how
to use Knative for serverless workloads on Kubernetes</a>.</p>
<h2 id="how-do-we-set-up-a-kubernetes-cluster-for-knative">How Do We Set
Up a Kubernetes Cluster for Knative?</h2>
<p>To set up a Kubernetes cluster for running serverless functions with
Knative, we can follow these steps:</p>
<ol type="1">
<li><p><strong>Choose Our Environment:</strong> We can set up a
Kubernetes cluster on different platforms. Some options are AWS EKS,
Google GKE, Azure AKS, or we can run it locally using Minikube. Pick the
one that works best for us.</p></li>
<li><p><strong>Install Required Tools:</strong> We need to make sure we
have these tools installed:</p>
<ul>
<li><code>kubectl</code>: This is the command-line tool for working with
Kubernetes.</li>
<li><code>kustomize</code>: This tool helps us customize Kubernetes
resource settings.</li>
<li>A Kubernetes CLI for our chosen provider. For example, we need AWS
CLI for EKS.</li>
</ul></li>
<li><p><strong>Create a Kubernetes Cluster:</strong></p>
<ul>
<li><p><strong>Using Minikube:</strong></p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">minikube</span> start <span class="at">--kubernetes-version</span><span class="op">=</span>v1.21.0</span></code></pre></div></li>
<li><p><strong>Using AWS EKS:</strong></p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">aws</span> eks create-cluster <span class="at">--name</span> my-cluster <span class="at">--role-arn</span> <span class="op">&lt;</span>role-arn<span class="op">&gt;</span> --resources-vpc-config subnetIds=<span class="op">&lt;</span>subnet-ids<span class="op">&gt;</span>,securityGroupIds=<span class="op">&lt;</span>security-group-ids<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Using Google GKE:</strong></p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gcloud</span> container clusters create my-cluster <span class="at">--zone</span> us-central1-a</span></code></pre></div></li>
<li><p><strong>Using Azure AKS:</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">az</span> aks create <span class="at">--resource-group</span> myResourceGroup <span class="at">--name</span> myAKSCluster <span class="at">--node-count</span> 1 <span class="at">--enable-addons</span> monitoring <span class="at">--generate-ssh-keys</span></span></code></pre></div></li>
</ul></li>
<li><p><strong>Configure <code>kubectl</code>:</strong> After we set up
our cluster, we configure <code>kubectl</code> to use it:</p>
<ul>
<li><p><strong>For AWS EKS:</strong></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">aws</span> eks update-kubeconfig <span class="at">--name</span> my-cluster</span></code></pre></div></li>
<li><p><strong>For GKE:</strong></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">gcloud</span> container clusters get-credentials my-cluster <span class="at">--zone</span> us-central1-a</span></code></pre></div></li>
<li><p><strong>For AKS:</strong></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">az</span> aks get-credentials <span class="at">--resource-group</span> myResourceGroup <span class="at">--name</span> myAKSCluster</span></code></pre></div></li>
</ul></li>
<li><p><strong>Verify the Cluster:</strong> We check if our cluster is
running:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get nodes</span></code></pre></div></li>
<li><p><strong>Install Necessary Add-ons:</strong> We need to make sure
the following add-ons are installed:</p>
<ul>
<li><p>Metrics Server for getting resource metrics:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml</span></code></pre></div></li>
</ul></li>
<li><p><strong>Prepare for Knative Installation:</strong> Before we
install Knative, we check that our cluster meets the requirements. We
also need to enable any necessary Kubernetes features.</p></li>
</ol>
<p>This setup gives us a good base for running serverless functions with
Knative on our Kubernetes cluster. For more steps about installing
Knative, we can check “How Do We Install Knative on Our Kubernetes
Cluster?”</p>
<h2 id="how-can-we-install-knative-on-our-kubernetes-cluster">How Can We
Install Knative on Our Kubernetes Cluster?</h2>
<p>To install Knative on our Kubernetes cluster, we can follow these
steps:</p>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>We need a running Kubernetes cluster (v1.16 or higher).</li>
<li>We should have <code>kubectl</code> command-line tool installed to
access our cluster.</li>
<li>We also need the <code>kn</code> CLI tool for managing Knative.</li>
</ul>
<h3 id="step-1-install-the-knative-serving-component">Step 1: Install
the Knative Serving Component</h3>
<ol type="1">
<li><p><strong>Apply the Knative Serving YAML:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/knative/serving/releases/download/v1.8.0/serving.yaml</span></code></pre></div></li>
<li><p><strong>Check the installation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">-n</span> knative-serving</span></code></pre></div></li>
</ol>
<h3 id="step-2-install-the-knative-eventing-component-optional">Step 2:
Install the Knative Eventing Component (Optional)</h3>
<p>If we want event-driven features with Knative, we can install the
Eventing component:</p>
<ol type="1">
<li><p><strong>Apply the Knative Eventing YAML:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/knative/eventing/releases/download/v1.8.0/eventing.yaml</span></code></pre></div></li>
<li><p><strong>Check the installation:</strong></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">-n</span> knative-eventing</span></code></pre></div></li>
</ol>
<h3 id="step-3-install-a-networking-layer">Step 3: Install a Networking
Layer</h3>
<p>Knative needs a networking layer. We can use Istio, Contour, or
Kourier. For example, to install Kourier:</p>
<ol type="1">
<li><p><strong>Apply the Kourier YAML:</strong></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/kourier-project/kourier/releases/latest/download/kourier.yaml</span></code></pre></div></li>
<li><p><strong>Check the installation:</strong></p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">-n</span> kourier-system</span></code></pre></div></li>
</ol>
<h3 id="step-4-configure-dns">Step 4: Configure DNS</h3>
<p>We need to set up our DNS to point to the Kourier ingress. This
usually means creating a wildcard DNS entry that points to the IP of our
Kourier service.</p>
<h3 id="step-5-install-the-kn-cli-tool">Step 5: Install the
<code>kn</code> CLI Tool</h3>
<ol type="1">
<li><p><strong>Download the <code>kn</code> CLI:</strong></p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-Lo</span> kn.tar.gz https://github.com/knative/client/releases/latest/download/kn-linux-amd64.tar.gz</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">tar</span> <span class="at">-xvf</span> kn.tar.gz</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> install kn /usr/local/bin</span></code></pre></div></li>
<li><p><strong>Check <code>kn</code> installation:</strong></p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kn</span> version</span></code></pre></div></li>
</ol>
<h3 id="additional-resources">Additional Resources</h3>
<p>For more details and setups, we can check <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">How
Do I Use Knative for Serverless Workloads on Kubernetes?</a> for
examples and advanced configurations.</p>
<h2 id="how-do-we-create-a-simple-serverless-function-with-knative">How
Do We Create a Simple Serverless Function with Knative?</h2>
<p>To create a simple serverless function with Knative, we can follow
these steps:</p>
<ol type="1">
<li><p><strong>Write Our Function</strong>: We need to create a simple
HTTP function. For example, in Node.js, we can create a file named
<code>index.js</code>:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> http <span class="op">=</span> <span class="pp">require</span>(<span class="st">&#39;http&#39;</span>)<span class="op">;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> requestHandler <span class="op">=</span> (req<span class="op">,</span> res) <span class="kw">=&gt;</span> {</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    res<span class="op">.</span><span class="fu">end</span>(<span class="st">&#39;Hello, World!&#39;</span>)<span class="op">;</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>}<span class="op">;</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> server <span class="op">=</span> http<span class="op">.</span><span class="fu">createServer</span>(requestHandler)<span class="op">;</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> PORT <span class="op">=</span> <span class="bu">process</span><span class="op">.</span><span class="at">env</span><span class="op">.</span><span class="at">PORT</span> <span class="op">||</span> <span class="dv">8080</span><span class="op">;</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>server<span class="op">.</span><span class="fu">listen</span>(PORT<span class="op">,</span> () <span class="kw">=&gt;</span> {</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">console</span><span class="op">.</span><span class="fu">log</span>(<span class="vs">`Server is running on port </span><span class="sc">${</span>PORT<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>})<span class="op">;</span></span></code></pre></div></li>
<li><p><strong>Create a Dockerfile</strong>: This file tells how to
build our container image.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;index.js&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Build the Container Image</strong>: We can use Docker to
build our image. Replace <code>your-image-name</code> with a name we
like.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> your-image-name .</span></code></pre></div></li>
<li><p><strong>Push the Image to a Container Registry</strong>: We need
to push our image to a registry like Docker Hub or Google Container
Registry (GCR).</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> tag your-image-name gcr.io/your-project-id/your-image-name</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> push gcr.io/your-project-id/your-image-name</span></code></pre></div></li>
<li><p><strong>Create a Knative Service</strong>: We should define a
Knative service in a YAML file. We can call it
<code>service.yaml</code>.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> hello-world</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> gcr.io/your-project-id/your-image-name</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a><span class="at">            </span><span class="kw">-</span><span class="at"> </span><span class="fu">containerPort</span><span class="kw">:</span><span class="at"> </span><span class="dv">8080</span></span></code></pre></div></li>
<li><p><strong>Deploy the Service</strong>: We use <code>kubectl</code>
to deploy our Knative service.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> service.yaml</span></code></pre></div></li>
<li><p><strong>Access Our Function</strong>: After we deploy, we can
access our serverless function by getting the URL.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get ksvc hello-world</span></code></pre></div>
<p>This command will show the URL where we can access our
function.</p></li>
</ol>
<p>This process help us create and deploy a simple serverless function
using Knative on Kubernetes. For more details on using Knative for
serverless workloads, we can check <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">this
article</a>.</p>
<h2
id="what-configuration-files-do-we-need-for-knative-deployments">What
Configuration Files Do We Need for Knative Deployments?</h2>
<p>To deploy serverless functions using Knative on Kubernetes, we need
specific configuration files in YAML format. These files help us set up
the resources and settings for our Knative services. The main
configuration files we need are:</p>
<ol type="1">
<li><p><strong>Service Configuration File</strong>: This YAML file tells
us about the Knative service. It shows the desired state of our service.
It includes the image to deploy, environment variables, and scaling
settings.</p>
<p>Example <code>service.yaml</code>:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-serverless-function</span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> docker.io/username/my-function:latest</span></span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="fu">env</span><span class="kw">:</span></span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a><span class="at">            </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> ENV_VAR_NAME</span></span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">value</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;value&quot;</span></span></code></pre></div></li>
<li><p><strong>Configuration File for Routes and Revisions</strong>:
This file usually goes with the service configuration. But it can be
separate if we manage more complex deployments. This helps us control
traffic routing and revisions.</p>
<p>Example <code>route.yaml</code> (optional):</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Route</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-serverless-function-route</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">traffic</span><span class="kw">:</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">revisionName</span><span class="kw">:</span><span class="at"> my-serverless-function-00001</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">percent</span><span class="kw">:</span><span class="at"> </span><span class="dv">100</span></span></code></pre></div></li>
<li><p><strong>ConfigMap Configuration</strong>: If our application
needs settings that can change without redeploying, we can define a
ConfigMap.</p>
<p>Example <code>configmap.yaml</code>:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> v1</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> ConfigMap</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-config</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span><span class="kw">:</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">key1</span><span class="kw">:</span><span class="at"> value1</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">key2</span><span class="kw">:</span><span class="at"> value2</span></span></code></pre></div></li>
<li><p><strong>Secret Configuration</strong>: For sensitive info like
API keys or passwords, we should use Kubernetes Secrets.</p>
<p>Example <code>secret.yaml</code>:</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> v1</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Secret</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-secret</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="fu">type</span><span class="kw">:</span><span class="at"> Opaque</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="fu">data</span><span class="kw">:</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">api-key</span><span class="kw">:</span><span class="at"> BASE64_ENCODED_API_KEY</span></span></code></pre></div></li>
</ol>
<p>To deploy these configurations, we use the <code>kubectl apply</code>
command:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> service.yaml</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> route.yaml</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> configmap.yaml</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> secret.yaml</span></code></pre></div>
<p>These configuration files are important for defining and managing our
serverless functions in Knative. This lets us make the most of the
serverless features in our Kubernetes cluster. For more details on using
Knative for serverless workloads, check out <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">this
article</a>.</p>
<h2
id="how-can-we-monitor-and-scale-our-serverless-functions-in-knative">How
Can We Monitor and Scale Our Serverless Functions in Knative?</h2>
<p>Monitoring and scaling serverless functions in Knative is very
important for good performance and reliability. Knative gives us tools
to help with these tasks through its components.</p>
<h3 id="monitoring-serverless-functions">Monitoring Serverless
Functions</h3>
<ol type="1">
<li><p><strong>Logging</strong>: Knative works with logging tools like
Fluentd and Elasticsearch. We can see logs using this command:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> logs <span class="at">-l</span> serving.knative.dev/service=<span class="op">&lt;</span>service-name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Metrics</strong>: Knative can collect metrics using
Prometheus. To use it, we need to install the Prometheus operator in our
cluster. After we install it, we can check metrics like request count,
error rate, and latency.</p>
<p><strong>Example Prometheus configuration:</strong></p>
<div class="sourceCode" id="cb31"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> monitoring.coreos.com/v1</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> ServiceMonitor</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> knative-monitor</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">selector</span><span class="kw">:</span></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">matchLabels</span><span class="kw">:</span></span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">knative.dev/serving</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;true&quot;</span></span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">endpoints</span><span class="kw">:</span></span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">port</span><span class="kw">:</span><span class="at"> http</span></span></code></pre></div></li>
<li><p><strong>Tracing</strong>: We can use Zipkin or Jaeger for
tracing. We just need to set up our Knative services to send traces to
these tools.</p></li>
</ol>
<h3 id="scaling-serverless-functions">Scaling Serverless Functions</h3>
<ol type="1">
<li><p><strong>Automatic Scaling</strong>: Knative can scale our
services by itself based on incoming traffic. We can change the
autoscaling settings in our <code>Configuration</code> or
<code>Revision</code> YAML files.</p>
<p><strong>Example Configuration:</strong></p>
<div class="sourceCode" id="cb32"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Configuration</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> hello-world</span></span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">annotations</span><span class="kw">:</span></span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/minScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;1&quot;</span></span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/maxScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;10&quot;</span></span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> gcr.io/my-project/hello-world</span></span></code></pre></div></li>
<li><p><strong>Concurrency Control</strong>: We can decide how many
requests each instance of our serverless function can handle at the same
time. We do this by setting the
<code>autoscaling.knative.dev/target</code> annotation.</p>
<p><strong>Example:</strong></p>
<div class="sourceCode" id="cb33"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">annotations</span><span class="kw">:</span></span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/target</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;100&quot;</span></span></code></pre></div></li>
<li><p><strong>Manual Scaling</strong>: If we want to change the number
of replicas based on certain needs, we can manually adjust the
<code>minScale</code> and <code>maxScale</code> settings in our Knative
service configuration.</p></li>
</ol>
<p>We need to check metrics and logs regularly. Also, good scaling
settings will help us get better performance from our serverless
functions in Knative. For more information on serverless workloads, we
can look at <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">how
to use Knative for serverless workloads on Kubernetes</a>.</p>
<h2
id="what-are-some-real-life-use-cases-for-deploying-serverless-functions-with-knative">What
Are Some Real-Life Use Cases for Deploying Serverless Functions with
Knative?</h2>
<p>Knative helps us to deploy serverless functions on Kubernetes. It
gives us many ways to use serverless functions. We can enjoy benefits
like scaling, flexibility, and less work to manage. Here are some
real-life examples:</p>
<ol type="1">
<li><strong>Microservices Architecture</strong>:
<ul>
<li>We can deploy microservices as serverless functions. They can scale
on their own based on what we need. Each service can be built and
managed separately. This helps us to be faster in developing
applications.</li>
</ul></li>
<li><strong>Event-Driven Applications</strong>:
<ul>
<li>We can create event-driven applications. Functions can start when
events happen in cloud services or databases. For example, a serverless
function can process data from a message broker like Kafka or handle
webhooks from other services.</li>
</ul></li>
<li><strong>Data Processing Pipelines</strong>:
<ul>
<li>Knative helps us to make serverless functions that process data in
real-time. This is great for ETL (Extract, Transform, Load), image
processing, or video transcoding. Functions can run as data comes
in.</li>
</ul></li>
<li><strong>Web Application Backends</strong>:
<ul>
<li>We can build backends for web apps where functions reply to HTTP
requests. This makes it easy to handle user requests without needing
dedicated servers. We can use resources better this way.</li>
</ul></li>
<li><strong>API Gateway</strong>:
<ul>
<li>We can set up serverless functions that work as endpoints for APIs.
Knative manages scaling automatically based on how much traffic we get.
This keeps the API responsive when we have a lot of users.</li>
</ul></li>
<li><strong>Scheduled Tasks</strong>:
<ul>
<li>With Knative, we can run tasks on a schedule like data cleanup,
report making, or sending out notifications. We do not need a service
running all the time.</li>
</ul></li>
<li><strong>Machine Learning Inference</strong>:
<ul>
<li>We can use serverless functions for model inference in machine
learning. Functions can handle data and give predictions when we need
them. This helps us to use resources wisely.</li>
</ul></li>
<li><strong>IoT Data Processing</strong>:
<ul>
<li>We can use serverless functions to process data from IoT devices.
Functions can start when new data comes in. This makes real-time
analytics and decision-making possible.</li>
</ul></li>
<li><strong>A/B Testing</strong>:
<ul>
<li>We can use Knative to run different versions of a function for A/B
testing. This helps us to see how well different versions perform or how
users engage with them.</li>
</ul></li>
<li><strong>Cost-Effective Resource Management</strong>:
<ul>
<li>We can save money with Knative’s automatic scaling. Functions scale
down to zero when they aren’t used. This way, we only use resources when
we really need them.</li>
</ul></li>
</ol>
<p>These examples show how we can use serverless functions with Knative
on Kubernetes. If we want to learn more about using Knative for
serverless workloads, we can check out <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">this
article</a>.</p>
<h2 id="how-do-we-troubleshoot-issues-with-knative-deployments">How Do
We Troubleshoot Issues with Knative Deployments?</h2>
<p>When we troubleshoot issues with Knative deployments on Kubernetes,
we need to follow some clear steps. This helps us find and fix problems
better. Here are some important ways to do this:</p>
<ol type="1">
<li><p><strong>Check Pod Status</strong>:<br />
We can use <code>kubectl</code> to look at the status of our Knative
service and its pods. We should check if there are any pods in a
<code>CrashLoopBackOff</code> or <code>Error</code> state.</p>
<div class="sourceCode" id="cb34"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">-n</span> <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>View Logs</strong>:<br />
We need to look at the logs of our Knative service. This helps us find
errors or strange behavior.</p>
<div class="sourceCode" id="cb35"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> logs <span class="op">&lt;</span>pod-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div>
<p>For more logs, we can use:</p>
<div class="sourceCode" id="cb36"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> logs <span class="op">&lt;</span>pod-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span> --previous</span></code></pre></div></li>
<li><p><strong>Describe Resources</strong>:<br />
We can get more details about our Knative service, revision, and
configuration.</p>
<div class="sourceCode" id="cb37"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> describe ksvc <span class="op">&lt;</span>service-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> describe revision <span class="op">&lt;</span>revision-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> describe configuration <span class="op">&lt;</span>configuration-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Check Knative Eventing</strong>:<br />
If we use Knative Eventing, we must make sure that the event sources are
set up right and that events are delivered. We check the status of
brokers, triggers, and subscriptions.</p>
<div class="sourceCode" id="cb38"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get brokers <span class="at">-n</span> <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get triggers <span class="at">-n</span> <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Monitor the Knative Serving Components</strong>:<br />
We should check the status of the Knative Serving components. This
includes the activator, autoscaler, and controller.</p>
<div class="sourceCode" id="cb39"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">-n</span> knative-serving</span></code></pre></div></li>
<li><p><strong>Inspect Network Configuration</strong>:<br />
We need to make sure that the networking parts are set up correctly.
This means checking the Ingress resource and any load balancers.</p>
<div class="sourceCode" id="cb40"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get ingress <span class="at">-n</span> <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Look at Metrics</strong>:<br />
If we have set up monitoring, like with Prometheus, we should check the
metrics for our Knative service. This helps us see if there are
performance issues.</p></li>
<li><p><strong>Check Resource Quotas</strong>:<br />
We must ensure that our Kubernetes cluster has enough resources, like
CPU and memory. We should check for resource quotas that might limit our
service.</p>
<div class="sourceCode" id="cb41"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get resourcequotas <span class="at">-n</span> <span class="op">&lt;</span>your-namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Review Configuration Files</strong>:<br />
If we have changed configuration files, we need to make sure they are
correct. We can use <code>kubectl apply</code> to reapply configurations
if needed.</p></li>
<li><p><strong>Consult Knative Documentation</strong>:<br />
If we see specific errors, we should check the <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-knative-for-serverless-workloads-on-kubernetes.html">Knative
documentation</a>. This can help us with common problems and how to fix
them.</p></li>
</ol>
<p>By following these steps, we can find and fix issues with our Knative
deployments quickly. This helps our serverless functions on Kubernetes
to run well.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-knative-and-how-does-it-help-with-serverless-deployment-on-kubernetes">1.
What is Knative and how does it help with serverless deployment on
Kubernetes?</h3>
<p>Knative is a framework that helps to improve Kubernetes. It adds
serverless features. Knative makes it easier to deploy serverless
functions on Kubernetes. It takes care of the infrastructure, allows
automatic scaling, and makes event-driven applications simple. With
Knative, we can spend more time writing code and less time managing
servers. This makes deploying serverless functions on Kubernetes better
and easier.</p>
<h3 id="how-can-i-fix-problems-with-my-knative-serverless-functions">2.
How can I fix problems with my Knative serverless functions?</h3>
<p>To fix problems in Knative, we need to check logs and look at
metrics. We also have to make sure our configuration is correct. We can
use <code>kubectl</code> commands to see logs for our Knative services.
This helps us find issues. Checking our service configuration files and
making sure all dependencies are set up can help us avoid common
problems. For more details on troubleshooting, please see our guide on
<a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-troubleshoot-issues-in-my-kubernetes-deployments.html">troubleshooting
issues in Kubernetes deployments</a>.</p>
<h3
id="what-configuration-files-do-i-need-for-deploying-serverless-functions-with-knative">3.
What configuration files do I need for deploying serverless functions
with Knative?</h3>
<p>When we deploy serverless functions with Knative, we usually need a
<code>Service</code> YAML file. This file tells us about our function’s
settings, like the image source, environment variables, and scaling
options. Sometimes, we may need extra files for managing traffic or
specifying event sources. It is important that these files are correct
for a successful deployment of serverless functions on Kubernetes with
Knative.</p>
<h3
id="how-do-i-check-the-performance-of-my-serverless-functions-on-knative">4.
How do I check the performance of my serverless functions on
Knative?</h3>
<p>We can monitor serverless functions in Knative using built-in metrics
and logging. We can use tools like Prometheus and Grafana to see metrics
like request counts, latencies, and error rates. Knative also works with
logging tools, which help us see how our serverless functions are doing.
For more ways to monitor, check our article on <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-monitor-a-kubernetes-application-with-prometheus-and-grafana.html">monitoring
a Kubernetes application with Prometheus and Grafana</a>.</p>
<h3
id="what-are-some-real-life-examples-of-using-knative-in-serverless-applications">5.
What are some real-life examples of using Knative in serverless
applications?</h3>
<p>Many people use Knative for different real-life applications. For
example, it helps in building microservices, processing data streams,
and creating event-driven systems. Companies use Knative to make
scalable APIs that change with traffic needs. They also use it for
deploying machine learning models and doing background tasks. Knative’s
flexibility and connection with Kubernetes make it great for many
serverless jobs. You can learn more about deploying microservices on
Kubernetes <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-deploy-microservices-on-kubernetes.html">here</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            