
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TFCQEJR7TD');
</script>
            <title>How Do I Use Knative for Serverless Workloads on Kubernetes?</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to leverage Knative for serverless workloads on Kubernetes with our step-by-step guide and best practices.">

            <div id="head-placeholder"></div>
            <script src="/assets/js/blog.js" defer></script>
            <link rel="stylesheet" href="/assets/css/post.css">
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Do I Use Knative for Serverless Workloads on Kubernetes?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Knative is a tool that helps us use Kubernetes better. It gives us
components to build, deploy, and manage serverless applications. Knative
makes it easier to create serverless workloads on Kubernetes. It does
this by providing features like automatic scaling, traffic management,
and event-driven design. This way, we can focus on writing code and not
worry too much about the infrastructure under it.</p>
<p>In this article, we will learn how to use Knative for serverless
workloads on Kubernetes. We will talk about important things like what
Knative is, why it is good, how to install it on your Kubernetes
cluster, how to deploy our first Knative service, how to set up
autoscaling, how to manage traffic splitting, real-life examples, how to
monitor and debug our applications, and best tips for using Knative.</p>
<ul>
<li>How Can I Use Knative for Serverless Workloads on Kubernetes?</li>
<li>What is Knative and Why Use It for Serverless Workloads?</li>
<li>How to Install Knative on Your Kubernetes Cluster?</li>
<li>How to Deploy Your First Knative Service?</li>
<li>How to Configure Autoscaling for Knative Services?</li>
<li>How Do I Manage Traffic Splitting with Knative?</li>
<li>What Are Real Life Use Cases for Knative on Kubernetes?</li>
<li>How to Monitor and Debug Knative Applications?</li>
<li>What Are the Best Practices for Using Knative?</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to read more about Kubernetes and similar topics, we can
check these articles: <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubernetes-and-how-does-it-simplify-container-management.html">What
is Kubernetes and How Does it Simplify Container Management?</a> and <a
href="https://bestonlinetutorial.com/kubernetes/why-should-i-use-kubernetes-for-my-applications.html">Why
Should I Use Kubernetes for My Applications?</a>.</p>
<h2 id="what-is-knative-and-why-use-it-for-serverless-workloads">What is
Knative and Why Use It for Serverless Workloads?</h2>
<p>Knative is a platform that runs on Kubernetes. It helps us make it
easier to deploy and manage serverless workloads. Knative gives us tools
that let our applications scale up and down. It handles incoming
requests well without us needing to worry about the infrastructure under
it.</p>
<h3 id="key-features-of-knative">Key Features of Knative:</h3>
<ul>
<li><strong>Serverless Framework</strong>: Knative makes it simple. We
do not have to manage Kubernetes resources. This way, we can focus on
writing code instead of handling infrastructure.</li>
<li><strong>Autoscaling</strong>: It scales services up and down based
on traffic. It can even scale to zero when there are no requests.</li>
<li><strong>Event-Driven Architecture</strong>: Knative supports events.
Our applications can respond to events from many sources like cloud
storage and messaging systems.</li>
<li><strong>Routing and Traffic Management</strong>: It helps us route
traffic and deploy new versions of our applications easily.</li>
<li><strong>Integration with Existing Tools</strong>: Knative works well
with our current CI/CD pipelines and cloud tools. This makes it a good
choice for developers.</li>
</ul>
<h3 id="why-use-knative-for-serverless-workloads">Why Use Knative for
Serverless Workloads?</h3>
<ol type="1">
<li><p><strong>Cost Efficiency</strong>: Knative saves money. It uses
resources only when we need them. It scales to zero when not in
use.</p></li>
<li><p><strong>Rapid Development</strong>: We can deploy applications
fast. We do not need to worry about operations. This helps us get our
products to market quicker.</p></li>
<li><p><strong>Flexibility and Portability</strong>: Knative can run on
any Kubernetes cluster. This means our applications can move between
different cloud providers or even on-premises setups.</p></li>
<li><p><strong>Enhanced Developer Experience</strong>: We have a simpler
way to configure and deploy. This lets us focus on building features
instead of managing the infrastructure.</p></li>
<li><p><strong>Ecosystem Support</strong>: Knative uses the larger
Kubernetes ecosystem. We can integrate with tools like Istio for service
mesh and Prometheus for monitoring.</p></li>
</ol>
<p>For more information on serverless Kubernetes, you can read this
article on <a
href="https://bestonlinetutorial.com/kubernetes/what-is-serverless-kubernetes-and-how-does-it-work.html">What
is Serverless Kubernetes and How Does It Work?</a>.</p>
<h2 id="how-to-install-knative-on-your-kubernetes-cluster">How to
Install Knative on Your Kubernetes Cluster?</h2>
<p>To install Knative on our Kubernetes cluster, we can follow these
steps:</p>
<ol type="1">
<li><p><strong>Prerequisites</strong>:</p>
<ul>
<li>We need a running Kubernetes cluster (v1.16 or later).</li>
<li>We should install <code>kubectl</code> to manage our cluster.</li>
<li>We also need to install the <code>kn</code> CLI tool for
Knative.</li>
</ul></li>
<li><p><strong>Install Knative Serving</strong>: We can install Knative
Serving with this command:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/knative/serving/releases/latest/download/serving.yaml</span></code></pre></div></li>
<li><p><strong>Install Knative Eventing</strong> (optional): If we need
event-driven setup, we can install Knative Eventing:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/knative/eventing/releases/latest/download/eventing.yaml</span></code></pre></div></li>
<li><p><strong>Verify the Installation</strong>: We should check if the
Knative parts are working:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get pods <span class="at">--namespace</span> knative-serving</span></code></pre></div>
<p>We should see parts like <code>activator</code>,
<code>autoscaler</code>, and <code>controller</code> in
<code>Running</code> state.</p></li>
<li><p><strong>Install a Networking Layer</strong>: Knative needs a
networking layer like Istio, Kourier, or Contour. For example, to
install Kourier:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">--filename</span> https://github.com/knative/net-kourier/releases/latest/download/kourier.yaml</span></code></pre></div></li>
<li><p><strong>Set Up DNS</strong>: We need to make sure DNS is set up
right to send traffic to our Knative services. For local work, we can
use <code>nip.io</code> or similar services.</p></li>
<li><p><strong>Check Knative Configuration</strong>: After we install,
we should check our Knative setup:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get configurations.serving.knative.dev <span class="at">--all-namespaces</span></span></code></pre></div></li>
<li><p><strong>Install the Kn CLI</strong> (optional): To manage Knative
parts, we can install the Kn CLI:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> <span class="at">-s</span> https://raw.githubusercontent.com/knative/client/main/scripts/install.sh <span class="kw">|</span> <span class="fu">bash</span></span></code></pre></div></li>
</ol>
<p>By following these steps, we can install Knative on our Kubernetes
cluster. This helps us to deploy serverless workloads easily. If we want
to learn more about Kubernetes and how to deploy it, we can check <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubernetes-and-how-does-it-simplify-container-management.html">Kubernetes
Overview</a>.</p>
<h2 id="how-to-deploy-your-first-knative-service">How to Deploy Your
First Knative Service?</h2>
<p>To deploy our first Knative service, we need to follow some
steps:</p>
<ol type="1">
<li><p><strong>Create a Knative Service YAML File</strong>: We define
our service in a YAML file. Here is an example of a simple Knative
service that runs a container image.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> hello-world</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">namespace</span><span class="kw">:</span><span class="at"> default</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> gcr.io/knative-samples/helloworld</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="at">            </span><span class="kw">-</span><span class="at"> </span><span class="fu">containerPort</span><span class="kw">:</span><span class="at"> </span><span class="dv">8080</span></span></code></pre></div></li>
<li><p><strong>Apply the YAML to Our Cluster</strong>: We use
<code>kubectl</code> to deploy the service to our Kubernetes
cluster.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> hello-world.yaml</span></code></pre></div></li>
<li><p><strong>Check the Service Status</strong>: We should check if our
service is running correctly.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get ksvc hello-world</span></code></pre></div>
<p>We will see an output that shows the service is ready and gives its
URL.</p></li>
<li><p><strong>Access the Service</strong>: We use the URL from the
output to access our Knative service. We can send a request using
<code>curl</code> or a web browser.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> http://<span class="op">&lt;</span>your-knative-url<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Update the Service</strong>: If we want to change our
service, we update the YAML file and apply it again.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> hello-world.yaml</span></code></pre></div></li>
</ol>
<p>This simple deployment shows us how easy it is to start with Knative
for serverless workloads on Kubernetes. For more details about setting
up and managing workloads, we can check the <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-deploy-a-simple-web-application-on-kubernetes.html">Kubernetes
documentation</a>.</p>
<h2 id="how-to-configure-autoscaling-for-knative-services">How to
Configure Autoscaling for Knative Services?</h2>
<p>Knative gives us strong autoscaling features for serverless work on
Kubernetes. This helps our applications to grow or shrink based on how
much they are used. Knative services can change the number of instances
that handle requests. This way, we use resources better.</p>
<h3 id="step-1-set-up-autoscaling-configuration">Step 1: Set Up
Autoscaling Configuration</h3>
<p>Knative uses <code>KPA</code> (Kubernetes Pod Autoscaler) to manage
autoscaling. We can set autoscaling settings by using annotations or by
editing the Knative service YAML file directly.</p>
<h4 id="example-configuration-in-yaml">Example Configuration in
YAML</h4>
<div class="sourceCode" id="cb12"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">annotations</span><span class="kw">:</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/minScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;1&quot;</span><span class="co">   # Minimum number of instances</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/maxScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;10&quot;</span><span class="co">  # Maximum number of instances</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/target</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;100&quot;</span><span class="co">   # Target concurrency (requests per instance)</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-image:latest</span></span></code></pre></div>
<h3 id="step-2-deploy-the-service">Step 2: Deploy the Service</h3>
<p>After we set up the autoscaling settings, we can deploy our Knative
service:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> my-service.yaml</span></code></pre></div>
<h3 id="step-3-monitor-autoscaling-behavior">Step 3: Monitor Autoscaling
Behavior</h3>
<p>We can check the autoscaling behavior with this command:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get ksvc</span></code></pre></div>
<p>This command shows the current scale of our Knative service. It also
shows its URL and readiness status.</p>
<h3 id="autoscaling-triggers">Autoscaling Triggers</h3>
<p>Knative autoscaling can start because of different metrics, like:</p>
<ul>
<li><strong>Concurrency</strong>: This is how many requests are being
handled at the same time by each instance.</li>
<li><strong>CPU Usage</strong>: This shows how much CPU we are using in
percent.</li>
</ul>
<h3 id="step-4-adjusting-autoscaling-settings">Step 4: Adjusting
Autoscaling Settings</h3>
<p>If we need to change the autoscaling settings, like changing min/max
scale or target concurrency, we can update the annotations in our
service YAML and then redeploy:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> my-service.yaml</span></code></pre></div>
<h3 id="additional-considerations">Additional Considerations</h3>
<ul>
<li>Make sure our cluster has the right resource limits and requests for
Knative services to work well.</li>
<li>Keep an eye on our service’s performance. We should change the
autoscaling settings if needed to save costs and improve
performance.</li>
</ul>
<p>For more details about Kubernetes and its parts, we can check <a
href="https://bestonlinetutorial.com/kubernetes/what-are-the-key-components-of-a-kubernetes-cluster.html">What
Are the Key Components of a Kubernetes Cluster?</a>.</p>
<h2 id="how-do-we-manage-traffic-splitting-with-knative">How Do We
Manage Traffic Splitting with Knative?</h2>
<p>Traffic splitting in Knative helps us send requests between different
versions of a service. This is good for canary deployments, A/B testing,
or rolling out updates slowly. Let’s see how we can set up traffic
splitting for our Knative services.</p>
<h3 id="step-1-deploy-multiple-versions">Step 1: Deploy Multiple
Versions</h3>
<p>First, we need to have more than one version of a service running. We
can create a new version by using an updated configuration. Here’s an
example:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">labels</span><span class="kw">:</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">version</span><span class="kw">:</span><span class="at"> v1</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-image:v1</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a><span class="pp">---</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">labels</span><span class="kw">:</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">version</span><span class="kw">:</span><span class="at"> v2</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-image:v2</span></span></code></pre></div>
<h3 id="step-2-define-traffic-distribution">Step 2: Define Traffic
Distribution</h3>
<p>Next, we can decide how to split the traffic between the versions
using the <code>traffic</code> field in the service setup. Here is an
example that sends 80% of traffic to <code>v1</code> and 20% to
<code>v2</code>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">traffic</span><span class="kw">:</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">revisionName</span><span class="kw">:</span><span class="at"> my-service-v1</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">percent</span><span class="kw">:</span><span class="at"> </span><span class="dv">80</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">revisionName</span><span class="kw">:</span><span class="at"> my-service-v2</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">percent</span><span class="kw">:</span><span class="at"> </span><span class="dv">20</span></span></code></pre></div>
<h3 id="step-3-apply-configuration">Step 3: Apply Configuration</h3>
<p>Now we use <code>kubectl</code> to apply our service
configuration:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> my-service.yaml</span></code></pre></div>
<h3 id="step-4-verify-traffic-splitting">Step 4: Verify Traffic
Splitting</h3>
<p>To check if traffic is split right, we can send requests to our
service and see the responses. We can also use Knative’s monitoring
tools to look at traffic patterns and make sure routing is correct.</p>
<h3 id="additional-features">Additional Features</h3>
<ul>
<li><strong>Header-based Routing</strong>: Knative also lets us route
traffic based on request headers.</li>
<li><strong>Versions Management</strong>: We can manage versions using
<code>kubectl</code> to promote or rollback changes depending on how
traffic performs.</li>
</ul>
<p>For more advanced traffic management like A/B testing or blue-green
deployments, we can check <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-canary-deployments-in-kubernetes.html">how
do I use canary deployments in Kubernetes</a>.</p>
<h2 id="what-are-real-life-use-cases-for-knative-on-kubernetes">What Are
Real Life Use Cases for Knative on Kubernetes?</h2>
<p>Knative is a great tool. It makes it easier to deploy and manage
serverless workloads on Kubernetes. Here are some real-life examples
where we can use Knative well:</p>
<ol type="1">
<li><strong>Microservices Architecture</strong>:
<ul>
<li>We can use Knative to deploy microservices as serverless functions.
Each microservice can grow or shrink based on demand.</li>
<li>For example, a retail app can have separate services for inventory,
payment, and notifications. All these services can be managed with
Knative.</li>
</ul></li>
<li><strong>Event-Driven Applications</strong>:
<ul>
<li>Knative Eventing lets apps respond to events from different sources.
This includes message queues or HTTP requests. We can trigger functions
based on these events.</li>
<li>For example, a serverless function can start when a new order comes
in through a messaging system.</li>
</ul></li>
<li><strong>Data Processing Pipelines</strong>:
<ul>
<li>We can build data processing pipelines with Knative. These pipelines
can scale based on the amount of data, making data processing more
efficient.</li>
<li>For example, a real-time analytics app can scale functions to handle
data coming from IoT devices.</li>
</ul></li>
<li><strong>Web Applications</strong>:
<ul>
<li>When we deploy web apps with Knative, they can automatically scale
based on the traffic they receive. This helps with cost and
performance.</li>
<li>For example, a blog platform that gets variable traffic can use
Knative’s autoscaling features.</li>
</ul></li>
<li><strong>API Backends</strong>:
<ul>
<li>Knative can be a backend for APIs. It can automatically scale API
endpoints based on how many requests there are.</li>
<li>For example, an API service for a mobile app can grow during busy
times and shrink when there are fewer requests.</li>
</ul></li>
<li><strong>CI/CD Workflows</strong>:
<ul>
<li>We can connect Knative with CI/CD tools. This allows us to automate
deployments of serverless apps. This makes managing the app lifecycle
easier.</li>
<li>For example, we can deploy a new version of a serverless function
every time we push code to a repository.</li>
</ul></li>
<li><strong>Machine Learning Inference</strong>:
<ul>
<li>Knative can serve machine learning models as serverless endpoints.
It can scale based on the number of requests for inference.</li>
<li>For example, an image classification service can use a trained model
and scale based on user requests for classification.</li>
</ul></li>
<li><strong>Cost Optimization</strong>:
<ul>
<li>Using Knative helps organizations save money. They only use
resources when they are needed. Workloads can scale to zero when they
are not in use.</li>
<li>For example, a seasonal e-commerce app can handle high traffic
during holidays and low traffic at other times.</li>
</ul></li>
<li><strong>Chatbots and Voice Assistants</strong>:
<ul>
<li>We can deploy chatbots with Knative. This allows scaling based on
user interactions, so we can provide quick and efficient service.</li>
<li>For example, a customer service chatbot can handle questions and can
grow based on user demand.</li>
</ul></li>
<li><strong>Integration with Third-party Services</strong>:
<ul>
<li>Knative helps connect with different APIs and services. This allows
developers to create complex workflows that react to outside
triggers.</li>
<li>For example, a function can process payments and send notifications
when done. It can work with payment gateways and notification
services.</li>
</ul></li>
</ol>
<p>In conclusion, Knative on Kubernetes helps organizations use
serverless features. It is a great choice for many scalable,
event-driven, and cost-effective applications. For more about serverless
Kubernetes, we can check out <a
href="https://bestonlinetutorial.com/kubernetes/what-is-serverless-kubernetes-and-how-does-it-work.html">what
is serverless Kubernetes and how does it work</a>.</p>
<h2 id="how-to-monitor-and-debug-knative-applications">How to Monitor
and Debug Knative Applications?</h2>
<p>Monitoring and debugging Knative applications is very important. It
helps us make sure that our serverless workloads on Kubernetes work
well. Knative gives us many tools and ways to do this easily.</p>
<h3 id="monitoring-knative-applications">Monitoring Knative
Applications</h3>
<ol type="1">
<li><p><strong>Prometheus and Grafana</strong>: Knative works with
Prometheus to collect metrics. We can install Prometheus and Grafana to
see our metrics better.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> https://github.com/knative/serving/releases/download/<span class="va">$(</span><span class="ex">kubectl</span> get deployment <span class="at">-n</span> knative-monitoring <span class="at">-o</span> jsonpath=<span class="st">&#39;{.items[?(@.metadata.name==&quot;prometheus&quot;)].metadata.labels.version}&#39;</span><span class="va">)</span>/monitoring.yaml</span></code></pre></div></li>
<li><p><strong>Knative Metrics</strong>: Knative automatically sends out
metrics about request count, latency, and error rates. We can query
these metrics using Prometheus.</p>
<p>Here is a sample Prometheus query for request count:</p>
<pre class="promql"><code>sum(rate( http_request_count[5m])) by (service)</code></pre></li>
<li><p><strong>Kubernetes Dashboard</strong>: We can use the Kubernetes
Dashboard to see the status of our Knative services and
resources.</p></li>
</ol>
<h3 id="debugging-knative-applications">Debugging Knative
Applications</h3>
<ol type="1">
<li><p><strong>Logs</strong>: Knative pods create logs that we can
access using <code>kubectl</code>. We can see logs for a specific
service with:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> logs <span class="at">-l</span> serving.knative.dev/service=<span class="op">&lt;</span>service-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Knative CLI (kn)</strong>: We can use the <code>kn</code>
CLI tool to get more information about our services, revisions, and
routes.</p>
<ul>
<li>To see service details:</li>
</ul>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kn</span> service describe <span class="op">&lt;</span>service-name<span class="op">&gt;</span> -n <span class="op">&lt;</span>namespace<span class="op">&gt;</span></span></code></pre></div>
<ul>
<li>To see the revisions:</li>
</ul>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kn</span> revision list <span class="at">-n</span> <span class="op">&lt;</span>namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Eventing</strong>: Knative Eventing helps us debug
communication between services. We can check events using:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get events <span class="at">-n</span> <span class="op">&lt;</span>namespace<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Tracing with Zipkin</strong>: We can use Zipkin for
tracing. This helps us follow requests across services.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> https://raw.githubusercontent.com/knative/serving/main/docs/monitoring/zipkin.yaml</span></code></pre></div></li>
</ol>
<h3 id="additional-tools">Additional Tools</h3>
<ul>
<li><p><strong>Kiali</strong>: If we use Istio as our service mesh,
Kiali gives us a console to monitor and debug traffic flow between our
services.</p></li>
<li><p><strong>Sentry</strong>: We can integrate Sentry to catch
exceptions and track performance issues in our Knative apps.</p></li>
<li><p><strong>Custom Metrics</strong>: We can create custom metrics to
watch specific behaviors in our apps using the <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-monitor-my-kubernetes-cluster.html">Kubernetes
Metrics API</a>.</p></li>
</ul>
<p>By using these tools and methods, we can monitor and debug our
Knative applications well. This way, our serverless workloads on
Kubernetes run better.</p>
<h2 id="what-are-the-best-practices-for-using-knative">What Are the Best
Practices for Using Knative?</h2>
<p>When we use Knative for serverless work on Kubernetes, it’s important
to follow some best practices. These practices can help us improve
performance, reliability, and ease of maintenance. Here are some key
tips for using Knative well:</p>
<ol type="1">
<li><p><strong>Resource Management</strong>: We should define resource
requests and limits for our Knative services. This helps us use
resources in the best way and avoid conflicts.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-image</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="at">          </span><span class="fu">resources</span><span class="kw">:</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="at">            </span><span class="fu">requests</span><span class="kw">:</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">memory</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;256Mi&quot;</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">cpu</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;500m&quot;</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="at">            </span><span class="fu">limits</span><span class="kw">:</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">memory</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;512Mi&quot;</span></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="at">              </span><span class="fu">cpu</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;1&quot;</span></span></code></pre></div></li>
<li><p><strong>Use Revision Names</strong>: We can keep track of
different revisions by using clear names. This makes it easier to manage
rollbacks and see the history of deployments.</p></li>
<li><p><strong>Traffic Management</strong>: We can use Knative’s traffic
splitting to slowly roll out new versions of services.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">traffic</span><span class="kw">:</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">revisionName</span><span class="kw">:</span><span class="at"> my-service-v1</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">percent</span><span class="kw">:</span><span class="at"> </span><span class="dv">90</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="kw">-</span><span class="at"> </span><span class="fu">revisionName</span><span class="kw">:</span><span class="at"> my-service-v2</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">percent</span><span class="kw">:</span><span class="at"> </span><span class="dv">10</span></span></code></pre></div></li>
<li><p><strong>Autoscaling Configuration</strong>: We should set up
autoscaling based on how many requests we get and CPU usage. This helps
us adjust to traffic changes.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> autoscaling.knative.dev/v1beta1</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Configuration</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">annotations</span><span class="kw">:</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/minScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;1&quot;</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">autoscaling.knative.dev/maxScale</span><span class="kw">:</span><span class="at"> </span><span class="st">&quot;10&quot;</span></span></code></pre></div></li>
<li><p><strong>Monitoring and Logging</strong>: It is good to have
monitoring and logging in place. This helps us track how our
applications are doing and fix problems. We can use tools like
Prometheus and Grafana for this.</p></li>
<li><p><strong>Security Practices</strong>: We should follow security
best practices. Using Role-Based Access Control (RBAC) can help us limit
who can access Knative resources. Also, we should manage secrets and
sensitive data with Kubernetes Secrets.</p></li>
<li><p><strong>Use Knative Eventing</strong>: We can use Knative
Eventing to build applications that respond to events. We need to set up
triggers for this.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> eventing.knative.dev/v1</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Trigger</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-trigger</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">broker</span><span class="kw">:</span><span class="at"> default</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">filter</span><span class="kw">:</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">attributes</span><span class="kw">:</span></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">type</span><span class="kw">:</span><span class="at"> dev.knative.samples.hello</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">subscriber</span><span class="kw">:</span></span>
<span id="cb29-11"><a href="#cb29-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ref</span><span class="kw">:</span></span>
<span id="cb29-12"><a href="#cb29-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> serving.knative.dev/v1</span></span>
<span id="cb29-13"><a href="#cb29-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">kind</span><span class="kw">:</span><span class="at"> Service</span></span>
<span id="cb29-14"><a href="#cb29-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-service</span></span></code></pre></div></li>
<li><p><strong>Regularly Update Knative</strong>: We should keep Knative
updated. This way, we can use new features and security fixes.</p></li>
<li><p><strong>Testing and Staging Environments</strong>: It is helpful
to have special environments for testing and staging. This ensures that
we check new changes before putting them into production.</p></li>
<li><p><strong>Documentation</strong>: We need to keep clear
documentation for our Knative services. This includes decisions about
the architecture, service links, and guidelines for operation.</p></li>
</ol>
<p>By sticking to these best practices for Knative on Kubernetes, we can
build serverless applications that are scalable, efficient, and strong.
For more tips on using Kubernetes well, check out <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubernetes-and-how-does-it-simplify-container-management.html">this
guide on Kubernetes</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-knative-and-how-does-it-help-with-serverless-workloads-on-kubernetes">What
is Knative and how does it help with serverless workloads on
Kubernetes?</h3>
<p>Knative is a platform that is open-source. It makes it easier to
manage serverless workloads on Kubernetes. It helps with things like
automatic scaling, traffic routing, and easy application deployment. We
can focus on writing our code while Knative takes care of the hard work
of scaling and managing serverless applications on Kubernetes.</p>
<h3 id="how-do-i-deploy-a-knative-service-on-my-kubernetes-cluster">How
do I deploy a Knative service on my Kubernetes cluster?</h3>
<p>To deploy a Knative service, we first need to create a YAML file.
This file tells Knative about our service. It should have details like
the image, environment variables, and other settings. After that, we can
deploy the service by using the command
<code>kubectl apply -f &lt;your-file&gt;.yaml</code>. For more details,
check out our article on how to <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-deploy-a-simple-web-application-on-kubernetes.html">deploy
a simple web application on Kubernetes</a>.</p>
<h3 id="how-can-i-set-up-autoscaling-for-my-knative-services">How can I
set up autoscaling for my Knative services?</h3>
<p>Knative does autoscaling automatically based on traffic and limits we
set. We can say how many instances we want at least and at most in the
service settings. Knative can then scale our application without us
having to do anything. For more information on autoscaling, see our
article on how to <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-autosale-my-applications-with-horizontal-pod-autoscaler-hpa.html">autoscale
applications with Horizontal Pod Autoscaler (HPA)</a>.</p>
<h3
id="what-are-the-best-ways-to-manage-traffic-splitting-in-knative">What
are the best ways to manage traffic splitting in Knative?</h3>
<p>Traffic splitting in Knative helps us send some traffic to different
versions of a service. This is good for canary deployments and A/B
testing. The best ways to do this are to set clear routing rules in our
Knative service YAML, watch performance metrics, and slowly increase
traffic to new versions. For more details, read our article on <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-canary-deployments-in-kubernetes.html">how
to implement canary deployments in Kubernetes</a>.</p>
<h3 id="how-do-i-monitor-and-debug-my-knative-applications-well">How do
I monitor and debug my Knative applications well?</h3>
<p>We can monitor and debug Knative applications using tools like
Kubernetes logs, metrics from Prometheus, and tracing tools like
OpenTelemetry. We can also use the Knative CLI tools to see the status
of our services and fix any issues. For more on monitoring, look at our
guide on <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-monitor-my-kubernetes-cluster.html">how
to monitor my Kubernetes cluster</a>.</p>
<p>These FAQs give us a basic understanding of using Knative for
serverless workloads on Kubernetes. They guide us through important
steps for deployment, configuration, and best ways to work.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            