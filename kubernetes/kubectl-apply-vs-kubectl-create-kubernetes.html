
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>kubectl apply vs kubectl create? - kubernetes</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover the differences between kubectl apply and kubectl create in Kubernetes. Learn when to use each command effectively!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">kubectl apply vs kubectl create? - kubernetes</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>When we choose between <code>kubectl apply</code> and
<code>kubectl create</code> in Kubernetes, we need to know that these
commands do different things in managing resources. We use
<code>kubectl apply</code> to manage resources that already exist. It
helps us make updates without causing too much trouble. On the other
hand, we use <code>kubectl create</code> when we want to set up new
resources for the first time. Understanding this difference is very
important for good Kubernetes work and managing resources over time.</p>
<p>In this article, we will look at the main differences between
<code>kubectl apply</code> and <code>kubectl create</code>. We will also
see when to use each command the right way. We will talk about best ways
to manage resources in Kubernetes. We will share common examples for
both commands and answer questions that many people ask. This will help
us understand their roles better.</p>
<ul>
<li><strong>kubectl apply vs kubectl create which one to use in
Kubernetes?</strong></li>
<li><strong>Understanding the Differences Between kubectl apply and
kubectl create in Kubernetes</strong></li>
<li><strong>When to Use kubectl apply for Kubernetes Resource
Management?</strong></li>
<li><strong>When to Choose kubectl create for Initial Resource
Deployment in Kubernetes?</strong></li>
<li><strong>Best Practices for Using kubectl apply and kubectl create in
Kubernetes</strong></li>
<li><strong>Common Use Cases for kubectl apply vs kubectl create in
Kubernetes</strong></li>
<li><strong>Frequently Asked Questions</strong></li>
</ul>
<p>For more information about Kubernetes, we can read articles like <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubernetes-and-how-does-it-simplify-container-management.html">What
is Kubernetes and How Does It Simplify Container Management?</a> and <a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-kubectl-to-manage-my-kubernetes-resources.html">How
Do I Use kubectl to Manage My Kubernetes Resources?</a>. These will help
us learn more.</p>
<h2
id="understanding-the-differences-between-kubectl-apply-and-kubectl-create-in-kubernetes">Understanding
the Differences Between kubectl apply and kubectl create in
Kubernetes</h2>
<p>In Kubernetes, we use both <code>kubectl apply</code> and
<code>kubectl create</code> to manage resources. But they have different
tasks and act in different ways.</p>
<ul>
<li><p><strong>kubectl create</strong>: This command helps us create a
resource from a file or from stdin. It does not update existing
resources. If the resource is already there, this command will give us
an error. We often use it for one-time resource creation.</p>
<p>Example:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create <span class="at">-f</span> deployment.yaml</span></code></pre></div></li>
<li><p><strong>kubectl apply</strong>: This command helps us create or
update a resource. If the resource is not there,
<code>kubectl apply</code> will create it. If it is there,
<code>kubectl apply</code> will update it based on changes in the
configuration file. This command is good for ongoing configuration
management.</p>
<p>Example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> deployment.yaml</span></code></pre></div></li>
</ul>
<h3 id="key-differences">Key Differences:</h3>
<ol type="1">
<li><strong>Use Case</strong>:
<ul>
<li><code>kubectl create</code>: Good for starting resource
creation.</li>
<li><code>kubectl apply</code>: Good for both creation and updates.</li>
</ul></li>
<li><strong>Error Handling</strong>:
<ul>
<li><code>kubectl create</code>: Gives error if the resource
exists.</li>
<li><code>kubectl apply</code>: Creates or updates the resource without
error if it exists.</li>
</ul></li>
<li><strong>Declarative vs Imperative</strong>:
<ul>
<li><code>kubectl create</code>: Imperative command (one-time
action).</li>
<li><code>kubectl apply</code>: Declarative command (managing the
desired state).</li>
</ul></li>
<li><strong>Resource Configuration</strong>:
<ul>
<li><code>kubectl create</code>: Needs the full resource details.</li>
<li><code>kubectl apply</code>: Allows partial updates; we only need to
say what changed in the configuration.</li>
</ul></li>
<li><strong>Management Style</strong>:
<ul>
<li><code>kubectl create</code>: Best for starting resources.</li>
<li><code>kubectl apply</code>: Best for continuous management and
version control.</li>
</ul></li>
</ol>
<p>To manage Kubernetes resources well, we must know when to use
<code>kubectl apply</code> and when to use <code>kubectl create</code>.
Use <code>kubectl create</code> for resources that do not change much.
Use <code>kubectl apply</code> for environments where configurations
change often.</p>
<h2
id="when-to-use-kubectl-apply-for-kubernetes-resource-management">When
to Use kubectl apply for Kubernetes Resource Management?</h2>
<p>We use <code>kubectl apply</code> when we want to manage Kubernetes
resources. This command helps us create or update resources in a clear
way. It lets us keep the desired state of resources in the cluster by
using configuration files.</p>
<h3 id="key-use-cases-for-kubectl-apply">Key Use Cases for kubectl
apply:</h3>
<ul>
<li><p><strong>Declarative Configuration</strong>: We should use
<code>kubectl apply</code> when we want to manage resources by defining
their desired state in YAML files. This method makes it easy to see
changes over time.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> apps/v1</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Deployment</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-app</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">replicas</span><span class="kw">:</span><span class="at"> </span><span class="dv">3</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">selector</span><span class="kw">:</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">matchLabels</span><span class="kw">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">app</span><span class="kw">:</span><span class="at"> my-app</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">labels</span><span class="kw">:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">app</span><span class="kw">:</span><span class="at"> my-app</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-app-container</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-app-image:latest</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">containerPort</span><span class="kw">:</span><span class="at"> </span><span class="dv">80</span></span></code></pre></div>
<p>To apply the configuration, we run:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> my-app-deployment.yaml</span></code></pre></div></li>
<li><p><strong>Update Existing Resources</strong>: We can use
<code>kubectl apply</code> to update resources that already exist. We do
not need to delete and recreate them. It combines changes
smartly.</p></li>
<li><p><strong>Version Control Integration</strong>: If we use GitOps
practices, <code>kubectl apply</code> helps us keep our configuration
files in version control. This way, we can easily track and go back to
previous changes.</p></li>
<li><p><strong>Support for Patches</strong>: We can apply patches to
change certain fields in existing resources without needing to redefine
the whole resource.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> patch deployment my-app <span class="at">-p</span> <span class="st">&#39;{&quot;spec&quot;:{&quot;replicas&quot;:5}}&#39;</span></span></code></pre></div></li>
<li><p><strong>Manage Multiple Resources</strong>: We can apply many
resource configurations at the same time by pointing to a folder with
YAML files.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> ./manifests/</span></code></pre></div></li>
</ul>
<p>Using <code>kubectl apply</code> helps us follow a GitOps workflow.
It makes sure that the actual state of the Kubernetes cluster matches
the desired state we define in our configuration files. For more
understanding, check the link <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubectl-and-how-do-i-use-it-to-manage-kubernetes.html">what
is kubectl and how do I use it to manage Kubernetes?</a>.</p>
<h2
id="when-to-choose-kubectl-create-for-initial-resource-deployment-in-kubernetes">When
to Choose kubectl create for Initial Resource Deployment in
Kubernetes?</h2>
<p>We use <code>kubectl create</code> in Kubernetes to make new
resources from the beginning. This command is good for initial
deployments. It helps us set up resources without changing what is
already there. Here is when we should pick <code>kubectl create</code>
for the first resource deployment:</p>
<ul>
<li><p><strong>Initial Setup</strong>: We should use
<code>kubectl create</code> when we are deploying resources for the
first time. This includes Pods, Deployments, or Services. This command
makes sure we are creating a new instance of a resource.</p></li>
<li><p><strong>Static Resources</strong>: If the resource setup is fixed
and will not change much, we can use <code>kubectl create</code>. It
directly shows the configuration we wrote.</p></li>
<li><p><strong>Simpler Scenarios</strong>: In easy cases where we do not
need complex updates or settings, <code>kubectl create</code> makes the
deployment easier for us.</p></li>
</ul>
<h3 id="example">Example</h3>
<p>To create a Deployment with <code>kubectl create</code>, we can run
this command:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create deployment my-deployment <span class="at">--image</span><span class="op">=</span>my-image:latest</span></code></pre></div>
<p>This command makes a new Deployment called <code>my-deployment</code>
with the Docker image we specified.</p>
<h3 id="specific-use-cases">Specific Use Cases</h3>
<ul>
<li><p><strong>Creating Namespaces</strong>: If we need a new namespace,
we can use <code>kubectl create namespace my-namespace</code>.</p></li>
<li><p><strong>ConfigMaps and Secrets</strong>: For making ConfigMaps or
Secrets that do not need updates, we can use:</p></li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create configmap my-config <span class="at">--from-literal</span><span class="op">=</span>key1=value1</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create secret generic my-secret <span class="at">--from-literal</span><span class="op">=</span>password=my_password</span></code></pre></div>
<ul>
<li><strong>Resource Quotas</strong>: When we set up resource quotas for
the first time, we can create them without thinking about existing
setups.</li>
</ul>
<p>By using <code>kubectl create</code>, we make sure we are starting
from a clean state. This is especially good in places where we should
not change current setups by mistake.</p>
<p>For more details on managing Kubernetes resources well, we can check
<a
href="https://bestonlinetutorial.com/kubernetes/how-do-i-use-kubectl-to-manage-my-kubernetes-resources.html">this
article on Kubernetes</a>.</p>
<h2
id="best-practices-for-using-kubectl-apply-and-kubectl-create-in-kubernetes">Best
Practices for Using kubectl apply and kubectl create in Kubernetes</h2>
<p>When we manage Kubernetes resources, using <code>kubectl apply</code>
and <code>kubectl create</code> in the right way is very important. This
helps us with deployment and managing configurations. Here are some best
practices for these commands.</p>
<ul>
<li><strong>Use <code>kubectl apply</code> for Declarative
Management</strong>:
<ul>
<li><p>This is good for managing resources over time.</p></li>
<li><p>It allows us to update configurations easily.</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> deployment.yaml</span></code></pre></div></li>
</ul></li>
<li><strong>Use <code>kubectl create</code> for Initial
Deployments</strong>:
<ul>
<li><p>This is best for creating resources that do not change
often.</p></li>
<li><p>It helps us avoid unplanned changes later.</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create <span class="at">-f</span> service.yaml</span></code></pre></div></li>
</ul></li>
<li><strong>Keep YAML Files Versioned</strong>:
<ul>
<li>We should store our Kubernetes YAML files in version control systems
like Git. This helps us track changes over time.</li>
</ul></li>
<li><strong>Leverage <code>kubectl apply</code> with
<code>--record</code></strong>:
<ul>
<li><p>We can use the <code>--record</code> flag to track changes made
to the resources. This is useful for checking and rolling back
changes.</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> deployment.yaml <span class="at">--record</span></span></code></pre></div></li>
</ul></li>
<li><strong>Use <code>kubectl apply</code> for Merging Changes</strong>:
<ul>
<li>When we apply changes, <code>kubectl apply</code> merges the old
configuration with the new one. This is good for updating
resources.</li>
</ul></li>
<li><strong>Avoid Mixing <code>kubectl apply</code> and
<code>kubectl create</code></strong>:
<ul>
<li>We should stick to one method for a resource. This helps us prevent
confusion and mistakes.</li>
</ul></li>
<li><strong>Utilize <code>kubectl apply --dry-run</code> for
Testing</strong>:
<ul>
<li><p>We can test our changes without applying them. This helps us make
sure everything is correct and avoid issues.</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> deployment.yaml <span class="at">--dry-run</span><span class="op">=</span>client</span></code></pre></div></li>
</ul></li>
<li><strong>Monitor Resource Status After Applying Changes</strong>:
<ul>
<li><p>We should always check the status of resources after applying
changes. This helps us confirm they are running as we expect.</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> get deployment my-deployment</span></code></pre></div></li>
</ul></li>
</ul>
<p>By following these best practices, we can manage Kubernetes resources
well using <code>kubectl apply</code> and <code>kubectl create</code>.
This will make our deployment process better and reduce mistakes. For
more details, we can learn about <a
href="https://bestonlinetutorial.com/kubernetes/what-are-essential-kubectl-commands-i-should-know.html">essential
kubectl commands</a> that help us in managing Kubernetes.</p>
<h2
id="common-use-cases-for-kubectl-apply-vs-kubectl-create-in-kubernetes">Common
Use Cases for kubectl apply vs kubectl create in Kubernetes</h2>
<p>In Kubernetes, we need to know when to use <code>kubectl apply</code>
and when to use <code>kubectl create</code>. This is important for
managing resources well. Here are some common times to use each
command:</p>
<h3 id="use-cases-for-kubectl-apply">Use Cases for kubectl apply:</h3>
<ol type="1">
<li><p><strong>Updating Existing Resources</strong>:<br />
When we need to change the setup of resources we already have, we should
use <code>kubectl apply</code>. This command helps us change resources
easily.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> deployment.yaml</span></code></pre></div></li>
<li><p><strong>Managing Resource Configuration as Code</strong>:<br />
When we handle Kubernetes resources with YAML files in version control,
<code>kubectl apply</code> makes sure that changes in the YAML are
applied to the cluster. We do not have to delete and create resources
again.</p></li>
<li><p><strong>Resource Merging</strong>:<br />
<code>kubectl apply</code> can merge changes. For example, if a
deployment has a current image and we want to change it, using
<code>kubectl apply</code> will update just that part without changing
the others.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="fu">apiVersion</span><span class="kw">:</span><span class="at"> apps/v1</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">kind</span><span class="kw">:</span><span class="at"> Deployment</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="fu">metadata</span><span class="kw">:</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-app</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">template</span><span class="kw">:</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">spec</span><span class="kw">:</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">containers</span><span class="kw">:</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="fu">name</span><span class="kw">:</span><span class="at"> my-app</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-app:v2</span><span class="co">  # Updated image version</span></span></code></pre></div></li>
<li><p><strong>Handling Multiple Resource Types</strong>:<br />
We can use <code>kubectl apply</code> to manage many types of resources
in one command. This gives us a simple way to deploy and update.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> apply <span class="at">-f</span> ./manifests/</span></code></pre></div></li>
</ol>
<h3 id="use-cases-for-kubectl-create">Use Cases for kubectl create:</h3>
<ol type="1">
<li><p><strong>Initial Resource Creation</strong>:<br />
We use <code>kubectl create</code> when we are making resources for the
first time. This command is easy and good for starting setups.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create <span class="at">-f</span> service.yaml</span></code></pre></div></li>
<li><p><strong>Creating Single Resources</strong>:<br />
If we are creating just one type of resource,
<code>kubectl create</code> is faster and easier.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create deployment my-app <span class="at">--image</span><span class="op">=</span>my-app:latest</span></code></pre></div></li>
<li><p><strong>When Resource Specification is Simple</strong>:<br />
For simple resource setups that do not need complex settings or merging,
<code>kubectl create</code> is the better choice.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">kubectl</span> create configmap my-config <span class="at">--from-literal</span><span class="op">=</span>key1=value1</span></code></pre></div></li>
<li><p><strong>Debugging Resource Creation Issues</strong>:<br />
Using <code>kubectl create</code> can help us find problems with
resource definitions quickly. It shows errors right away if the resource
cannot be created.</p></li>
</ol>
<p>These examples show that <code>kubectl apply</code> is great for
ongoing management and updates. On the other hand,
<code>kubectl create</code> is best for first-time resource creation and
simple tasks. For more information on managing Kubernetes resources, we
can read <a
href="https://bestonlinetutorial.com/kubernetes/what-is-kubectl-and-how-do-i-use-it-to-manage-kubernetes.html">what
is kubectl and how do I use it to manage Kubernetes?</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-difference-between-kubectl-apply-and-kubectl-create-in-kubernetes">1.
What is the difference between <code>kubectl apply</code> and
<code>kubectl create</code> in Kubernetes?</h3>
<p>We use <code>kubectl apply</code> for managing Kubernetes resources.
It helps us update existing resources by applying changes from
configuration files. On the other hand, <code>kubectl create</code> is
for making new resources without changing the ones that are already
there. Knowing this difference is important. It helps us pick the right
command for our deployment needs.</p>
<h3 id="when-should-i-use-kubectl-apply">2. When should I use
<code>kubectl apply</code>?</h3>
<p>We should use <code>kubectl apply</code> when we want to manage the
current settings of our Kubernetes resources. It lets us make updates
step by step and combine changes with what is already there. This is
very helpful in CI/CD pipelines and when we use infrastructure as code.
By using <code>kubectl apply</code>, we keep our resource definitions in
sync with what we want.</p>
<h3
id="is-it-possible-to-update-resources-created-with-kubectl-create-using-kubectl-apply">3.
Is it possible to update resources created with
<code>kubectl create</code> using <code>kubectl apply</code>?</h3>
<p>Yes, we can update resources made with <code>kubectl create</code> by
using <code>kubectl apply</code>. But we need to remember that
<code>kubectl apply</code> will change the existing settings only if the
resource’s definition matches what we have in the YAML file. This shows
how flexible <code>kubectl apply</code> is for managing Kubernetes
resources over time.</p>
<h3
id="what-are-some-best-practices-for-using-kubectl-apply-and-kubectl-create">4.
What are some best practices for using <code>kubectl apply</code> and
<code>kubectl create</code>?</h3>
<p>Some best practices are to use <code>kubectl apply</code> for
managing and updating resources. We should keep
<code>kubectl create</code> for when we first deploy things. It is good
to keep our YAML files neat and organized. We should also use comments
in the files to make them clearer. Following these tips can help us work
better with Kubernetes and manage resources more easily.</p>
<h3
id="can-i-use-kubectl-apply-for-all-types-of-kubernetes-resources">5.
Can I use <code>kubectl apply</code> for all types of Kubernetes
resources?</h3>
<p>Yes, we can use <code>kubectl apply</code> for most Kubernetes
resources. This includes Deployments, Services, ConfigMaps, and Secrets.
But we should know that some resources, like persistent volume claims,
might need special attention. To manage our Kubernetes environment well,
we should learn the details of each resource type and how they work with
<code>kubectl apply</code>.</p>
<p>For more information on Kubernetes and its parts, we can look at
articles about <a
href="https://bestonlinetutorial.com/kubernetes/what-are-the-key-components-of-a-kubernetes-cluster.html">Kubernetes
key components</a> or <a
href="https://bestonlinetutorial.com/kubernetes/how-does-kubernetes-networking-work.html">understanding
Kubernetes networking</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            