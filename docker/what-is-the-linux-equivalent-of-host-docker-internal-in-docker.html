
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>What is the Linux Equivalent of "host.docker.internal" in Docker?</title>
            <meta name="description" content="Discover the Linux equivalent of "host.docker.internal" in Docker. Learn how to connect Docker containers to the host network!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">What is the Linux Equivalent of "host.docker.internal" in Docker?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>In Linux, to connect to the host from Docker containers, we use the
host’s network IP address. This is often <code>172.17.0.1</code>. If we
use Docker Desktop for Linux, we can also use
<code>host.docker.internal</code>. This helps our Docker containers talk
to services on the host machine. If we run Docker on a Linux system
without Docker Desktop, we may need to change some network settings to
get it to work.</p>
<p>In this article, we will talk about different ways to access host
services from Docker containers on Linux. We will explain what
<code>host.docker.internal</code> does. We will also look at other
options like using the host network mode, creating a custom DNS entry,
and checking Docker bridge network settings. Plus, we will answer common
questions about connecting Docker containers to host services.</p>
<ul>
<li>Understanding the Purpose of <code>host.docker.internal</code> in
Docker</li>
<li>How to Access Host Services from Docker Containers on Linux</li>
<li>Using Docker Host Network Mode as an Alternative to
<code>host.docker.internal</code></li>
<li>Setting Up a Custom DNS Entry for <code>host.docker.internal</code>
Equivalent</li>
<li>Exploring Docker Bridge Network Configuration for Linux Systems</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-purpose-of-host.docker.internal-in-docker">Understanding
the Purpose of host.docker.internal in Docker</h2>
<p>The <code>host.docker.internal</code> is a special DNS name. It helps
Docker containers talk to the host machine. This is very helpful when a
container needs to reach services on the host, like databases or APIs.
We can summarize the purpose of <code>host.docker.internal</code> like
this:</p>
<ul>
<li><strong>Inter-Container Communication</strong>: It helps containers
connect to services on the Docker host without knowing the host’s IP
address.</li>
<li><strong>Development Convenience</strong>: When we develop, it lets
us run services in containers while still getting host services
easily.</li>
<li><strong>Cross-Platform Compatibility</strong>:
<code>host.docker.internal</code> works on Docker for Windows and macOS.
But on Linux, it does not work by default. We need other ways to do
this.</li>
</ul>
<p>In Linux, we can access the host from a Docker container in different
ways. We will talk about these methods later. This ability makes our
development and testing process better. It helps us build and fix
applications in different environments. For more details about Docker
networking and containers, check out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">this
article about what is Docker and why you should use it</a>.</p>
<h2 id="how-to-access-host-services-from-docker-containers-on-linux">How
to Access Host Services from Docker Containers on Linux</h2>
<p>We can access host services from Docker containers on Linux in
several ways. The “host.docker.internal” does not work on Linux by
default. Here are some easy methods to do it:</p>
<ol type="1">
<li><p><strong>Using the Host Network Mode</strong>: We can run our
Docker container in host network mode. This way, the container shares
the network with the host. So, the container can access services on the
host using <code>localhost</code>.</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--network</span> host my-container</span></code></pre></div>
<p>Now, we can access host services on <code>localhost</code> inside our
container.</p></li>
<li><p><strong>Using the Docker Bridge Network</strong>: If we use the
default bridge network, we can find the host’s IP address from the
default gateway. This gateway is usually <code>172.17.0.1</code>.</p>
<p>To access a service, we can use:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> http://172.17.0.1:<span class="op">&lt;</span>host-port<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Custom DNS Entry</strong>: We can create a custom DNS
entry for our host. We need to edit the <code>/etc/hosts</code> file in
the container. This file maps a hostname to the host IP.</p>
<p>First, we need to find the host IP. It is often
<code>192.168.1.1</code> or something like that. Then, we can run:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--add-host</span><span class="op">=</span>host.docker.internal:<span class="op">&lt;</span>host-ip<span class="op">&gt;</span> my-container</span></code></pre></div></li>
<li><p><strong>Environment Variables</strong>: We can pass the host IP
as an environment variable when we run the container. We use the
<code>--env</code> flag:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--env</span> HOST_IP=<span class="op">&lt;</span>host-ip<span class="op">&gt;</span> my-container</span></code></pre></div>
<p>In our application, we can use the <code>HOST_IP</code> variable to
connect to host services.</p></li>
<li><p><strong>Docker Compose</strong>: If we are using Docker Compose,
we can set the host IP in the <code>docker-compose.yml</code> file:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">my-service</span><span class="kw">:</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-container</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">extra_hosts</span><span class="kw">:</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;host.docker.internal:&lt;host-ip&gt;&quot;</span></span></code></pre></div></li>
</ol>
<p>By using these methods, we can easily access host services from
Docker containers on Linux. Each method works well depending on what we
need for our application and network setup.</p>
<h2
id="using-docker-host-network-mode-as-an-alternative-to-host.docker.internal">Using
Docker Host Network Mode as an Alternative to host.docker.internal</h2>
<p>In Linux, we can make Docker containers reach services on the host
machine by using the Host Network Mode. This mode lets the container
share the host’s network. So, the container can use the host’s IP
address directly. This is a good choice when
<code>host.docker.internal</code> is not available on Linux.</p>
<h3 id="enabling-host-network-mode">Enabling Host Network Mode</h3>
<p>To run a Docker container in Host Network Mode, we use the
<code>--network host</code> option when we start the container. Here is
an example command:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--network</span> host <span class="op">&lt;</span>image-name<span class="op">&gt;</span></span></code></pre></div>
<h3 id="accessing-host-services">Accessing Host Services</h3>
<p>When we use Host Network Mode, any services on the host can be
reached directly via <code>localhost</code> or the host’s IP address
from inside the container. For example, if we have a web server running
on port 8080 on the host, we can access it from the container with:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> http://localhost:8080</span></code></pre></div>
<h3 id="limitations">Limitations</h3>
<ul>
<li><strong>Port Conflicts</strong>: The container uses the host’s
network stack. So, it can’t run services on the same ports as the
host.</li>
<li><strong>Isolation</strong>: This mode does not give the same network
isolation for the container. This may not work for every situation.</li>
</ul>
<h3 id="use-cases">Use Cases</h3>
<ul>
<li>Development environments where we need direct access to host
services.</li>
<li>Cases where performance-sensitive applications can gain from lower
latency.</li>
</ul>
<p>Using Host Network Mode helps us connect and communicate between
Docker containers and host services easily. We do not need extra
settings or DNS entries.</p>
<h2
id="setting-up-a-custom-dns-entry-for-host.docker.internal-equivalent">Setting
Up a Custom DNS Entry for host.docker.internal Equivalent</h2>
<p>To access services on the host from Docker containers on Linux, we
can set up a custom DNS entry. This entry will act like
<code>host.docker.internal</code>. We can do this by changing the
<code>/etc/hosts</code> file on the host machine or by setting up a
local DNS server.</p>
<h3 id="method-1-modifying-etchosts">Method 1: Modifying /etc/hosts</h3>
<ol type="1">
<li><p><strong>Open the <code>/etc/hosts</code> file</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> nano /etc/hosts</span></code></pre></div></li>
<li><p><strong>Add a new entry</strong> for the Docker host’s IP
address. Change <code>YOUR_HOST_IP</code> to your real host’s IP
address. It is often <code>172.17.0.1</code> for Docker:</p>
<pre><code>YOUR_HOST_IP host.docker.internal</code></pre></li>
<li><p><strong>Save and exit</strong> the editor.</p></li>
<li><p><strong>Check the entry</strong> by pinging:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ping</span> host.docker.internal</span></code></pre></div></li>
</ol>
<h3 id="method-2-using-dockers-dns-options">Method 2: Using Docker’s DNS
Options</h3>
<p>We can also set DNS options when we start the Docker container. This
helps to route requests to the host.</p>
<ol type="1">
<li><p><strong>Run Docker with custom DNS</strong>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--dns</span><span class="op">=</span>YOUR_DNS_IP <span class="at">--add-host</span><span class="op">=</span>host.docker.internal:YOUR_HOST_IP your_image</span></code></pre></div></li>
</ol>
<h3 id="method-3-using-docker-compose">Method 3: Using Docker
Compose</h3>
<p>If we use Docker Compose, we can define the host entry in our
<code>docker-compose.yml</code> file:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">your_service</span><span class="kw">:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> your_image</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">extra_hosts</span><span class="kw">:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;host.docker.internal:YOUR_HOST_IP&quot;</span></span></code></pre></div>
<h3 id="note">Note</h3>
<p>Remember to change <code>YOUR_HOST_IP</code> to the real IP of your
Docker host. This setup helps our Docker containers resolve
<code>host.docker.internal</code> to the host IP. It makes it easier to
access services that run on the host.</p>
<p>For more information about Docker networking, we can check <a
href="https://bestonlinetutorial.com/docker/how-does-docker-networking-work-for-multi-container-applications.html">how
Docker handles networking for multi-container applications</a>.</p>
<h2
id="exploring-docker-bridge-network-configuration-for-linux-systems">Exploring
Docker Bridge Network Configuration for Linux Systems</h2>
<p>Docker’s bridge network is the default network driver in Docker for
containers. It helps containers talk to each other and the host system.
We need to understand how to set up and use the bridge network. This is
important for managing Docker containers on Linux systems.</p>
<h3 id="creating-a-bridge-network">Creating a Bridge Network</h3>
<p>To make a custom bridge network, we use this command:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network create <span class="at">--driver</span> bridge my_bridge_network</span></code></pre></div>
<h3 id="inspecting-the-bridge-network">Inspecting the Bridge
Network</h3>
<p>To see the details of our bridge network, we use:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network inspect my_bridge_network</span></code></pre></div>
<p>This shows us the setup. It includes connected containers and IP
address ranges.</p>
<h3 id="running-containers-on-the-bridge-network">Running Containers on
the Bridge Network</h3>
<p>To run a container on the bridge network, we use:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> my_container <span class="at">--network</span> my_bridge_network nginx</span></code></pre></div>
<p>This command starts a new NGINX container that connects to
<code>my_bridge_network</code>.</p>
<h3 id="container-communication">Container Communication</h3>
<p>Containers on the same bridge network can talk to each other by using
their container names as hostnames. For example, if we have two
containers named <code>web</code> and <code>db</code>, we can access
<code>db</code> from <code>web</code> like this:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ping</span> db</span></code></pre></div>
<h3 id="configuring-ip-addressing">Configuring IP Addressing</h3>
<p>We can set a static IP address for a container in the bridge network
with this command:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> my_container <span class="at">--network</span> my_bridge_network <span class="at">--ip</span> 172.18.0.22 nginx</span></code></pre></div>
<h3 id="using-docker-compose-with-bridge-networks">Using Docker Compose
with Bridge Networks</h3>
<p>In a <code>docker-compose.yml</code> file, we can define a bridge
network like this:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">my_bridge_network</span><span class="kw">:</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="fu">ipv4_address</span><span class="kw">:</span><span class="at"> </span><span class="fl">172.18.0.22</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">my_bridge_network</span><span class="kw">:</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">driver</span><span class="kw">:</span><span class="at"> bridge</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ipam</span><span class="kw">:</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">config</span><span class="kw">:</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="at">        </span><span class="kw">-</span><span class="at"> </span><span class="fu">subnet</span><span class="kw">:</span><span class="at"> 172.18.0.0/16</span></span></code></pre></div>
<h3 id="default-bridge-network">Default Bridge Network</h3>
<p>Docker also has a default bridge network called <code>bridge</code>.
To connect a container to this network, we just run:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> my_container <span class="at">--network</span> bridge nginx</span></code></pre></div>
<h3 id="troubleshooting-bridge-network-issues">Troubleshooting Bridge
Network Issues</h3>
<p>If we have problems with container communication, we can:</p>
<ul>
<li>Check the network setup with
<code>docker network inspect bridge</code>.</li>
<li>Make sure that the containers are in the same bridge network.</li>
<li>Check firewall rules that might block the traffic between
containers.</li>
</ul>
<p>By using Docker’s bridge network setup on Linux, we can manage
container networking well. This helps containers communicate smoothly.
For more details on Docker networks, we can read this <a
href="https://bestonlinetutorial.com/docker/what-are-docker-networks-and-why-are-they-necessary.html">article
on Docker networks</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-linux-equivalent-of-host.docker.internal-in-docker">What
is the Linux equivalent of “host.docker.internal” in Docker?</h3>
<p>On Linux, we do not have <code>host.docker.internal</code> like in
Docker for Windows and Mac. We can use the IP address of the Docker
host. This is often <code>172.17.0.1</code> for the default bridge
network. We can also access services on the host by using the host
network mode or by making a custom DNS entry.</p>
<h3
id="how-can-i-access-the-host-machine-from-a-docker-container-on-linux">How
can I access the host machine from a Docker container on Linux?</h3>
<p>To access the host machine from a Docker container on Linux, we can
use the host’s IP address, which is usually <code>172.17.0.1</code>. We
can also run the container in host network mode by using the
<code>--network host</code> flag. This way, the container shares the
host’s network. It lets us access services running on the host
directly.</p>
<h3 id="why-is-host.docker.internal-not-available-on-linux">Why is
<code>host.docker.internal</code> not available on Linux?</h3>
<p>The <code>host.docker.internal</code> address is made for Docker
Desktop on Windows and Mac. It helps with communication between
containers and the host machine. On Linux, Docker doesn’t have this by
default. It thinks users can access the host’s network settings
directly. So, we can just use the host’s IP address instead.</p>
<h3
id="how-do-i-set-up-a-custom-dns-entry-for-host.docker.internal-equivalent-on-linux">How
do I set up a custom DNS entry for <code>host.docker.internal</code>
equivalent on Linux?</h3>
<p>To set up a custom DNS entry for <code>host.docker.internal</code> on
Linux, we can change the <code>/etc/hosts</code> file on the host
machine. We need to add a line like
<code>172.17.0.1 host.docker.internal</code>. Here,
<code>172.17.0.1</code> is the IP address of the Docker host. This helps
containers resolve <code>host.docker.internal</code> to the host’s IP
and makes communication easier.</p>
<h3 id="what-is-dockers-host-network-mode-and-how-can-it-help">What is
Docker’s host network mode, and how can it help?</h3>
<p>Docker’s host network mode lets containers share the host’s network
stack. This means the container can access all the host’s network
interfaces without the extra work of network address translation (NAT).
We can turn on this mode by using the <code>--network host</code> flag
when we run a Docker container. It makes it easier to access services on
the host.</p>
<hr />
<p>For more details on Docker networking and its settings, check out <a
href="https://bestonlinetutorial.com/docker/how-to-set-up-dns-for-docker-containers.html">How
to set up DNS for Docker containers</a> and <a
href="https://bestonlinetutorial.com/docker/what-are-bridge-networks-in-docker.html">What
are bridge networks in Docker</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            