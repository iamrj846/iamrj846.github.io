
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>How Can You Combine Multiple Docker Images Effectively?</title>
            <meta name="description" content="Discover effective strategies to combine multiple Docker images for optimized performance and streamlined workflows in our latest blog!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Can You Combine Multiple Docker Images Effectively?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Combining multiple Docker images can help us make our development and
deployment easier. It lets us use the best parts of each image. We can
use some methods like Docker Multi-Stage Builds, Docker Compose, and
making custom base images. These methods help us add features without
making our final image too big. Learning these ways will help us work
better with Docker and make our applications run more smoothly.</p>
<p>In this article, we will look at different ways to combine Docker
images. We will check out these topics:</p>
<ul>
<li>How to Combine Multiple Docker Images Effectively</li>
<li>Understanding Docker Multi-Stage Builds for Image Combination</li>
<li>Using Docker Compose to Combine Multiple Services</li>
<li>Using Dockerfile to Merge Functionality of Images</li>
<li>Creating a Custom Base Image to Combine Features</li>
<li>Exploring Image Layering for Efficient Docker Image Combination</li>
<li>Frequently Asked Questions</li>
</ul>
<p>By looking at these methods, we can learn how to make our Docker
images work better and be easier to maintain.</p>
<h2
id="understanding-docker-multi-stage-builds-for-image-combination">Understanding
Docker Multi-Stage Builds for Image Combination</h2>
<p>We can use Docker Multi-Stage Builds to make better images. This
method lets us use many <code>FROM</code> statements in one
<code>Dockerfile</code>. It helps us make the image smaller. Also, it
makes the build process faster by keeping build tools separate from what
we need to run the app.</p>
<h3 id="basic-syntax">Basic Syntax</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First stage: build the application</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> builder</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Second stage: create the final image</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/myapp .</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;./myapp&quot;</span>]</span></code></pre></div>
<h3 id="key-benefits">Key Benefits</h3>
<ul>
<li><strong>Reduced Image Size</strong>: We only include what we really
need in the final image.</li>
<li><strong>Cleaner Images</strong>: We do not add build tools and extra
files that make the image bigger.</li>
<li><strong>Enhanced Security</strong>: Smaller images are safer because
they have less risk.</li>
</ul>
<h3 id="example-use-case">Example Use Case</h3>
<p>For a Node.js app, we might first install development tools in one
stage. Then, we only copy the files we need for production to the final
image.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First stage: install dependencies</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json yarn.lock ./</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">yarn</span> install</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Second stage: build the application</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14-alpine</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app .</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;app.js&quot;</span>]</span></code></pre></div>
<p>Using Multi-Stage Builds helps us create smaller Docker images. It
also makes our CI/CD pipeline work better by saving time on moving and
storing images. For more on Docker images, check out <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">what
are Docker images and how do they work</a>.</p>
<h2 id="using-docker-compose-to-combine-multiple-services">Using Docker
Compose to Combine Multiple Services</h2>
<p>Docker Compose is a great tool. It helps us define and run many
Docker applications with containers. With one YAML file, we can set up
our application’s services, networks, and volumes. This lets us combine
many Docker images easily.</p>
<h3 id="defining-services-in-docker-compose">Defining Services in Docker
Compose</h3>
<p>A typical <code>docker-compose.yml</code> file shows each service and
how it is set up. Here is an example that puts together an application
with a database:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3.8&#39;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-web-app:latest</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">context</span><span class="kw">:</span><span class="at"> ./web</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;80:80&quot;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> db</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> DATABASE_URL=mysql://user:password@db:3306/mydatabase</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db</span><span class="kw">:</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> mysql:5.7</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> db_data:/var/lib/mysql</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">MYSQL_ROOT_PASSWORD</span><span class="kw">:</span><span class="at"> password</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">MYSQL_DATABASE</span><span class="kw">:</span><span class="at"> mydatabase</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">MYSQL_USER</span><span class="kw">:</span><span class="at"> user</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">MYSQL_PASSWORD</span><span class="kw">:</span><span class="at"> password</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db_data</span><span class="kw">:</span></span></code></pre></div>
<h3 id="key-features-of-docker-compose">Key Features of Docker
Compose</h3>
<ul>
<li><strong>Service Dependencies</strong>: We can use the
<code>depends_on</code> to tell the order in which services should
start.</li>
<li><strong>Environment Variables</strong>: We use
<code>environment</code> variables to send settings and sensitive
information.</li>
<li><strong>Volume Management</strong>: We can keep our data safe with
volumes. This way, data stays even when the container restarts.</li>
<li><strong>Networking</strong>: Services in a Compose file connect to a
default network. They can talk to each other easily.</li>
</ul>
<h3 id="running-docker-compose">Running Docker Compose</h3>
<p>To start the services in our <code>docker-compose.yml</code>, we run
this command:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">-d</span></span></code></pre></div>
<p>The <code>-d</code> flag runs the containers in detached mode. When
we want to stop the services, we use:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> down</span></code></pre></div>
<p>This command also removes the containers, networks, and volumes from
the <code>docker-compose.yml</code> file.</p>
<h3 id="scaling-services">Scaling Services</h3>
<p>We can make our services bigger by using the <code>--scale</code>
option:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">--scale</span> web=3</span></code></pre></div>
<p>This command will run three copies of the <code>web</code> service.
It combines many containers of the same image.</p>
<p>For more details on using Docker Compose for multi-container
applications, check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">this
guide</a>.</p>
<h2
id="leveraging-dockerfile-to-merge-functionality-of-images">Leveraging
Dockerfile to Merge Functionality of Images</h2>
<p>We can use a Dockerfile well to combine features of many Docker
images into one image. We do this by using the <code>FROM</code> command
to choose base images and adding more features on top of them. Here are
some key tips and examples.</p>
<h3 id="multi-stage-builds">Multi-Stage Builds</h3>
<p>Multi-stage builds let us create images in steps. This helps us
combine features while keeping the final image small. It is especially
good for compiling applications.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 1: Build Stage</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> build</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 2: Final Stage</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /root/</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=build</span> /app/myapp .</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;./myapp&quot;</span>]</span></code></pre></div>
<p>In this example, the first stage builds a Go application. The second
stage makes a small Alpine image that only has the compiled binary.</p>
<h3 id="combining-dependencies">Combining Dependencies</h3>
<p>We can combine features from different images by installing
dependencies from one image into another. We can do this with one
Dockerfile.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> python:3.9</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    libpq-dev <span class="dt">\</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="ex">pip</span> install psycopg2</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=0</span> /usr/local/lib/python3.9/site-packages /usr/local/lib/python3.9/site-packages</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span></code></pre></div>
<p>Here, we copy the Python dependencies into the Node.js image.</p>
<h3 id="using-arg-for-dynamic-builds">Using ARG for Dynamic Builds</h3>
<p>Using <code>ARG</code> in our Dockerfile helps us build images based
on different variables at build time.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ARG</span> NODE_VERSION=14</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> curl <span class="dt">\</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="ex">curl</span> <span class="at">-fsSL</span> https://deb.nodesource.com/setup_<span class="va">${NODE_VERSION}</span>.x.x <span class="kw">|</span> <span class="fu">bash</span> <span class="at">-</span> <span class="dt">\</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> nodejs</span></code></pre></div>
<p>By changing the <code>NODE_VERSION</code> argument, we can create
images with different Node.js versions without changing the
Dockerfile.</p>
<h3 id="environment-variables">Environment Variables</h3>
<p>We can set environment variables in our Dockerfile. This helps us
change how our image works at runtime.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> MY_ENV_VAR=production</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> nginx.conf /etc/nginx/nginx.conf</span></code></pre></div>
<p>This way, the same base image can have different settings based on
the environment.</p>
<h3 id="layer-caching">Layer Caching</h3>
<p>When we combine features, we should think about Docker’s caching. We
can organize our <code>Dockerfile</code> to make builds faster:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies first to use caching</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json package-lock.json ./</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the rest of the application</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;npm&quot;</span>, <span class="st">&quot;start&quot;</span>]</span></code></pre></div>
<p>By copying the <code>package.json</code> before the application code,
Docker can cache the layer with the dependencies. This speeds up future
builds when we only change the application code.</p>
<p>Using Dockerfiles to merge features helps us make our Docker images
better and makes development easier. For more information on
Dockerfiles, check out <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">What
is the Dockerfile and How Do You Create One?</a>.</p>
<h2 id="creating-a-custom-base-image-to-combine-features">Creating a
Custom Base Image to Combine Features</h2>
<p>Creating a custom base image in Docker helps us mix features from
different images. We can make our images smaller and more useful. We do
this by using existing images and adding new parts. Here is how we can
create a custom base image easily:</p>
<ol type="1">
<li><p><strong>Start with a Base Image</strong>: First, we pick an image
that is close to what we need.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span></code></pre></div></li>
<li><p><strong>Install Required Packages</strong>: We use
<code>RUN</code> to get the software or libraries we need.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    python3 <span class="dt">\</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    python3-pip <span class="dt">\</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    curl <span class="dt">\</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Add Application Code</strong>: We use <code>COPY</code>
to put our application code into the image.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> ./my_app /app</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span></code></pre></div></li>
<li><p><strong>Install Dependencies</strong>: If our application needs
other packages, we install them.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">pip3</span> install <span class="at">-r</span> requirements.txt</span></code></pre></div></li>
<li><p><strong>Expose Ports</strong>: If our application uses a certain
port, we use <code>EXPOSE</code>.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 5000</span></code></pre></div></li>
<li><p><strong>Define Entry Point</strong>: We use <code>CMD</code> or
<code>ENTRYPOINT</code> to set the command that starts our
application.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python3&quot;</span>, <span class="st">&quot;app.py&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Build the Image</strong>: We save our Dockerfile and
build the custom image with this command:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> my_custom_image .</span></code></pre></div></li>
<li><p><strong>Run the Custom Image</strong>: Finally, we can run a
container from our custom image.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">-p</span> 5000:5000 my_custom_image</span></code></pre></div></li>
</ol>
<p>By following these steps, we create a custom base image that mixes
the features we want from different sources. This method helps us work
better and keeps our images light and easy to manage. For more info
about Docker images and how they work, we can check out <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">What
are Docker Images and How Do They Work?</a>.</p>
<h2
id="exploring-image-layering-for-efficient-docker-image-combination">Exploring
Image Layering for Efficient Docker Image Combination</h2>
<p>Docker images have layers. These layers show the changes made during
the build process. To combine multiple Docker images well, we need to
understand and use these layers. Here’s how to use image layering for
better Docker image combination:</p>
<ol type="1">
<li><p><strong>Base Image Selection</strong>: We should pick a small
base image to make the overall size smaller. For example, using
<code>alpine</code> as a base image can really cut down the image
size.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span></code></pre></div></li>
<li><p><strong>Layer Caching</strong>: Docker saves layers after they
are built. If a layer does not change, Docker uses it again in future
builds. We can organize our Dockerfile to use the cache better. Place
commands that change less often at the top.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Base layer</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies first</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json package-lock.json ./</span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy application code</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;npm&quot;</span>, <span class="st">&quot;start&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Minimize Layer Count</strong>: We can combine commands to
have fewer layers. Use <code>&amp;&amp;</code> to join commands in one
<code>RUN</code> line.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="ex">apt-get</span> install <span class="at">-y</span> curl git <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">apt-get</span> clean</span></code></pre></div></li>
<li><p><strong>Avoid Unnecessary Files</strong>: We can use
<code>.dockerignore</code> to leave out files that we do not need in the
image. This helps make layer size smaller and speeds up build time.</p>
<pre><code>node_modules
npm-debug.log
.git</code></pre></li>
<li><p><strong>Multi-Stage Builds</strong>: We can use multi-stage
builds to keep build-time tools separate from runtime images. This helps
to keep the final image small by only including what we really need.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Build stage</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> builder</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Production stage</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/myapp /myapp</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/myapp&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Layer Squashing</strong>: Docker does not support layer
squashing directly, but we can use tools like BuildKit to squash layers.
This helps reduce the final image size.</p>
<p>Enable BuildKit:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DOCKER_BUILDKIT</span><span class="op">=</span>1</span></code></pre></div>
<p>Build with squash:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">--squash</span> <span class="at">-t</span> myapp:latest .</span></code></pre></div></li>
<li><p><strong>Use Docker Hub’s Layer Caching</strong>: When we pull
images, Docker looks for existing layers on Docker Hub. If we use a
popular base image, chances are the layers are already saved on our
machine. This speeds up builds.</p></li>
</ol>
<p>By using image layering well, we can make smaller and more efficient
Docker images that combine many functions easily. Knowing how to handle
layers not only improves performance but also makes the development
process smoother.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-are-docker-multi-stage-builds-and-how-do-they-help-in-combining-images">1.
What are Docker multi-stage builds and how do they help in combining
images?</h3>
<p>Docker multi-stage builds lets us make one image from many images. We
do this by using several <code>FROM</code> statements in a
<code>Dockerfile</code>. This way helps us make the build process
faster. We can copy only what we need from one stage to another. This
reduces the final image size and makes everything work better. For more
details, see <a
href="https://bestonlinetutorial.com/docker/what-are-multi-stage-docker-builds-and-how-do-they-improve-efficiency.html">what
are multi-stage Docker builds</a>.</p>
<h3 id="how-can-docker-compose-be-used-to-combine-multiple-services">2.
How can Docker Compose be used to combine multiple services?</h3>
<p>Docker Compose is a useful tool that makes it easy to manage apps
with many containers. We can define services, networks, and volumes in a
<code>docker-compose.yml</code> file. With this file, we can combine
several Docker images and run them together. This method improves our
development process and helps services talk to each other without
problems. Learn more about <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">using
Docker Compose for multi-container applications</a>.</p>
<h3
id="what-is-the-role-of-a-dockerfile-in-combining-multiple-images">3.
What is the role of a Dockerfile in combining multiple images?</h3>
<p>A Dockerfile is like a plan for making Docker images. With a
Dockerfile, we can tell how to combine different images. We can specify
base images, dependencies, and steps to build the final image. This
makes deploying apps easier and keeps things the same across different
environments. For more information, read about <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">what
is a Dockerfile and how do you create one</a>.</p>
<h3
id="how-can-i-create-a-custom-base-image-to-combine-features-from-multiple-images">4.
How can I create a custom base image to combine features from multiple
images?</h3>
<p>To create a custom base image, we need a Dockerfile. This Dockerfile
helps us build an image that takes features from other images. We do
this by using several <code>FROM</code> statements and copying the files
we need. This method lets us combine different functions and make our
Docker images better. Read more about <a
href="https://bestonlinetutorial.com/docker/how-to-build-a-docker-image-from-a-dockerfile.html">creating
custom Docker images</a>.</p>
<h3
id="what-are-the-best-practices-for-optimizing-docker-images-through-layering">5.
What are the best practices for optimizing Docker images through
layering?</h3>
<p>Docker images come in layers. Each step in a Dockerfile makes a new
layer. To make Docker images better, we should try to reduce the number
of layers. We can combine commands when we can and put them in order
from least to most changed. Good layering makes the image size smaller
and speeds up build times. For a full guide, check out <a
href="https://bestonlinetutorial.com/docker/what-is-a-docker-image-layer-and-why-does-it-matter.html">what
is a Docker image layer and why does it matter</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            