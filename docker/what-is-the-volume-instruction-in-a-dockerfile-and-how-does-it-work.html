
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>What is the "VOLUME" Instruction in a Dockerfile and How Does it Work?</title>
            <meta name="description" content="Discover the VOLUME instruction in a Dockerfile, its purpose, and how it enhances data management in containerized applications.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">What is the "VOLUME" Instruction in a Dockerfile and How Does it Work?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The “VOLUME” instruction in a Dockerfile is a strong command. We use
it to set up points for keeping data safe in Docker containers. When we
declare a volume, we make sure the data from the container stays even if
we stop or remove the container. This is very important for apps that
need to keep data safe. This instruction helps us keep the app’s data
separate from the container’s file system. It makes managing data easier
and helps our Docker apps run better.</p>
<p>In this article, we will look at the details of the “VOLUME”
instruction in Dockerfiles. We will talk about what it does, how to set
it up, and tips for using it well. We will also see how to manage data
safely with the “VOLUME” instruction. Plus, we will mention some common
cases where this feature is useful. The topics we cover will be:</p>
<ul>
<li>What is the Purpose of the VOLUME Instruction in a Dockerfile</li>
<li>How to Set Up a VOLUME in a Dockerfile</li>
<li>Tips for Using the VOLUME Instruction in Dockerfiles</li>
<li>How to Manage Data Safety with the VOLUME Instruction</li>
<li>Common Cases for the VOLUME Instruction in Dockerfiles</li>
<li>Questions We Often Get</li>
</ul>
<p>For more reading on similar topics, we think you will find these
articles useful: <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It?</a>, <a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">What
are Docker Volumes and How Do They Work?</a>, and <a
href="https://bestonlinetutorial.com/docker/how-to-create-and-use-docker-volumes.html">How
to Create and Use Docker Volumes</a>.</p>
<h2
id="understanding-the-purpose-of-the-volume-instruction-in-a-dockerfile">Understanding
the Purpose of the VOLUME Instruction in a Dockerfile</h2>
<p>The <code>VOLUME</code> instruction in a Dockerfile lets us set a
spot for outside storage. This helps our data stay safe even after we
stop or remove the container. So, the data that our app makes or changes
inside the container is still there.</p>
<h3 id="key-purposes-of-the-volume-instruction">Key Purposes of the
VOLUME Instruction:</h3>
<ul>
<li><strong>Data Persistence:</strong> It keeps the data from the app
stored outside the container. This way, we do not lose data when we
remove the container.</li>
<li><strong>Sharing Data:</strong> We can let many containers use the
same data by mounting the same volume.</li>
<li><strong>Improved Performance:</strong> Docker can make reading and
writing from volumes faster than keeping data inside the container.</li>
<li><strong>Isolation:</strong> Volumes hold data separately from the
container. This helps avoid problems and makes our data more
secure.</li>
</ul>
<h3 id="example-of-using-volume-in-dockerfile">Example of Using VOLUME
in Dockerfile:</h3>
<p>To set a volume in a Dockerfile, we write like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Define a volume</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/data&quot;</span>]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Other instructions</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> ./app /app</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python&quot;</span>, <span class="st">&quot;/app/app.py&quot;</span>]</span></code></pre></div>
<p>In this example, we make the <code>/data</code> folder a volume. When
we run the container, Docker will create a new volume for this path.
This allows data saved there to stay even after the container stops.</p>
<p>Using the <code>VOLUME</code> instruction is very important for apps
that need to keep data across different runs. This is true for things
like databases or file upload services. If we want to learn more about
managing data in Docker, we can check out <a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">what
are Docker volumes and how do they work</a>.</p>
<h2 id="how-to-define-a-volume-in-a-dockerfile">How to Define a VOLUME
in a Dockerfile</h2>
<p>To define a <code>VOLUME</code> in a Dockerfile, we use the
<code>VOLUME</code> instruction. After that, we write the path for the
volume. This tells Docker to make a mount point at the path we choose.
We use volumes to keep data that Docker containers create and use.</p>
<h3 id="syntax">Syntax</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/path/to/volume&quot;</span>]</span></code></pre></div>
<h3 id="example">Example</h3>
<p>Here is a simple example of how we can define a volume in a
Dockerfile:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a directory for the volume</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="fu">mkdir</span> <span class="at">-p</span> /data</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the volume</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/data&quot;</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /data</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy files into the volume</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . /data</span></code></pre></div>
<p>In this example, we will create the <code>/data</code> directory in
the container. This directory will be a volume. Any data we write to
this directory will stay there even if we stop or remove the
container.</p>
<h3 id="multiple-volumes">Multiple Volumes</h3>
<p>We can define more than one volume by listing them in the same
instruction:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/data&quot;</span>, <span class="st">&quot;/logs&quot;</span>]</span></code></pre></div>
<h3 id="important-notes">Important Notes</h3>
<ul>
<li>Volumes stay outside the container filesystem. So, data stays there
even if we delete the container.</li>
<li>Using named volumes makes it easier to manage data. We can specify a
volume by name when we run Docker.</li>
<li>To manage data better, we should think about using Docker Compose or
the <code>docker run -v</code> command for mounting volumes.</li>
</ul>
<p>For more information about Docker volumes and how they work, we can
check <a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">What
Are Docker Volumes and How Do They Work?</a>.</p>
<h2
id="best-practices-for-using-the-volume-instruction-in-dockerfiles">Best
Practices for Using the VOLUME Instruction in Dockerfiles</h2>
<p>When we use the <code>VOLUME</code> instruction in Dockerfiles,
following best practices helps us manage data better and improve how our
containers work.</p>
<ol type="1">
<li><p><strong>Define Volumes Early</strong>: We should put the
<code>VOLUME</code> instruction near the top of our Dockerfile. It is
best to place it after the <code>FROM</code> instruction and before
commands like <code>COPY</code> or <code>RUN</code>. This way, we set up
the volume structure early in the build process.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /data</span></code></pre></div></li>
<li><p><strong>Use Named Volumes</strong>: We can choose named volumes.
They make it easier to manage and share data between containers. Docker
creates named volumes automatically. They are friendlier than anonymous
volumes.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/data&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Limit the Number of Volumes</strong>: It might be
tempting to create many volumes for different folders. But, it is better
to keep the number of volumes to what is really needed. This keeps our
container clean and makes data management easier.</p></li>
<li><p><strong>Document Volume Usage</strong>: We should write down the
purpose of each volume in our Dockerfile comments. This helps other
developers understand why each volume is there and why it is
important.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Volume for application data</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /app/data</span></code></pre></div></li>
<li><p><strong>Persist Critical Data</strong>: We must use volumes to
keep important data safe. This data should survive when containers
restart or get deleted. For example, database files or user-created
content should be in volumes.</p></li>
<li><p><strong>Avoid Storing Application Code in Volumes</strong>: We
should not put application code in volumes unless it is really
necessary. This can make the build process and versioning more
complicated. Instead, we should copy application files directly into the
image.</p></li>
<li><p><strong>Use <code>.dockerignore</code></strong>: Let’s use a
<code>.dockerignore</code> file. This file helps us stop unneeded files
from being added to the build context. It can also affect volumes. We
should list patterns to ignore during the build process.</p></li>
<li><p><strong>Test Volume Configuration</strong>: After we set up
volumes, we need to test the configuration well. This is to make sure
they mount correctly and that we can access data as we expect. We can
use commands like <code>docker run</code> and
<code>docker inspect</code> to check.</p></li>
<li><p><strong>Secure Sensitive Data</strong>: If our application deals
with sensitive information, we must keep volumes secure. They should not
be open to the public. We can use Docker secrets or environment
variables for sensitive data when we can.</p></li>
<li><p><strong>Regular Cleanup</strong>: We should have a regular
cleanup plan for volumes. This helps us avoid using too much storage. We
can use commands like <code>docker volume prune</code> to remove unused
volumes that we no longer need.</p></li>
</ol>
<p>By following these best practices for the <code>VOLUME</code>
instruction in Dockerfiles, we can make our containerized applications
better in performance, security, and maintenance. For more information
about Docker volumes and how they work, we can explore <a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">about
Docker volumes and how they work</a>.</p>
<h2 id="how-to-manage-data-persistence-with-the-volume-instruction">How
to Manage Data Persistence with the VOLUME Instruction</h2>
<p>The <code>VOLUME</code> instruction in a Dockerfile is very important
for managing data persistence in Docker containers. It marks a directory
as a volume. This lets us store data that can stay even after the
container stops or is deleted. This is vital when we want to keep data
safe.</p>
<h3 id="defining-a-volume">Defining a Volume</h3>
<p>To define a volume in a Dockerfile, we use this syntax:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/path/to/directory&quot;</span>]</span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> [<span class="st">&quot;/data&quot;</span>]</span></code></pre></div>
<p>This command makes a mount point at <code>/data</code> where we can
keep our persistent data.</p>
<h3 id="managing-data-persistence">Managing Data Persistence</h3>
<ol type="1">
<li><p><strong>Default Behavior</strong>: When we create a volume,
Docker keeps it outside the container’s file system. It stores the data
in a special place on the host system, usually under
<code>/var/lib/docker/volumes/</code>.</p></li>
<li><p><strong>Data Sharing</strong>: We can share volumes between
containers. This allows data exchange. We can define the same volume in
multiple containers. Then they can read and write to the same data.</p>
<p>Here is an example of sharing a volume in a Docker Compose file:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">app1</span><span class="kw">:</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> myapp:latest</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> mydata:/data</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">app2</span><span class="kw">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> myapp:latest</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> mydata:/data</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">mydata</span><span class="kw">:</span></span></code></pre></div></li>
<li><p><strong>Volume Management Commands</strong>:</p>
<ul>
<li><p>To list all volumes, we use:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> volume ls</span></code></pre></div></li>
<li><p>To inspect a specific volume, we use:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> volume inspect mydata</span></code></pre></div></li>
<li><p>To remove an unused volume, we run:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> volume rm mydata</span></code></pre></div></li>
</ul></li>
<li><p><strong>Backing Up and Restoring Volumes</strong>: We can back up
the data in a volume by making a temporary container:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-v</span> mydata:/data <span class="at">-v</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/backup ubuntu tar cvf /backup/backup.tar /data</span></code></pre></div>
<p>To restore, we run:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">--rm</span> <span class="at">-v</span> mydata:/data <span class="at">-v</span> <span class="va">$(</span><span class="bu">pwd</span><span class="va">)</span>:/backup ubuntu bash <span class="at">-c</span> <span class="st">&quot;cd /data &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span></span></code></pre></div></li>
</ol>
<p>Using the <code>VOLUME</code> instruction in our Dockerfile helps our
applications keep data across container lifecycles. This helps us manage
data in our Dockerized applications. For more tips on managing Docker,
check out <a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">what
are Docker volumes and how do they work</a>.</p>
<h2
id="common-use-cases-for-the-volume-instruction-in-dockerfiles">Common
Use Cases for the VOLUME Instruction in Dockerfiles</h2>
<p>The <code>VOLUME</code> instruction in a Dockerfile helps us create a
place to store data. This data comes from the host or other containers.
We use this instruction to manage data that needs to stay even if the
container stops. Here are some common ways we can use the
<code>VOLUME</code> instruction:</p>
<ol type="1">
<li><p><strong>Database Storage</strong>: When we run databases in
containers, we need to keep the data safe. Using <code>VOLUME</code>
helps us store database files outside the container. For example:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> mysql:5.7</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /var/lib/mysql</span></code></pre></div></li>
<li><p><strong>Application Logs</strong>: If our application makes logs,
we can use a volume to keep log files. This way, we do not lose logs
when the container stops or restarts:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /var/log/nginx</span></code></pre></div></li>
<li><p><strong>User Data</strong>: For apps where users upload files, we
can set a volume to save user data. This keeps uploaded files available
even if we recreate the container:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> your_app_image</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /usr/src/app/uploads</span></code></pre></div></li>
<li><p><strong>Configuration Files</strong>: We can use volumes to
handle configuration files. This lets us change them without changing
the container image. For instance:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> your_app_image</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /etc/app/config</span></code></pre></div></li>
<li><p><strong>Sharing Data Between Containers</strong>: We can share
data between many containers using volumes. This is great in
microservices where different services need the same data:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> service_a</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /data</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> service_b</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /data</span></code></pre></div></li>
<li><p><strong>Development Environments</strong>: In development, we can
link host folders to containers for live code updates. We often use a
volume for the application code:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="kw">VOLUME</span> /usr/src/app</span></code></pre></div></li>
<li><p><strong>Backups and Restores</strong>: Using volumes helps us
back up data from our containers. For example, we can back up a database
volume to keep data safe and available.</p></li>
</ol>
<p>Each of these use cases shows us how important the
<code>VOLUME</code> instruction is in Dockerfiles. It helps us keep
data, share data between containers, and manage our apps well. By
knowing these common examples, we can use Docker better to build strong
and scalable applications. For more info on Docker volumes, check this
<a
href="https://bestonlinetutorial.com/docker/what-are-docker-volumes-and-how-do-they-work.html">article
on Docker volumes</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-purpose-of-the-volume-instruction-in-a-dockerfile">1.
What is the purpose of the VOLUME instruction in a Dockerfile?</h3>
<p>The VOLUME instruction in a Dockerfile helps us keep data safe in
Docker containers. When we use a volume, we make sure certain folders in
the container do not change when we stop or delete containers. This
means we can store data separately and access it between different
container runs. It gives us more flexibility and reliability when we
develop applications.</p>
<h3 id="how-do-you-define-a-volume-in-a-dockerfile">2. How do you define
a volume in a Dockerfile?</h3>
<p>To define a volume in a Dockerfile, we use the VOLUME instruction and
write the path of the folder we want to keep. For example, if we want to
create a volume at <code>/data</code>, we write
<code>VOLUME /data</code> in our Dockerfile. This tells Docker to treat
that folder as a volume. It helps keep our data safe even when we
restart the container.</p>
<h3
id="can-you-use-multiple-volume-instructions-in-a-single-dockerfile">3.
Can you use multiple VOLUME instructions in a single Dockerfile?</h3>
<p>Yes, we can use many VOLUME instructions in one Dockerfile. Each
VOLUME instruction makes a new volume. This lets us manage different
data folders separately. For example, we can write
<code>VOLUME /data</code> and <code>VOLUME /logs</code> to keep our app
data and log files safe. This is important for apps that need to save
data from many sources.</p>
<h3
id="what-are-the-best-practices-for-using-the-volume-instruction-in-dockerfiles">4.
What are the best practices for using the VOLUME instruction in
Dockerfiles?</h3>
<p>When we use the VOLUME instruction in Dockerfiles, we should follow
some best practices. First, we should define volumes for folders that
need to keep data. Second, we should not put sensitive data in volumes.
Third, we should write down what each volume is for. Also, it is better
to use named volumes instead of anonymous ones for easier management.
For more tips on Docker best practices, we can check out <a
href="https://bestonlinetutorial.com/docker/what-are-docker-security-best-practices.html">Docker
security best practices</a>.</p>
<h3 id="how-does-the-volume-instruction-impact-container-performance">5.
How does the VOLUME instruction impact container performance?</h3>
<p>The VOLUME instruction can change how well the container works. It
helps keep data safe, but getting data from volumes can be slower than
getting data from the container’s filesystem. This is more true when we
use network storage. We need to find a good balance between keeping data
safe and making sure our application runs quickly while using Docker
volumes.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            