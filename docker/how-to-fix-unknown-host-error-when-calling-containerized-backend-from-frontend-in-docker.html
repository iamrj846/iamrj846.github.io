
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>How to Fix "Unknown Host" Error When Calling Containerized Backend from Frontend in Docker?</title>
            <meta name="description" content="Learn how to resolve the "Unknown Host" error when connecting your frontend to a containerized backend in Docker.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How to Fix "Unknown Host" Error When Calling Containerized Backend from Frontend in Docker?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>To fix the “Unknown Host” error when we call a containerized backend
from a frontend in Docker, we need to make sure that both the frontend
and backend are set up to talk to each other through the same Docker
network. This means we should use the right service names or container
names as hostnames. We also have to check that our Docker Compose file
is set up correctly for the containers to communicate. Fixing DNS
settings and making sure the containers are on the same bridge network
can help solve these problems too.</p>
<p>In this article, we will look at different ways to troubleshoot and
fix the “Unknown Host” error in Docker setups. We will talk about
important topics like what the error means, how to set up the network
correctly, using Docker Compose for better networking, and how to debug
connection problems. Here is a list of solutions we will cover:</p>
<ul>
<li>Understanding the Unknown Host Error in Docker Applications</li>
<li>Ensuring Proper Network Configuration for Docker Containers</li>
<li>Using Docker Compose to Manage Networking Between Containers</li>
<li>Accessing Backend Services with Correct Hostnames in Docker</li>
<li>Debugging Network Connectivity Issues in Docker</li>
</ul>
<p>For more information on Docker basics, we can read about <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">what
is Docker and why you should use it</a> and <a
href="https://bestonlinetutorial.com/docker/how-does-docker-differ-from-virtual-machines.html">how
Docker differs from virtual machines</a>.</p>
<h2
id="understanding-the-unknown-host-error-in-docker-applications">Understanding
the Unknown Host Error in Docker Applications</h2>
<p>The “Unknown Host” error happens when a Docker container cannot find
the hostname of another service or API it wants to connect to. This can
be due to mistakes in networking settings, wrong service names, or DNS
problems in the Docker environment.</p>
<p>Here are some common reasons for the “Unknown Host” error:</p>
<ul>
<li><p><strong>Incorrect Hostname</strong>: Make sure the hostname you
want to reach matches the service name in your Docker setup.</p></li>
<li><p><strong>Missing Networking Configuration</strong>: If your
containers are not on the same network, they cannot talk to each
other.</p></li>
<li><p><strong>DNS Resolution Issues</strong>: Docker has its own DNS to
resolve container names. If this is not set up right or is not working,
you will see this error.</p></li>
</ul>
<p>To fix the “Unknown Host” error, we can follow these steps:</p>
<ol type="1">
<li><p><strong>Check Service Names</strong>: Make sure you use the right
service name in your API calls. For example, if you want to reach a
service named <code>api</code>, your requests should be
<code>http://api:port</code>.</p></li>
<li><p><strong>Inspect Docker Network</strong>: Run this command to see
the networks you created. This helps to check if your containers are
connected to the right network:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network ls</span></code></pre></div></li>
<li><p><strong>Inspect Container Network Settings</strong>: Check the
network settings of your containers. Confirm they are on the same
network:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> inspect <span class="op">&lt;</span>container_id<span class="op">&gt;</span> <span class="kw">|</span> <span class="fu">grep</span> <span class="at">-i</span> network</span></code></pre></div></li>
<li><p><strong>Test DNS Resolution</strong>: Go into the container’s
shell and use tools like <code>nslookup</code> or <code>ping</code> to
see if the service can be resolved:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> exec <span class="at">-it</span> <span class="op">&lt;</span>container_id<span class="op">&gt;</span> /bin/sh</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">nslookup</span> api</span></code></pre></div></li>
<li><p><strong>Docker Compose Configuration</strong>: If we use Docker
Compose, check that your <code>docker-compose.yml</code> file is set up
correctly with the right service names and networks. For example:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> frontend-image</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> my-network</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> backend-image</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> my-network</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">my-network</span><span class="kw">:</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">driver</span><span class="kw">:</span><span class="at"> bridge</span></span></code></pre></div></li>
</ol>
<p>By checking the setup and making sure everything connects well, we
can fix the “Unknown Host” error in Docker applications quickly.</p>
<h2
id="ensuring-proper-network-configuration-for-docker-containers">Ensuring
Proper Network Configuration for Docker Containers</h2>
<p>To fix the “Unknown Host” error when we call a backend in a container
from a frontend in Docker, we need to make sure the network is set up
right for Docker containers. It is important to know how containers talk
to each other in the Docker network and how to set them up
correctly.</p>
<ol type="1">
<li><p><strong>Check Docker Network</strong>: First, we check if both
frontend and backend containers are on the same Docker network. We can
list the networks with this command:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network ls</span></code></pre></div>
<p>To look at a specific network, we use:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network inspect <span class="op">&lt;</span>network_name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Create a Custom Network</strong>: If they are not on the
same network, we can create a custom network:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network create my_custom_network</span></code></pre></div>
<p>Then we can run our containers on this network:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--network</span> my_custom_network <span class="at">--name</span> backend <span class="op">&lt;</span>backend_image<span class="op">&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--network</span> my_custom_network <span class="at">--name</span> frontend <span class="op">&lt;</span>frontend_image<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Service Discovery</strong>: We should use container names
as hostnames. Docker makes DNS for containers, so they can find each
other by names. In our frontend code, we access the backend service by
its container name:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">fetch</span>(<span class="st">&#39;http://backend:port/api/endpoint&#39;</span>)</span></code></pre></div></li>
<li><p><strong>Ports Configuration</strong>: We have to check that the
backend service shows the right ports. In our Dockerfile or Docker
Compose file, we should set the ports:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> &lt;backend_image&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;port:port&quot;</span></span></code></pre></div></li>
<li><p><strong>Docker Compose Example</strong>: If we use Docker
Compose, we write our services in the <code>docker-compose.yml</code>
file. Here is a simple example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> &lt;backend_image&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;5000:5000&quot;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> &lt;frontend_image&gt;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;3000:3000&quot;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> backend</span></span></code></pre></div></li>
<li><p><strong>Network Mode</strong>: If we use <code>host</code> mode,
remember that the containers share the host’s network stack. Then we can
access the backend directly via <code>localhost</code> and the mapped
port:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> &lt;backend_image&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">network_mode</span><span class="kw">:</span><span class="at"> host</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> &lt;frontend_image&gt;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">network_mode</span><span class="kw">:</span><span class="at"> host</span></span></code></pre></div></li>
<li><p><strong>Firewall and Security Groups</strong>: If our Docker
containers are on a cloud service, we need to check that our security
group or firewall rules allow traffic on the needed ports.</p></li>
</ol>
<p>By setting up the network right, we can fix the “Unknown Host” error
when we call a backend in a container from our frontend in Docker. For
more details about Docker networking and settings, we can look at
articles on <a
href="https://bestonlinetutorial.com/docker/what-are-docker-networks-and-why-are-they-necessary.html">Docker
networking</a> and <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">Docker
Compose</a>.</p>
<h2
id="using-docker-compose-to-manage-networking-between-containers">Using
Docker Compose to Manage Networking Between Containers</h2>
<p>Docker Compose makes it easier to manage networks for our container
applications. We can define services in a
<code>docker-compose.yml</code> file. This way, we can run many
containers together as one application. They can talk to each other
smoothly through a shared network.</p>
<h3 id="basic-docker-compose-example">Basic Docker Compose Example</h3>
<p>Here is a simple <code>docker-compose.yml</code> example. It shows a
frontend and a backend service:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3.8&#39;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-frontend:latest</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;3000:3000&quot;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> backend</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-backend:latest</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;5000:5000&quot;</span></span></code></pre></div>
<h3 id="networking-configuration">Networking Configuration</h3>
<p>Docker Compose automatically makes one network for our application.
Containers can talk using their service names. For example, the frontend
can reach the backend using the name <code>backend</code>.</p>
<h3 id="custom-network">Custom Network</h3>
<p>We can also create a custom network if we want:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3.8&#39;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">my_network</span><span class="kw">:</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">driver</span><span class="kw">:</span><span class="at"> bridge</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-frontend:latest</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> my_network</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> my-backend:latest</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> my_network</span></span></code></pre></div>
<h3 id="accessing-services">Accessing Services</h3>
<p>To reach the backend service from the frontend, we can use this URL
in our frontend app:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode javascript"><code class="sourceCode javascript"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">const</span> backendUrl <span class="op">=</span> <span class="st">&#39;http://backend:5000/api/endpoint&#39;</span><span class="op">;</span></span></code></pre></div>
<h3 id="verifying-network-connectivity">Verifying Network
Connectivity</h3>
<p>We can check if our containers can connect using this command:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec frontend ping backend</span></code></pre></div>
<p>This command tells us if the frontend can reach the backend service.
If we see responses, it means the network is set up right.</p>
<h3 id="additional-considerations">Additional Considerations</h3>
<ul>
<li>Make sure our services are running well by using
<code>docker-compose up</code>.</li>
<li>We can use <code>docker-compose logs</code> to fix any problems with
starting services or connecting.</li>
<li>If needed, we can set specific network names to change how services
find each other.</li>
</ul>
<p>Using Docker Compose for networking helps us manage and grow our
container applications. It ensures the frontend can talk to the backend
without “Unknown Host” errors. For more details on using Docker Compose,
check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">this
guide on Docker Compose</a>.</p>
<h2
id="accessing-backend-services-with-correct-hostnames-in-docker">Accessing
Backend Services with Correct Hostnames in Docker</h2>
<p>When we work with Docker containers, using the right hostnames is
very important to access backend services. Each container runs in its
own space. So, we need to understand how Docker manages DNS and
networking.</p>
<h3 id="using-container-names-as-hostnames">Using Container Names as
Hostnames</h3>
<ol type="1">
<li><p><strong>Container Name</strong>: By default, Docker lets us use
the container name as the hostname to talk between containers on the
same Docker network. For example, if we have a backend service in a
container called <code>backend</code>, we can reach it from another
container using the name <code>backend</code>:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> http://backend:port/endpoint</span></code></pre></div></li>
<li><p><strong>Network Configuration</strong>: We must make sure that
both containers are on the same Docker network. We can create a custom
network and connect our containers to it:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network create my-network</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> backend <span class="at">--network</span> my-network backend-image</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> frontend <span class="at">--network</span> my-network frontend-image</span></code></pre></div></li>
</ol>
<h3 id="using-docker-compose-for-simplified-networking">Using Docker
Compose for Simplified Networking</h3>
<p>Docker Compose makes it easier to manage multi-container apps. We can
define services in a <code>docker-compose.yml</code> file, where service
names act as hostnames:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> backend-image</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> frontend-image</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> backend</span></span></code></pre></div>
<p>With this setup, the frontend service can reach the backend service
using <code>http://backend:port/endpoint</code>.</p>
<h3 id="setting-environment-variables">Setting Environment
Variables</h3>
<p>We can also set environment variables in our Docker Compose file to
define hostnames or ports:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> frontend-image</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> BACKEND_URL=http://backend:port/endpoint</span></span></code></pre></div>
<p>The frontend app can then use this variable to connect to the backend
service.</p>
<h3 id="verifying-connectivity">Verifying Connectivity</h3>
<p>If we have problems accessing backend services, we should check
connectivity:</p>
<ul>
<li><p><strong>Inspect Network</strong>: We can use
<code>docker network inspect</code> to make sure both containers are in
the same network.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network inspect my-network</span></code></pre></div></li>
<li><p><strong>Ping the Service</strong>: From the frontend container,
we can ping the backend to test connectivity.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> exec <span class="at">-it</span> frontend ping backend</span></code></pre></div></li>
</ul>
<p>By following these steps for accessing backend services with correct
hostnames in Docker, we can avoid “Unknown Host” errors. This helps us
keep good communication between our container applications.</p>
<h2 id="debugging-network-connectivity-issues-in-docker">Debugging
Network Connectivity Issues in Docker</h2>
<p>We can debug network connection problems between our container apps
in Docker by following these simple steps.</p>
<ol type="1">
<li><p><strong>Check Container Status</strong>: First, we need to make
sure that both the frontend and backend containers are running.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> ps</span></code></pre></div></li>
<li><p><strong>Inspect Network Configuration</strong>: Next, we use this
command to see the networks our containers are connected to.</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network inspect <span class="op">&lt;</span>network_name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Ping Between Containers</strong>: We enter the shell of
the frontend container. Then, we try to ping the backend container using
its name or IP.</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> exec <span class="at">-it</span> <span class="op">&lt;</span>frontend_container_name<span class="op">&gt;</span> /bin/sh</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="fu">ping</span> <span class="op">&lt;</span>backend_container_name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Check DNS Resolution</strong>: If pinging by name does
not work, we check if the DNS is working correctly in the container.</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span> /etc/resolv.conf</span></code></pre></div></li>
<li><p><strong>View Container Logs</strong>: We look at the logs for
both frontend and backend containers. This might show some errors that
point to network problems.</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> logs <span class="op">&lt;</span>container_name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Test Direct Connectivity</strong>: We can use
<code>curl</code> or <code>wget</code> to test if we can connect to the
backend service from the frontend container.</p>
<div class="sourceCode" id="cb28"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="ex">curl</span> http://<span class="op">&lt;</span>backend_container_name<span class="op">&gt;</span>:<span class="op">&lt;</span>port<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Check Firewall Rules</strong>: It is important to check
that our host’s firewall is not blocking the Docker bridge network. We
should change the rules if needed.</p></li>
<li><p><strong>Docker Compose Networks</strong>: If we are using Docker
Compose, we need to make sure that the services are on the same network.
We can check this in the <code>docker-compose.yml</code> file.</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">frontend</span><span class="kw">:</span></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> mynetwork</span></span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">backend</span><span class="kw">:</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> mynetwork</span></span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-9"><a href="#cb29-9" aria-hidden="true" tabindex="-1"></a><span class="fu">networks</span><span class="kw">:</span></span>
<span id="cb29-10"><a href="#cb29-10" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">mynetwork</span><span class="kw">:</span></span></code></pre></div></li>
<li><p><strong>Check for Port Exposure</strong>: We must check that the
backend service is exposing the right ports in the
<code>Dockerfile</code> or <code>docker-compose.yml</code>.</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;8080:80&quot;</span></span></code></pre></div></li>
<li><p><strong>Restart Docker</strong>: If we still have problems,
restarting Docker can fix many temporary connection issues.</p></li>
</ol>
<div class="sourceCode" id="cb31"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a><span class="fu">sudo</span> systemctl restart docker</span></code></pre></div>
<p>By following these steps, we can find and fix network issues in our
Docker apps. For more information on Docker networking, we can read
about <a
href="https://bestonlinetutorial.com/docker/what-are-docker-networks-and-why-are-they-necessary.html">what
are Docker networks and why are they necessary</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-causes-the-unknown-host-error-in-docker-applications">1.
What causes the “Unknown Host” error in Docker applications?</h3>
<p>The “Unknown Host” error in Docker applications happens when the
frontend cannot find the hostname of the backend service. This can be
from wrong network settings, wrong service names in the code, or DNS
problems in Docker. We need to make sure our containers are correctly
connected and that we use the right service names in our API calls to
fix this error.</p>
<h3
id="how-can-i-ensure-proper-network-configuration-for-my-docker-containers">2.
How can I ensure proper network configuration for my Docker
containers?</h3>
<p>To make sure our Docker containers have the right network setup, we
should create a user-defined bridge network. This helps containers talk
to each other using their service names. We can set this up in our
Docker Compose file or by using the <code>docker network create</code>
command. For more help on Docker networking, see our article on <a
href="https://bestonlinetutorial.com/docker/what-are-docker-networks-and-why-are-they-necessary.html">Docker
networks and their necessity</a>.</p>
<h3
id="how-does-docker-compose-help-in-managing-networking-between-containers">3.
How does Docker Compose help in managing networking between
containers?</h3>
<p>Docker Compose makes it easy to manage networking between containers.
We can define services, networks, and volumes in one YAML file. This
helps containers communicate using service names and avoids “Unknown
Host” errors. For more information on this, check our guide on <a
href="https://bestonlinetutorial.com/docker/how-to-write-a-simple-docker-compose-yml-file.html">how
to write a simple Docker Compose YAML file</a>.</p>
<h3
id="what-should-i-do-if-my-backend-service-is-still-inaccessible-after-checking-the-hostname">4.
What should I do if my backend service is still inaccessible after
checking the hostname?</h3>
<p>If our backend service is still not accessible, we should look at our
Docker logs for any error messages. Also, we need to check if the
backend service is running fine and that the right ports are open. For
tips on fixing problems, see our article on <a
href="https://bestonlinetutorial.com/docker/how-to-troubleshoot-docker-networking-issues.html">how
to troubleshoot Docker networking issues</a>.</p>
<h3
id="can-i-access-a-host-machines-services-from-within-a-docker-container">5.
Can I access a host machine’s services from within a Docker
container?</h3>
<p>Yes, we can access a host machine’s services from a Docker container
by using the special DNS name <code>host.docker.internal</code>. This
lets us connect to the host’s services just like they are running inside
the container. If we have problems, check our article on <a
href="https://bestonlinetutorial.com/docker/how-to-connect-to-the-host-machine-s-localhost-from-inside-a-docker-container.html">how
to connect to the host machine’s localhost from inside a Docker
container</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            