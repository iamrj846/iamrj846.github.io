
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>What Does Multiple FROMs Mean in Docker?</title>
            <meta name="description" content="Discover what multiple FROMs mean in Docker, how they affect your build process, and tips for using them effectively.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">What Does Multiple FROMs Mean in Docker?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Using many <code>FROM</code> statements in Docker helps us make
multi-stage builds. This can make our Dockerfile clearer and more
efficient. With this method, we can separate build dependencies from
runtime dependencies. This leads to smaller final images and better
build speed. When we use multiple <code>FROM</code> commands well, we
can improve our Docker images and make our containerized apps work
better.</p>
<p>In this article, we will look closely at multiple <code>FROM</code>
statements in Docker. We will talk about how to use multi-stage builds.
We will also explain why we use multiple <code>FROM</code> commands and
share some best practices. Plus, we will show how these multiple
<code>FROM</code> statements can improve build speed and help with
common problems. In the end, we will answer some frequently asked
questions to help you understand this useful feature in Docker
better.</p>
<ul>
<li>What Does Multiple FROMs Mean in Docker and How to Use Them
Well</li>
<li>Understanding the Purpose of Multiple FROMs in Docker</li>
<li>How to Use Multi-Stage Builds with Multiple FROMs in Docker</li>
<li>Best Practices for Using Multiple FROMs in Dockerfiles</li>
<li>How Multiple FROMs Improve Build Speed in Docker</li>
<li>Solving Common Problems with Multiple FROMs in Docker</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-purpose-of-multiple-froms-in-docker">Understanding
the Purpose of Multiple FROMs in Docker</h2>
<p>The <code>FROM</code> instruction in a Dockerfile tells which base
image to use for the following steps. When we use multiple
<code>FROM</code> statements, we can create multi-stage builds. This
helps us make the image smaller and makes building faster. Each
<code>FROM</code> starts a new build stage. This helps us keep build and
runtime environments separate.</p>
<h3 id="key-purposes-of-using-multiple-froms">Key Purposes of Using
Multiple FROMs:</h3>
<ol type="1">
<li><p><strong>Separation of Concerns</strong>: We can use different
base images for different tasks like building, testing, and
running.</p></li>
<li><p><strong>Smaller Final Image Size</strong>: We only copy what we
need from earlier stages. This way, we do not include build tools and
other extra stuff in the final image.</p></li>
<li><p><strong>Better Build Performance</strong>: Each stage can be
saved separately. So, when we change something in later stages, the
builds are faster.</p></li>
<li><p><strong>Environment Customization</strong>: We can set up
different stages with their own settings and needs. This gives us more
control over how we build.</p></li>
</ol>
<h3 id="example-of-multiple-from-usage">Example of Multiple FROM
Usage:</h3>
<p>Here is an example Dockerfile. It shows how to use multiple
<code>FROM</code> statements in a multi-stage build:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 1: Build the application</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 2: Serve the application</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/build /usr/share/nginx/html</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 80</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;nginx&quot;</span>, <span class="st">&quot;-g&quot;</span>, <span class="st">&quot;daemon off;&quot;</span>]</span></code></pre></div>
<p>In this example: - The first <code>FROM</code> gets the Node.js image
to build the app. - The second <code>FROM</code> uses the Nginx image to
serve the built app. We only copy the necessary build parts from the
first stage. This makes the final image smaller.</p>
<p>Using multiple <code>FROMs</code> in Docker helps us create images
better. It makes the process smoother and helps us manage dependencies
easier. For more details about Docker images, check this <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">article
on Docker images</a>.</p>
<h2
id="how-to-implement-multi-stage-builds-with-multiple-froms-in-docker">How
to Implement Multi-Stage Builds with Multiple FROMs in Docker</h2>
<p>Multi-stage builds in Docker let us use multiple <code>FROM</code>
instructions in one Dockerfile. This helps us make smaller and more
efficient images. We can separate build and runtime environments.</p>
<h3 id="basic-structure-of-multi-stage-builds">Basic Structure of
Multi-Stage Builds</h3>
<p>A multi-stage build works by having many stages in a Dockerfile. Each
stage can have its own base image. Here is a simple example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 1: Build</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> build</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 2: Production</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=build</span> /app/build /usr/share/nginx/html</span></code></pre></div>
<p>In this example: - The first stage uses the <code>node:14</code>
image to build a Node.js app. - The second stage uses
<code>nginx:alpine</code> and copies only what we need from the first
stage.</p>
<h3 id="benefits-of-multi-stage-builds">Benefits of Multi-Stage
Builds</h3>
<ul>
<li><strong>Reduced Image Size</strong>: We only include the final stage
in the final image. This removes unnecessary build dependencies.</li>
<li><strong>Improved Security</strong>: We use a small base image for
the production stage. This makes it safer.</li>
<li><strong>Simplified Dockerfile</strong>: All build steps stay in one
Dockerfile. This helps with keeping things clear.</li>
</ul>
<h3 id="using-multiple-froms">Using Multiple FROMs</h3>
<p>We can define many <code>FROM</code> instructions for different
stages. For example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 1: Build Backend</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> backend</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /go/src/app</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> backend/ ./</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> backend .</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 2: Build Frontend</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> frontend</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> frontend/ ./</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install <span class="kw">&amp;&amp;</span> <span class="ex">npm</span> run build</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 3: Production</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=backend</span> /go/src/app/backend /usr/local/bin/</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=frontend</span> /app/build /usr/share/nginx/html</span></code></pre></div>
<p>This way we can build both a backend service and a frontend app. We
make sure only the needed parts are in the final image.</p>
<h3 id="optimizing-layers">Optimizing Layers</h3>
<p>Using multi-stage builds helps us optimize layers. We can combine
commands to reduce the number of layers we create:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> build</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">npm</span> cache clean <span class="at">--force</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Final stage</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=build</span> /app/build /usr/share/nginx/html</span></code></pre></div>
<h3 id="building-the-image">Building the Image</h3>
<p>To build the Docker image with multi-stage builds, we can use this
build command:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> my-multi-stage-app .</span></code></pre></div>
<h3 id="conclusion">Conclusion</h3>
<p>Using multi-stage builds with multiple <code>FROM</code> instructions
in Docker helps us create images better. We reduce size and improve
security. By organizing our Dockerfile well, we can make our build
process easier and keep our containerized apps clear.</p>
<p>If you want to know more about Docker, you can read about <a
href="https://bestonlinetutorial.com/docker/what-are-multi-stage-docker-builds-and-how-do-they-improve-efficiency.html">what
are multi-stage Docker builds and how do they improve
efficiency</a>.</p>
<h2 id="best-practices-for-using-multiple-froms-in-dockerfiles">Best
Practices for Using Multiple FROMs in Dockerfiles</h2>
<p>When we use multiple <code>FROM</code> statements in Dockerfiles,
especially in multi-stage builds, we can follow some best practices.
This helps us make the build faster and keep the final image smaller.
Here are some important tips:</p>
<ol type="1">
<li><p><strong>Use Named Stages</strong>: Give good names to your
stages. This makes it easier to understand and manage. We can refer to
specific stages later in the Dockerfile.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json ./</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine <span class="kw">AS</span> production</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/build /usr/share/nginx/html</span></code></pre></div></li>
<li><p><strong>Limit the Number of Stages</strong>: Using many
<code>FROM</code> statements can help, but do not use too many stages.
Too many can make things complicated. We should find a good
balance.</p></li>
<li><p><strong>Optimize Layer Usage</strong>: When we define stages, we
should group commands in a smart way. This helps to reduce the number of
layers. For example, we can combine <code>RUN</code> commands.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    build-essential <span class="dt">\</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> clean</span></code></pre></div></li>
<li><p><strong>Clean Up Intermediate Artifacts</strong>: In every stage,
we should remove files that we do not need. This keeps the final image
light. We can use <code>rm</code> to delete temporary files after we
install.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install <span class="at">--production</span> <span class="dt">\</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span> /tmp/<span class="pp">*</span> /var/tmp/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Use Specific Base Images</strong>: Choose small base
images for each stage based on the task. For example, we can use a
lightweight image like <code>alpine</code> for production stages if we
can.</p></li>
<li><p><strong>Leverage Build Arguments</strong>: We can use build
arguments to change builds and pick different base images or settings
without changing the Dockerfile.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ARG</span> NODE_VERSION=14</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:${NODE_VERSION} <span class="kw">AS</span> builder</span></code></pre></div></li>
<li><p><strong>Test Each Stage Independently</strong>: We need to check
that each build stage works well. This makes it easier to fix bugs and
ensures everything builds like we want before going to the next
stage.</p></li>
<li><p><strong>Utilize Caching Effectively</strong>: We should set up
our Dockerfile to use Docker’s caching features. We can do this by
putting commands that do not change often earlier in the file.</p></li>
<li><p><strong>Document Each Stage</strong>: We should write comments to
explain what each stage does. This makes it easier for others or for us
later to understand the logic of the Dockerfile.</p></li>
</ol>
<p>By following these best practices for using multiple
<code>FROM</code> statements in Dockerfiles, we can create Docker images
that are efficient, easy to manage, and optimized. This will help us in
our development work. For more details about Docker and how it works,
you can check out <a
href="https://bestonlinetutorial.com/docker/what-are-multi-stage-docker-builds-and-how-do-they-improve-efficiency.html">What
are Multi-Stage Docker Builds and How Do They Improve
Efficiency?</a>.</p>
<h2 id="how-multiple-froms-enhance-build-performance-in-docker">How
Multiple FROMs Enhance Build Performance in Docker</h2>
<p>Using many <code>FROM</code> statements in a Dockerfile helps us
create multi-stage builds. This can make our builds faster and reduce
the final image size. We can do this by separating the build environment
from the runtime environment.</p>
<h3 id="key-benefits-of-multiple-froms">Key Benefits of Multiple
FROMs:</h3>
<ol type="1">
<li><strong>Smaller Image Size</strong>: When we separate build tools
from runtime tools, we only keep the needed files in the final image.
This makes the image smaller.</li>
<li><strong>Faster Builds</strong>: We can reuse layers from previous
builds. This means if some layers don’t change, they stay cached and do
not need to rebuild. So, our builds go faster.</li>
<li><strong>Better Security</strong>: A smaller runtime image means
fewer tools for attackers to exploit. We don’t carry over unneeded build
tools and dependencies.</li>
<li><strong>Easier Dockerfiles</strong>: We can split complex build
processes into simpler stages. This makes Dockerfiles easier to read and
manage.</li>
</ol>
<h3 id="example-of-multi-stage-build">Example of Multi-Stage Build:</h3>
<p>Here is a simple example of a Dockerfile with multiple
<code>FROM</code> statements:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 1: Build</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json ./</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Stage 2: Production</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/build /usr/share/nginx/html</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 80</span></code></pre></div>
<p>In this example: - The first stage (<code>builder</code>) installs
the dependencies and builds the app. - The second stage uses a small
Nginx image to serve the built files. It only copies what is needed from
the builder stage.</p>
<h3 id="performance-tips">Performance Tips:</h3>
<ul>
<li><strong>Optimize Layers</strong>: We can combine commands to make
fewer layers. This helps with caching and speeds up the build.</li>
<li><strong>Use Specific Tags</strong>: It is good to use exact versions
of base images. This helps us avoid surprises that can slow down our
builds.</li>
<li><strong>Clean Up</strong>: After the build stage, we should remove
unnecessary files. This keeps the final image light.</li>
</ul>
<p>By using multiple <code>FROM</code> statements in Docker, we can make
our builds faster and ensure a clean and secure final image. For more
details on Docker and its features, we can check <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">this
article on Docker images</a>.</p>
<h2
id="troubleshooting-common-issues-with-multiple-froms-in-docker">Troubleshooting
Common Issues with Multiple FROMs in Docker</h2>
<p>When we use multiple <code>FROM</code> statements in a Dockerfile, we
can face some problems. Here are some common issues and how we can fix
them:</p>
<ol type="1">
<li><p><strong>Incorrect Build Context</strong>: We need to make sure
that the files we reference in our builds are in the right context
directory. If we try to copy files from one stage to another and those
files are not in the correct context, our build will fail.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . . </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> nginx:alpine</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/build /usr/share/nginx/html</span></code></pre></div></li>
<li><p><strong>Missing Dependencies</strong>: Each <code>FROM</code>
creates a new build stage. If a later stage needs packages from an
earlier stage, we must make sure those packages are installed in that
earlier stage.</p></li>
<li><p><strong>Layer Caching Issues</strong>: Docker keeps layers based
on the commands in the Dockerfile. If we make changes, we should update
the context and all layers. We can use the <code>--no-cache</code>
option to force a rebuild.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">--no-cache</span> <span class="at">-t</span> myapp .</span></code></pre></div></li>
<li><p><strong>Accessing Environment Variables</strong>: Environment
variables set in one stage do not work in another. We can use
<code>ARG</code> to pass variables between stages.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ARG</span> APP_ENV</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NODE_ENV=$APP_ENV</span></code></pre></div></li>
<li><p><strong>File Permissions</strong>: Files copied from one stage to
another may have different permissions. If we have permission issues, we
can change the permissions in the Dockerfile.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="fu">chmod</span> <span class="at">-R</span> 755 /usr/share/nginx/html</span></code></pre></div></li>
<li><p><strong>Resource Limitations</strong>: If one of our stages needs
a lot of resources, we might reach system limits. We should keep an eye
on resource usage and change our Docker settings if needed.</p></li>
<li><p><strong>Debugging Builds</strong>: We can use the
<code>--progress=plain</code> option during build to see more output.
This might help us find problems.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">--progress</span><span class="op">=</span>plain <span class="at">-t</span> myapp .</span></code></pre></div></li>
<li><p><strong>Verifying Image Layers</strong>: After we build, we
should check the image layers to make sure all expected content is
there. We can use this command:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> history myapp</span></code></pre></div></li>
</ol>
<p>By fixing these common issues, we can use multiple <code>FROM</code>
statements in our Docker builds without big problems. For more insights
on Docker and how it works, we can check out <a
href="https://bestonlinetutorial.com/docker/what-are-multi-stage-docker-builds-and-how-do-they-improve-efficiency.html">what
are multi-stage Docker builds and how do they improve
efficiency</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-are-the-benefits-of-using-multiple-from-statements-in-docker">1.
What are the benefits of using multiple FROM statements in Docker?</h3>
<p>We can use multiple FROM statements in Docker to make multi-stage
builds. This helps to make the final images smaller. We separate the
build environment from the runtime environment. In one stage, we compile
applications with all the tools and dependencies we need. The final
image only has the essentials for running. For more details on Docker’s
efficiency, check out <a
href="https://bestonlinetutorial.com/docker/what-are-multi-stage-docker-builds-and-how-do-they-improve-efficiency.html">what
are multi-stage Docker builds and how do they improve
efficiency</a>.</p>
<h3 id="how-do-multiple-from-statements-impact-docker-image-layers">2.
How do multiple FROM statements impact Docker image layers?</h3>
<p>Every FROM statement in a Dockerfile starts a new build stage. This
creates separate layers for each stage. We can optimize each layer
independently. This means we can cache better and cut down unnecessary
dependencies in the final image. So, the Docker image becomes leaner and
more efficient. Understanding Docker layers is important. Learn more
about <a
href="https://bestonlinetutorial.com/docker/what-is-a-docker-image-layer-and-why-does-it-matter.html">what
is a Docker image layer and why does it matter</a>.</p>
<h3 id="can-i-use-multiple-from-statements-in-a-single-dockerfile">3.
Can I use multiple FROM statements in a single Dockerfile?</h3>
<p>Yes, we can use multiple FROM statements in one Dockerfile. This lets
us do multi-stage builds. We can create more complex applications while
keeping the final image size small. Each stage can have a different base
image and do specific jobs like building and packaging the application.
For more on how Docker builds images, visit <a
href="https://bestonlinetutorial.com/docker/how-do-you-build-a-docker-image-from-a-dockerfile.html">how
do you build a Docker image from a Dockerfile</a>.</p>
<h3
id="what-are-some-common-issues-when-using-multiple-from-statements-in-docker">4.
What are some common issues when using multiple FROM statements in
Docker?</h3>
<p>Some common problems with multiple FROM statements are wrong
dependencies across stages. This can cause broken builds or runtime
errors. Also, managing environment variables between stages can be hard,
since each stage is separate. We need to make sure we copy necessary
files between stages correctly. For help with this, check out <a
href="https://bestonlinetutorial.com/docker/how-to-troubleshoot-docker-build-failures.html">how
to troubleshoot Docker build failures</a>.</p>
<h3
id="how-can-i-optimize-docker-images-using-multiple-from-statements">5.
How can I optimize Docker images using multiple FROM statements?</h3>
<p>To optimize Docker images with multiple FROM statements, we should
use lightweight base images for the final stage. We only add the
dependencies we need. We can use the
<code>COPY --from=&lt;stage&gt;</code> command to get only the needed
artifacts from earlier stages. This helps to make the final image size
smaller and improves build speed. For more tips, look at <a
href="https://bestonlinetutorial.com/docker/how-to-optimize-docker-images-for-performance.html">how
to optimize Docker images for performance</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            