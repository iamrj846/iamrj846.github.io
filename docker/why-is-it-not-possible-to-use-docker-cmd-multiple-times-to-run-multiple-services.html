
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>Why Is It Not Possible to Use Docker CMD Multiple Times to Run Multiple Services?</title>
            <meta name="description" content="Explore the reasons behind Docker CMD limitations and learn how to effectively run multiple services in your containers.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">Why Is It Not Possible to Use Docker CMD Multiple Times to Run Multiple Services?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Using Docker CMD many times to run many services is not a good idea.
This is because the CMD instruction in a Dockerfile can only be set
once. If we write CMD many times, only the last CMD will work. So, we
can only start one service. This happens because CMD tells which command
to run when we start a container. If we have many CMD directives, it
would be unclear which command to run.</p>
<p>In this article, we will look at different ways to run many services
in Docker. We will talk about the limits of Docker CMD for managing many
services. We will see how to use Dockerfile ENTRYPOINT for better
process control. We will also explain the benefits of using Docker
Compose. Moreover, we will share best practices for running several
services in Docker. We will answer common questions about this topic
too. Here are the main solutions we will cover:</p>
<ul>
<li>Limits of Docker CMD for multiple services</li>
<li>How to use Dockerfile ENTRYPOINT for many services</li>
<li>Process management solutions for Docker containers</li>
<li>Using Docker Compose to run many services</li>
<li>Best practices for running several services in Docker</li>
<li>Common questions about running many services in Docker</li>
</ul>
<h2
id="understanding-the-limitations-of-docker-cmd-for-multiple-services">Understanding
the Limitations of Docker CMD for Multiple Services</h2>
<p>Using <code>CMD</code> in a Dockerfile helps us set the default
command when a container starts. But we cannot use <code>CMD</code> many
times in a Dockerfile to run multiple services. Here are some reasons
why:</p>
<ul>
<li><p><strong>Single Command Execution</strong>: Docker containers run
one process at a time in the foreground. If we add multiple
<code>CMD</code> instructions, only the last one will work. Docker
replaces the earlier ones.</p></li>
<li><p><strong>Process Management</strong>: Docker wants us to run one
service in each container. This makes it easier to manage, scale, and
log things. If we run many services in one container, it gets harder to
manage.</p></li>
<li><p><strong>Signal Handling</strong>: A container can only get Unix
signals for one main process. If we run many processes, handling signals
can be tricky. This makes stopping or restarting services smoothly very
difficult.</p></li>
</ul>
<p>Letâ€™s look at an example Dockerfile:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Install services</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> service1 service2</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co"># This CMD will override any previous CMD</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;service1&quot;</span>]</span></code></pre></div>
<p>In this example, even if we want to run <code>service2</code>, only
<code>service1</code> will run. This is because <code>service1</code> is
the last defined <code>CMD</code>.</p>
<p>To run multiple services, we can use other options like:</p>
<ul>
<li><p><strong>Docker Compose</strong>: This tool helps us define and
run multi-container Docker applications. Each service can run in its own
container.</p></li>
<li><p><strong>Supervisors</strong>: We can use tools like
<code>supervisord</code> in our Docker container to manage multiple
processes. But this is usually not a good idea because it makes things
complicated.</p></li>
<li><p><strong>Kubernetes</strong>: If we need to run many services
across clusters, Kubernetes is a strong choice. It helps with scaling,
load balancing, and service discovery.</p></li>
</ul>
<p>For more information about Docker and what it can do, we can check
out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">what
is Docker and why should you use it</a>.</p>
<h2
id="how-to-use-dockerfile-entrypoint-for-running-multiple-services">How
to Use Dockerfile ENTRYPOINT for Running Multiple Services</h2>
<p>We can run multiple services in a Docker container using the
<code>ENTRYPOINT</code> instruction in the Dockerfile. The
<code>CMD</code> can be changed when we start a container. But
<code>ENTRYPOINT</code> always runs the main command when the container
starts. To handle multiple services, we can make a script that starts
each service. Then we set that script as the
<code>ENTRYPOINT</code>.</p>
<p>Here is a simple example to show how to do this:</p>
<ol type="1">
<li>First, create a shell script called <code>start-services.sh</code>
to start the services:</li>
</ol>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">#!/bin/bash</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="co"># start-services.sh</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Start Service 1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="ex">service1</span> <span class="kw">&amp;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Start Service 2</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="ex">service2</span> <span class="kw">&amp;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Wait for all background processes</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">wait</span></span></code></pre></div>
<ol start="2" type="1">
<li>Next, make the script executable:</li>
</ol>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">chmod</span> +x start-services.sh</span></code></pre></div>
<ol start="3" type="1">
<li>Now, create a Dockerfile that uses this script:</li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Install necessary packages</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> service1 service2</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the script into the container</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> start-services.sh /usr/local/bin/start-services.sh</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the ENTRYPOINT</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/local/bin/start-services.sh&quot;</span>]</span></code></pre></div>
<ol start="4" type="1">
<li>Finally, build and run the Docker container:</li>
</ol>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> multi-service-app .</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run multi-service-app</span></code></pre></div>
<p>This setup allows us to run multiple services in one Docker container
using the <code>ENTRYPOINT</code> instruction. It makes sure all
services start when we launch the container. If we want to manage
multiple services better, we can look into frameworks like Docker
Compose. It can make things easier.</p>
<p>For more tips on using Docker, we can check out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">what
is Docker Compose and how does it simplify multi-container
applications</a>.</p>
<h2
id="exploring-process-management-solutions-for-docker-containers">Exploring
Process Management Solutions for Docker Containers</h2>
<p>When we run many services in a Docker container, managing processes
can be hard. Docker containers are made to run one process at a time.
So, we need to find ways to manage processes in this environment. Here
are some common methods:</p>
<ol type="1">
<li><p><strong>Using Supervisord</strong>: Supervisord is a tool to
control processes. It lets us manage many processes in one container. We
can install it in our Docker image and set it up to run multiple
services.</p>
<p><strong>Dockerfile Example</strong>:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> supervisor</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Add your config file</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> supervisord.conf /etc/supervisor/conf.d/supervisord.conf</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/usr/bin/supervisord&quot;</span>]</span></code></pre></div>
<p><strong>supervisord.conf Example</strong>:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[supervisord]</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">nodaemon</span><span class="ot">=</span><span class="kw">true</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">[program:service1]</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">command</span><span class="ot">=</span><span class="st">/path/to/service1</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="kw">[program:service2]</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="dt">command</span><span class="ot">=</span><span class="st">/path/to/service2</span></span></code></pre></div></li>
<li><p><strong>Using Tini</strong>: Tini is a small init system for
Docker containers. It helps us handle zombie processes and signals well.
We can use Tini as the entry point for our Docker container.</p>
<p><strong>Dockerfile Example</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> tini</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> my-service /usr/local/bin/my-service</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/usr/bin/tini&quot;</span>, <span class="st">&quot;--&quot;</span>]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/usr/local/bin/my-service&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Using S6 Overlay</strong>: S6 is another light tool for
supervising processes. It works well with Docker. It helps us manage
many services and gives us a strong environment for service
management.</p>
<p><strong>Dockerfile Example</strong>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:3.12</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apk</span> add <span class="at">--no-cache</span> s6</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> ./services /etc/services.d/</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> run /etc/cont-init.d/</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/usr/bin/s6-svscan&quot;</span>, <span class="st">&quot;/etc/services.d&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Docker Compose</strong>: Docker Compose is not a classic
process management tool. But it makes it easy to run many services by
defining them in a <code>docker-compose.yml</code> file. Each service
can run in its own container, which helps us manage them better.</p>
<p><strong>docker-compose.yml Example</strong>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;80:80&quot;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db</span><span class="kw">:</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> postgres</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_PASSWORD</span><span class="kw">:</span><span class="at"> example</span></span></code></pre></div></li>
<li><p><strong>Using SystemD</strong>: If we run Docker on a system that
uses systemd, we can set up services that manage Docker containers as
systemd services. This lets us manage containers in a native way.</p>
<p><strong>Service File Example</strong>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode ini"><code class="sourceCode ini"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">[Unit]</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="dt">Description</span><span class="ot">=</span><span class="st">My Docker Container</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="dt">Requires</span><span class="ot">=</span><span class="st">docker.service</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">After</span><span class="ot">=</span><span class="st">docker.service</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">[Service]</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dt">Restart</span><span class="ot">=</span><span class="st">always</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="dt">ExecStart</span><span class="ot">=</span><span class="st">/usr/bin/docker start my_container</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="dt">ExecStop</span><span class="ot">=</span><span class="st">/usr/bin/docker stop my_container</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">[Install]</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="dt">WantedBy</span><span class="ot">=</span><span class="st">multi-user.target</span></span></code></pre></div></li>
</ol>
<p>Using these process management solutions helps us run multiple
services in Docker containers better. It also keeps them running
smoothly without problems. For more instructions on managing services,
check out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">Docker
Compose</a> for an easy way to organize.</p>
<h2 id="using-docker-compose-to-run-multiple-services">Using Docker
Compose to Run Multiple Services</h2>
<p>Docker Compose is a useful tool. It helps us manage many container
Docker applications easily. We can define and run several services in
one YAML file. This makes it a great choice for apps with many connected
parts.</p>
<p>To use Docker Compose for running multiple services, we can follow
these steps:</p>
<ol type="1">
<li><strong>Create a <code>docker-compose.yml</code> File</strong>: This
file shows the services, networks, and volumes for our app.</li>
</ol>
<div class="sourceCode" id="cb12"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3.8&#39;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx:latest</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;80:80&quot;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">app</span><span class="kw">:</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">build</span><span class="kw">:</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">context</span><span class="kw">:</span><span class="at"> .</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">dockerfile</span><span class="kw">:</span><span class="at"> Dockerfile</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">depends_on</span><span class="kw">:</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> db</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="at">      </span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db</span><span class="kw">:</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> postgres:latest</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_USER</span><span class="kw">:</span><span class="at"> example</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_PASSWORD</span><span class="kw">:</span><span class="at"> example</span></span></code></pre></div>
<ol start="2" type="1">
<li><strong>Service Configuration</strong>:
<ul>
<li>Each service can have its own image, build context, ports,
environment variables, and dependencies.</li>
<li>In the example, the <code>web</code> service runs an Nginx server.
The <code>app</code> service builds from a Dockerfile in the current
folder. The <code>db</code> service runs a PostgreSQL database.</li>
</ul></li>
<li><strong>Running the Services</strong>:
<ul>
<li>To start the services in the <code>docker-compose.yml</code>, we run
the command:</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up</span></code></pre></div>
<ul>
<li>This command builds images and starts all the services we
defined.</li>
</ul></li>
<li><strong>Scaling Services</strong>:
<ul>
<li>We can scale services to run more instances easily. For example, to
scale the <code>app</code> service:</li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">--scale</span> app=3</span></code></pre></div></li>
<li><strong>Managing Services</strong>:
<ul>
<li>To stop all services, we use:</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> down</span></code></pre></div>
<ul>
<li>To see logs for all services, we write:</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> logs</span></code></pre></div></li>
<li><strong>Best Practices</strong>:
<ul>
<li>Use version control for your <code>docker-compose.yml</code>
file.</li>
<li>Keep services stateless when possible.</li>
<li>Define networks clearly for better isolation and communication
between services.</li>
</ul></li>
</ol>
<p>Using Docker Compose helps us reduce the difficulty of managing
several services. This makes our development and deployment process
smoother. For more information on Docker and its benefits, check out <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">what
are the benefits of using Docker in development</a>.</p>
<h2 id="best-practices-for-running-multiple-services-in-docker">Best
Practices for Running Multiple Services in Docker</h2>
<p>When we run multiple services in Docker, we need to follow some best
practices. This helps us keep our applications easy to maintain, scale,
and reliable. Here are some key practices we should use:</p>
<ul>
<li><p><strong>Use Docker Compose</strong>: We should use Docker Compose
to define and run multi-container applications. It helps us set up
services, networks, and volumes in one <code>docker-compose.yml</code>
file.</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;80:80&quot;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db</span><span class="kw">:</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> postgres</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_DB</span><span class="kw">:</span><span class="at"> exampledb</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_USER</span><span class="kw">:</span><span class="at"> user</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_PASSWORD</span><span class="kw">:</span><span class="at"> password</span></span></code></pre></div></li>
<li><p><strong>Leverage Docker Networks</strong>: We can create custom
networks for our containers. This is better than using the default
bridge network. It makes our setup safer and keeps things separate.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> network create my-network</span></code></pre></div></li>
<li><p><strong>Use Health Checks</strong>: We should add health checks
in our Docker containers. This makes sure that our services run well.
Docker can restart containers that do not pass health checks.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">HEALTHCHECK</span> <span class="op">--interval=30s</span> <span class="op">--timeout=10s</span> <span class="op">--retries=3</span> <span class="kw">CMD</span> <span class="ex">curl</span> <span class="at">-f</span> http://localhost/ <span class="kw">||</span> <span class="bu">exit</span> 1</span></code></pre></div></li>
<li><p><strong>Separate Concerns</strong>: We can split our application
into smaller services (microservices). This helps us follow the single
responsibility idea. Each service should do one job.</p></li>
<li><p><strong>Resource Limits</strong>: We need to set CPU and memory
limits for our containers. This stops one service from using all the
resources of the host.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="fu">deploy</span><span class="kw">:</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">resources</span><span class="kw">:</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">limits</span><span class="kw">:</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">cpus</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;0.1&#39;</span></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">memory</span><span class="kw">:</span><span class="at"> 50M</span></span></code></pre></div></li>
<li><p><strong>Environment Variables</strong>: We can use environment
variables for our configuration. This lets us change settings without
changing the code or the image.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> NODE_ENV=production</span></span></code></pre></div></li>
<li><p><strong>Volume Management</strong>: We should use volumes to keep
data and share it between containers. It is better to avoid bind mounts
in production since they can cause problems.</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="fu">volumes</span><span class="kw">:</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db-data</span><span class="kw">:</span></span></code></pre></div></li>
<li><p><strong>Logging and Monitoring</strong>: We need to have logging
and monitoring for our services. This helps us check how things are
working and find problems. We can use tools like Prometheus and Grafana
for monitoring. For logging, we can use the ELK stack.</p></li>
<li><p><strong>Service Discovery</strong>: We should use service
discovery methods. This helps containers find and talk to each other.
Docker Swarm or Kubernetes can help with this.</p></li>
<li><p><strong>Security Best Practices</strong>: We need to update our
images often. We should use small base images to reduce risks and run
containers as non-root users if we can.</p></li>
</ul>
<p>By following these best practices, we can manage multiple services in
Docker well. This helps our applications be strong and easy to scale.
For more details on container orchestration and best practices, we can
check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">this
article on Docker Compose</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="can-we-run-multiple-commands-in-a-docker-cmd-instruction">1. Can
we run multiple commands in a Docker CMD instruction?</h3>
<p>No, we cannot use Docker CMD many times to run several services. Each
Dockerfile can only have one CMD instruction. Instead, we can chain
commands using <code>&amp;&amp;</code>. We can also use a shell script
that includes all the commands we need and call it from CMD. This way,
our single CMD instruction runs our multi-service setup well.</p>
<h3 id="what-is-the-difference-between-cmd-and-entrypoint-in-docker">2.
What is the difference between CMD and ENTRYPOINT in Docker?</h3>
<p>The main difference between CMD and ENTRYPOINT in Docker is how they
run. CMD gives default arguments for the ENTRYPOINT instruction or tells
which command to run when a container starts. ENTRYPOINT defines the
main command that will always run in the container. This makes it better
for running services. For more details, check the article on <a
href="https://bestonlinetutorial.com/docker/what-are-the-key-differences-between-cmd-and-entrypoint-in-a-dockerfile.html">key
differences between CMD and ENTRYPOINT</a>.</p>
<h3 id="how-can-we-manage-multiple-services-in-a-docker-container">3.
How can we manage multiple services in a Docker container?</h3>
<p>To manage multiple services well in a Docker container, we can use
Docker Compose. Docker Compose helps us define and run multi-container
Docker applications easily. We can set up each service in a
<code>docker-compose.yml</code> file. This makes it easy to start many
services together. For more insights on managing services, visit <a
href="https://bestonlinetutorial.com/docker/how-do-you-define-multiple-services-in-docker-compose.html">how
to define multiple services in Docker Compose</a>.</p>
<h3
id="what-tools-can-help-with-process-management-in-docker-containers">4.
What tools can help with process management in Docker containers?</h3>
<p>We can use process management tools like Supervisor or systemd inside
our Docker container to help run and manage multiple services. These
tools can check and restart services if they fail. This way, our
applications stay available. For more information, see how to <a
href="https://bestonlinetutorial.com/docker/how-can-you-effectively-use-a-supervisor-in-docker.html">effectively
use a supervisor in Docker</a>.</p>
<h3 id="why-does-my-docker-container-stop-after-executing-cmd">5. Why
does my Docker container stop after executing CMD?</h3>
<p>A Docker container stops if the command in CMD finishes. This happens
because Docker containers run in the foreground. When the main process
exits, the container stops. To keep our container running, we can use a
long-running foreground process or a process manager that keeps the
container alive while managing the services. For more help, refer to <a
href="https://bestonlinetutorial.com/docker/why-does-a-docker-container-exit-immediately.html">why
does a Docker container exit immediately</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            