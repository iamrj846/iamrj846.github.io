
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TFCQEJR7TD');
</script>
            <title>How Do You Build a Docker Image from a Dockerfile?</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to build a Docker image from a Dockerfile with our step-by-step guide. Master Docker and streamline your development!">

            
            <script src="/assets/js/blog.js" defer></script>
            <link rel="stylesheet" href="/assets/css/post.css">
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Do You Build a Docker Image from a Dockerfile?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Building a Docker image from a Dockerfile is a basic step in
containerization. A Dockerfile is like a plan. It has a list of steps to
create a Docker image. This image holds everything we need to run an
application. It includes the code, runtime, libraries, and environment
variables. By following the steps in the Dockerfile, we can make sure
that our applications work the same way in different places. This helps
us automate things and keep our apps portable.</p>
<p>In this article, we will talk about how to build a Docker image using
a Dockerfile. We will also see why Dockerfiles are important in the
development process. We will list the steps to make a Dockerfile. Then,
we will look at good practices for writing one. We will also share tips
to make the Docker image build process better. Plus, we will answer some
common questions about Docker images and Dockerfiles.</p>
<ul>
<li>How Can We Build a Docker Image Using a Dockerfile?</li>
<li>What is a Dockerfile and Why is it Important?</li>
<li>What are the Steps to Create a Dockerfile?</li>
<li>How Do We Build a Docker Image from a Dockerfile?</li>
<li>What are Best Practices for Writing a Dockerfile?</li>
<li>How Can We Optimize Our Docker Image Build Process?</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information about Docker and what it can do, we can check
these related articles: <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It?</a>, <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">What
are Docker Images and How Do They Work?</a>, and <a
href="https://bestonlinetutorial.com/docker/how-to-install-docker-on-different-operating-systems.html">How
to Install Docker on Different Operating Systems</a>.</p>
<h2 id="what-is-a-dockerfile-and-why-is-it-important">What is a
Dockerfile and Why is it Important?</h2>
<p>A Dockerfile is a simple text file. It has all the commands we need
to build a Docker image. It helps us automate the image building
process. Each command in the Dockerfile makes a layer in the image. This
helps us with versioning and caching.</p>
<h3 id="importance-of-dockerfile">Importance of Dockerfile:</h3>
<ul>
<li><strong>Automation</strong>: It automates how we create images. This
keeps everything the same in different environments.</li>
<li><strong>Reproducibility</strong>: Anyone can easily create the same
environment. They just need to use the same Dockerfile to build the
image.</li>
<li><strong>Version Control</strong>: We can track changes to the
Dockerfile like we do with source code.</li>
<li><strong>Efficiency</strong>: Docker saves the layers from Dockerfile
commands. This makes the next builds faster by reusing layers that did
not change.</li>
<li><strong>Documentation</strong>: The Dockerfile shows the setup and
dependencies of the application. This makes it easier for new developers
to learn about the environment.</li>
</ul>
<h3 id="example-of-a-simple-dockerfile">Example of a Simple
Dockerfile:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use an official Python runtime as a parent image</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> python:3.9-slim</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory in the container</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the current directory contents into the container at /app</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Install any needed packages specified in requirements.txt</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">pip</span> install <span class="at">--no-cache-dir</span> <span class="at">-r</span> requirements.txt</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Make port 80 available to the world outside this container</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 80</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Define environment variable</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NAME World</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Run app.py when the container launches</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python&quot;</span>, <span class="st">&quot;app.py&quot;</span>]</span></code></pre></div>
<p>This example shows how to set up a Python app using a Dockerfile. For
more detailed info about Dockerfile and how we can create one, please
check this article on <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">What
is the Dockerfile and how do you create one</a>.</p>
<h2 id="what-are-the-steps-to-create-a-dockerfile">What are the Steps to
Create a Dockerfile?</h2>
<p>Creating a Dockerfile means we define some instructions. Docker will
use these to build an image. Here are the easy steps to create a
Dockerfile.</p>
<ol type="1">
<li><p><strong>Choose a Base Image</strong>: We start with a base image
from Docker Hub. This image is the base for our application. We use the
<code>FROM</code> instruction.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span></code></pre></div></li>
<li><p><strong>Set Working Directory</strong>: We use the
<code>WORKDIR</code> instruction. This sets the directory where we run
commands.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span></code></pre></div></li>
<li><p><strong>Copy Files</strong>: We use the <code>COPY</code>
instruction to copy files from our host to the image.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span></code></pre></div></li>
<li><p><strong>Install Dependencies</strong>: We use the
<code>RUN</code> instruction. This helps us run commands to install the
dependencies.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> python3</span></code></pre></div></li>
<li><p><strong>Add Environment Variables</strong>: We use the
<code>ENV</code> instruction to set environment variables.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> PORT=5000</span></code></pre></div></li>
<li><p><strong>Expose Ports</strong>: We use the <code>EXPOSE</code>
instruction. This shows the port where the container will listen.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 5000</span></code></pre></div></li>
<li><p><strong>Define Command to Run</strong>: We use the
<code>CMD</code> instruction. This tells what command to run when the
container starts.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python3&quot;</span>, <span class="st">&quot;app.py&quot;</span>]</span></code></pre></div></li>
</ol>
<p>By following these steps, we can create a Dockerfile. This will show
how to build a Docker image for our application. For more details on the
Dockerfile and what it has, check out <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">What
is the Dockerfile and how do you create one?</a>.</p>
<h2 id="how-do-you-build-a-docker-image-from-a-dockerfile">How Do You
Build a Docker Image from a Dockerfile?</h2>
<p>Building a Docker image from a Dockerfile is easy. We use the
<code>docker build</code> command for this. A Dockerfile has
instructions that tell how to make an image. Let’s see how we can build
a Docker image from a Dockerfile.</p>
<ol type="1">
<li><p><strong>Create a Dockerfile</strong>: First, we need to make a
file called <code>Dockerfile</code> in our project folder. Here is a
simple example of a Dockerfile that uses Node.js:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the official Node.js image as a base</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory in the container</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /usr/src/app</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy package.json and package-lock.json</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the rest of the application files</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Expose the application port</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 8080</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Command to run the application</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;app.js&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Open a terminal</strong>: Now we should go to the folder
where our Dockerfile is.</p></li>
<li><p><strong>Build the Docker image</strong>: Next, we run this
command to build the image. Change <code>my-node-app</code> to whatever
name you want for your image.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> my-node-app .</span></code></pre></div>
<ul>
<li>The <code>-t</code> flag gives the image a name.</li>
<li>The <code>.</code> at the end means we are using the current folder
as the build context.</li>
</ul></li>
<li><p><strong>Verify the image is created</strong>: We can check with
this command to see all Docker images and to make sure our image is
there.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> images</span></code></pre></div></li>
<li><p><strong>Run the Docker image</strong>: To run the image we built,
we can use this command:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-p</span> 8080:8080 my-node-app</span></code></pre></div></li>
</ol>
<p>This command connects port 8080 on our computer to port 8080 in the
container.</p>
<p>For more information about Docker and its parts, we can look at
resources like <a
href="https://bestonlinetutorial.com/docker/what-is-a-dockerfile-and-how-do-you-create-one.html">What
is a Dockerfile and Why is it Important?</a> and <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">What
are Docker Images and How Do They Work?</a>.</p>
<h2 id="what-are-best-practices-for-writing-a-dockerfile">What are Best
Practices for Writing a Dockerfile?</h2>
<p>Writing a good Dockerfile is important for making Docker images that
work well. Here are some best practices we can follow:</p>
<ol type="1">
<li><p><strong>Use Official Base Images</strong>: We should start with
an official base image from Docker Hub. These images are usually safe
and well-kept. For example:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span></code></pre></div></li>
<li><p><strong>Minimize Number of Layers</strong>: We can combine
commands to make fewer layers in our image. Use <code>&amp;&amp;</code>
to join commands:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    package1 <span class="dt">\</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    package2 <span class="dt">\</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Leverage Caching</strong>: We need to order instructions
smartly to use Docker’s cache well. Place commands that don’t change
much at the top. Put the commands that change often at the
bottom.</p></li>
<li><p><strong>Specify Image Versions</strong>: We should lock specific
versions of base images and dependencies. This helps avoid builds that
behave unpredictably:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14.17.0</span></code></pre></div></li>
<li><p><strong>Use .dockerignore</strong>: We can create a
<code>.dockerignore</code> file. This file helps us ignore files and
folders we don’t need in the build. This action makes our image smaller
and builds faster:</p>
<pre><code>node_modules
*.log</code></pre></li>
<li><p><strong>Avoid Installing Unnecessary Packages</strong>: We only
install packages that our application really needs. This choice keeps
the image size down.</p></li>
<li><p><strong>Use Multi-Stage Builds</strong>: For bigger apps, we can
use multi-stage builds. This method helps to make the final image
smaller by separating what we need for building and what we need to
run:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> builder</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/myapp .</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;./myapp&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Set Non-Root User</strong>: To keep things safe, we run
our application as a non-root user:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">useradd</span> <span class="at">-ms</span> /bin/bash appuser</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">USER</span> appuser</span></code></pre></div></li>
<li><p><strong>Keep Dockerfile Simple</strong>: We write clear and short
instructions. We use comments to explain parts that are hard to
understand.</p></li>
<li><p><strong>Regularly Update Base Images</strong>: We should update
base images and dependencies often. This update helps us get security
fixes and improvements.</p></li>
</ol>
<p>By following these best practices, we can make Dockerfiles that are
efficient, safe, and easy to maintain. This way, we will get better
Docker images. For more information on Dockerfiles, we can check <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">What
is the Dockerfile and how do you create one?</a>.</p>
<h2 id="how-can-we-optimize-our-docker-image-build-process">How Can We
Optimize Our Docker Image Build Process?</h2>
<p>We can make our Docker image build process better. This will help us
build faster and work more efficiently. Here are some simple ways to do
this:</p>
<ol type="1">
<li><p><strong>Use Multi-Stage Builds</strong>:<br />
Multi-stage builds help us separate the build environment from the
runtime environment. This way, we can make the final image smaller.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First stage: build environment</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> builder</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Second stage: runtime environment</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/myapp /app/myapp</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/app/myapp&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Leverage Cache</strong>:<br />
Docker keeps a cache of layers. So, we should structure our Dockerfile
to use cache well. We can put commands that change less often at the
top. We can place commands that change more often at the bottom.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This order helps in caching</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json ./</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> run build</span></code></pre></div></li>
<li><p><strong>Minimize Layers</strong>:<br />
We should combine commands when we can. This helps to reduce the number
of layers in our image.</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    package1 <span class="dt">\</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    package2 <span class="dt">\</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Use .dockerignore</strong>:<br />
We should create a <code>.dockerignore</code> file. This file helps us
exclude files we do not need from the build context. It makes the
context sent to Docker daemon smaller.</p>
<pre><code>node_modules
.git
*.log</code></pre></li>
<li><p><strong>Optimize Base Images</strong>:<br />
We should choose small base images like <code>alpine</code> or
<code>scratch</code>. This helps to reduce the size of the image. But we
need to ensure they fit our application needs.</p></li>
<li><p><strong>Clean Up After Installation</strong>:<br />
We should clean up temporary files and caches in the same layer. This
keeps our image size small.</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    package <span class="dt">\</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> clean <span class="dt">\</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Use Specific Tags</strong>:<br />
When we pull base images, we should use specific tags. This helps us
avoid unexpected changes that can slow down our builds.</p></li>
<li><p><strong>Parallel Builds</strong>:<br />
If we build many images, we can use Docker’s BuildKit. It lets us build
images at the same time. This can make the process much faster. We can
enable BuildKit with:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="bu">export</span> <span class="va">DOCKER_BUILDKIT</span><span class="op">=</span>1</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build .</span></code></pre></div></li>
<li><p><strong>Profile Builds</strong>:<br />
We can use Docker’s build history and performance features. These can
help us check our builds and find slow parts:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">--progress</span><span class="op">=</span>plain .</span></code></pre></div></li>
</ol>
<p>By using these simple tips, we can make our Docker image build
process better. This means we will have faster builds and smaller
images. For more information about creating Dockerfiles and best
practices, we can refer to <a
href="https://bestonlinetutorial.com/docker/what-is-a-dockerfile-and-how-do-you-create-one.html">what
is the Dockerfile and how do we create one</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-a-dockerfile-and-how-does-it-work">1. What is a
Dockerfile and how does it work?</h3>
<p>A Dockerfile is a text file. It has all the commands we need to
create a Docker image. It helps us build images automatically. This
keeps things the same across different places. With a Dockerfile, we can
choose the base image, add files, install what we need, and set up the
environment. If you want to learn more about Dockerfiles and how to make
one, check this article on <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">what
is the Dockerfile and how do you create one</a>.</p>
<h3 id="how-do-i-optimize-my-docker-image-size">2. How do I optimize my
Docker image size?</h3>
<p>To make our Docker image smaller, we can use a smaller base image
like Alpine Linux. We should also try to have fewer layers in our
Dockerfile. We can use multi-stage builds to keep the build environment
separate from the runtime environment. This way, we only include the
files we need in the final image. Also, we should clean up any images
and layers we no longer use to save space. For more details on
optimizing Docker images, visit <a
href="https://bestonlinetutorial.com/docker/how-to-install-docker-on-different-operating-systems.html">how
to install Docker on different operating systems</a>.</p>
<h3 id="can-i-build-a-docker-image-without-a-dockerfile">3. Can I build
a Docker image without a Dockerfile?</h3>
<p>Yes, we can build a Docker image without a Dockerfile. We can use the
Docker CLI’s <code>docker commit</code> command. This lets us create an
image from a running container’s current state. But it’s better to use a
Dockerfile. It helps us keep things clear and makes it easier to manage
our images. For more insights on Docker images, read <a
href="https://bestonlinetutorial.com/docker/what-are-docker-images-and-how-do-they-work.html">what
are Docker images and how do they work</a>.</p>
<h3 id="what-are-the-common-commands-used-in-a-dockerfile">4. What are
the common commands used in a Dockerfile?</h3>
<p>Some common commands in a Dockerfile are <code>FROM</code> to pick
the base image, <code>RUN</code> to run commands while making the image,
<code>COPY</code> to add files from our computer to the image, and
<code>CMD</code> to set the default command that runs when the container
starts. Knowing these commands is important to build Docker images well.
For a deeper look into Docker commands, check <a
href="https://bestonlinetutorial.com/docker/how-do-docker-images-get-created.html">how
do Docker images get created</a>.</p>
<h3 id="what-are-the-best-practices-for-writing-a-dockerfile">5. What
are the best practices for writing a Dockerfile?</h3>
<p>Some good practices for writing a Dockerfile are to start with a
small base image, combine commands to have fewer layers, and remove
temporary files to keep the image size down. It is also good to use
specific versions of images. This helps us keep things the same and
avoid problems when we deploy. For more tips, check out <a
href="https://bestonlinetutorial.com/docker/what-are-the-core-components-of-docker-architecture.html">what
are the core components of Docker architecture</a>.</p>
<p>These questions help us learn about building a Docker image from a
Dockerfile. They make it easier to understand the process and improve
our Docker workflow. For more knowledge, explore the articles linked
above.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            