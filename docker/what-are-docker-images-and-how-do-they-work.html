
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TFCQEJR7TD');
</script>
            <title>What Are Docker Images and How Do They Work?</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover what Docker images are and how they function. Learn their role in containerization for efficient app development.">

            
            <script src="/assets/js/blog.js" defer></script>
            <link rel="stylesheet" href="/assets/css/post.css">
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">What Are Docker Images and How Do They Work?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Docker images are small and standalone software packages. They have
everything needed to run software. This includes the code, runtime,
libraries, environment variables, and configuration files. We can think
of them as a blueprint for making Docker containers. Containers are the
running versions of these images. When we use Docker images, we help our
applications run the same way in different environments. This helps us
avoid the problem of “it works on my machine.”</p>
<p>In this article, we will look at the basics of Docker images. We will
talk about how they work and what they are made of. We will also learn
how to create our own Docker image. Additionally, we will explore Docker
image layers and caching. We will discuss how we can use Docker images
in our projects. We will give tips on managing and improving them for
better performance. Lastly, we will answer some common questions about
Docker images to help us understand this important part of
containerization.</p>
<ul>
<li>What Are Docker Images and How Do They Function?</li>
<li>Understanding the Structure of Docker Images</li>
<li>How to Create Your Own Docker Image?</li>
<li>Exploring Docker Image Layers and Caching</li>
<li>How to Use Docker Images in Your Projects?</li>
<li>Managing and Optimizing Docker Images</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on related topics, we can check these articles: <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It?</a>, <a
href="https://bestonlinetutorial.com/docker/how-does-docker-differ-from-virtual-machines.html">How
Does Docker Differ from Virtual Machines?</a>, <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
Are the Benefits of Using Docker in Development?</a>, <a
href="https://bestonlinetutorial.com/docker/what-is-containerization-and-how-does-it-relate-to-docker.html">What
is Containerization and How Does It Relate to Docker?</a>, and <a
href="https://bestonlinetutorial.com/docker/how-to-install-docker-on-different-operating-systems.html">How
to Install Docker on Different Operating Systems?</a>.</p>
<h2 id="understanding-the-structure-of-docker-images">Understanding the
Structure of Docker Images</h2>
<p>We know that Docker images are built using layers. This helps us
store and share application parts easily. Each image has one or more
layers stacked on each other. We can break down the structure of a
Docker image into these parts:</p>
<ol type="1">
<li><p><strong>Layers</strong>: Each layer shows changes to files or
commands from a Dockerfile. Layers are read-only. We create them using
commands like <code>RUN</code>, <code>COPY</code>, or <code>ADD</code>.
If we change a layer, we create a new layer on top.</p></li>
<li><p><strong>Base Image</strong>: The bottom layer of a Docker image
is usually a base image. This can be an operating system like Ubuntu or
a simple image like <code>scratch</code>. This base image is the
starting point for our application.</p></li>
<li><p><strong>Dockerfile</strong>: We write the steps to build a Docker
image in a file called <code>Dockerfile</code>. This file has commands
that define how the image looks and works. This includes installing
needed packages or setting environment variables.</p></li>
<li><p><strong>Metadata</strong>: Each Docker image has metadata. This
includes details like the image name, tag, and the command to run when
the container starts. We store this metadata in a JSON format. We can
see it using the <code>docker inspect</code> command.</p></li>
<li><p><strong>Union File System (UFS)</strong>: Docker uses a union
file system to join the layers into one view. This helps containers read
from the layers without making copies of the data. It makes storage more
efficient.</p></li>
</ol>
<h3 id="example-dockerfile">Example Dockerfile</h3>
<p>Here is a simple Dockerfile that shows the structure of a Docker
image:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use an official Python runtime as a parent image</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> python:3.9-slim</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory in the container</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the current directory contents into the container at /app</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Install any needed packages specified in requirements.txt</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">pip</span> install <span class="at">--no-cache-dir</span> <span class="at">-r</span> requirements.txt</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Run app.py when the container launches</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python&quot;</span>, <span class="st">&quot;app.py&quot;</span>]</span></code></pre></div>
<h3 id="building-the-docker-image">Building the Docker Image</h3>
<p>To build a Docker image from this Dockerfile, we use this
command:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> my-python-app .</span></code></pre></div>
<p>This command makes an image called <code>my-python-app</code> based
on the steps in the Dockerfile. Each command in the Dockerfile makes a
new layer. This helps Docker remember them for future builds.</p>
<p>We think understanding the structure of Docker images is important.
It helps us build better and manage images well. For more information
about Docker and its benefits, we can look at <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">what
are the benefits of using Docker in development</a>.</p>
<h2 id="how-to-create-your-own-docker-image">How to Create Your Own
Docker Image?</h2>
<p>We can create our own Docker image by writing a
<code>Dockerfile</code>. This file is like a script that tells Docker
how to build our image. Here is a simple guide to help us do it.</p>
<h3 id="step-1-write-a-dockerfile">Step 1: Write a Dockerfile</h3>
<p>First, we open a text editor. Then we create a file called
<code>Dockerfile</code>. Here is a basic example of a
<code>Dockerfile</code> for a simple Node.js app:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use the official Node.js image as a base</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory in the container</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /usr/src/app</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy package.json and package-lock.json</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package*.json ./</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the rest of the application code</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Expose the application port</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 3000</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Command to run the application</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;app.js&quot;</span>]</span></code></pre></div>
<h3 id="step-2-build-the-docker-image">Step 2: Build the Docker
Image</h3>
<p>Next, we go to the folder where our <code>Dockerfile</code> is
located. We run this command to build our Docker image. We should change
<code>your-image-name</code> to whatever name we want:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> your-image-name .</span></code></pre></div>
<h3 id="step-3-verify-the-image-creation">Step 3: Verify the Image
Creation</h3>
<p>Once the build is done, we can check our new image by listing all
Docker images:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> images</span></code></pre></div>
<h3 id="step-4-run-your-docker-image">Step 4: Run Your Docker Image</h3>
<p>Now we can run a container using our image with this command:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-p</span> 3000:3000 your-image-name</span></code></pre></div>
<p>This command connects port 3000 of the container to port 3000 on our
host machine.</p>
<h3 id="additional-tips">Additional Tips</h3>
<ul>
<li>We can use <code>.dockerignore</code> to avoid copying some files to
the image.</li>
<li>We should keep our images small. We can do this by optimizing the
<code>Dockerfile</code> and using multi-stage builds if we need to.</li>
<li>For more details, we can check the official <a
href="https://docs.docker.com/engine/reference/builder/">Docker
documentation</a>.</li>
</ul>
<p>By following these steps, we can make custom Docker images for our
apps. This makes our work of developing and deploying easier. For more
information about Docker and its advantages, we can also look at <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">what
are the benefits of using Docker in development</a>.</p>
<h2 id="exploring-docker-image-layers-and-caching">Exploring Docker
Image Layers and Caching</h2>
<p>Docker images are made of layers. Each layer shows changes in the
filesystem. These changes can be adding, changing, or deleting files and
folders. We need to understand these layers well. This helps us make
better image builds and improve performance when we run them.</p>
<h3 id="docker-image-layers">Docker Image Layers</h3>
<ul>
<li><p><strong>Layer Structure</strong>: Each layer sits on top of the
last one. When we use a Dockerfile, each command creates a new layer.
For example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> install <span class="at">-y</span> nginx</span></code></pre></div>
<p>This Dockerfile makes three layers:</p>
<ol type="1">
<li>The base layer from <code>ubuntu:20.04</code></li>
<li>A layer from the <code>RUN apt-get update</code> command</li>
<li>A layer from the <code>RUN apt-get install -y nginx</code>
command</li>
</ol></li>
<li><p><strong>Read-Only Layers</strong>: All layers are read-only. When
we create a container from an image, we add a thin writable layer on
top. This means changes in the container do not change the original
image.</p></li>
</ul>
<h3 id="caching-mechanism">Caching Mechanism</h3>
<p>Docker has a caching system. This helps to build images faster. If a
command in the Dockerfile stays the same, Docker will use the saved
layer instead of making a new one. This can save a lot of time when
building.</p>
<ul>
<li><p><strong>Cache Behavior</strong>:</p>
<ul>
<li>If a command in the Dockerfile (like <code>RUN</code>,
<code>COPY</code>, <code>ADD</code>) is the same and its dependencies
are also the same, Docker uses the saved layer.</li>
<li>If we change a command, all layers after it must be rebuilt.</li>
</ul></li>
<li><p><strong>Cache Busting</strong>: If we want Docker to rebuild a
layer, we can change the command or use a build argument. For
example:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ARG</span> CACHEBUST=1</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="bu">echo</span> <span class="st">&quot;This command will always be run&quot;</span></span></code></pre></div></li>
</ul>
<h3 id="layer-size-and-optimization">Layer Size and Optimization</h3>
<ul>
<li><p><strong>Minimize Layers</strong>: We can combine commands to make
fewer layers. For example:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> nginx <span class="kw">&amp;&amp;</span> <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Order of Instructions</strong>: We should put commands
that change often at the end of the Dockerfile. This way, we can use
caching for the layers that do not change much.</p></li>
</ul>
<p>We need to understand Docker image layers and caching well. This
helps us create Docker images that build fast and use storage space
wisely. For more on Docker and how it helps in development, check out <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
Are the Benefits of Using Docker in Development</a>.</p>
<h2 id="how-to-use-docker-images-in-your-projects">How to Use Docker
Images in Your Projects?</h2>
<p>We can use Docker images in our projects to create consistent
environments. This helps with easy deployment and better teamwork. Here
is how we can use Docker images well:</p>
<ol type="1">
<li><p><strong>Pulling Docker Images</strong>: First, we pull existing
images from Docker Hub.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> pull <span class="op">&lt;</span>image-name<span class="op">&gt;</span>:<span class="op">&lt;</span>tag<span class="op">&gt;</span></span></code></pre></div>
<p>For example, to pull the latest Ubuntu image, we can use:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> pull ubuntu:latest</span></code></pre></div></li>
<li><p><strong>Running Docker Images</strong>: Next, we create and run a
container from a Docker image.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> <span class="op">&lt;</span>container-name<span class="op">&gt;</span> <span class="op">&lt;</span>image-name<span class="op">&gt;</span>:<span class="op">&lt;</span>tag<span class="op">&gt;</span></span></code></pre></div>
<p>For example:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">--name</span> my-ubuntu-container ubuntu:latest</span></code></pre></div></li>
<li><p><strong>Building Custom Images</strong>: We can make our own
Docker images using a Dockerfile. Here is a simple example:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use an official Python runtime as a parent image</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> python:3.8-slim</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy the current directory contents into the container at /app</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . /app</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Install any needed packages specified in requirements.txt</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">pip</span> install <span class="at">--no-cache-dir</span> <span class="at">-r</span> requirements.txt</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Make port 80 available to the world outside this container</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a><span class="kw">EXPOSE</span> 80</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Define environment variable</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NAME World</span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Run app.py when the container launches</span></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;python&quot;</span>, <span class="st">&quot;app.py&quot;</span>]</span></code></pre></div>
<p>To build the image, we use:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> my-python-app .</span></code></pre></div></li>
<li><p><strong>Managing Containers</strong>: We can list running
containers and their statuses.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> ps</span></code></pre></div>
<p>To stop a running container, we use:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> stop <span class="op">&lt;</span>container-name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Persisting Data</strong>: We can use Docker volumes to
keep data that Docker containers generate and use.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-d</span> <span class="at">-v</span> /host/path:/container/path <span class="op">&lt;</span>image-name<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Tagging Images</strong>: It is good to tag our images for
better management.</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> tag <span class="op">&lt;</span>image-name<span class="op">&gt;</span>:<span class="op">&lt;</span>tag<span class="op">&gt;</span> <span class="op">&lt;</span>new-image-name<span class="op">&gt;</span>:<span class="op">&lt;</span>new-tag<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Pushing Images</strong>: We can share our images on
Docker Hub.</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> login</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> push <span class="op">&lt;</span>your-dockerhub-username<span class="op">&gt;</span>/<span class="op">&lt;</span>image-name<span class="op">&gt;</span>:<span class="op">&lt;</span>tag<span class="op">&gt;</span></span></code></pre></div></li>
<li><p><strong>Working with Docker Compose</strong>: We can use
<code>docker-compose.yml</code> to define and run multi-container Docker
applications.</p>
<p>Here is an example of <code>docker-compose.yml</code>:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">web</span><span class="kw">:</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> nginx:latest</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">ports</span><span class="kw">:</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="kw">-</span><span class="at"> </span><span class="st">&quot;80:80&quot;</span></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">db</span><span class="kw">:</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> postgres:latest</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">environment</span><span class="kw">:</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_USER</span><span class="kw">:</span><span class="at"> example</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="at">      </span><span class="fu">POSTGRES_PASSWORD</span><span class="kw">:</span><span class="at"> example</span></span></code></pre></div>
<p>We can run the application with:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up</span></code></pre></div></li>
</ol>
<p>By doing these steps, we can use Docker images in our projects. This
helps to make sure we have consistent and separate development
environments. For more information about Docker and its benefits, we can
check out <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
Are the Benefits of Using Docker in Development</a>.</p>
<h2 id="managing-and-optimizing-docker-images">Managing and Optimizing
Docker Images</h2>
<p>Managing and optimizing Docker images is very important for good
development and deployment. Here are some key practices we can think
about:</p>
<ul>
<li><p><strong>Image Cleanup</strong>: We should regularly remove images
we do not use. This helps free up disk space. We can use this
command:</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> image prune</span></code></pre></div></li>
<li><p><strong>Tagging Images</strong>: We can use tags to manage
versions easily. For example:</p>
<div class="sourceCode" id="cb24"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> myapp:v1.0 .</span></code></pre></div></li>
<li><p><strong>Minimize Image Size</strong>: It is good to start from a
smaller base image like <code>alpine</code>. We should only add the
necessary things in our Dockerfile:</p>
<div class="sourceCode" id="cb25"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apk</span> add <span class="at">--no-cache</span> python3 py3-pip</span></code></pre></div></li>
<li><p><strong>Multi-Stage Builds</strong>: We can use multi-stage
builds. This helps to make final image size smaller by separating build
and runtime:</p>
<div class="sourceCode" id="cb26"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> golang:1.16 <span class="kw">AS</span> builder</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">go</span> build <span class="at">-o</span> myapp</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine:latest</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/myapp .</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;./myapp&quot;</span>]</span></code></pre></div></li>
<li><p><strong>Layer Optimization</strong>: We can combine commands in
the Dockerfile. This reduces the number of layers:</p>
<div class="sourceCode" id="cb27"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> <span class="dt">\</span></span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    package1 <span class="dt">\</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a>    package2 <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a>    <span class="fu">rm</span> <span class="at">-rf</span> /var/lib/apt/lists/<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Use .dockerignore</strong>: We should create a
<code>.dockerignore</code> file. This helps to exclude unnecessary files
from the build. This speeds up the process and reduces image size:</p>
<pre><code>node_modules
tmp
*.log</code></pre></li>
<li><p><strong>Automate Builds</strong>: We can use CI/CD pipelines.
This helps to automate the building and testing of our Docker images.
This way, we get consistent deployments.</p></li>
<li><p><strong>Monitor and Audit Images</strong>: We need to regularly
scan images for problems. We can use tools like
<code>Docker Bench Security</code> or <code>Anchore</code>.</p></li>
<li><p><strong>Push to a Registry</strong>: We use a Docker registry,
like Docker Hub or a private one, to store and manage our images:</p>
<div class="sourceCode" id="cb29"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> push myapp:v1.0</span></code></pre></div></li>
</ul>
<p>By following these practices, we can manage and optimize our Docker
images well. This will improve performance and keep our environment
clean. For more info on what Docker can do, we can check this article on
<a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It?</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-are-docker-images-and-how-do-they-differ-from-containers">What
are Docker images and how do they differ from containers?</h3>
<p>Docker images are small and self-contained packages. They have
everything needed to run a software, like code, runtime, libraries, and
environment variables. A Docker container is a running version of a
Docker image. So, images are like templates to make containers. It is
important to know the differences for better container use.</p>
<h3 id="how-can-i-optimize-my-docker-images-for-faster-builds">How can I
optimize my Docker images for faster builds?</h3>
<p>To make your Docker images faster to build, we should try to reduce
the number of layers. We can do this by combining commands in the
Dockerfile. Using <code>.dockerignore</code> files helps to leave out
files that we do not need in the build. We should also use caching
smartly by arranging commands from least to most likely to change. These
steps will help us build faster and work better.</p>
<h3 id="what-is-the-purpose-of-docker-image-layers">What is the purpose
of Docker image layers?</h3>
<p>Docker images have many layers. Each layer shows changes made to the
base image. Each layer is saved, so we can build and deploy faster by
using layers that have not changed. By understanding how these layers
work, we can make our images better and manage them well. Only the
layers that we change need to be rebuilt.</p>
<h3 id="how-do-i-create-a-docker-image-from-an-existing-container">How
do I create a Docker image from an existing container?</h3>
<p>To make a Docker image from a running container, we can use the
<code>docker commit</code> command. This command saves the current state
of the container as a new image. The usual way to use it is:</p>
<div class="sourceCode" id="cb30"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> commit <span class="op">&lt;</span>container_id<span class="op">&gt;</span> <span class="op">&lt;</span>new_image_name<span class="op">&gt;</span></span></code></pre></div>
<p>After we run this command, the new image will be ready for our
projects.</p>
<h3 id="can-i-use-docker-images-across-different-operating-systems">Can
I use Docker images across different operating systems?</h3>
<p>Yes, Docker images can work on different operating systems. But they
need to be compatible with the Docker engine on the host system. This
means we can build a Docker image on one OS and run it on another. Both
systems must support the needed architecture and have Docker installed.
For more details on how to install Docker on different operating
systems, you can read this article on <a
href="https://bestonlinetutorial.com/docker/how-to-install-docker-on-different-operating-systems.html">how
to install Docker on different operating systems</a>.</p>
<p>By answering these common questions about Docker images, we want to
help you understand how they work and how to use them well in your
projects. If you are new to Docker or want to make your workflows
better, knowing these important ideas will help a lot.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            