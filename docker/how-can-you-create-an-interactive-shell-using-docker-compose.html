
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>How Can You Create an Interactive Shell Using Docker Compose?</title>
            <meta name="description" content="Learn to create an interactive shell with Docker Compose in this step-by-step guide. Boost your development workflow today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Can You Create an Interactive Shell Using Docker Compose?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>To create an interactive shell with Docker Compose, we need to set up
a service in our <code>docker-compose.yml</code> file. This service will
let us access the terminal interactively. We have to choose the right
image, set the command correctly, and make sure the container runs in
interactive mode. With a simple command, we can open a shell in our
Docker container.</p>
<p>In this article, we will go through the steps to create an
interactive shell using Docker Compose. We will cover how to define a
service for the interactive shell. We will also see how to access a
shell in a running container. Plus, we will learn how to make a custom
Dockerfile and run interactive commands. At the end, we will answer some
common questions to help everyone understand the topic better.</p>
<ul>
<li>How to Create an Interactive Shell Using Docker Compose</li>
<li>What is Docker Compose and How Does It Relate to an Interactive
Shell</li>
<li>How Can You Define a Service for an Interactive Shell in Docker
Compose</li>
<li>How Can You Use Docker Compose to Access a Shell in a Running
Container</li>
<li>How Can You Create a Custom Dockerfile for an Interactive Shell</li>
<li>How Can You Execute Interactive Commands with Docker Compose</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on Docker and its parts, check out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It</a> and <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">What
is Docker Compose and How Does It Simplify Multi-Container
Applications</a>.</p>
<h2
id="what-is-docker-compose-and-how-does-it-relate-to-an-interactive-shell">What
is Docker Compose and How Does It Relate to an Interactive Shell</h2>
<p>Docker Compose is a tool that makes managing multi-container Docker
apps easier. It lets us define and run these apps using a simple YAML
file called <code>docker-compose.yml</code>. This file tells us about
the services, networks, and volumes we need for our app. It helps us
manage complicated setups better.</p>
<p>When we work with interactive apps, Docker Compose is very helpful.
It helps us create an interactive shell inside the containers. This way,
we can run commands and interact with our app directly where it runs. It
makes testing, debugging, and development easier. The interactive shell
is very important for apps that need direct user input or commands.</p>
<p>For example, to make an interactive shell in a Docker container using
Compose, we can use this configuration:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">app</span><span class="kw">:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> ubuntu:latest</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">stdin_open</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">tty</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span></code></pre></div>
<p>In this example:</p>
<ul>
<li><code>stdin_open: true</code> keeps the input open for the
container. This lets us run interactive commands.</li>
<li><code>tty: true</code> gives us a pseudo-TTY. This makes the
interactive shell work well.</li>
</ul>
<p>To start the interactive shell, we can run this command:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> run app /bin/bash</span></code></pre></div>
<p>This command starts the container and opens a Bash shell. Now we can
run commands interactively.</p>
<p>By using Docker Compose like this, we can manage our environments
better. We can quickly access interactive shells for testing and
development. For more details on Docker Compose and its features, we can
check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">what
is Docker Compose and how does it simplify multi-container
applications</a>.</p>
<h2
id="how-can-we-define-a-service-for-an-interactive-shell-in-docker-compose">How
Can We Define a Service for an Interactive Shell in Docker Compose</h2>
<p>To define a service for an interactive shell in Docker Compose, we
need to create a <code>docker-compose.yml</code> file. This file tells
Docker what we want to do. An interactive shell service usually uses a
base image that gives us a shell environment. Good examples are
<code>ubuntu</code>, <code>alpine</code>, or any specific application
image that allows shell access.</p>
<p>Here is a simple example of how we can define a service in our
<code>docker-compose.yml</code> file for an interactive shell:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3.8&#39;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">interactive-shell</span><span class="kw">:</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> ubuntu:latest</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">command</span><span class="kw">:</span><span class="at"> /bin/bash</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">stdin_open</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span><span class="co">  # Keep stdin open for interaction</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">tty</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span><span class="co">         # Allocate a pseudo-TTY</span></span></code></pre></div>
<h3 id="key-properties">Key Properties:</h3>
<ul>
<li><strong>image</strong>: This tells which Docker image to use. Here,
we use <code>ubuntu:latest</code>.</li>
<li><strong>command</strong>: This changes the default command of the
image to run a shell. We use <code>/bin/bash</code> for that.</li>
<li><strong>stdin_open</strong>: This keeps the standard input open. It
allows us to run interactive shell commands.</li>
<li><strong>tty</strong>: This gives us a pseudo-terminal. It is needed
for interactive commands.</li>
</ul>
<h3 id="running-the-service">Running the Service</h3>
<p>To start the interactive shell service, we run:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">-d</span></span></code></pre></div>
<p>After that, we can attach to the shell using:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec interactive-shell /bin/bash</span></code></pre></div>
<p>This command opens an interactive bash shell in the running
container. Now we can execute commands directly inside the
container.</p>
<p>For more details on Docker Compose configurations, we can check out
<a
href="https://bestonlinetutorial.com/docker/how-to-write-a-simple-docker-compose-yml-file.html">this
article</a>.</p>
<h2
id="how-can-we-use-docker-compose-to-access-a-shell-in-a-running-container">How
Can We Use Docker Compose to Access a Shell in a Running Container</h2>
<p>We can easily access a shell in a running container using Docker
Compose. We do this with the <code>docker-compose exec</code> command.
This command lets us run commands inside the container. Here’s how we
can do it:</p>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>We need to have Docker and Docker Compose installed.</li>
<li>We must have a <code>docker-compose.yml</code> file that shows our
services.</li>
</ul>
<h3 id="step-by-step-instructions">Step-by-Step Instructions</h3>
<ol type="1">
<li><p><strong>Define Your Docker Compose File</strong>: If we do not
have a <code>docker-compose.yml</code> file, we should create one. Here
is a simple example:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">app</span><span class="kw">:</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> ubuntu:latest</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">container_name</span><span class="kw">:</span><span class="at"> my_app</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">tty</span><span class="kw">:</span><span class="at"> </span><span class="ch">true</span></span></code></pre></div></li>
<li><p><strong>Start Your Services</strong>: We can run our services in
the background:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">-d</span></span></code></pre></div></li>
<li><p><strong>Access the Shell in a Running Container</strong>: To
access the shell of the running container, we use this command:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec app /bin/bash</span></code></pre></div>
<ul>
<li>We must replace <code>app</code> with the name of our service from
the <code>docker-compose.yml</code>.</li>
<li>If our container does not have <code>bash</code>, we can also use
<code>/bin/sh</code>.</li>
</ul></li>
<li><p><strong>Execute Commands</strong>: Now that we are inside the
container’s shell, we can run commands just like in a normal
terminal.</p></li>
</ol>
<h3 id="example">Example</h3>
<p>After we run the command, our terminal will change to show we are
inside the container:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="ex">root@</span><span class="op">&lt;</span>container_id<span class="op">&gt;</span>:/#</span></code></pre></div>
<p>Here, we can run commands like <code>ls</code> or
<code>apt-get update</code>.</p>
<h3 id="important-notes">Important Notes</h3>
<ul>
<li><p>We must make sure the container is running. We can check running
containers with:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> ps</span></code></pre></div></li>
<li><p>To leave the container shell without stopping it, we can use
<code>Ctrl + P</code> then <code>Ctrl + Q</code>.</p></li>
</ul>
<p>For more information on Docker Compose, we can read <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">what
is Docker Compose and how does it simplify multi-container
applications</a>.</p>
<h2
id="how-can-we-create-a-custom-dockerfile-for-an-interactive-shell">How
Can We Create a Custom Dockerfile for an Interactive Shell</h2>
<p>To create a custom Dockerfile for an interactive shell, we first need
to choose a base image. Then we install any needed packages and set up
the entry point. Here is a simple way to do this.</p>
<ol type="1">
<li><p><strong>Start with a Base Image</strong>: We should pick a base
image that works well with our shell. For example, we can use
<code>ubuntu</code> or <code>alpine</code>.</p></li>
<li><p><strong>Install Required Packages</strong>: We can use the
<code>RUN</code> command to install tools or packages we need in our
interactive shell.</p></li>
<li><p><strong>Set the Entry Point</strong>: We will use the
<code>CMD</code> or <code>ENTRYPOINT</code> command to set which shell
will start when the container runs.</p></li>
</ol>
<h3 id="example-dockerfile">Example Dockerfile</h3>
<p>Here is an example Dockerfile that creates an interactive shell using
Ubuntu:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Use Ubuntu as the base image</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Install required packages</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="dt">\</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="ex">apt-get</span> install <span class="at">-y</span> bash curl</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the default command to launch an interactive bash shell</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/bin/bash&quot;</span>]</span></code></pre></div>
<h3 id="build-the-docker-image">Build the Docker Image</h3>
<p>We can build the Docker image with this command:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> build <span class="at">-t</span> custom-interactive-shell .</span></code></pre></div>
<h3 id="running-the-container">Running the Container</h3>
<p>To run the container with an interactive shell, we can use:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker</span> run <span class="at">-it</span> custom-interactive-shell</span></code></pre></div>
<p>This command opens an interactive terminal session in the running
container. We can then run commands directly.</p>
<h3 id="notes">Notes</h3>
<ul>
<li>Make sure we have the right permissions if we install packages that
need it.</li>
<li>We can also change this Dockerfile to include more complex setups or
different shells as we need.</li>
</ul>
<p>By following these steps, we can create a custom Dockerfile for an
interactive shell session. For more information on Docker and what it
can do, we can check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">what
Docker is and why you should use it</a>.</p>
<h2 id="how-can-we-execute-interactive-commands-with-docker-compose">How
Can We Execute Interactive Commands with Docker Compose</h2>
<p>Executing interactive commands inside Docker containers with Docker
Compose is simple. We can use the <code>docker-compose exec</code>
command to run commands in a running container interactively. Let’s see
how we can do this.</p>
<ol type="1">
<li><p><strong>Start Our Services</strong>: First, we need to make sure
our Docker Compose services are running. We can start them with:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> up <span class="at">-d</span></span></code></pre></div></li>
<li><p><strong>Execute Interactive Commands</strong>: We can use this
syntax to run commands interactively in a container:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec <span class="pp">[</span><span class="ss">service_name</span><span class="pp">]</span> <span class="pp">[</span><span class="ss">command</span><span class="pp">]</span></span></code></pre></div>
<p>For example, if we want to open a bash shell in a service called
<code>web</code>, we should run:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec web bash</span></code></pre></div></li>
<li><p><strong>Options for Interactive Mode</strong>: If we need to run
a command with a TTY (terminal), we can add the <code>-it</code>
flags:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec <span class="at">-it</span> <span class="pp">[</span><span class="ss">service_name</span><span class="pp">]</span> <span class="pp">[</span><span class="ss">command</span><span class="pp">]</span></span></code></pre></div>
<p>Example:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec <span class="at">-it</span> web /bin/sh</span></code></pre></div></li>
<li><p><strong>Running Non-Interactive Commands</strong>: We can also
run commands that do not need interaction:</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec web ls <span class="at">-l</span></span></code></pre></div></li>
<li><p><strong>Accessing Environment Variables</strong>: If our service
has special environment variables in the
<code>docker-compose.yml</code>, we can see them inside the interactive
shell:</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="ex">docker-compose</span> exec web printenv</span></code></pre></div></li>
<li><p><strong>Using Docker Compose with a Custom Dockerfile</strong>:
If we have our own Dockerfile, we should make sure it is defined in the
<code>docker-compose.yml</code> file under the right service. This way,
we can use interactive commands easily.</p></li>
</ol>
<p>This way helps us manage our containers well and run needed commands
without attaching to the container directly. For more details on Docker
Compose, we can check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-compose-and-how-does-it-simplify-multi-container-applications.html">this
article</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="how-do-we-access-an-interactive-shell-in-a-docker-container-using-docker-compose">1.
How do we access an interactive shell in a Docker container using Docker
Compose?</h3>
<p>To access an interactive shell in a Docker container, we use the
<code>docker-compose exec</code> command. We write the service name and
the shell type after the command. For example, we can write
<code>docker-compose exec &lt;service_name&gt; /bin/bash</code> or
<code>docker-compose exec &lt;service_name&gt; /bin/sh</code>. This will
start a shell session inside the container of the service we choose.
This is very important for debugging and working with running apps.</p>
<h3
id="what-is-the-difference-between-docker-exec-and-docker-compose-exec">2.
What is the difference between <code>docker exec</code> and
<code>docker-compose exec</code>?</h3>
<p>Both <code>docker exec</code> and <code>docker-compose exec</code>
let us run commands inside a running container. But
<code>docker-compose exec</code> is for services in a
<code>docker-compose.yml</code> file. It helps with service dependencies
and networking. This makes it easier to work with setups that have many
containers.</p>
<h3
id="how-can-we-define-a-service-for-an-interactive-shell-in-docker-compose-1">3.
How can we define a service for an interactive shell in Docker
Compose?</h3>
<p>In a <code>docker-compose.yml</code> file, we can define a service
for an interactive shell by choosing the right image and command. For
example:</p>
<div class="sourceCode" id="cb21"><pre
class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="fu">version</span><span class="kw">:</span><span class="at"> </span><span class="st">&#39;3&#39;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">services</span><span class="kw">:</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="fu">shell</span><span class="kw">:</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">image</span><span class="kw">:</span><span class="at"> ubuntu:latest</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">command</span><span class="kw">:</span><span class="at"> /bin/bash</span></span></code></pre></div>
<p>This will create a service called <code>shell</code>. We can then run
an interactive shell in an Ubuntu container.</p>
<h3 id="can-we-create-a-custom-dockerfile-for-an-interactive-shell">4.
Can we create a custom Dockerfile for an interactive shell?</h3>
<p>Yes, we can make a custom <code>Dockerfile</code> to set up an
interactive shell that fits our needs. In this <code>Dockerfile</code>,
we can install software, set environment variables, and choose the
default shell. For example:</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> curl</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;/bin/bash&quot;</span>]</span></code></pre></div>
<p>We can then use this Dockerfile in our
<code>docker-compose.yml</code> to build our interactive shell
service.</p>
<h3
id="how-can-we-execute-interactive-commands-with-docker-compose-1">5.
How can we execute interactive commands with Docker Compose?</h3>
<p>To run interactive commands in a running container with Docker
Compose, we use the <code>docker-compose exec</code> command. We put the
service name and the command after it. For example,
<code>docker-compose exec &lt;service_name&gt; &lt;command&gt;</code>
lets us run any command interactively. We need to make sure the
container is running. Then, it will give us a terminal to interact with
the application.</p>
<p>For more information about Docker and what it can do, we can look at
<a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">what
is Docker and why should you use it</a> and learn more about <a
href="https://bestonlinetutorial.com/docker/how-to-run-a-docker-container-in-interactive-mode.html">how
to run a Docker container in interactive mode</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            