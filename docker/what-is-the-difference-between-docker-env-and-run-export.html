
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>What is the Difference Between Docker ENV and RUN Export?</title>
            <meta name="description" content="Discover the key differences between Docker ENV and RUN Export in our comprehensive guide. Enhance your container management skills!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">What is the Difference Between Docker ENV and RUN Export?</h1>
                        </header>

                        <div class="blog-post-body">
                            <h1
id="understanding-the-difference-between-docker-env-and-run-export">Understanding
the Difference Between Docker ENV and RUN Export</h1>
<p>We need to know the difference between Docker ENV and RUN export.
This is very important for managing environment variables in our Docker
containers. Docker ENV helps us set environment variables that stay in
the container. On the other hand, RUN export sets temporary environment
variables while we build the container. This difference is very
important for us as developers. It helps us make our Dockerfiles better
and clearer.</p>
<p>In this article, we will look at the differences between Docker ENV
and RUN export. We will see how to use each one and when to use them.
Here are the topics we will cover:</p>
<ul>
<li>What is the Difference Between Docker ENV and RUN Export</li>
<li>Understanding Docker ENV Command and Its Usage</li>
<li>Exploring the RUN Export Command in Docker</li>
<li>Key Differences Between Docker ENV and RUN Export</li>
<li>When to Use Docker ENV Over RUN Export</li>
<li>Practical Examples of Docker ENV and RUN Export</li>
<li>Frequently Asked Questions</li>
</ul>
<p>At the end of this article, we will understand how to use these
commands. This will help us manage environment variables well in our
Docker containers.</p>
<h2 id="understanding-docker-env-command-and-its-usage">Understanding
Docker ENV Command and Its Usage</h2>
<p>The <code>ENV</code> command in Docker helps us set environment
variables inside a Docker container. We can access these variables by
applications running in the container. This allows us to change settings
and customize how our application works.</p>
<h3 id="syntax">Syntax</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span></code></pre></div>
<h3 id="usage">Usage</h3>
<ul>
<li><strong>Defining Environment Variables</strong>: We can set
variables that affect how applications behave inside the container.</li>
<li><strong>Persistent Across Layers</strong>: The environment variables
we set with <code>ENV</code> are available for all instructions after it
in the Dockerfile and while the container runs.</li>
</ul>
<h3 id="example">Example</h3>
<p>Here is an example of using the <code>ENV</code> command in a
Dockerfile:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Set environment variables</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> APP_HOME /usr/src/app</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NODE_ENV production</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Create application directory</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="fu">mkdir</span> <span class="at">-p</span> <span class="va">$APP_HOME</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> $APP_HOME</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy application files</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Command to run the application</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;npm&quot;</span>, <span class="st">&quot;start&quot;</span>]</span></code></pre></div>
<p>In this example: - We set <code>APP_HOME</code> to
<code>/usr/src/app</code>. We use this later to create the application
directory. - We set <code>NODE_ENV</code> to <code>production</code>.
This affects how the Node.js application runs.</p>
<h3 id="benefits">Benefits</h3>
<ul>
<li><strong>Flexibility</strong>: We can easily change settings without
changing the application code.</li>
<li><strong>Security</strong>: We can keep sensitive data like API keys
and secrets safe with environment variables.</li>
<li><strong>Portability</strong>: Our applications can run in different
environments like development, staging, and production with little
changes.</li>
</ul>
<p>Using the <code>ENV</code> command well can help us improve the
settings and security of Docker containers. For more information on
Docker, we can look at articles like <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
Are the Benefits of Using Docker in Development</a>.</p>
<h2 id="exploring-the-run-export-command-in-docker">Exploring the RUN
Export Command in Docker</h2>
<p>The <code>RUN</code> command in Docker helps us to run commands when
we build an image in a Dockerfile. We can use this command to install
packages, change files, or prepare the environment for our
application.</p>
<p>The <code>RUN export</code> command is not a separate command in
Docker. It helps us to set environment variables for a short time during
the build. When we use <code>RUN</code> to run commands, any environment
variables we set with <code>export</code> will only work for that
specific layer of the image we are building.</p>
<h3 id="example-of-using-run-with-export">Example of Using RUN with
Export</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:20.04</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Update the package repository and install curl</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> curl</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Set a temporary environment variable</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="bu">export</span> <span class="va">MY_VAR</span><span class="op">=</span><span class="st">&quot;Hello World&quot;</span> <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="va">$MY_VAR</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Verify that MY_VAR is not available in the next RUN command</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="bu">echo</span> <span class="va">$MY_VAR</span> <span class="co"># This will not output &quot;Hello World&quot;</span></span></code></pre></div>
<p>In this example: - The first <code>RUN</code> command installs
<code>curl</code>. - The second <code>RUN</code> command sets the
environment variable <code>MY_VAR</code> and shows it. - The third
<code>RUN</code> command cannot access <code>MY_VAR</code>. This shows
that the variable does not last across layers.</p>
<p>If we want to set an environment variable that lasts in all layers of
our Docker image, we should use the <code>ENV</code> command
instead.</p>
<h3 id="differences-between-run-and-export">Differences Between RUN and
Export</h3>
<ul>
<li><strong>Scope</strong>: <code>RUN</code> runs a command.
<code>export</code> sets environment variables but only for that
command.</li>
<li><strong>Persistence</strong>: Environment variables from
<code>export</code> do not last in the next layers unless we use
<code>ENV</code>.</li>
</ul>
<p>Using <code>RUN</code> with export is good for temporary settings or
configurations when we build the image. But if we need variables in the
final image, we should use the <code>ENV</code> command.</p>
<p>For more information on Docker commands, check out <a
href="https://bestonlinetutorial.com/docker/what-is-the-dockerfile-and-how-do-you-create-one.html">What
is the Dockerfile and How Do You Create One</a>.</p>
<h2 id="key-differences-between-docker-env-and-run-export">Key
Differences Between Docker ENV and RUN Export</h2>
<p>Docker ENV and RUN Export are two commands we use in Dockerfiles.
They have different purposes when we build Docker images. Knowing these
differences is important for building and managing Docker images
well.</p>
<ol type="1">
<li><strong>Purpose</strong>:
<ul>
<li><strong>ENV</strong>: This command sets environment variables that
stay in the container when it runs. We can use these variables in the
application running inside the container.</li>
<li><strong>RUN</strong>: This command runs a command while we build the
image. The result of this command goes into the image layer, but it does
not set environment variables that last for the container runtime.</li>
</ul></li>
<li><strong>Syntax</strong>:
<ul>
<li><p><strong>ENV</strong>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> &lt;key&gt; &lt;value&gt;</span></code></pre></div></li>
<li><p><strong>RUN</strong>:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="op">&lt;</span>command<span class="op">&gt;</span></span></code></pre></div></li>
</ul></li>
<li><strong>Scope</strong>:
<ul>
<li><strong>ENV</strong>: The variables we set with ENV are available in
all the later layers of the image. Any process running in the container
can access these variables.</li>
<li><strong>RUN</strong>: The command runs and we can see the output.
But any environment variables set in the command do not stay in the
image.</li>
</ul></li>
<li><strong>Example</strong>:
<ul>
<li><p>Using <strong>ENV</strong> to set a variable:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> APP_HOME /usr/src/app</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> $APP_HOME</span></code></pre></div></li>
<li><p>Using <strong>RUN</strong> to install a package:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> curl</span></code></pre></div></li>
</ul></li>
<li><strong>Use Cases</strong>:
<ul>
<li><strong>ENV</strong>: It is good for setting configuration details
or paths that our application needs when it runs.</li>
<li><strong>RUN</strong>: We use this for installing packages, running
scripts, or doing build actions that change the image.</li>
</ul></li>
<li><strong>Layering</strong>:
<ul>
<li><strong>ENV</strong> makes a new layer with the environment variable
set. This can add to the image size.</li>
<li><strong>RUN</strong> also makes a new layer. But it can make the
image bigger if we do not manage it well, like using
<code>&amp;&amp;</code> to connect commands.</li>
</ul></li>
<li><strong>Persistence</strong>:
<ul>
<li><strong>ENV</strong> values stay when we run the container from the
image.</li>
<li><strong>RUN</strong> commands do not keep runtime variables unless
we export them clearly.</li>
</ul></li>
</ol>
<p>Knowing these key differences between Docker ENV and RUN Export helps
us optimize our Dockerfiles for better performance and easier
maintenance. For more tips on Docker best practices, we can read <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
are the Benefits of Using Docker in Development</a>.</p>
<h2 id="when-to-use-docker-env-over-run-export">When to Use Docker ENV
Over RUN Export</h2>
<p>Choosing between <code>Docker ENV</code> and <code>RUN export</code>
depend on what we need and how long we want the environment variables to
last.</p>
<p><strong>Docker ENV</strong>: - <strong>Scope</strong>: When we use
<code>ENV</code> in a Dockerfile, the environment variables stay
available for all commands that come after it. They also stay in the
running container. - <strong>Use Case</strong>: - We use it when we want
to set default values. These values can be changed at runtime with the
<code>-e</code> flag or <code>--env-file</code>. - It is good for
configuration that our app needs while it runs.</p>
<p><strong>Example</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> APP_ENV=production</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;echo&quot;</span>, <span class="st">&quot;$APP_ENV&quot;</span>]</span></code></pre></div>
<p><strong>RUN export</strong>: - <strong>Scope</strong>: The variables
we export in a <code>RUN</code> command only work while that command
runs. They do not stay in the final image. - <strong>Use Case</strong>:
- We use it for temporary variables. These are for a specific command or
during building. They do not need to last when we run the container.</p>
<p><strong>Example</strong>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> alpine</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="bu">export</span> <span class="va">TEMP_VAR</span><span class="op">=</span>temporary <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="st">&quot;</span><span class="va">$TEMP_VAR</span><span class="st">&quot;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;echo&quot;</span>, <span class="st">&quot;$TEMP_VAR&quot;</span>]  <span class="co"># This will not print TEMP_VAR</span></span></code></pre></div>
<p>In short, we use <code>ENV</code> for settings that need to stay
throughout the container’s life. We use <code>RUN export</code> for
temporary settings just for the build. Knowing this helps us make Docker
images that work well and are easy to manage. For more about Docker
environment variables, check this <a
href="https://bestonlinetutorial.com/docker/how-can-i-pass-environment-variables-to-docker-containers.html">Docker
tutorial</a>.</p>
<h2 id="practical-examples-of-docker-env-and-run-export">Practical
Examples of Docker ENV and RUN Export</h2>
<h3 id="example-of-docker-env">Example of Docker ENV</h3>
<p>We use the <code>ENV</code> instruction in a Dockerfile to set
environment variables. These variables are available to the running
container. Here is a simple example:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dockerfile</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Set environment variables</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> APP_HOME /usr/src/app</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NODE_ENV production</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Create app directory</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="fu">mkdir</span> <span class="at">-p</span> <span class="va">$APP_HOME</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Set the working directory</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> $APP_HOME</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Copy files</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Start the application</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;npm&quot;</span>, <span class="st">&quot;start&quot;</span>]</span></code></pre></div>
<p>In this example, we set <code>APP_HOME</code> and
<code>NODE_ENV</code> as environment variables. We can access them
inside the container.</p>
<h3 id="example-of-run-export">Example of RUN Export</h3>
<p>We use the <code>RUN</code> instruction to execute commands in the
Dockerfile. It can set environment variables but only for the build
phase. For example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Dockerfile</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> ubuntu:latest</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Install dependencies and set environment variable</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">apt-get</span> update <span class="kw">&amp;&amp;</span> <span class="ex">apt-get</span> install <span class="at">-y</span> curl <span class="dt">\</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="bu">export</span> <span class="va">MY_VAR</span><span class="op">=</span><span class="st">&quot;Hello World&quot;</span> <span class="dt">\</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">&amp;&amp;</span> <span class="bu">echo</span> <span class="va">$MY_VAR</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Check the variable</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="bu">echo</span> <span class="va">$MY_VAR</span> <span class="co"># This will not output &quot;Hello World&quot;</span></span></code></pre></div>
<p>In this case, <code>MY_VAR</code> is only available when we run the
<code>RUN</code> command. It will not stay in the final image.</p>
<h3 id="multi-stage-example">Multi-stage Example</h3>
<p>We can use both <code>ENV</code> and <code>RUN</code> together in a
multi-stage build:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="co"># First stage</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14 <span class="kw">AS</span> builder</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> package.json ./</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">RUN</span> <span class="ex">npm</span> install</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Second stage</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="kw">FROM</span> node:14</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Set environment variable</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a><span class="kw">ENV</span> NODE_ENV production</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="kw">WORKDIR</span> /app</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> <span class="op">--from=builder</span> /app/node_modules ./node_modules</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="kw">COPY</span> . .</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="kw">CMD</span> [<span class="st">&quot;node&quot;</span>, <span class="st">&quot;server.js&quot;</span>]</span></code></pre></div>
<p>In this example, we set <code>NODE_ENV</code> for the final image.
The dependencies are installed in a separate build stage.</p>
<p>These examples show how we can use <code>ENV</code> for permanent
environment variables. We use <code>RUN</code> for temporary variables
during the image build. For more information on Docker commands, we can
check <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-purpose-of-the-docker-env-command">1. What is the
purpose of the Docker ENV command?</h3>
<p>The Docker ENV command sets environment variables in a Docker image.
We can use these variables in applications that run inside the
container. This helps us change settings without changing the code. With
Docker ENV, our applications can have the right settings and
credentials. This makes it easier to manage different environments like
development, testing, and production.</p>
<h3 id="how-does-the-run-export-command-differ-from-docker-env">2. How
does the RUN export command differ from Docker ENV?</h3>
<p>The RUN export command is used in a Dockerfile. It sets environment
variables only for the build process. Unlike Docker ENV, the variables
set with RUN export do not stay in the final image. They are only
available during the build stage. So, we need to pick the right command
based on if we want the variable to stay for the container’s runtime or
just for the build.</p>
<h3
id="can-i-access-environment-variables-set-with-docker-env-in-my-application">3.
Can I access environment variables set with Docker ENV in my
application?</h3>
<p>Yes, we can access environment variables set with Docker ENV in our
application running in the container. This is very important for apps
that need settings like database connection strings or API keys. Using
Docker ENV helps us keep private information out of our code while
giving our application the right context to work well.</p>
<h3 id="when-should-i-use-run-export-instead-of-docker-env">4. When
should I use RUN export instead of Docker ENV?</h3>
<p>Use RUN export when we need to set variables just for a short time
during the Docker image build. This is especially for installation
commands or scripts. If we want the environment variables to be
available when the container runs, we should use Docker ENV. Knowing how
long we need the variables will help us choose the right command.</p>
<h3
id="are-there-any-limitations-to-using-docker-env-for-sensitive-information">5.
Are there any limitations to using Docker ENV for sensitive
information?</h3>
<p>Docker ENV makes it easy to set environment variables. But we should
know that anyone with access to the Docker image or container can see
these variables. For sensitive information like API keys or passwords,
it is better to use Docker Secrets or Docker Compose with securely
stored environment variables. This way, we can improve security while
still using Docker for application settings.</p>
<p>For more information about Docker, check out <a
href="https://bestonlinetutorial.com/docker/what-is-docker-and-why-should-you-use-it.html">What
is Docker and Why Should You Use It?</a> and <a
href="https://bestonlinetutorial.com/docker/what-are-the-benefits-of-using-docker-in-development.html">What
are the Benefits of Using Docker in Development?</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            