
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of k Non-Overlapping Subarrays - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Sum of k Non-Overlapping Subarrays problem using dynamic programming techniques.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of k Non-Overlapping Subarrays - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Sum of k Non-Overlapping Subarrays problem is a hard task
in dynamic programming. We need to find the maximum sum we can get by
picking k non-overlapping subarrays from a given array. To solve this,
we need to break down the problem in a clear way. We will use dynamic
programming ideas to make sure we use optimal substructure and handle
overlapping subproblems well. By keeping track of our state and using
cumulative sums, we can find the maximum sums for different values of
k.</p>
<p>In this article, we will look at many parts of the Maximum Sum of k
Non-Overlapping Subarrays problem. We will do problem analysis. We will
also outline a better dynamic programming method. We will give solutions
in Java, Python, and C++. Also, we will talk about space complexity,
edge cases, and check how well our dynamic programming method works. At
the end, we will compare this method with other methods. We will also
answer some common questions.</p>
<ul>
<li>Dynamic Programming Maximum Sum of k Non-Overlapping Subarrays
Problem Analysis</li>
<li>Optimized Dynamic Programming Approach for Maximum Sum</li>
<li>Dynamic Programming Solution in Java for Maximum Sum</li>
<li>Dynamic Programming Solution in Python for Maximum Sum</li>
<li>Dynamic Programming Solution in C++ for Maximum Sum</li>
<li>Understanding Space Complexity in Dynamic Programming</li>
<li>Handling Edge Cases in Maximum Sum Problem</li>
<li>Performance Analysis of the Dynamic Programming Approach</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, you may like
related articles. One is about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming on Fibonacci Numbers</a>. Another one is about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming on Minimum Cost Climbing Stairs</a>. These articles will
help you understand dynamic programming and how to use it.</p>
<h2
id="optimized-dynamic-programming-approach-for-maximum-sum">Optimized
Dynamic Programming Approach for Maximum Sum</h2>
<p>We want to find the maximum sum of <code>k</code> non-overlapping
subarrays. To do this quickly, we can use an optimized dynamic
programming approach. The main idea is to keep track of the maximum sums
of subarrays while making sure they do not overlap.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Precompute Maximum Subarray Sums</strong>: We will use
Kadane’s algorithm. This will help us find the maximum sum for each
subarray that ends at every index. We will save these sums in a 2D array
called <code>maxSubarraySum</code>.</p></li>
<li><p><strong>Dynamic Programming Table</strong>: Next, we create a DP
table. Here, <code>dp[i][j]</code> shows the maximum sum we can get by
using <code>j</code> subarrays from the first <code>i</code> elements of
the array. We will fill this table step by step.</p></li>
<li><p><strong>Transition Logic</strong>:</p>
<ul>
<li><p>For each position <code>i</code> and number of partitions
<code>j</code>, we will find the maximum sum. We will look at all
possible previous partitions. For each starting point <code>p</code> of
the last subarray, we update:</p>
<pre><code>dp[i][j] = max(dp[i][j], dp[p-1][j-1] + maxSubarraySum[p][i])</code></pre></li>
<li><p>This keeps the last subarray starting from <code>p</code> and
ending at <code>i</code>, so they do not overlap.</p></li>
</ul></li>
</ol>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2 * k). Here <code>n</code> is
the length of the array and <code>k</code> is the number of
non-overlapping subarrays.</li>
<li><strong>Space Complexity</strong>: O(n * k) for the DP table and
O(n) for the maximum subarray sums.</li>
</ul>
<h3 id="example-code">Example Code</h3>
<p>Here is a Java code for the optimized dynamic programming method:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumSumKSubarrays <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumOfKSubarrays</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> maxSubarraySum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> start <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> start <span class="op">&lt;</span> n<span class="op">;</span> start<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> currentSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> end <span class="op">=</span> start<span class="op">;</span> end <span class="op">&lt;</span> n<span class="op">;</span> end<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                currentSum <span class="op">+=</span> nums<span class="op">[</span>end<span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                maxSubarraySum<span class="op">[</span>start <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>end <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> currentSum<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> p <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> p <span class="op">&lt;</span> i<span class="op">;</span> p<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>p<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> maxSubarraySum<span class="op">[</span>p<span class="op">][</span>i<span class="op">]);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code calculates the maximum sum of <code>k</code>
non-overlapping subarrays quickly. If you want to learn more about
dynamic programming, you can check resources like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2 id="dynamic-programming-solution-in-java-for-maximum-sum">Dynamic
Programming Solution in Java for Maximum Sum</h2>
<p>We want to find the maximum sum of <code>k</code> non-overlapping
subarrays using dynamic programming in Java. We can do this by following
some clear steps. The main idea is to keep a table that shows the
maximum sums of subarrays as we go through the input array.</p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumKNonOverlappingSubarrays <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumOfKSubarrays</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> k<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 1: Calculate the prefix sums for quick range sum queries</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> prefixSum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            prefixSum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 2: Initialize the dp table</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 3: Fill the dp table</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> k<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> m <span class="op">&lt;</span> j<span class="op">;</span> m<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>m<span class="op">]</span> <span class="op">+</span> prefixSum<span class="op">[</span>j<span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>m<span class="op">]);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 4: The answer is the maximum sum of k non-overlapping subarrays</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>k<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        MaxSumKNonOverlappingSubarrays solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaxSumKNonOverlappingSubarrays</span><span class="op">();</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span> <span class="co">// Example input</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> solution<span class="op">.</span><span class="fu">maxSumOfKSubarrays</span><span class="op">(</span>nums<span class="op">,</span> k<span class="op">);</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of &quot;</span> <span class="op">+</span> k <span class="op">+</span> <span class="st">&quot; non-overlapping subarrays: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ol type="1">
<li><strong>Prefix Sum Calculation</strong>: We first find the prefix
sums of the input array. This helps us to calculate range sums
quickly.</li>
<li><strong>Dynamic Programming Table Initialization</strong>: We make a
table <code>dp</code> where <code>dp[i][j]</code> shows the maximum sum
of <code>i</code> non-overlapping subarrays from the first
<code>j</code> elements.</li>
<li><strong>Filling the DP Table</strong>: For each ending point of the
last subarray (<code>j</code>), we check possible starting points
(<code>m</code>). We update the maximum sum of <code>i</code>
subarrays.</li>
<li><strong>Final Result</strong>: The answer in <code>dp[k][n]</code>
gives us the maximum sum we can get using <code>k</code> non-overlapping
subarrays.</li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(k * n^2). Here <code>k</code> is
the number of subarrays we need and <code>n</code> is the total number
of elements.</li>
<li><strong>Space Complexity</strong>: O(n) for the prefix sum and O(k *
n) for the dynamic programming table.</li>
</ul>
<p>This code helps us find the maximum sum of <code>k</code>
non-overlapping subarrays. It follows the rules of dynamic programming.
For more problems, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-two-non-overlapping-subarrays-advanced-hard.html">maximum
sum of two non-overlapping subarrays</a> to learn more about dynamic
programming techniques.</p>
<h2 id="dynamic-programming-solution-in-python-for-maximum-sum">Dynamic
Programming Solution in Python for Maximum Sum</h2>
<p>We want to solve the problem of finding the maximum sum of
<code>k</code> non-overlapping subarrays using dynamic programming in
Python. We will make a function that calculates this value in an
efficient way. Our approach will use two main ideas: prefix sums and
dynamic programming states.</p>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li><p><strong>Prefix Sum Calculation</strong>: First, we calculate the
prefix sums of the array. This helps us get the sum of any subarray
quickly.</p></li>
<li><p><strong>Dynamic Programming Table</strong>: We create a 2D DP
table. Here, <code>dp[i][j]</code> shows the maximum sum we can get with
the first <code>i</code> elements of the array using <code>j</code>
subarrays.</p></li>
<li><p><strong>Transition</strong>: For each element, we look for the
maximum sum we can get by checking all possible previous subarrays that
could end before the current index.</p></li>
</ol>
<h3 id="python-code">Python Code</h3>
<p>Here is the Python code for the dynamic programming solution:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumOfKSubarrays(arr, k):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> k:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Calculate the prefix sums</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        prefix_sum[i] <span class="op">=</span> prefix_sum[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> arr[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Initialize the DP table</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(j, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Compute the max sum for the j-th subarray</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            current_sum <span class="op">=</span> prefix_sum[i] <span class="op">-</span> prefix_sum[i <span class="op">-</span> j]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            max_sum[i] <span class="op">=</span> <span class="bu">max</span>(max_sum[i <span class="op">-</span> <span class="dv">1</span>], dp[i <span class="op">-</span> j][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> current_sum)</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> max_sum[i]</span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][k]</span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">5</span>, <span class="dv">1</span>]</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumOfKSubarrays(arr, k))  <span class="co"># Output: 20</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Prefix Sum</strong>: The <code>prefix_sum</code> array helps
us calculate any subarray sum quickly.</li>
<li><strong>DP Initialization</strong>: We start with a 2D list
<code>dp</code> to store the maximum sums for each count of
subarrays.</li>
<li><strong>Looping through Subarrays</strong>: The two loops go through
the number of subarrays and the elements of the array. They update the
<code>dp</code> table and the <code>max_sum</code> array as we go.</li>
</ul>
<p>This code calculates the maximum sum of <code>k</code>
non-overlapping subarrays in O(n^2) time. This is good for arrays of
moderate size.</p>
<p>If we want to learn more about dynamic programming, we can check out
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2 id="dynamic-programming-solution-in-c-for-maximum-sum">Dynamic
Programming Solution in C++ for Maximum Sum</h2>
<p>To find the maximum sum of k non-overlapping subarrays using dynamic
programming in C++, we can use a clear method.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an integer array <code>nums</code> and an integer
<code>k</code>. Our goal is to find <code>k</code> non-overlapping
subarrays. We want to maximize the sum of their elements. We need to
calculate the sums of subarrays quickly and keep track of the maximum
sums as we go through the array.</p>
<h3 id="approach-1">Approach</h3>
<ol type="1">
<li><strong>Prefix Sum Array</strong>: First, we create a prefix sum
array. This helps us calculate the sums of subarrays easily.</li>
<li><strong>Dynamic Programming Table</strong>: We use a 2D DP table.
Here, <code>dp[i][j]</code> shows the maximum sum we can get from the
first <code>i</code> elements of the array with <code>j</code>
non-overlapping subarrays.</li>
<li><strong>Transition</strong>: For each position <code>i</code> in the
array and for each <code>j</code> from <code>1</code> to <code>k</code>,
we decide if we end a subarray at <code>i</code> or not. If we do, we
find the best earlier position <code>p</code> to start the new
subarray.</li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSumOfKSubarrays<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 1: Create prefix sums</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefix<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            prefix<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> prefix<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 2: Initialize DP array</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> maxSum<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// To keep the maximum sums</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 3: Fill the DP table</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> j<span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> currentSum <span class="op">=</span> prefix<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> prefix<span class="op">[</span>i <span class="op">-</span> j<span class="op">];</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> maxSum<span class="op">[</span>i <span class="op">-</span> j<span class="op">]</span> <span class="op">+</span> currentSum<span class="op">);</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>                maxSum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>maxSum<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    Solution sol<span class="op">;</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Sum of &quot;</span> <span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot; Non-Overlapping Subarrays: &quot;</span> </span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> sol<span class="op">.</span>maxSumOfKSubarrays<span class="op">(</span>nums<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Prefix Sum Calculation</strong>: We calculate the prefix sum
to quickly find the sum of any subarray.</li>
<li><strong>Dynamic Programming Table</strong>: The <code>dp</code>
table gets filled by checking if we include the current position
<code>i</code> as the end of a subarray or not.</li>
<li><strong>Max Tracking</strong>: The <code>maxSum</code> array helps
us track the maximum sums found so far. This makes it easier to update
as we move through the array.</li>
</ul>
<p>This code helps us find the maximum sum of <code>k</code>
non-overlapping subarrays in C++ efficiently.</p>
<h2
id="understanding-space-complexity-in-dynamic-programming">Understanding
Space Complexity in Dynamic Programming</h2>
<p>Space complexity in dynamic programming (DP) is very important. It
shows how well an algorithm uses memory. This means how much memory an
algorithm needs based on the input size. In dynamic programming, this
can really change how well we solve problems like Maximum Sum of k
Non-Overlapping Subarrays.</p>
<h3 id="key-considerations">Key Considerations:</h3>
<ul>
<li><p><strong>State Representation</strong>: The space complexity
depends a lot on how we show the state of the problem. When we have to
track many dimensions, like subarrays or sums, this can use up more
space.</p></li>
<li><p><strong>Memoization vs. Tabulation</strong>:</p>
<ul>
<li><strong>Memoization</strong> is a top-down method. It saves the
results of smaller problems in a hash table or array. This way, we do
not calculate the same thing again. This can give us an average space
complexity of O(n) if n is the number of unique subproblems.</li>
<li><strong>Tabulation</strong> is a bottom-up method. It fills a table
step by step. This usually needs O(n * k) space, where k is the number
of overlapping subarrays.</li>
</ul></li>
<li><p><strong>Optimizing Space Usage</strong>: We can reduce space
complexity in some cases. For example:</p>
<ul>
<li>Instead of keeping a full DP table, we can use only a few variables
to store past states. This can reduce space complexity from O(n) to O(1)
or O(k).</li>
</ul></li>
</ul>
<h3
id="example-of-space-complexity-in-maximum-sum-of-k-non-overlapping-subarrays">Example
of Space Complexity in Maximum Sum of k Non-Overlapping Subarrays</h3>
<p>For the Maximum Sum of k Non-Overlapping Subarrays problem, the
dynamic programming solution may look like this:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumOfKSubarrays</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Space for DP table</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Cumulative sum</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ans <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate maximum sums for k subarrays</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        ans <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>ans<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> dp<span class="op">[</span>i <span class="op">-</span> k<span class="op">]);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ans<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the example above, the space complexity is O(n) because we use an
extra array for cumulative sums. But if we only need to track the last k
sums, we can cut the space to O(k).</p>
<h3 id="conclusion">Conclusion</h3>
<p>We need to understand space complexity in dynamic programming to make
good algorithms. By looking at state representation and using better
methods, we can improve how well algorithms work like the Maximum Sum of
k Non-Overlapping Subarrays while keeping memory use low. For more
information on dynamic programming, we can check out related topics like
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-two-non-overlapping-subarrays-medium.html">Dynamic
Programming: Maximum Sum of Two Non-Overlapping Subarrays</a>.</p>
<h2 id="handling-edge-cases-in-maximum-sum-problem">Handling Edge Cases
in Maximum Sum Problem</h2>
<p>When we use dynamic programming for the “Maximum Sum of k
Non-Overlapping Subarrays” problem, we need to think about some edge
cases. These cases help us make sure that our algorithm works in all
situations. Here are some important edge cases to think about:</p>
<ul>
<li><strong>k is Zero</strong>: If we set <code>k</code> to zero, the
maximum sum should be zero too. This is because we do not select any
subarrays.</li>
<li><strong>Empty Array</strong>: If our input array is empty, the
maximum sum should also be zero. There are no elements to create
subarrays.</li>
<li><strong>k Greater than Array Length</strong>: If <code>k</code> is
bigger than the length of the array, we cannot create the needed
subarrays. Our function should handle this well. It can return zero or
an error.</li>
<li><strong>All Negative Numbers</strong>: If the array has only
negative numbers, our solution should still give the largest sum of
<code>k</code> non-overlapping subarrays. This sum can be negative but
should be the highest among them.</li>
<li><strong>Single Element Array</strong>: For an array with just one
element, if <code>k</code> is one, the result should be that single
element’s value. If <code>k</code> is more than one, we should treat it
like the case where <code>k</code> is bigger than the array length.</li>
<li><strong>Subarrays with Overlapping Elements</strong>: We must make
sure that our implementation does not allow overlapping elements in the
non-overlapping subarrays. This is a common mistake in simple
implementations.</li>
</ul>
<p>We need to check these edge cases carefully in our algorithm. This
helps us avoid wrong results or errors when running the program. Below
is a sample code snippet in Python that shows how we can handle some of
these edge cases:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumOfKNonOverlappingSubarrays(nums, k):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums <span class="kw">or</span> k <span class="op">&gt;</span> <span class="bu">len</span>(nums):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> start <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> end <span class="kw">in</span> <span class="bu">range</span>(start, n):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            current_sum <span class="op">+=</span> nums[end]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                dp[end <span class="op">+</span> <span class="dv">1</span>][j] <span class="op">=</span> <span class="bu">max</span>(dp[end][j], dp[start][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> current_sum)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][k]</span></code></pre></div>
<p>This code starts a 3D DP array to track the maximum sums while we
think about the edge cases we talked about. It manages cases where
<code>k</code> is zero, the array is empty, or <code>k</code> is more
than the array’s length.</p>
<h2
id="performance-analysis-of-dynamic-programming-approach">Performance
Analysis of Dynamic Programming Approach</h2>
<p>We can check the performance of the dynamic programming approach for
solving the Maximum Sum of k Non-Overlapping Subarrays problem. We look
at time complexity, space complexity, and how well it works in real
situations.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li><strong>Dynamic Programming Approach</strong>: The time complexity
mainly relies on how many subarrays there are and how many operations we
need to find their sums.</li>
<li>If we have an array <code>arr</code> with length <code>n</code> and
<code>k</code> is the number of subarrays:
<ul>
<li><strong>Overall Complexity</strong>: O(n * k)</li>
<li>This is because we keep a dynamic programming table of size
<code>k</code>. We must go through the array to fill it and do
calculations for each subarray.</li>
</ul></li>
</ul>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li><strong>Space Utilization</strong>: The space complexity is O(k +
n), where:
<ul>
<li>O(k) is for storing the maximum sums of the subarrays.</li>
<li>O(n) is for prefix sums. This helps us calculate the sum of any
subarray quickly.</li>
</ul></li>
</ul>
<h3 id="efficiency-in-implementation">Efficiency in Implementation</h3>
<ul>
<li><strong>Pre-computation of Sums</strong>: Using prefix sums makes
the time to calculate the sum of any subarray drop from O(n) to O(1).
This makes the algorithm run much faster.</li>
<li><strong>Iterative Updates</strong>: We can fill the dynamic
programming table in an iterative way. This reduces the need for too
many recursive calls. We avoid stack overflow problems in languages that
limit recursion depth.</li>
</ul>
<h3 id="real-world-performance">Real-World Performance</h3>
<ul>
<li>In real-life situations, the dynamic programming approach works well
for moderate sizes of arrays and values of <code>k</code>.</li>
<li>But for very large inputs, we may see performance issues because of
the quadratic time complexity. We can use optimization techniques like
memoization and iterative methods to help with these problems.</li>
</ul>
<h3 id="example-implementation">Example Implementation</h3>
<p>Here is a simple code for the Maximum Sum of k Non-Overlapping
Subarrays problem in Python. It shows how we can make the algorithm
efficient:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumOfKNonOverlapping(arr, k):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> k:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prefix sums</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        prefix_sum[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> prefix_sum[i] <span class="op">+</span> arr[i]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(j, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Max sum of j non-overlapping subarrays</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(j <span class="op">-</span> <span class="dv">1</span>, i):</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j], dp[m][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> prefix_sum[i] <span class="op">-</span> prefix_sum[m])</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][k]</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumOfKNonOverlapping(arr, k))  <span class="co"># Output: 6</span></span></code></pre></div>
<p>This code shows the space and time efficiency we get from using
dynamic programming and prefix sums to solve the problem well.</p>
<p>For more reading about dynamic programming basics, you can check the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a> and other articles.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we need to find the maximum sum of <strong>k non-overlapping
subarrays</strong>, we can use different methods. Each method has its
own difficulty, speed, and how easy it is to use. Here is a simple
comparison of the main methods:</p>
<ol type="1">
<li><strong>Brute Force Approach</strong>:
<ul>
<li>We generate all possible combinations of subarrays. Then we pick the
maximum sum of k non-overlapping subarrays.</li>
<li><strong>Complexity</strong>: O(n^k) where n is the number of
elements in the array. This makes it hard to use for bigger
datasets.</li>
<li><strong>Implementation</strong>: It is simple but not fast for
larger k or bigger arrays.</li>
</ul></li>
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>This method uses a dynamic programming table. It keeps results of
smaller problems. This helps us find the maximum sums without
overlapping subarrays.</li>
<li><strong>Time Complexity</strong>: O(n*k) where n is the length of
the array and k is the number of subarrays.</li>
<li><strong>Space Complexity</strong>: O(n*k) for the DP table, but we
can make it O(n) with some space-saving tricks.</li>
<li><strong>Implementation</strong>: This method is more complex than
brute force but much faster. It works better for larger datasets.</li>
</ul></li>
<li><strong>Optimized Dynamic Programming with Prefix Sums</strong>:
<ul>
<li>We can precompute prefix sums. This way we spend less time
calculating the sum of subarrays.</li>
<li><strong>Time Complexity</strong>: O(n*k) for filling the DP table,
with O(1) time to get the sum of subarrays using prefix sums.</li>
<li><strong>Space Complexity</strong>: O(n) for prefix sums, and O(k)
for the DP table.</li>
<li><strong>Implementation</strong>: This method is a good mix of speed
and clarity. Many people like to use it.</li>
</ul></li>
<li><strong>Greedy Approach</strong>:
<ul>
<li>A greedy algorithm might pick the top k subarrays by their
individual maximum sums. But this can cause overlaps.</li>
<li><strong>Complexity</strong>: This method is usually less efficient.
It can be O(n log n) because of sorting.</li>
<li><strong>Implementation</strong>: It seems easy, but it may not give
the best answer because of overlaps.</li>
</ul></li>
<li><strong>Sliding Window Technique</strong>:
<ul>
<li>We can use this method with dynamic programming. It helps us keep
track of valid subarrays while we find the maximum sums.</li>
<li><strong>Complexity</strong>: O(n) for going through the array and
keeping the window, plus dynamic programming for k subarrays. This makes
it O(n*k).</li>
<li><strong>Implementation</strong>: It works well for keeping the
non-overlapping rule.</li>
</ul></li>
</ol>
<p>In short, the dynamic programming approach with optimizations like
prefix sums is the fastest and most used method to solve the maximum sum
of k non-overlapping subarrays problem. The brute force method is good
to learn the basics. Greedy and sliding window methods are other options
but may not always give the best results.</p>
<p>If we want to learn more about dynamic programming, we can check the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a> article.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-k-non-overlapping-subarrays-problem">1.
What is the Maximum Sum of k Non-Overlapping Subarrays problem?</h3>
<p>The Maximum Sum of k Non-Overlapping Subarrays problem is a challenge
in dynamic programming. We need to find the maximum sum of
<code>k</code> non-overlapping subarrays from a given list of numbers.
This problem is important for doing better resource allocation and
making more profit in areas like finance and operations research.</p>
<h3
id="how-can-i-solve-the-maximum-sum-of-k-non-overlapping-subarrays-problem-using-dynamic-programming">2.
How can I solve the Maximum Sum of k Non-Overlapping Subarrays problem
using dynamic programming?</h3>
<p>To solve this problem with dynamic programming, we can make a DP
table. This table will help us track the maximum sums for different
lengths and positions in the array. We will go through the array and
update the sums based on what we calculated before. This way, we can
find the best solution efficiently.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-approach-for-this-problem">3.
What is the time complexity of the dynamic programming approach for this
problem?</h3>
<p>The time complexity for the dynamic programming method for the
Maximum Sum of k Non-Overlapping Subarrays problem is usually O(n * k).
Here, <code>n</code> is the length of the array and <code>k</code> is
the number of subarrays. This method works well because we update the DP
table in a nice way that avoids repeating calculations.</p>
<h3
id="how-can-i-handle-edge-cases-when-implementing-a-solution-for-this-problem">4.
How can I handle edge cases when implementing a solution for this
problem?</h3>
<p>When we implement a solution for this problem, we need to think about
edge cases. For example, what if <code>k</code> is bigger than the
number of subarrays we have? Or what if the array only has negative
numbers? We can handle these cases with some checks before we start the
main part of our algorithm.</p>
<h3
id="are-there-any-alternative-approaches-to-solve-the-maximum-sum-of-k-non-overlapping-subarrays-problem">5.
Are there any alternative approaches to solve the Maximum Sum of k
Non-Overlapping Subarrays problem?</h3>
<p>Yes, there are other ways to solve this problem. We can use a
brute-force method to check all possible combinations of subarrays. Or
we can try a greedy algorithm. But dynamic programming is still the best
method because it works well with time and is easier to use with bigger
datasets. If you want to learn more about dynamic programming, you can
read articles about the Fibonacci sequence and other problems like that
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">here</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            