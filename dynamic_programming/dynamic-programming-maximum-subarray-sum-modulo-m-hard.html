
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Subarray Sum Modulo M - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content=""Unlock dynamic programming techniques with our guide on Maximum Subarray Sum Modulo M. Master this challenging problem today!"">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Subarray Sum Modulo M - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Subarray Sum Modulo M problem is about finding the
biggest sum of a continuous subarray from a list of integers. We take
this sum and apply a modulo operation with a number M. The tricky part
is to find this maximum sum quickly while also considering the modulo.
This is important because modular arithmetic has a repeating pattern
that can change the result. We usually use dynamic programming methods
to find the best solution.</p>
<p>In this article, we will talk about the details of the Maximum
Subarray Sum Modulo M problem. We will explain the problem and its
challenges. We will look at a dynamic programming method to solve this
problem in different programming languages like Java, Python, and C++.
We will also talk about ways to improve space usage, how to deal with
negative numbers, and how to test our solution with different edge
cases. At the end, we will check how well our solutions perform and
answer some common questions about this topic.</p>
<ul>
<li>[Dynamic Programming] Maximum Subarray Sum Modulo M - Hard</li>
<li>Understanding the Problem Statement for Maximum Subarray Sum Modulo
M</li>
<li>Dynamic Programming Approach to Maximum Subarray Sum Modulo M in
Java</li>
<li>Dynamic Programming Approach to Maximum Subarray Sum Modulo M in
Python</li>
<li>Dynamic Programming Approach to Maximum Subarray Sum Modulo M in
C++</li>
<li>Optimizing Space Complexity for Maximum Subarray Sum Modulo M</li>
<li>Handling Negative Numbers in Maximum Subarray Sum Modulo M</li>
<li>Testing and Edge Cases for Maximum Subarray Sum Modulo M</li>
<li>Performance Analysis of Maximum Subarray Sum Modulo M Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check
these articles too: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number - Easy</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-sum-with-one-deletion-medium.html">Dynamic
Programming: Maximum Subarray Sum with One Deletion - Medium</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-edit-distance-hard.html">Dynamic
Programming: Edit Distance - Hard</a>.</p>
<h2
id="dynamic-programming-maximum-subarray-sum-modulo-m---hard">[Dynamic
Programming] Maximum Subarray Sum Modulo M - Hard</h2>
<h3
id="understanding-the-problem-statement-for-maximum-subarray-sum-modulo-m">Understanding
the Problem Statement for Maximum Subarray Sum Modulo M</h3>
<p>The Maximum Subarray Sum Modulo M is a well-known dynamic programming
problem. We have an array of numbers and a positive number ( M ). Our
goal is to find the highest sum of a contiguous subarray, using modulo (
M ).</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: An array of numbers <code>nums</code> and a
number ( M ).</li>
<li><strong>Output</strong>: The highest value of the sum of a
contiguous subarray modulo ( M ).</li>
</ul>
<h3 id="example">Example</h3>
<p>Let’s take the array <code>nums = [3, 3, 9, 9, 5]</code> and ( M = 7
):</p>
<ul>
<li>Possible subarrays and their sums:
<ul>
<li><code>[3]</code> gives ( 3 = 3 )</li>
<li><code>[3, 3]</code> gives ( 6 = 6 )</li>
<li><code>[3, 3, 9]</code> gives ( 15 = 1 )</li>
<li><code>[9]</code> gives ( 9 = 2 )</li>
<li><code>[9, 5]</code> gives ( 14 = 0 )</li>
<li>and more.</li>
</ul></li>
<li>The highest subarray sum modulo ( M ) is ( 6 ).</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The size of the array ( N ) can be as big as ( 10^5 ).</li>
<li>The numbers in the array can be negative, zero, or positive.</li>
</ul>
<p>We need a smart way to solve this problem. We want to find the answer
in ( O(N N) ) or ( O(N) ) time. We can use properties of prefix sums and
modular math.</p>
<p>For more examples of similar dynamic programming problems, we can
look at articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray Sum with Kadane’s Algorithm</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming - Minimum Path Sum in a Grid</a>.</p>
<h2
id="dynamic-programming-approach-to-maximum-subarray-sum-modulo-m-in-java">Dynamic
Programming Approach to Maximum Subarray Sum Modulo M in Java</h2>
<p>We can solve the problem of finding the maximum subarray sum modulo (
M ) using a simple dynamic programming method. The main idea is to keep
track of the cumulative sums modulo ( M ) as we go through the
array.</p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSubarraySumModuloM <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSubarraySumModuloM</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span><span class="op">[]</span> prefixSum <span class="op">=</span> <span class="kw">new</span> <span class="dt">long</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            prefixSum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span>prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">])</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>prefixSum<span class="op">);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> maxModSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">long</span> currentSum <span class="op">=</span> prefixSum<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> index <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">binarySearch</span><span class="op">(</span>prefixSum<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> i<span class="op">,</span> currentSum<span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                index <span class="op">=</span> <span class="op">-(</span>index <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>index <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                maxModSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxModSum<span class="op">,</span> <span class="op">(</span>currentSum <span class="op">-</span> prefixSum<span class="op">[</span>index<span class="op">]</span> <span class="op">+</span> M<span class="op">)</span> <span class="op">%</span> M<span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> maxModSum<span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> M <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="fu">maxSubarraySumModuloM</span><span class="op">(</span>arr<span class="op">,</span> M<span class="op">));</span> <span class="co">// Output: 6</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ol type="1">
<li><p><strong>Prefix Sum Array</strong>: We first calculate the prefix
sums of the array with modulo ( M ).</p></li>
<li><p><strong>Sort Prefix Sums</strong>: Next, we sort the prefix sums.
This helps us to use binary search for finding the biggest
difference.</p></li>
<li><p><strong>Binary Search</strong>: For each prefix sum, we use
binary search to find the largest prefix sum that is less than or equal
to the current prefix sum. This way, we can calculate the possible
maximum subarray sum modulo ( M ).</p></li>
<li><p><strong>Result</strong>: The biggest value we find during this
process is our result.</p></li>
</ol>
<p>This dynamic programming method helps us find the maximum subarray
sum modulo ( M ) in ( O(n n) ) time because of sorting and binary
searching.</p>
<p>If you want to learn more about dynamic programming techniques, you
can check out related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2
id="dynamic-programming-approach-to-maximum-subarray-sum-modulo-m-in-python">Dynamic
Programming Approach to Maximum Subarray Sum Modulo M in Python</h2>
<p>We want to find the maximum subarray sum modulo ( M ) in a smart way.
We can use dynamic programming for this. The main idea is to keep track
of the sums we get as we go through the array. We also find their modulo
( M ) values. This helps us search for the biggest sums better.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create an array <code>dp</code>.
This will store the maximum sums up to each index. We start by setting
all values to zero. We also keep a variable to remember the overall
maximum sum modulo ( M ).</li>
<li><strong>Prefix Sum Calculation</strong>: We go through the array. We
calculate the cumulative sum and its modulo ( M ).</li>
<li><strong>Store the Maximum Modulo Value</strong>: We use a sorted
list to quickly find the largest value that is smaller than the current
cumulative sum modulo ( M ).</li>
<li><strong>Update the Result</strong>: For each cumulative sum, we find
the possible maximum subarray sum modulo ( M ) and update our
result.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSubarraySumModuloM(arr, M):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    sorted_prefix_sums <span class="op">=</span> []</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        prefix_sum <span class="op">+=</span> arr[i]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        current_mod <span class="op">=</span> prefix_sum <span class="op">%</span> M</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Use binary search to find the largest prefix sum less than current_mod</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Insert current mod into sorted list</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="im">import</span> bisect</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect.bisect_right(sorted_prefix_sums, current_mod)</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, (current_mod <span class="op">-</span> sorted_prefix_sums[pos <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> M) <span class="op">%</span> M)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Insert current_mod into the sorted list of prefix sums</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        bisect.insort(sorted_prefix_sums, current_mod)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(max_sum, prefix_sum <span class="op">%</span> M)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>M <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSubarraySumModuloM(arr, M))  <span class="co"># Output: 2</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Input Parameters</strong>: The function
<code>maxSubarraySumModuloM</code> takes an array <code>arr</code> and a
number ( M ).</li>
<li><strong>Cumulative Sum</strong>: We keep track of the cumulative sum
with <code>prefix_sum</code> as we go.</li>
<li><strong>Modulo Calculation</strong>: We calculate the modulo ( M )
for the cumulative sum.</li>
<li><strong>Binary Search</strong>: We use the <code>bisect</code>
module to keep a sorted list of prefix sums. This lets us search for
maximum values quickly.</li>
<li><strong>Output</strong>: The function gives back the maximum
subarray sum modulo ( M ).</li>
</ul>
<p>This dynamic programming method helps us find the result fast with a
time complexity of ( O(n n) ). This makes it good for bigger
datasets.</p>
<h2
id="dynamic-programming-approach-to-maximum-subarray-sum-modulo-m-in-c">Dynamic
Programming Approach to Maximum Subarray Sum Modulo M in C++</h2>
<p>We can solve the Maximum Subarray Sum Modulo M problem in a good way
using Dynamic Programming in C++. Our goal is to find the maximum sum of
a continuous subarray modulo M. We can do this by keeping track of a
running sum and using the rules of modulo math.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple version of the dynamic programming approach:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;set&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSubarraySumModuloM<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;</span> prefixSum<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    set<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;</span> modSet<span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>prefixSum<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        modSet<span class="op">.</span>insert<span class="op">(</span>prefixSum<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> modSet<span class="op">.</span>upper_bound<span class="op">(</span>prefixSum<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>it <span class="op">!=</span> modSet<span class="op">.</span>begin<span class="op">())</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">--</span>it<span class="op">;</span> <span class="co">// Get the largest element less than or equal to prefixSum[i]</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> max<span class="op">(</span>maxSum<span class="op">,</span> <span class="op">(</span>prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="op">*</span>it <span class="op">+</span> M<span class="op">)</span> <span class="op">%</span> M<span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> M <span class="op">=</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Subarray Sum Modulo &quot;</span> <span class="op">&lt;&lt;</span> M <span class="op">&lt;&lt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&lt;</span> maxSubarraySumModuloM<span class="op">(</span>arr<span class="op">,</span> M<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Prefix Sum Array</strong>: We find the prefix sum of the
array modulo M to keep track of the sums.</li>
<li><strong>Set for Unique Modulo Values</strong>: We use a set to store
the unique modulo values of prefix sums. This helps us find the largest
prefix sum that is less than the current prefix sum fast.</li>
<li><strong>Finding Maximum</strong>: For each prefix sum, we look for
the largest value in the set that is less than the current prefix sum.
We use the <code>upper_bound</code> function to help us keep the maximum
subarray sum modulo M.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity of this method is O(n log n). This is because of
the insertion and searching in the set. Here, n is the length of the
input array.</p>
<p>This dynamic programming method helps us find the maximum subarray
sum modulo M in a good way and can work with many cases, even big input
sizes. For more information on similar topics, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray Sum with Kadane’s Algorithm</a>.</p>
<h2
id="optimizing-space-complexity-for-maximum-subarray-sum-modulo-m">Optimizing
Space Complexity for Maximum Subarray Sum Modulo M</h2>
<p>To optimize space complexity for the Maximum Subarray Sum Modulo M
problem, we can change the 2D dynamic programming array into a 1D array.
The main idea is to keep only the states we need for our calculations at
any time.</p>
<p>The original method usually uses a 2D array <code>dp[i][j]</code>.
Here, <code>i</code> is the index of the subarray end, and
<code>j</code> is the modulo sum. But we can change it to a 1D array
<code>dp[j]</code>. In this array, <code>j</code> will keep the maximum
subarray sum modulo M.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><strong>Create a 1D Array</strong>: First, we create a 1D array
<code>dp</code> of size <code>M</code> and fill it with <code>-1</code>.
This shows that we have not calculated any sum for that modulo yet.</li>
<li><strong>Go Through the Array</strong>: Next, we look at each element
in the array. We update the <code>dp</code> array based on the values
from before.</li>
<li><strong>Update Logic</strong>: For each sum, we calculate the modulo
and update the <code>dp</code> array. We make sure to keep only the
maximum values.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is how the optimized algorithm looks in Java, Python, and
C++:</p>
<h4 id="java-implementation-1">Java Implementation</h4>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSubarraySumModulo <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSubarraySumModulo</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>M<span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> currentSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            currentSum <span class="op">=</span> <span class="op">(</span>currentSum <span class="op">+</span> num<span class="op">)</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> currentSum<span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>currentSum<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>currentSum<span class="op">],</span> currentSum<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> M<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>j<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                    <span class="dt">int</span> newSum <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> num<span class="op">)</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>newSum<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>newSum<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                    maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> dp<span class="op">[</span>newSum<span class="op">]);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python-implementation">Python Implementation</h4>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_subarray_sum_modulo(nums, M):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> M</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    current_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> (current_sum <span class="op">+</span> num) <span class="op">%</span> M</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, current_sum)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        dp[current_sum] <span class="op">=</span> <span class="bu">max</span>(dp[current_sum], current_sum)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(M):</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> dp[j] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                new_sum <span class="op">=</span> (dp[j] <span class="op">+</span> num) <span class="op">%</span> M</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                dp[new_sum] <span class="op">=</span> <span class="bu">max</span>(dp[new_sum], dp[j] <span class="op">+</span> num)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, dp[new_sum])</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div>
<h4 id="c-implementation-1">C++ Implementation</h4>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSubarraySumModulo<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>M<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> currentSum <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        currentSum <span class="op">=</span> <span class="op">(</span>currentSum <span class="op">+</span> num<span class="op">)</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>maxSum<span class="op">,</span> currentSum<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>currentSum<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>currentSum<span class="op">],</span> currentSum<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> M<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>j<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> newSum <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> num<span class="op">)</span> <span class="op">%</span> M<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>newSum<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>newSum<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                maxSum <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>maxSum<span class="op">,</span> dp<span class="op">[</span>newSum<span class="op">]);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This method reduces the space complexity from O(N*M) to O(M). This
helps us use memory better while still getting the right results
quickly. For more information on dynamic programming, you can check the
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray Sum using Kadane’s Algorithm</a>.</p>
<h2
id="handling-negative-numbers-in-maximum-subarray-sum-modulo-m">Handling
Negative Numbers in Maximum Subarray Sum Modulo M</h2>
<p>In the <strong>Maximum Subarray Sum Modulo M</strong> problem, we
must handle negative numbers well. They can change the result of the
maximum sum. Our goal is to find the highest sum of any continuous
subarray, using modulo M.</p>
<p>When we deal with negative numbers, we must change our method to keep
track of the maximum sum. Here is how we can manage negative values
effectively:</p>
<ol type="1">
<li><p><strong>Initialization</strong>: We start with a sum of
<code>0</code>. We also need a variable to keep the highest sum found.
We can set this to <code>Integer.MIN_VALUE</code> or something similar
in our programming language.</p></li>
<li><p><strong>Prefix Sum Array</strong>: We create a prefix sum array.
This array will store sums that we get using modulo M. It helps us find
subarray sums quickly.</p></li>
<li><p><strong>Handling Negative Values</strong>: When we add negative
numbers, the prefix sum can go down. We must make sure the sum modulo M
stays non-negative. We can do this with the following code:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>current_sum <span class="op">=</span> (current_sum <span class="op">+</span> num) <span class="op">%</span> M</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>current_sum <span class="op">=</span> (current_sum <span class="op">+</span> M) <span class="op">%</span> M  <span class="co"># This keeps the result non-negative</span></span></code></pre></div></li>
<li><p><strong>Tracking Maximum</strong>: As we go through the
array:</p>
<ul>
<li>We update the prefix sum.</li>
<li>We use a set or sorted list to remember all the prefix sums we have
seen.</li>
<li>For each prefix sum, we check how we can get the highest sums by
looking at the differences with the sums we have seen before.</li>
</ul></li>
<li><p><strong>Implementation Example in Python</strong>:</p></li>
</ol>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSubarraySumModuloM(arr, M):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    current_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    prefix_sums <span class="op">=</span> {<span class="dv">0</span>}  <span class="co"># To handle case where subarray starts from index 0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> (current_sum <span class="op">+</span> num) <span class="op">%</span> M</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_sum <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            current_sum <span class="op">+=</span> M</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check previous prefix sums to find the maximum modulo</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> ps <span class="kw">in</span> <span class="bu">sorted</span>(prefix_sums):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, (current_sum <span class="op">-</span> ps <span class="op">+</span> M) <span class="op">%</span> M)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        prefix_sums.add(current_sum)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div>
<p>This function finds the maximum subarray sum modulo M. It handles
negative numbers well. Using modulo keeps our results in the right range
and avoids negative sums.</p>
<p>If we write similar code in other languages like Java or C++, the
main ideas stay the same. We focus on keeping a running total and
managing prefix sums smartly. Handling negative numbers correctly helps
us to create a strong solution that works for any input array.</p>
<p>For more on dynamic programming, we can look into topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a>. This can help us
understand better how to solve maximum subarray sum problems.</p>
<h2
id="testing-and-edge-cases-for-maximum-subarray-sum-modulo-m">Testing
and Edge Cases for Maximum Subarray Sum Modulo M</h2>
<p>When we test the Maximum Subarray Sum Modulo M problem, we need to
check different edge cases. This helps us make sure that our solution
works well. Here are some important situations to think about:</p>
<ol type="1">
<li><strong>Single Element Arrays</strong>:
<ul>
<li>Input: <code>[5]</code>, <code>M = 3</code></li>
<li>Expected Output: <code>2</code> (5 % 3 = 2)</li>
</ul></li>
<li><strong>All Negative Numbers</strong>:
<ul>
<li>Input: <code>[-1, -2, -3, -4]</code>, <code>M = 2</code></li>
<li>Expected Output: <code>1</code> (the max sum mod 2 is -1 % 2 =
1)</li>
</ul></li>
<li><strong>Mixed Positive and Negative Numbers</strong>:
<ul>
<li>Input: <code>[1, -2, 3, -4, 5]</code>, <code>M = 7</code></li>
<li>Expected Output: <code>6</code> (the max subarray sum is 5 and 5 % 7
= 5)</li>
</ul></li>
<li><strong>Large Values of M</strong>:
<ul>
<li>Input: <code>[1, 2, 3, 4]</code>, <code>M = 100</code></li>
<li>Expected Output: <code>10</code> (the sum is 10, which is less than
100)</li>
</ul></li>
<li><strong>Array with Zeroes</strong>:
<ul>
<li>Input: <code>[0, 0, 0, 0]</code>, <code>M = 10</code></li>
<li>Expected Output: <code>0</code> (the max sum is 0)</li>
</ul></li>
<li><strong>Complete Cyclic Array</strong>:
<ul>
<li>Input: <code>[1, 2, 3, 4, -10]</code>, <code>M = 5</code></li>
<li>Expected Output: <code>4</code> (the max subarray sum is 4, from the
subarray <code>[1, 2, 3, 4]</code>)</li>
</ul></li>
<li><strong>Large Arrays</strong>:
<ul>
<li>Input: <code>[-1, 2, 3, -4, 5, -2, 3, 4]</code>,
<code>M = 100</code></li>
<li>Expected Output: <code>15</code> (the max subarray sum is 15 from
the subarray <code>[2, 3, -4, 5, -2, 3, 4]</code>)</li>
</ul></li>
<li><strong>All Elements are the Same</strong>:
<ul>
<li>Input: <code>[2, 2, 2, 2]</code>, <code>M = 3</code></li>
<li>Expected Output: <code>2</code> (the max sum is 8, and 8 % 3 =
2)</li>
</ul></li>
<li><strong>Negative Modulus Case</strong>:
<ul>
<li>Input: <code>[-1, -2, -3]</code>, <code>M = 2</code></li>
<li>Expected Output: <code>1</code> (the max subarray sum is -1, and -1
% 2 = 1)</li>
</ul></li>
<li><strong>Very Large Array</strong>:
<ul>
<li>Input: An array of size 10^5 with random numbers,
<code>M = 1000</code></li>
<li>Expected Output: We check the performance and correctness.</li>
</ul></li>
</ol>
<p>By looking at these edge cases, we can make sure that our Maximum
Subarray Sum Modulo M algorithm works well and handles all
situations.</p>
<h2
id="performance-analysis-of-maximum-subarray-sum-modulo-m-solutions">Performance
Analysis of Maximum Subarray Sum Modulo M Solutions</h2>
<p>We need good algorithms for the Maximum Subarray Sum Modulo M
problem. This problem can have big input sizes and values. We look at
time complexity, space complexity, and how well the code runs in
different programming languages.</p>
<h3 id="time-complexity-1">Time Complexity</h3>
<ol type="1">
<li><strong>Naive Approach</strong>: O(N^2)
<ul>
<li>This method checks all subarrays. It is not good for big
arrays.</li>
</ul></li>
<li><strong>Optimized Approach using Prefix Sums</strong>: O(N)
<ul>
<li>We keep a prefix sum and use a sorted data structure, like a
balanced BST. This helps us find the maximum subarray sum modulo M
quickly.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li><strong>Naive Approach</strong>: O(1)
<ul>
<li>We do not need extra space. Only some variables for
calculations.</li>
</ul></li>
<li><strong>Optimized Approach</strong>: O(N)
<ul>
<li>This needs extra space to store prefix sums and a sorted structure
to get the minimum quickly.</li>
</ul></li>
</ul>
<h3 id="language-specific-performance">Language-Specific
Performance</h3>
<ul>
<li><p><strong>Java</strong>: It runs fast with built-in libraries.
Using <code>TreeSet</code> for sorted prefix sums can make insertions
and queries faster.</p></li>
<li><p><strong>Python</strong>: It has similar speed using
<code>SortedList</code> from <code>sortedcontainers</code>. Python’s
lists are flexible but can have some overhead.</p></li>
<li><p><strong>C++</strong>: Using <code>set</code> or
<code>unordered_map</code> for prefix sums lets us insert and look up
quickly. C++ usually has less overhead than Java and Python. This can
lead to faster runtimes.</p></li>
</ul>
<h3 id="benchmarking">Benchmarking</h3>
<p>We should test performance on big datasets. We focus on: - Execution
time for different input sizes like 10^3, 10^4, 10^5. - Memory use
during execution to make sure it is okay.</p>
<h3 id="example-code-snippet-java">Example Code Snippet (Java)</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">TreeSet</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSubarraySumModuloM <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSubarraySumModuloM</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">,</span> <span class="dt">int</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prefixSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">TreeSet</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> set <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        set<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            prefixSum <span class="op">=</span> <span class="op">(</span>prefixSum <span class="op">+</span> num<span class="op">)</span> <span class="op">%</span> m<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Integer</span> ceiling <span class="op">=</span> set<span class="op">.</span><span class="fu">ceiling</span><span class="op">(</span>prefixSum <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>ceiling <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> <span class="op">(</span>prefixSum <span class="op">-</span> ceiling <span class="op">+</span> m<span class="op">)</span> <span class="op">%</span> m<span class="op">);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            set<span class="op">.</span><span class="fu">add</span><span class="op">(</span>prefixSum<span class="op">);</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span>maxSum <span class="op">+</span> m<span class="op">)</span> <span class="op">%</span> m<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="performance-metrics">Performance Metrics</h3>
<p>We measure the time for execution in milliseconds. We track memory
usage during the run. We check edge cases like: - All numbers being
negative. - Maximum integer values.</p>
<p>For more on dynamic programming optimization methods, check out the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray Sum (Kadane’s Algorithm)</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-maximum-subarray-sum-modulo-m-problem">1. What is
the Maximum Subarray Sum Modulo M problem?</h3>
<p>The Maximum Subarray Sum Modulo M problem is about finding the
biggest sum of any continuous part of an array. We take this sum and
then find the result when we divide it by M. This problem checks our
knowledge of dynamic programming. It also asks us to deal with tricky
cases like negative numbers and big input sizes.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-maximum-subarray-sum-modulo-m">2.
How can Dynamic Programming be applied to solve Maximum Subarray Sum
Modulo M?</h3>
<p>We can use dynamic programming to solve the Maximum Subarray Sum
Modulo M. We keep a running sum of the subarray while going through the
array. By tracking the remainders when we divide by M, we can easily
find the maximum sum that meets the modulo rule. This method is better
in time and space than simple ways.</p>
<h3
id="what-are-the-complexities-when-handling-negative-numbers-in-the-maximum-subarray-sum-modulo-m">3.
What are the complexities when handling negative numbers in the Maximum
Subarray Sum Modulo M?</h3>
<p>Handling negative numbers is important in the Maximum Subarray Sum
Modulo M. Negative numbers can change the total sum and the final
modulo. We need to make sure our method can calculate sums that might go
below zero. A good way to deal with this is to adjust the modulo so we
always get non-negative remainders.</p>
<h3
id="are-there-any-specific-edge-cases-to-consider-when-implementing-the-maximum-subarray-sum-modulo-m">4.
Are there any specific edge cases to consider when implementing the
Maximum Subarray Sum Modulo M?</h3>
<p>Yes, we should think about some edge cases when working on the
Maximum Subarray Sum Modulo M. These cases include when the array is
empty, has only negative numbers, or when M is less than or equal to 0.
If we handle these cases well, our algorithm will work better and give
correct results.</p>
<h3
id="how-can-i-optimize-the-space-complexity-of-the-maximum-subarray-sum-modulo-m-solution">5.
How can I optimize the space complexity of the Maximum Subarray Sum
Modulo M solution?</h3>
<p>To make the space use better in the Maximum Subarray Sum Modulo M
solution, we can use fewer extra arrays. We only need to keep some
important variables. Instead of using a big array for all results, we
can track current sums and maximum values with just a few variables.
This way, we save memory and still get a good solution.</p>
<p>For more details and examples about dynamic programming, we can look
at our articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Kadane’s
Algorithm for Maximum Subarray Sum</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Handling
Edge Cases in Dynamic Programming Problems</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            