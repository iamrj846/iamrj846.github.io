
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Climb Stairs - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover an easy method to count the ways to climb stairs using dynamic programming. Boost your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Climb Stairs - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong method we use to solve tough
problems. It helps us break down these problems into easier parts. For
the “Count Ways to Climb Stairs” problem, we want to find out how many
different ways we can reach the top of a staircase with a certain number
of steps. We can take either one or two steps at a time. By using
dynamic programming, we can find the number of ways to climb the stairs
quickly and avoid doing the same work over again.</p>
<p>In this article, we will look at different ways to solve the climbing
stairs problem with dynamic programming. We will give examples in Java,
Python, and C++. We will explain the problem in detail. We will also
check out a better way to use space and a recursive solution with
memoization for each programming language. Here is what we will
cover:</p>
<ul>
<li>[Dynamic Programming] Counting Ways to Climb Stairs with Dynamic
Programming</li>
<li>Understanding the Problem Statement for Climbing Stairs</li>
<li>Dynamic Programming Approach to Count Ways in Java</li>
<li>Dynamic Programming Approach to Count Ways in Python</li>
<li>Dynamic Programming Approach to Count Ways in C++</li>
<li>Optimizing Space Complexity in Climbing Stairs Problem</li>
<li>Recursive Solution with Memoization in Java</li>
<li>Recursive Solution with Memoization in Python</li>
<li>Recursive Solution with Memoization in C++</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming techniques, you
can check other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Min Cost Climbing Stairs</a>.</p>
<h2
id="understanding-the-problem-statement-for-climbing-stairs">Understanding
the Problem Statement for Climbing Stairs</h2>
<p>The Climbing Stairs problem is a well-known challenge in dynamic
programming. It helps us find how many different ways we can climb a
staircase with <code>n</code> steps. We can take either 1 step or 2
steps at a time. Our goal is to count how many different combinations of
these steps will get us to the top.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have an integer <code>n</code>. This number shows how many steps
are in the staircase. We need to find out how many distinct ways we can
reach the top.</p>
<h3 id="example">Example</h3>
<ul>
<li>If <code>n = 2</code>, we have 2 ways to climb the stairs: (1, 1) or
(2).</li>
<li>If <code>n = 3</code>, we have 3 ways to climb the stairs: (1, 1,
1), (1, 2), (2, 1).</li>
</ul>
<h3 id="recurrence-relation">Recurrence Relation</h3>
<p>We can define the number of ways to reach the <code>n</code>th step
using a recursive formula: -
<code>ways(n) = ways(n-1) + ways(n-2)</code> This means to get to the
nth step, we can: - Come from the (n-1)th step by taking a single step,
or - Come from the (n-2)th step by taking a double step.</p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>ways(0) = 1</code>: There is one way to stay on the ground (by
doing nothing).</li>
<li><code>ways(1) = 1</code>: There is one way to reach the first step
(by taking one step).</li>
</ul>
<p>We can solve this problem well using dynamic programming methods. We
will talk about this in the next sections. We will include Java, Python,
and C++ examples.</p>
<p>For more related information, visit <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="dynamic-programming-approach-to-count-ways-in-java">Dynamic
Programming Approach to Count Ways in Java</h2>
<p>To solve the “Count Ways to Climb Stairs” problem with dynamic
programming in Java, we use an array. This array will store how many
ways we can reach each step. The basic idea is that the number of ways
to reach the nth step is the total of the ways to reach the (n-1)th step
and the (n-2)th step.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ClimbStairs <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to stay at the ground</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to reach the first step</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; stairs: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Base Cases</strong>:
<ul>
<li>If <code>n</code> is 0 or 1, there is only 1 way to climb.</li>
</ul></li>
<li><strong>Dynamic Programming Array</strong>:
<ul>
<li>We create an array <code>dp</code> to store the number of ways to
reach each step from 0 to <code>n</code>.</li>
</ul></li>
<li><strong>Loop</strong>:
<ul>
<li>We start from the 2nd step to find the number of ways for each step.
We add the values from the two steps before it.</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>The result for the nth step is in <code>dp[n]</code>.</li>
</ul></li>
</ul>
<p>This method has a time complexity of O(n) and a space complexity of
O(n). To make it better, we can reduce the space complexity to O(1). We
just need two variables to keep the last two results instead of using an
array.</p>
<p>For more insight into dynamic programming techniques, refer to <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2 id="dynamic-programming-approach-to-count-ways-in-python">Dynamic
Programming Approach to Count Ways in Python</h2>
<p>In Python, we can count how many ways we can climb stairs using a
dynamic programming method. This method uses overlapping subproblems to
find the result quickly.</p>
<h3 id="dynamic-programming-implementation">Dynamic Programming
Implementation</h3>
<p>We can make a function that takes the number of stairs <code>n</code>
as input. It will return how many distinct ways we can reach the top. We
represent the states with the number of ways to reach each step. We
calculate this step by step.</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(n):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize an array for dynamic programming</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>  <span class="co"># Base cases</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp array</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]  <span class="co"># Ways to reach current step</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to climb </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> stairs: </span><span class="sc">{</span>countWays(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) - We find each step
once.</li>
<li><strong>Space Complexity</strong>: O(n) - We use an array of size
<code>n</code>.</li>
</ul>
<h3 id="optimizing-space-complexity">Optimizing Space Complexity</h3>
<p>To make space use better, we can remember only the last two steps.
The current step only needs the last two steps to calculate.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysOptimized(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    first, second <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> first <span class="op">+</span> second</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> second, current  <span class="co"># Update for the next step</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to climb </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> stairs (Optimized): </span><span class="sc">{</span>countWaysOptimized(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This optimized solution keeps O(1) space complexity. It still has
O(n) time complexity. If you want to read more about related dynamic
programming problems, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a> article.</p>
<h2 id="dynamic-programming-approach-to-count-ways-in-c">Dynamic
Programming Approach to Count Ways in C++</h2>
<p>In C++, we can use dynamic programming to count distinct ways to
climb stairs. We can do this in a simple way using an iterative method.
The problem says we can take either 1 or 2 steps at a time. We need to
find the total ways to reach the top of <code>n</code> stairs.</p>
<h3 id="code-implementation">Code Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to stay at the ground</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to climb to the first step</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span> <span class="co">// Sum of ways from the last two steps</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: number of stairs</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; stairs is: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create an array <code>dp</code>.
Here, <code>dp[i]</code> stores the number of ways to reach the
<code>i-th</code> step.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>We set <code>dp[0]</code> to 1 because there is one way to stay at
the ground (do nothing).</li>
<li>We also set <code>dp[1]</code> to 1 since there is only one way to
reach the first step.</li>
</ul></li>
<li><strong>Dynamic Programming Relation</strong>: For each step
<code>i</code>, the number of ways to reach that step is the sum of the
ways to reach the two previous steps:
<code>dp[i] = dp[i - 1] + dp[i - 2]</code>.</li>
<li><strong>Output</strong>: The function gives back the value of
<code>dp[n]</code>, which shows the number of distinct ways to climb
<code>n</code> stairs.</li>
</ul>
<h3 id="time-and-space-complexity-1">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n), where <code>n</code> is the
number of stairs.</li>
<li><strong>Space Complexity</strong>: O(n) for the <code>dp</code>
array.</li>
</ul>
<p>This C++ code is good for counting the ways to climb stairs. We can
make it even better by reducing space. For example, we can use just two
variables instead of the whole array. If we want to learn more about
dynamic programming, we can read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Min Cost Climbing Stairs</a> articles for more insights.</p>
<h2
id="optimizing-space-complexity-in-climbing-stairs-problem">Optimizing
Space Complexity in Climbing Stairs Problem</h2>
<p>In the Climbing Stairs problem, we can make space better. We only
need to remember the last two values we calculated. We do not need to
save all previous values. This change helps us lower space from O(n) to
O(1).</p>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ClimbingStairs <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">climbStairs</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ClimbingStairs:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> climb_stairs(<span class="va">self</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">2</span>:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> n</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> first <span class="op">+</span> second</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> second</span></code></pre></div>
<h3 id="implementation-in-c">Implementation in C++</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ClimbingStairs <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> climbStairs<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>With this space saving method, we keep the same time of O(n). But we
use much less space. This makes our solution work better for bigger
inputs. If you want to learn more about similar topics in dynamic
programming, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming: Min Cost Climbing Stairs</a>.</p>
<h2 id="recursive-solution-with-memoization-in-java">Recursive Solution
with Memoization in Java</h2>
<p>We can improve the recursive way to count how many ways to climb
stairs by using memoization. This helps us save results we have already
found. It makes the process faster, especially for bigger numbers.</p>
<h3 id="code-implementation-1">Code Implementation</h3>
<p>Here is a simple way to show the recursive solution with memoization
in Java:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ClimbStairs <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: 1 way to climb 0 or 1 stair</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span> <span class="co">// Return cached result</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recursive step: count ways for n-1 and n-2</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ways <span class="op">=</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> ways<span class="op">);</span> <span class="co">// Cache the result</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ways<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        ClimbStairs cs <span class="op">=</span> <span class="kw">new</span> <span class="fu">ClimbStairs</span><span class="op">();</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: Climbing 5 stairs</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; stairs: &quot;</span> <span class="op">+</span> cs<span class="op">.</span><span class="fu">countWays</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Base Case</strong>: If <code>n</code> is 0 or 1, there is
only one way to climb the stairs.</li>
<li><strong>Memoization</strong>: We use a <code>HashMap</code> to save
the results we got before.</li>
<li><strong>Recursion</strong>: The method <code>countWays(n)</code>
finds out how many ways to climb <code>n</code> stairs by adding the
ways to climb <code>n-1</code> and <code>n-2</code> stairs.</li>
<li><strong>Caching</strong>: Before doing the math, we check if we
already have the result for <code>n</code>. If we do, we just return
that result to save time.</li>
</ul>
<p>This way to write the code helps us deal with bigger numbers and
still keeps the logic clear and easy to follow. If you want to learn
more about dynamic programming methods, you can check out the article on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming: Fibonacci with Memoization</a>.</p>
<h2 id="recursive-solution-with-memoization-in-python">Recursive
Solution with Memoization in Python</h2>
<p>In the Climbing Stairs problem, we can use a recursive method with
memoization. This helps us count the ways to reach the top of the stairs
quickly. We break down the problem into smaller parts. Then we save
their results to avoid doing the same work again.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have <code>n</code> stairs. We can climb either 1 or 2 stairs at a
time. Our goal is to find out how many different ways we can reach the
top.</p>
<h3 id="recursive-formula">Recursive Formula</h3>
<p>Let <code>f(n)</code> be the number of ways to climb to the nth
stair. The formula is: - <code>f(n) = f(n-1) + f(n-2)</code>, and we
have base cases: - <code>f(0) = 1</code> (There is 1 way to stay on the
ground) - <code>f(1) = 1</code> (There is 1 way to reach the first
stair)</p>
<h3 id="implementation-in-python-1">Implementation in Python</h3>
<p>We can use a dictionary to keep the computed values
(memoization).</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> climbStairs(n):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(n):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[n]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> helper(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> helper(n <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> helper(n)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to climb </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> stairs: </span><span class="sc">{</span>climbStairs(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<ul>
<li><code>memo</code>: This is a dictionary that saves the number of
ways to climb to each stair level.</li>
<li><code>helper(n)</code>: This is the recursive function that finds
the number of ways to reach the nth stair.</li>
<li>We check base cases first to return known values.</li>
<li>We store the result for each stair in <code>memo</code> to make
future calls faster.</li>
</ul>
<p>This recursive method with memoization makes things much faster than
using a simple recursive method. It avoids recalculating, so it works
better for larger values of <code>n</code>.</p>
<p>For more learning on dynamic programming methods, check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">dynamic
programming climbing stairs article</a>.</p>
<h2 id="recursive-solution-with-memoization-in-c">Recursive Solution
with Memoization in C++</h2>
<p>We can use the recursive solution with memoization to solve the
“Count Ways to Climb Stairs” problem in C++. This method helps us break
the problem into simpler parts. We store the results of these parts so
we do not calculate them again.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have <code>n</code> stairs. We can climb either 1 or 2 stairs at
once. Our goal is to find the total number of different ways to reach
the top.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<p>We can define the recursive relation like this: - If
<code>n == 0</code>, there is 1 way to stay on the ground. - If
<code>n == 1</code>, there is 1 way to reach the first step. - If
<code>n == 2</code>, there are 2 ways to reach the second step (1+1 or
2).</p>
<p>For <code>n &gt; 2</code>, we have:</p>
<pre><code>ways(n) = ways(n-1) + ways(n-2)</code></pre>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is the C++ code that uses the recursive solution with
memoization:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> ClimbStairs <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> memo<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> countWaysUtil<span class="op">(</span>n<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countWaysUtil<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base cases</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check if already computed</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recursive case with memoization</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> countWaysUtil<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> countWaysUtil<span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    ClimbStairs cs<span class="op">;</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: 5 stairs</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; stairs: &quot;</span> <span class="op">&lt;&lt;</span> cs<span class="op">.</span>countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Memoization Array</strong>: We use a vector called
<code>memo</code>. It stores results of subproblems. It starts with
<code>-1</code> to show the value is not computed yet.</li>
<li><strong>Base Cases</strong>: We handle cases for <code>0</code> and
<code>1</code> stairs directly.</li>
<li><strong>Recursive Function</strong>: The function
<code>countWaysUtil</code> checks if we already computed the result for
<code>n</code>. If not, it calculates it using the recursive relation
and saves it in the <code>memo</code> array.</li>
</ul>
<p>This method makes the time taken much less than the simple recursive
method. So it works better for larger values of <code>n</code>.</p>
<p>For more insights into dynamic programming solutions, you can check
out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-climbing-stairs-problem-in-dynamic-programming">1.
What is the climbing stairs problem in dynamic programming?</h3>
<p>The climbing stairs problem is a well-known challenge in dynamic
programming. We need to find the number of different ways to reach the
top of a staircase that has <code>n</code> steps. You can go up either 1
step or 2 steps at a time. This problem is similar to the Fibonacci
sequence because of how it works. For more information on related
problems, look at our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci numbers</a>.</p>
<h3
id="how-can-i-implement-the-dynamic-programming-approach-in-python-for-climbing-stairs">2.
How can I implement the dynamic programming approach in Python for
climbing stairs?</h3>
<p>To solve the climbing stairs problem with dynamic programming in
Python, we need to make a list. This list will hold the number of ways
to reach each step. We start with the first two steps. Then we fill the
list using the rule: <code>ways[i] = ways[i-1] + ways[i-2]</code>. For a
full code example, check out our Python section in the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">dynamic
programming climbing stairs</a>.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-climbing-stairs">3.
What is the time complexity of the dynamic programming solution for
climbing stairs?</h3>
<p>The time complexity of the dynamic programming solution to count ways
to climb stairs is O(n). Here, <code>n</code> means the number of steps.
This is because we calculate the number of ways for each step just one
time and save the results. This makes our calculation fast. For more
complex versions of this problem, look at our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">min
cost climbing stairs</a>.</p>
<h3 id="can-i-use-recursion-to-solve-the-climbing-stairs-problem">4. Can
I use recursion to solve the climbing stairs problem?</h3>
<p>Yes, we can use a recursive method to solve the climbing stairs
problem. But this way can lead to slow performance. This happens because
of overlapping subproblems. To make it better, we can use memoization to
save results we already calculated. For an example of this method in
Java, go to our section on recursive solutions with memoization in the
climbing stairs article.</p>
<h3
id="how-can-i-optimize-space-complexity-when-solving-the-climbing-stairs-problem">5.
How can I optimize space complexity when solving the climbing stairs
problem?</h3>
<p>To make space complexity better in the climbing stairs problem, we do
not need to keep all the values for each step. We only need to remember
the last two computed values. This changes the space complexity from
O(n) to O(1). This makes our solution more efficient. For more ideas on
other dynamic programming problems and how to save space, check our
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">maximum
subarray using Kadane’s algorithm</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            