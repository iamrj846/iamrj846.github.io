
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Common Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Master dynamic programming with our guide on Longest Common Subsequence. Learn algorithms, tips, and examples for success!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Common Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Common Subsequence (LCS) is a well-known problem in
computer science. It is part of dynamic programming. The goal is to find
the longest subsequence that two sequences share. This subsequence does
not have to be next to each other. We can solve the Longest Common
Subsequence problem efficiently by using different dynamic programming
methods. These methods include recursive ways, memoization, and
tabulation.</p>
<p>In this article, we will explore the dynamic programming method to
solve the Longest Common Subsequence problem. We will look at the
recursive method, the memoization technique, the tabulation method, and
a solution that uses less space. We will also show how to implement the
LCS algorithm in Java, Python, and C++. We will check the time
complexity of this algorithm and answer some common questions about
it.</p>
<ul>
<li>Dynamic Programming Longest Common Subsequence Problem Overview</li>
<li>Dynamic Programming Longest Common Subsequence Recursive
Approach</li>
<li>Dynamic Programming Longest Common Subsequence Memoization
Technique</li>
<li>Dynamic Programming Longest Common Subsequence Tabulation
Method</li>
<li>Dynamic Programming Longest Common Subsequence Space Optimized
Solution</li>
<li>Dynamic Programming Longest Common Subsequence Java
Implementation</li>
<li>Dynamic Programming Longest Common Subsequence Python
Implementation</li>
<li>Dynamic Programming Longest Common Subsequence C++
Implementation</li>
<li>Dynamic Programming Longest Common Subsequence Time Complexity
Analysis</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, we can suggest
some related articles. You might find <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming Unique Paths in a Grid</a> helpful.</p>
<h2
id="dynamic-programming-longest-common-subsequence-recursive-approach">Dynamic
Programming Longest Common Subsequence Recursive Approach</h2>
<p>The Longest Common Subsequence (LCS) problem wants to find the
longest subsequence in two sequences. A subsequence is a sequence that
shows up in the same order but not always next to each other. We can
solve the LCS problem with a recursive approach based on these
ideas:</p>
<ol type="1">
<li>If the last characters of both sequences are the same, the LCS
length is 1 plus the LCS length of the rest of the sequences.</li>
<li>If the last characters are different, the LCS length is the bigger
value from ignoring the last character of one sequence or the
other.</li>
</ol>
<h3 id="recursive-function">Recursive Function</h3>
<p>Here is a simple way to write the recursive function for the LCS
problem:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcs_recursive(X, Y, m, n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> X[m <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> Y[n <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> lcs_recursive(X, Y, m <span class="op">-</span> <span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(lcs_recursive(X, Y, m, n <span class="op">-</span> <span class="dv">1</span>), lcs_recursive(X, Y, m <span class="op">-</span> <span class="dv">1</span>, n))</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="st">&quot;AGGTAB&quot;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="st">&quot;GXTXAYB&quot;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(Y)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of LCS is:&quot;</span>, lcs_recursive(X, Y, m, n))  <span class="co"># Output: Length of LCS is: 4</span></span></code></pre></div>
<h3 id="properties">Properties</h3>
<ul>
<li>The recursive solution has a time complexity of (O(2^{(m, n)})).
This makes it slow for larger sequences because the number of recursive
calls grows a lot.</li>
<li>It is easy to implement but can repeat calculations for the same
problems.</li>
</ul>
<p>This recursive method helps us understand how to approach LCS. Later,
we can make it better using memoization or dynamic programming
tabulation. For more information on dynamic programming methods, we can
read articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a>.</p>
<h2
id="dynamic-programming-longest-common-subsequence-memoization-technique">Dynamic
Programming Longest Common Subsequence Memoization Technique</h2>
<p>We use the memoization technique to make the recursive solution for
the Longest Common Subsequence (LCS) problem faster. This method stores
the results of expensive function calls. Then we can use these results
again when we see the same inputs.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have two sequences. Our job is to find the length of the longest
subsequence that is in both sequences. A subsequence is made by deleting
some elements from another sequence. We do not change the order of what
is left.</p>
<h3 id="recursive-approach-with-memoization">Recursive Approach with
Memoization</h3>
<ol type="1">
<li><strong>Recursive Function</strong>: We need to define a recursive
function. This function takes the indices of both sequences and compares
their characters.</li>
<li><strong>Memoization Table</strong>: We use a 2D array to save
results of LCS lengths for specific indices. This way, we avoid doing
the same calculations again.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is a Python code to solve the LCS problem using the memoization
technique:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lcs_memoization(X, Y):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(Y)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lcs_helper(i, j):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memo[i][j] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[i][j]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> X[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> Y[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            memo[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> lcs_helper(i <span class="op">-</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            memo[i][j] <span class="op">=</span> <span class="bu">max</span>(lcs_helper(i <span class="op">-</span> <span class="dv">1</span>, j), lcs_helper(i, j <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[i][j]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lcs_helper(m, n)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="st">&quot;AGGTAB&quot;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="st">&quot;GXTXAYB&quot;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of LCS is&quot;</span>, lcs_memoization(X, Y))</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The function <code>lcs_memoization</code> starts by making a
memoization table called <code>memo</code>. This table has size
<code>(m+1) x (n+1)</code> where <code>m</code> and <code>n</code> are
the lengths of the input strings <code>X</code> and <code>Y</code>.</li>
<li>The helper function <code>lcs_helper</code> does the recursive work.
It checks if we have already found the result for indices
<code>(i, j)</code>.</li>
<li>If the characters match, we add 1 to the result from the previous
indices. If they do not match, we take the maximum from two choices:
excluding the current character from either string.</li>
</ul>
<p>Using memoization helps us lower the time needed to solve the
problem. It goes from an exponential time to polynomial time,
specifically O(m * n). This makes it easier to handle bigger inputs.</p>
<p>For more about dynamic programming, we can read the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming Longest Increasing Subsequence</a> article.</p>
<h2
id="dynamic-programming-longest-common-subsequence-tabulation-method">Dynamic
Programming Longest Common Subsequence Tabulation Method</h2>
<p>We can solve the Longest Common Subsequence (LCS) problem using the
tabulation method. This method is an iterative way. It uses a 2D array
to keep the lengths of the longest common subsequences for parts of the
two sequences. We build the solution from the bottom up. We fill the
table based on values we calculated before.</p>
<h3 id="algorithm">Algorithm</h3>
<ol type="1">
<li>First, we create a 2D array <code>dp</code> of size
<code>(m+1) x (n+1)</code>. Here, <code>m</code> and <code>n</code> are
the lengths of the two strings.</li>
<li>We set the first row and column of <code>dp</code> to zero. The LCS
of any string with an empty string is 0.</li>
<li>Next, we go through each character of both strings. If the
characters are the same, we set
<code>dp[i][j] = dp[i-1][j-1] + 1</code>. If not, we set
<code>dp[i][j] = max(dp[i-1][j], dp[i][j-1])</code>.</li>
<li>Finally, the value in <code>dp[m][n]</code> gives us the length of
the longest common subsequence.</li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is how we can write the tabulation method for LCS in Python:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_common_subsequence(str1, str2):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(str1), <span class="bu">len</span>(str2)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> str1[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> str2[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>str1 <span class="op">=</span> <span class="st">&quot;AGGTAB&quot;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>str2 <span class="op">=</span> <span class="st">&quot;GXTXAYB&quot;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Common Subsequence is&quot;</span>, longest_common_subsequence(str1, str2))</span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). Here, m and n are the
lengths of the two strings.</li>
<li><strong>Space Complexity</strong>: O(m * n) for the <code>dp</code>
table.</li>
</ul>
<p>The tabulation method works well to find the LCS. It uses results we
got earlier. This makes it a good choice for dynamic programming
problems. For more about dynamic programming, we can read about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming Longest Increasing Subsequence</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a>.</p>
<h2
id="dynamic-programming-longest-common-subsequence-space-optimized-solution">Dynamic
Programming Longest Common Subsequence Space Optimized Solution</h2>
<p>We can solve the Longest Common Subsequence (LCS) problem using a
smart approach that saves space. Instead of using a full 2D array for
dynamic programming, we can lower the space needed to O(min(m, n)).
Here, m and n are the lengths of the two sequences.</p>
<p>In this method, we use two 1D arrays. These arrays will hold the
current and previous rows of the DP table. We will go through the
characters of both strings and update the arrays as needed.</p>
<p>Here is a simple code for the space-optimized solution in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_common_subsequence(X, Y):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    m <span class="op">=</span> <span class="bu">len</span>(X)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(Y)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create two arrays for storing results of current and previous row</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    previous <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> X[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> Y[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                current[j] <span class="op">=</span> previous[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                current[j] <span class="op">=</span> <span class="bu">max</span>(previous[j], current[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update previous to current for the next iteration</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        previous, current <span class="op">=</span> current, previous</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> previous[n]</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> <span class="st">&quot;AGGTAB&quot;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>Y <span class="op">=</span> <span class="st">&quot;GXTXAYB&quot;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of LCS is&quot;</span>, longest_common_subsequence(X, Y))</span></code></pre></div>
<h3 id="key-points">Key Points:</h3>
<ul>
<li><strong>Space Complexity</strong>: We reduce it to O(min(m,
n)).</li>
<li><strong>Time Complexity</strong>: It stays O(m * n).</li>
<li><strong>Array Usage</strong>: We use two 1D arrays to keep results
of the last and current steps.</li>
</ul>
<p>This space-optimized way works well to find the length of the longest
common subsequence. It also uses less memory, so it is good for bigger
inputs. If we want to learn more about dynamic programming, we can check
out topics like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-longest-common-subsequence-java-implementation">Dynamic
Programming Longest Common Subsequence Java Implementation</h2>
<p>The Longest Common Subsequence (LCS) problem is a well-known problem
in dynamic programming. In this section, we will show how to implement
the LCS algorithm using Java. We will look at the recursive approach and
the memoization technique.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<p>The recursive approach checks if the last characters of both
sequences are the same. If they are, we add that character to the LCS
and check the rest of the characters. If they are not the same, we find
the LCS by ignoring one character from either sequence.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LCS <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lcsRecursive</span><span class="op">(</span><span class="bu">String</span> X<span class="op">,</span> <span class="bu">String</span> Y<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> Y<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">lcsRecursive</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">lcsRecursive</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> <span class="fu">lcsRecursive</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">));</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="memoization-technique">Memoization Technique</h3>
<p>To make the recursive approach better, we can use memoization. This
means we store the results of smaller problems. This helps us avoid
doing the same calculations again and makes it much faster.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LCS <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lcsMemoization</span><span class="op">(</span><span class="bu">String</span> X<span class="op">,</span> <span class="bu">String</span> Y<span class="op">,</span> <span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">[][]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>m<span class="op">][</span>n<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> Y<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            memo<span class="op">[</span>m<span class="op">][</span>n<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">lcsMemoization</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            memo<span class="op">[</span>m<span class="op">][</span>n<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">lcsMemoization</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">),</span> <span class="fu">lcsMemoization</span><span class="op">(</span>X<span class="op">,</span> Y<span class="op">,</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="tabulation-method">Tabulation Method</h3>
<p>The tabulation method creates a 2D array to store the lengths of LCS
for different parts of the sequences. We do this step by step.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LCS <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lcsTabulation</span><span class="op">(</span><span class="bu">String</span> X<span class="op">,</span> <span class="bu">String</span> Y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> X<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> Y<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> Y<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="space-optimized-solution">Space Optimized Solution</h3>
<p>To save space, we can use just one array. This array will hold the
current and previous row of the DP table.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LCS <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lcsSpaceOptimized</span><span class="op">(</span><span class="bu">String</span> X<span class="op">,</span> <span class="bu">String</span> Y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> X<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> Y<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> prev <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> curr <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> Y<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                    curr<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> prev<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                    curr<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>prev<span class="op">[</span>j<span class="op">],</span> curr<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span><span class="op">[]</span> temp <span class="op">=</span> prev<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> curr<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The methods we showed give good ways to solve the Longest Common
Subsequence problem in Java using dynamic programming. For more reading
on similar topics, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming Longest Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-longest-common-subsequence-python-implementation">Dynamic
Programming Longest Common Subsequence Python Implementation</h2>
<p>We can solve the Longest Common Subsequence (LCS) problem using
dynamic programming in Python. The goal is to find the longest sequence
that shows up in the same order in both strings. They do not need to be
next to each other.</p>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<p>Here is a simple Python code that shows how to use dynamic
programming to solve the LCS problem. It uses a 2D table to save
results.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_common_subsequence(s1: <span class="bu">str</span>, s2: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s1), <span class="bu">len</span>(s2)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s1[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s2[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="st">&quot;AGGTAB&quot;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="st">&quot;GXTXAYB&quot;</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>length <span class="op">=</span> longest_common_subsequence(s1, s2)</span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;The length of the Longest Common Subsequence is: </span><span class="sc">{</span>length<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a 2D list called
<code>dp</code>. It has size <code>(m + 1) x (n + 1)</code> and starts
with zeros.</li>
<li><strong>Filling the DP Table</strong>: We look at both strings and
fill the table like this:
<ul>
<li>If the characters match (<code>s1[i-1] == s2[j-1]</code>), we take
the value from the diagonal cell and add one.</li>
<li>If they do not match, we take the bigger value from the cell on the
left or the cell above.</li>
</ul></li>
<li><strong>Final Result</strong>: The bottom-right cell of the table
gives us the length of the LCS.</li>
</ul>
<p>This code runs with a time cost of (O(m n)) and space cost of (O(m
n)). If we want to make it better, we can keep only two rows.</p>
<p>For more details about dynamic programming methods, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-longest-common-subsequence-c-implementation">Dynamic
Programming Longest Common Subsequence C++ Implementation</h2>
<p>We can solve the Longest Common Subsequence (LCS) problem using
dynamic programming. Here is a simple C++ code for the LCS algorithm
with a tabulation method.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestCommonSubsequence<span class="op">(</span>string text1<span class="op">,</span> string text2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> text1<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> text2<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>text1<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> text2<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    string text1 <span class="op">=</span> <span class="st">&quot;abcde&quot;</span><span class="op">;</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    string text2 <span class="op">=</span> <span class="st">&quot;ace&quot;</span><span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> lcs_length <span class="op">=</span> longestCommonSubsequence<span class="op">(</span>text1<span class="op">,</span> text2<span class="op">);</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Common Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> lcs_length <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<p>We have a function called <code>longestCommonSubsequence</code> that
takes two strings. It makes a 2D vector called <code>dp</code>. This
vector saves the lengths of LCS at different points.</p>
<p>We use a nested loop to go through each character of both strings. If
the characters match, we add one to the length of LCS we found so far.
If they do not match, we take the bigger value from the nearby
cells.</p>
<p>At the end, we find the length of LCS in <code>dp[m][n]</code>, and
we return this value.</p>
<p>This code runs in O(m*n) time. Here m and n are the lengths of the
two strings. It works well for moderate input sizes. To learn more about
dynamic programming, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming Longest Increasing Subsequence</a> article.</p>
<h2
id="dynamic-programming-longest-common-subsequence-time-complexity-analysis">Dynamic
Programming Longest Common Subsequence Time Complexity Analysis</h2>
<p>The time complexity of the Longest Common Subsequence (LCS) problem
changes based on the method we use. Here is a simple overview of the
different methods and their complexities:</p>
<h3 id="recursive-approach-1">Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(2^{(m, n)}))</li>
<li>The recursive method looks at all possible pairs of characters. This
leads to a huge number of calls.</li>
</ul>
<h3 id="memoization-technique-1">Memoization Technique</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(m n))</li>
<li>This method improves the recursive approach. We save results in a 2D
array. Here, (m) is the length of the first sequence and (n) is the
length of the second sequence. We calculate each state only once.</li>
</ul>
<h3 id="tabulation-method-1">Tabulation Method</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(m n))</li>
<li>The tabulation method is like memoization. It builds a table step by
step. The space complexity is also (O(m n)) because of the table
storage.</li>
</ul>
<h3 id="space-optimized-solution-1">Space Optimized Solution</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(m n))</li>
<li>In this method, we use only two arrays to keep current and previous
results. This cuts down the space to (O((m, n))). But the time
complexity stays the same. We still look at all pairs of
subsequences.</li>
</ul>
<h3 id="summary-of-time-complexity">Summary of Time Complexity</h3>
<ul>
<li>Recursive: (O(2^{(m, n)}))</li>
<li>Memoization: (O(m n))</li>
<li>Tabulation: (O(m n))</li>
<li>Space Optimized: (O(m n)) time, (O((m, n))) space</li>
</ul>
<p>We can solve the Longest Common Subsequence problem well using
dynamic programming methods. These methods greatly lower the time
complexity compared to simple recursive methods. If we want to learn
more about dynamic programming, we can check out related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-longest-common-subsequence-lcs-problem-in-dynamic-programming">1.
What is the Longest Common Subsequence (LCS) problem in dynamic
programming?</h3>
<p>The Longest Common Subsequence (LCS) problem is a well-known problem
in dynamic programming. It is about finding the longest subsequence that
is in two sequences. The subsequence keeps the order of characters but
does not have to be next to each other. We can use this problem in many
ways like comparing files and analyzing DNA sequences. Knowing the LCS
problem is important for learning dynamic programming methods.</p>
<h3
id="how-does-the-recursive-approach-work-for-solving-the-lcs-problem">2.
How does the recursive approach work for solving the LCS problem?</h3>
<p>The recursive approach for the Longest Common Subsequence (LCS)
problem means we make a function that checks characters from both
sequences. If the characters are the same, we add to the count and call
the function again with the next characters from both sequences. If they
are not the same, we call the function again but skip a character from
one of the sequences. This way is easy to understand but can be slow
because of repeating problems. This makes the time complexity grow
fast.</p>
<h3 id="what-is-memoization-in-the-context-of-lcs">3. What is
memoization in the context of LCS?</h3>
<p>Memoization is a way to make the recursive solution of the Longest
Common Subsequence (LCS) problem faster. We save the results of costly
function calls and give back the saved result when we see the same
inputs again. This really cuts down the number of times we call the
function again and changes the time complexity from exponential to
polynomial. This makes the algorithm much quicker.</p>
<h3 id="how-does-the-tabulation-method-improve-the-lcs-solution">4. How
does the tabulation method improve the LCS solution?</h3>
<p>The tabulation method is a bottom-up way to use dynamic programming.
It helps to solve the Longest Common Subsequence (LCS) problem by using
a table with two dimensions. This table keeps the lengths of LCS for
different subsequences. We fill the table step by step by using values
we got before. This way, we solve each small problem only one time.
Because of this, it gives us a clear and organized way to find the LCS
with a time complexity of O(m * n), where m and n are the lengths of the
input sequences.</p>
<h3
id="what-are-some-applications-of-the-longest-common-subsequence-algorithm">5.
What are some applications of the Longest Common Subsequence
algorithm?</h3>
<p>The Longest Common Subsequence (LCS) algorithm has many uses in
computer science and bioinformatics. We often use it in tools that
compare files to see what changed in text files. It is also used in
version control systems and in analyzing DNA sequences to find
similarities in genetic sequences. Also, LCS can help in machine
learning for choosing features and in natural language processing tasks.
This makes it a useful tool in many areas.</p>
<p>For more about dynamic programming ideas, we can look at other
articles on problems like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">minimum
path sum</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">longest
increasing subsequence</a>. Each of these topics helps us understand
dynamic programming methods and how to use them.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            