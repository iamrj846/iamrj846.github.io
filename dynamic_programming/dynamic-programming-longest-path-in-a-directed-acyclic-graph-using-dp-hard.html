
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Path in a Directed Acyclic Graph using DP - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Longest Path problem in Directed Acyclic Graphs using dynamic programming techniques. Dive in now!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Path in a Directed Acyclic Graph using DP - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p><strong>The Longest Path in a Directed Acyclic Graph
(DAG)</strong></p>
<p>The Longest Path in a Directed Acyclic Graph is a well-known problem
in dynamic programming. It focuses on finding the longest simple path
between two points in a graph. This graph has directed edges and no
cycles. We can solve this problem well using dynamic programming and
topological sorting. Topological sorting helps us to process the points
in a straight order that follows the directed edges. We keep track of
the longest path lengths to each point. This way, we can find the
longest path from the starting point to any other point in the DAG.</p>
<p>In this article, we will look closely at how to solve the Longest
Path in a Directed Acyclic Graph using dynamic programming. We will
learn about the basic ideas of DAGs, the dynamic programming method, and
why topological sorting is important. We will show examples in Java,
Python, and C++. After that, we will compare these examples. We will
also talk about ways to reduce space usage. To help you understand
better, we will answer some common questions about this problem.</p>
<ul>
<li>Dynamic Programming Longest Path in Directed Acyclic Graphs Using DP
- Hard</li>
<li>Understanding Directed Acyclic Graphs for Longest Path Problem</li>
<li>Dynamic Programming Approach for Longest Path in DAG</li>
<li>Topological Sorting for Longest Path in Directed Acyclic Graph</li>
<li>Java Implementation of Longest Path in DAG Using Dynamic
Programming</li>
<li>Python Solution for Longest Path in Directed Acyclic Graph</li>
<li>C++ Code for Finding Longest Path in DAG Using DP</li>
<li>Comparative Analysis of Java Python and C++ Implementations</li>
<li>Optimizing Space Complexity in Longest Path Problem</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-directed-acyclic-graphs-for-longest-path-problem">Understanding
Directed Acyclic Graphs for Longest Path Problem</h2>
<p>A Directed Acyclic Graph, or DAG, is a type of graph. It has directed
edges and does not have any cycles. This means we cannot start at one
vertex and come back to it by following the directed edges. This feature
makes DAGs very useful. We can model situations where we need a clear
order. Some examples are task scheduling, data processing, and solving
dependencies.</p>
<h3 id="properties-of-directed-acyclic-graphs">Properties of Directed
Acyclic Graphs:</h3>
<ul>
<li><strong>Directed Edges</strong>: Each edge points from one vertex to
another.</li>
<li><strong>Acyclic Nature</strong>: There are no cycles. So, we can’t
go back to the starting vertex.</li>
<li><strong>Topological Ordering</strong>: We can arrange DAGs in a way.
For every directed edge (u v), vertex (u) appears before vertex
(v).</li>
<li><strong>Applications</strong>: We often use them in project
scheduling like PERT and CPM, in version control systems, and to show
dependencies in different systems.</li>
</ul>
<h3 id="longest-path-problem-in-dags">Longest Path Problem in DAGs:</h3>
<p>The longest path problem in a DAG is about finding the longest path
between any two vertices. For DAGs, we can solve this problem better
than in regular graphs. We can use dynamic programming and topological
sorting.</p>
<h3 id="why-dynamic-programming">Why Dynamic Programming?</h3>
<p>Dynamic programming works well for this problem. It has overlapping
subproblems and optimal substructure properties. By breaking the problem
into smaller parts and saving their solutions, we do not need to
calculate them again. This helps us improve the performance.</p>
<h3 id="example">Example:</h3>
<p>Let’s look at a simple DAG:</p>
<pre><code>   0 → 1 → 3
   ↓   ↓
   2 → 4 </code></pre>
<p>The longest path starting from vertex 0 goes from 0 to 1 to 3. This
path has a length of 2. We can find this path quickly by using dynamic
programming after we sort the vertices in topological order.</p>
<p>Understanding DAGs and their properties is important. This knowledge
helps us use algorithms that solve the longest path problem well. It is
a basic idea in graph theory and computer science.</p>
<h2 id="dynamic-programming-approach-for-longest-path-in-dag">Dynamic
Programming Approach for Longest Path in DAG</h2>
<p>We can solve the Longest Path problem in a Directed Acyclic Graph
(DAG) in an easy way. We will use dynamic programming with topological
sorting. First, we will do a topological sort of the graph. After that,
we will use dynamic programming to find the longest path.</p>
<h3 id="steps-to-implement-the-dynamic-programming-approach">Steps to
Implement the Dynamic Programming Approach</h3>
<ol type="1">
<li><p><strong>Topological Sort</strong>: First, we do a topological
sort on the directed acyclic graph. This helps us to look at each vertex
in a straight order.</p></li>
<li><p><strong>Initialization</strong>: We initialize a distance array.
Each element starts as negative infinity. But we set the starting node
to zero.</p></li>
<li><p><strong>Relaxation</strong>: We go through each vertex in
topological order. For each vertex, we update the distances of the
vertices next to it.</p></li>
</ol>
<h3 id="dynamic-programming-algorithm">Dynamic Programming
Algorithm</h3>
<ol type="1">
<li><p><strong>Topological Sort Function</strong>:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(graph):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    indegree <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(graph)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph)):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            indegree[v] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque([i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(graph)) <span class="cf">if</span> indegree[i] <span class="op">==</span> <span class="dv">0</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    topo_order <span class="op">=</span> []</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> queue.popleft()</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        topo_order.append(u)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            indegree[v] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> indegree[v] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                queue.append(v)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> topo_order</span></code></pre></div></li>
<li><p><strong>Longest Path Function</strong>:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_path_dag(graph, start):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    topo_order <span class="op">=</span> topological_sort(graph)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    distances <span class="op">=</span> [<span class="op">-</span><span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)] <span class="op">*</span> <span class="bu">len</span>(graph)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    distances[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> topo_order:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> distances[u] <span class="op">!=</span> <span class="op">-</span><span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                distances[v] <span class="op">=</span> <span class="bu">max</span>(distances[v], distances[u] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> distances</span></code></pre></div></li>
</ol>
<h3 id="example-usage">Example Usage</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Graph represented as an adjacency list</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> [</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">2</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>],</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>],</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    [],</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">3</span>]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>start_node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>longest_distances <span class="op">=</span> longest_path_dag(graph, start_node)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Longest distances from start node:&quot;</span>, longest_distances)</span></code></pre></div>
<p>This code finds the longest path lengths from a start node to all
other nodes in the directed acyclic graph. The result goes into the
<code>distances</code> array. Each index shows the longest distance from
the start node to that index node.</p>
<p>We see that this dynamic programming method is good and works best
for DAGs. It uses topological sorting to make sure nodes are looked at
in the right order.</p>
<h2
id="topological-sorting-for-longest-path-in-directed-acyclic-graph">Topological
Sorting for Longest Path in Directed Acyclic Graph</h2>
<p>Topological sorting is important for working with directed acyclic
graphs (DAGs). It helps us find the longest path. The main idea of
topological sorting is to arrange the vertices. For every directed edge
( u v ), vertex ( u ) comes before ( v ). This allows us to use dynamic
programming (DP) to find the longest path in a DAG in a smart way.</p>
<h3 id="steps-for-topological-sorting">Steps for Topological
Sorting</h3>
<ol type="1">
<li><strong>Calculate In-Degree</strong>: For each vertex, we count how
many edges point to it (in-degree).</li>
<li><strong>Initialize Queue</strong>: We create a queue to keep all
vertices with in-degree zero.</li>
<li><strong>Process Vertices</strong>:
<ul>
<li>While the queue is not empty:
<ul>
<li>We take a vertex from the queue and add it to the topological
order.</li>
<li>For each edge going out from this vertex, we reduce the in-degree of
the target vertex by one.</li>
<li>If the in-degree of a target vertex becomes zero, we add it to the
queue.</li>
</ul></li>
</ul></li>
</ol>
<h3 id="topological-sort-implementation">Topological Sort
Implementation</h3>
<p>Here is a simple way to implement topological sorting using Kahn’s
algorithm in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict, deque</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(vertices, edges):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    in_degree <span class="op">=</span> {v: <span class="dv">0</span> <span class="cf">for</span> v <span class="kw">in</span> vertices}</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build the graph and compute in-degrees</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        graph[u].append(v)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        in_degree[v] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize queue with nodes of in-degree zero</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque([v <span class="cf">for</span> v <span class="kw">in</span> vertices <span class="cf">if</span> in_degree[v] <span class="op">==</span> <span class="dv">0</span>])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    topo_order <span class="op">=</span> []</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> queue.popleft()</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        topo_order.append(current)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> graph[current]:</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            in_degree[neighbor] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> in_degree[neighbor] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                queue.append(neighbor)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> topo_order <span class="cf">if</span> <span class="bu">len</span>(topo_order) <span class="op">==</span> <span class="bu">len</span>(vertices) <span class="cf">else</span> []</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>vertices <span class="op">=</span> [<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>, <span class="st">&#39;E&#39;</span>]</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>), (<span class="st">&#39;E&#39;</span>, <span class="st">&#39;D&#39;</span>)]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(topological_sort(vertices, edges))</span></code></pre></div>
<h3 id="application-to-longest-path-problem">Application to Longest Path
Problem</h3>
<p>After we find the topological order, we can use it to find the
longest path:</p>
<ol type="1">
<li>We start with a distance array. We set it to negative infinity for
all vertices, except the starting vertex which is set to zero.</li>
<li>We go through the vertices in topological order:
<ul>
<li>For each vertex, we update the distance for its neighbors based on
the current distances.</li>
</ul></li>
</ol>
<h3 id="longest-path-implementation-example">Longest Path Implementation
Example</h3>
<p>Here is a Python example that finds the longest path in a DAG using
the topological sort:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_path_dag(vertices, edges, start):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    topo_order <span class="op">=</span> topological_sort(vertices, edges)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    distance <span class="op">=</span> {v: <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">for</span> v <span class="kw">in</span> vertices}</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    distance[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u <span class="kw">in</span> topo_order:</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> distance[u] <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> graph[u]:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                distance[v] <span class="op">=</span> <span class="bu">max</span>(distance[v], distance[u] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(distance.values())</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>vertices <span class="op">=</span> [<span class="st">&#39;A&#39;</span>, <span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>, <span class="st">&#39;E&#39;</span>]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="st">&#39;A&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;B&#39;</span>, <span class="st">&#39;C&#39;</span>), (<span class="st">&#39;C&#39;</span>, <span class="st">&#39;D&#39;</span>), (<span class="st">&#39;E&#39;</span>, <span class="st">&#39;D&#39;</span>)]</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>start_vertex <span class="op">=</span> <span class="st">&#39;A&#39;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_path_dag(vertices, edges, start_vertex))</span></code></pre></div>
<p>This example shows how we can calculate the longest path length from
the starting vertex in a directed acyclic graph using topological
sorting. If you want to learn more about dynamic programming, you can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2
id="java-implementation-of-longest-path-in-dag-using-dynamic-programming">Java
Implementation of Longest Path in DAG Using Dynamic Programming</h2>
<p>To find the longest path in a Directed Acyclic Graph (DAG) using
Dynamic Programming in Java, we start with topological sorting. After we
get the topological order, we can find the longest path with a distance
array.</p>
<p>Here is a simple Java code for this:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.*;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestPathDAG <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="kw">class</span> Graph <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">final</span> <span class="dt">int</span> V<span class="op">;</span> <span class="co">// Number of vertices</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">private</span> <span class="dt">final</span> <span class="bu">List</span><span class="op">&lt;</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span> <span class="co">// Adjacency list</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Graph</span><span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            V <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            adj <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;(</span>v<span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                adj<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;());</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">addEdge</span><span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>u<span class="op">).</span><span class="fu">add</span><span class="op">(</span>v<span class="op">);</span> <span class="co">// Add edge u -&gt; v</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">topologicalSortUtil</span><span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> <span class="dt">boolean</span><span class="op">[]</span> visited<span class="op">,</span> <span class="bu">Stack</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> stack<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> neighbor <span class="op">:</span> adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>v<span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>neighbor<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">topologicalSortUtil</span><span class="op">(</span>neighbor<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span><span class="fu">push</span><span class="op">(</span>v<span class="op">);</span> <span class="co">// Push current vertex to stack</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">longestPath</span><span class="op">(</span><span class="dt">int</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Stack</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> stack <span class="op">=</span> <span class="kw">new</span> <span class="bu">Stack</span><span class="op">&lt;&gt;();</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>            <span class="dt">boolean</span><span class="op">[]</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>V<span class="op">];</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Do topological sort</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">topologicalSortUtil</span><span class="op">(</span>i<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span><span class="op">[]</span> dist <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>V<span class="op">];</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dist<span class="op">,</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>            dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Distance to the source is 0</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Process vertices in topological order</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(!</span>stack<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> u <span class="op">=</span> stack<span class="op">.</span><span class="fu">pop</span><span class="op">();</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>u<span class="op">]</span> <span class="op">!=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> neighbor <span class="op">:</span> adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>u<span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>neighbor<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-52"><a href="#cb7-52" aria-hidden="true" tabindex="-1"></a>                            dist<span class="op">[</span>neighbor<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Update distance</span></span>
<span id="cb7-53"><a href="#cb7-53" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb7-54"><a href="#cb7-54" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb7-55"><a href="#cb7-55" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-56"><a href="#cb7-56" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-57"><a href="#cb7-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-58"><a href="#cb7-58" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Print the longest path lengths</span></span>
<span id="cb7-59"><a href="#cb7-59" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-60"><a href="#cb7-60" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-61"><a href="#cb7-61" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Vertex &quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot; is not reachable from source &quot;</span> <span class="op">+</span> s<span class="op">);</span></span>
<span id="cb7-62"><a href="#cb7-62" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-63"><a href="#cb7-63" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Longest path from source &quot;</span> <span class="op">+</span> s <span class="op">+</span> <span class="st">&quot; to vertex &quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot; is &quot;</span> <span class="op">+</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb7-64"><a href="#cb7-64" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-65"><a href="#cb7-65" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-66"><a href="#cb7-66" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-67"><a href="#cb7-67" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-68"><a href="#cb7-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-69"><a href="#cb7-69" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-70"><a href="#cb7-70" aria-hidden="true" tabindex="-1"></a>        Graph g <span class="op">=</span> <span class="kw">new</span> <span class="fu">Graph</span><span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb7-71"><a href="#cb7-71" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-72"><a href="#cb7-72" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb7-73"><a href="#cb7-73" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb7-74"><a href="#cb7-74" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb7-75"><a href="#cb7-75" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb7-76"><a href="#cb7-76" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb7-77"><a href="#cb7-77" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">addEdge</span><span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb7-78"><a href="#cb7-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-79"><a href="#cb7-79" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> source <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-80"><a href="#cb7-80" aria-hidden="true" tabindex="-1"></a>        g<span class="op">.</span><span class="fu">longestPath</span><span class="op">(</span>source<span class="op">);</span> <span class="co">// Find longest path from vertex 0</span></span>
<span id="cb7-81"><a href="#cb7-81" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-82"><a href="#cb7-82" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Graph Class</strong>: This is the DAG with an adjacency
list.</li>
<li><strong>addEdge Method</strong>: It adds directed edges between
nodes.</li>
<li><strong>topologicalSortUtil Method</strong>: This is a helper method
to do a topological sort using DFS.</li>
<li><strong>longestPath Method</strong>: This uses dynamic programming
to find the longest path with distances updated based on the topological
order.</li>
</ul>
<h3 id="key-points">Key Points:</h3>
<ul>
<li>The time complexity is O(V + E). Here V is the number of vertices
and E is the number of edges.</li>
<li>Space complexity is O(V) to store the adjacency list and the
distance array.</li>
<li>This method makes sure we look at all possible paths in the directed
acyclic graph quickly.</li>
</ul>
<p>For more about dynamic programming, we can look at other <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming</a> problems and solutions.</p>
<h2
id="python-solution-for-longest-path-in-directed-acyclic-graph">Python
Solution for Longest Path in Directed Acyclic Graph</h2>
<p>We can find the longest path in a Directed Acyclic Graph (DAG) with
Python. We will use dynamic programming and topological sorting. The
steps are:</p>
<ol type="1">
<li><p><strong>Topological Sorting</strong>: First, we sort the graph in
a way that we process each node after its predecessors. This way, we
handle nodes in the correct order.</p></li>
<li><p><strong>Dynamic Programming Array</strong>: We create a dynamic
programming array. We will call it <code>dist</code>. Here,
<code>dist[i]</code> keeps the longest path from the start node to node
<code>i</code>.</p></li>
<li><p><strong>Relaxation</strong>: For every node in the topological
order, we will update the <code>dist</code> values for its
neighbors.</p></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is a complete code in Python:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict, deque</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_path_dag(vertices, edges):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Create adjacency list and in-degree array</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    adj <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    in_degree <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> vertices</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> u, v <span class="kw">in</span> edges:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        adj[u].append(v)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        in_degree[v] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Topological Sorting using Kahn&#39;s Algorithm</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    topo_order <span class="op">=</span> []</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque([i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(vertices) <span class="cf">if</span> in_degree[i] <span class="op">==</span> <span class="dv">0</span>])</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> queue.popleft()</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        topo_order.append(node)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> adj[node]:</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            in_degree[neighbor] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> in_degree[neighbor] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                queue.append(neighbor)</span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Initialize distances and compute longest path</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    dist <span class="op">=</span> [<span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)] <span class="op">*</span> vertices</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    dist[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># We start from node 0</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> topo_order:</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dist[node] <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>):  <span class="co"># We check reachable nodes</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> neighbor <span class="kw">in</span> adj[node]:</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dist[neighbor] <span class="op">&lt;</span> dist[node] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>                    dist[neighbor] <span class="op">=</span> dist[node] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The longest path length is the max value in dist</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>    longest_path_length <span class="op">=</span> <span class="bu">max</span>(dist)</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> longest_path_length <span class="cf">if</span> longest_path_length <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>vertices <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="dv">2</span>), (<span class="dv">1</span>, <span class="dv">3</span>), (<span class="dv">1</span>, <span class="dv">4</span>), (<span class="dv">2</span>, <span class="dv">4</span>), (<span class="dv">4</span>, <span class="dv">5</span>)]</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Longest Path Length in DAG:&quot;</span>, longest_path_dag(vertices, edges))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Graph Representation</strong>: We use an adjacency list to
represent the graph.</li>
<li><strong>Topological Sort</strong>: We apply Kahn’s algorithm to find
the topological order.</li>
<li><strong>Distance Calculation</strong>: We calculate the longest path
by relaxing the edges in topological order. We start from the source
node, which is <code>0</code> in this case. We keep track of the maximum
distance we find as we go through the graph.</li>
</ul>
<p>This method helps us find the longest path in a Directed Acyclic
Graph. We use dynamic programming to make it efficient. If you want to
learn more about dynamic programming, you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="c-code-for-finding-longest-path-in-dag-using-dp">C++ Code for
Finding Longest Path in DAG Using DP</h2>
<p>To find the longest path in a Directed Acyclic Graph (DAG) using
Dynamic Programming (DP), we can use topological sorting. First, we sort
the graph. Then we process each vertex in that order. This helps us
calculate the longest path to each vertex.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li>Do a topological sort of the graph.</li>
<li>Create an array <code>dist</code> to keep the longest distances. Set
all values to negative infinity except the starting node, which should
be zero.</li>
<li>Go through the vertices in topological order. For each vertex,
update the distances of its adjacent vertices.</li>
</ol>
<h3 id="c-implementation">C++ Implementation:</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Graph <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V<span class="op">;</span> <span class="co">// Number of vertices</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span> <span class="co">// Adjacency list</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    Graph<span class="op">(</span><span class="dt">int</span> V<span class="op">);</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addEdge<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> longestPath<span class="op">(</span><span class="dt">int</span> start<span class="op">);</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> topologicalSortUtil<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&amp;</span> visited<span class="op">,</span> stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> Stack<span class="op">);</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> topologicalSort<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> order<span class="op">);</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>Graph<span class="op">::</span>Graph<span class="op">(</span><span class="dt">int</span> V<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">this</span><span class="op">-&gt;</span>V <span class="op">=</span> V<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    adj<span class="op">.</span>resize<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Graph<span class="op">::</span>addEdge<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    adj<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Graph<span class="op">::</span>topologicalSortUtil<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&amp;</span> visited<span class="op">,</span> stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> Stack<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">:</span> adj<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>            topologicalSortUtil<span class="op">(</span>i<span class="op">,</span> visited<span class="op">,</span> Stack<span class="op">);</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>    Stack<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Graph<span class="op">::</span>topologicalSort<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> order<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> Stack<span class="op">;</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> visited<span class="op">(</span>V<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>            topologicalSortUtil<span class="op">(</span>i<span class="op">,</span> visited<span class="op">,</span> Stack<span class="op">);</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-50"><a href="#cb9-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(!</span>Stack<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb9-51"><a href="#cb9-51" aria-hidden="true" tabindex="-1"></a>        order<span class="op">.</span>push_back<span class="op">(</span>Stack<span class="op">.</span>top<span class="op">());</span></span>
<span id="cb9-52"><a href="#cb9-52" aria-hidden="true" tabindex="-1"></a>        Stack<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb9-53"><a href="#cb9-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-54"><a href="#cb9-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-55"><a href="#cb9-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-56"><a href="#cb9-56" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> Graph<span class="op">::</span>longestPath<span class="op">(</span><span class="dt">int</span> start<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-57"><a href="#cb9-57" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> order<span class="op">;</span></span>
<span id="cb9-58"><a href="#cb9-58" aria-hidden="true" tabindex="-1"></a>    topologicalSort<span class="op">(</span>order<span class="op">);</span></span>
<span id="cb9-59"><a href="#cb9-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-60"><a href="#cb9-60" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dist<span class="op">(</span>V<span class="op">,</span> INT_MIN<span class="op">);</span></span>
<span id="cb9-61"><a href="#cb9-61" aria-hidden="true" tabindex="-1"></a>    dist<span class="op">[</span>start<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-62"><a href="#cb9-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-63"><a href="#cb9-63" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">:</span> order<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-64"><a href="#cb9-64" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> INT_MIN<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-65"><a href="#cb9-65" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> neighbor <span class="op">:</span> adj<span class="op">[</span>i<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-66"><a href="#cb9-66" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>neighbor<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-67"><a href="#cb9-67" aria-hidden="true" tabindex="-1"></a>                    dist<span class="op">[</span>neighbor<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-68"><a href="#cb9-68" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb9-69"><a href="#cb9-69" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-70"><a href="#cb9-70" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-71"><a href="#cb9-71" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-72"><a href="#cb9-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-73"><a href="#cb9-73" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-74"><a href="#cb9-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> INT_MIN<span class="op">)</span></span>
<span id="cb9-75"><a href="#cb9-75" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Node &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; is not reachable from node &quot;</span> <span class="op">&lt;&lt;</span> start <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-76"><a href="#cb9-76" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb9-77"><a href="#cb9-77" aria-hidden="true" tabindex="-1"></a>            cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Longest path to node &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; is: &quot;</span> <span class="op">&lt;&lt;</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-78"><a href="#cb9-78" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-79"><a href="#cb9-79" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-80"><a href="#cb9-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-81"><a href="#cb9-81" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-82"><a href="#cb9-82" aria-hidden="true" tabindex="-1"></a>    Graph g<span class="op">(</span><span class="dv">6</span><span class="op">);</span></span>
<span id="cb9-83"><a href="#cb9-83" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-84"><a href="#cb9-84" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-85"><a href="#cb9-85" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb9-86"><a href="#cb9-86" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb9-87"><a href="#cb9-87" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">);</span></span>
<span id="cb9-88"><a href="#cb9-88" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>addEdge<span class="op">(</span><span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">);</span></span>
<span id="cb9-89"><a href="#cb9-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-90"><a href="#cb9-90" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> startNode <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-91"><a href="#cb9-91" aria-hidden="true" tabindex="-1"></a>    g<span class="op">.</span>longestPath<span class="op">(</span>startNode<span class="op">);</span></span>
<span id="cb9-92"><a href="#cb9-92" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-93"><a href="#cb9-93" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-94"><a href="#cb9-94" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li>The code creates a <code>Graph</code> class to show the DAG.</li>
<li>The <code>addEdge</code> method adds directed edges between
vertices.</li>
<li>The <code>topologicalSort</code> function makes a topological order
of the vertices.</li>
<li>The <code>longestPath</code> method finds the longest path from a
starting vertex using the topological order. It updates the distance
array with the longest path to each vertex.</li>
</ul>
<p>This C++ code finds the longest path in a directed acyclic graph
using dynamic programming. It follows the rules of DAGs.</p>
<h2
id="comparative-analysis-of-java-python-and-c-implementations">Comparative
Analysis of Java Python and C++ Implementations</h2>
<p>When we want to find the longest path in a Directed Acyclic Graph
(DAG) using dynamic programming, Java, Python, and C++ each have their
own strengths and ways of doing things. Let’s take a look at how they
compare.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Java is known for being fast and safe with types. Here is a simple
way to implement the longest path in a DAG using Java:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.*;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestPathDAG <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="kw">class</span> Graph <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> V<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">List</span><span class="op">&lt;</span><span class="bu">List</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="fu">Graph</span><span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            V <span class="op">=</span> v<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            adj <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;(</span>v<span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> v<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                adj<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;());</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">addEdge</span><span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>u<span class="op">).</span><span class="fu">add</span><span class="op">(</span>v<span class="op">);</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">longestPath</span><span class="op">(</span><span class="dt">int</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span><span class="op">[]</span> dist <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>V<span class="op">];</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dist<span class="op">,</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Stack</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> stack <span class="op">=</span> <span class="kw">new</span> <span class="bu">Stack</span><span class="op">&lt;&gt;();</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>            <span class="dt">boolean</span><span class="op">[]</span> visited <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>V<span class="op">];</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>            <span class="fu">topologicalSort</span><span class="op">(</span>s<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(!</span>stack<span class="op">.</span><span class="fu">isEmpty</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> u <span class="op">=</span> stack<span class="op">.</span><span class="fu">pop</span><span class="op">();</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>u<span class="op">))</span> <span class="op">{</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>v<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a>                        dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a>                <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Vertex &quot;</span> <span class="op">+</span> i <span class="op">+</span> <span class="st">&quot; has longest path: &quot;</span> <span class="op">+</span> dist<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">void</span> <span class="fu">topologicalSort</span><span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> <span class="dt">boolean</span><span class="op">[]</span> visited<span class="op">,</span> <span class="bu">Stack</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> stack<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>            visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n <span class="op">:</span> adj<span class="op">.</span><span class="fu">get</span><span class="op">(</span>v<span class="op">))</span> <span class="op">{</span></span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>n<span class="op">])</span> <span class="op">{</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>                    <span class="fu">topologicalSort</span><span class="op">(</span>n<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-49"><a href="#cb10-49" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-50"><a href="#cb10-50" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span><span class="fu">push</span><span class="op">(</span>v<span class="op">);</span></span>
<span id="cb10-51"><a href="#cb10-51" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-52"><a href="#cb10-52" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-53"><a href="#cb10-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Python is popular because it is easy to use and read. Here is how we
can implement this in Python:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Graph:</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, vertices):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.V <span class="op">=</span> vertices</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.adj <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> add_edge(<span class="va">self</span>, u, v):</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.adj[u].append(v)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> longest_path(<span class="va">self</span>, s):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        dist <span class="op">=</span> [<span class="op">-</span><span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)] <span class="op">*</span> <span class="va">self</span>.V</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        dist[s] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        stack <span class="op">=</span> []</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        visited <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> <span class="va">self</span>.V</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.topological_sort(s, visited, stack)</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> stack:</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            u <span class="op">=</span> stack.pop()</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> v <span class="kw">in</span> <span class="va">self</span>.adj[u]:</span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> dist[v] <span class="op">&lt;</span> dist[u] <span class="op">+</span> <span class="dv">1</span>:</span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>                    dist[v] <span class="op">=</span> dist[u] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="va">self</span>.V):</span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&#39;Vertex </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss"> has longest path: </span><span class="sc">{</span>dist[i]<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> topological_sort(<span class="va">self</span>, v, visited, stack):</span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>        visited[v] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> n <span class="kw">in</span> <span class="va">self</span>.adj[v]:</span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[n]:</span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>                <span class="va">self</span>.topological_sort(n, visited, stack)</span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>        stack.append(v)</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<p>C++ gives us good control over memory and speed. Here is how we can
do the same in C++:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stack&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits.h&gt;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Graph <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> V<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> adj<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    Graph<span class="op">(</span><span class="dt">int</span> v<span class="op">)</span> <span class="op">:</span> V<span class="op">(</span>v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">.</span>resize<span class="op">(</span>V<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> addEdge<span class="op">(</span><span class="dt">int</span> u<span class="op">,</span> <span class="dt">int</span> v<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        adj<span class="op">[</span>u<span class="op">].</span>push_back<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> longestPath<span class="op">(</span><span class="dt">int</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dist<span class="op">(</span>V<span class="op">,</span> INT_MIN<span class="op">);</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>        dist<span class="op">[</span>s<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> stack<span class="op">;</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> visited<span class="op">(</span>V<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>        topologicalSort<span class="op">(</span>s<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-26"><a href="#cb12-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(!</span>stack<span class="op">.</span>empty<span class="op">())</span> <span class="op">{</span></span>
<span id="cb12-27"><a href="#cb12-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> u <span class="op">=</span> stack<span class="op">.</span>top<span class="op">();</span></span>
<span id="cb12-28"><a href="#cb12-28" aria-hidden="true" tabindex="-1"></a>            stack<span class="op">.</span>pop<span class="op">();</span></span>
<span id="cb12-29"><a href="#cb12-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> adj<span class="op">[</span>u<span class="op">])</span> <span class="op">{</span></span>
<span id="cb12-30"><a href="#cb12-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>dist<span class="op">[</span>v<span class="op">]</span> <span class="op">&lt;</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-31"><a href="#cb12-31" aria-hidden="true" tabindex="-1"></a>                    dist<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> dist<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-32"><a href="#cb12-32" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb12-33"><a href="#cb12-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-34"><a href="#cb12-34" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-35"><a href="#cb12-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-36"><a href="#cb12-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> V<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-37"><a href="#cb12-37" aria-hidden="true" tabindex="-1"></a>            <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Vertex &quot;</span> <span class="op">&lt;&lt;</span> i <span class="op">&lt;&lt;</span> <span class="st">&quot; has longest path: &quot;</span> <span class="op">&lt;&lt;</span> dist<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb12-38"><a href="#cb12-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-39"><a href="#cb12-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-40"><a href="#cb12-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-41"><a href="#cb12-41" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> topologicalSort<span class="op">(</span><span class="dt">int</span> v<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&amp;</span> visited<span class="op">,</span> <span class="bu">std::</span>stack<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stack<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-42"><a href="#cb12-42" aria-hidden="true" tabindex="-1"></a>        visited<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb12-43"><a href="#cb12-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> n <span class="op">:</span> adj<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb12-44"><a href="#cb12-44" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(!</span>visited<span class="op">[</span>n<span class="op">])</span> <span class="op">{</span></span>
<span id="cb12-45"><a href="#cb12-45" aria-hidden="true" tabindex="-1"></a>                topologicalSort<span class="op">(</span>n<span class="op">,</span> visited<span class="op">,</span> stack<span class="op">);</span></span>
<span id="cb12-46"><a href="#cb12-46" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-47"><a href="#cb12-47" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-48"><a href="#cb12-48" aria-hidden="true" tabindex="-1"></a>        stack<span class="op">.</span>push<span class="op">(</span>v<span class="op">);</span></span>
<span id="cb12-49"><a href="#cb12-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-50"><a href="#cb12-50" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Runtime Efficiency</strong>: C++ is usually faster than Java
and Python because it allows more control.</li>
<li><strong>Memory Management</strong>: In C++, we manage memory
ourselves. Java does garbage collection. Python takes care of memory
automatically.</li>
<li><strong>Ease of Use</strong>: Python is the easiest to use and read.
This makes it great for quick projects.</li>
<li><strong>Type Safety</strong>: Java checks types at compile time.
This helps to catch errors before running the code, unlike Python.</li>
</ul>
<p>In conclusion, the choice of language depends on what we need for our
project. We should think about speed, how easy it is to develop, and how
we will maintain the code. Each language gives a good way to solve the
longest path problem in a DAG using dynamic programming.</p>
<h2 id="optimizing-space-complexity-in-longest-path-problem">Optimizing
Space Complexity in Longest Path Problem</h2>
<p>When we work on the Longest Path problem in a Directed Acyclic Graph
(DAG) with Dynamic Programming, we need to optimize space complexity.
Here are some simple ways to do this:</p>
<ol type="1">
<li><p><strong>Use of Single Array</strong>: Instead of using a big 2D
table for DP, we can use just one array. This array will show the
longest paths to each vertex. This method cuts down space from O(V^2) to
O(V). Here, V means the number of vertices.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> longestPath <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>V<span class="op">];</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>longestPath<span class="op">,</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>longestPath<span class="op">[</span>source<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> u <span class="op">:</span> topologicalOrder<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> v <span class="op">:</span> graph<span class="op">.</span><span class="fu">get</span><span class="op">(</span>u<span class="op">))</span> <span class="op">{</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>longestPath<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="fu">weight</span><span class="op">(</span>u<span class="op">,</span> v<span class="op">)</span> <span class="op">&gt;</span> longestPath<span class="op">[</span>v<span class="op">])</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            longestPath<span class="op">[</span>v<span class="op">]</span> <span class="op">=</span> longestPath<span class="op">[</span>u<span class="op">]</span> <span class="op">+</span> <span class="fu">weight</span><span class="op">(</span>u<span class="op">,</span> v<span class="op">);</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Iterative Topological Sort</strong>: We can use Kahn’s
algorithm for topological sorting. This method lets us process vertices
one by one. It helps us use less memory than using a recursive
way.</p></li>
<li><p><strong>Memory Efficient Graph Representation</strong>: Instead
of an adjacency matrix, we can use an adjacency list. This list uses
less space, which is good for sparse graphs.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> defaultdict</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>graph <span class="op">=</span> defaultdict(<span class="bu">list</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Adding edges</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>graph[u].append(v)</span></code></pre></div></li>
<li><p><strong>Reusing Space</strong>: While we calculate paths, if we
do not need the old path values anymore, we can reuse their memory. We
can write new values over them.</p></li>
<li><p><strong>Path Reconstruction Optimization</strong>: Instead of
keeping all paths, we can just keep the lengths of the paths. If we need
to rebuild a path, we can do it as we go. We can use backtracking from
the destination to the source based on stored predecessors.</p></li>
<li><p><strong>Sparse Representation</strong>: For very big graphs, we
can think about using sparse representations or compressed data
structures like CSR (Compressed Sparse Row). This helps keep memory use
low.</p></li>
</ol>
<p>By using these methods, we can lower the space complexity of solving
the Longest Path problem in a DAG. We can keep the performance good
too.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-longest-path-problem-in-a-directed-acyclic-graph-dag">What
is the longest path problem in a directed acyclic graph (DAG)?</h3>
<p>The longest path problem in a directed acyclic graph (DAG) is about
finding the longest path between two points. DAGs do not have cycles.
This means we can use some good methods to find the longest path. We can
use dynamic programming and topological sorting for this. This problem
is important in many areas like project planning and deciding which
tasks to do first. Knowing how to use dynamic programming can really
help us solve complex graphs better.</p>
<h3
id="how-does-dynamic-programming-apply-to-finding-the-longest-path-in-a-dag">How
does dynamic programming apply to finding the longest path in a
DAG?</h3>
<p>Dynamic programming (DP) is a good way to solve the longest path
problem in a DAG. We break the problem into smaller parts and keep their
solutions. This way, we can look at each point in the right order. This
helps us find the longest path faster. We update the longest path length
as we go through the graph. If you want to learn more, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-path-in-a-matrix-increasing-medium.html">Dynamic
Programming: Longest Path in a Matrix - Increasing</a>.</p>
<h3
id="what-is-topological-sorting-and-why-is-it-important-for-the-longest-path-in-a-dag">What
is topological sorting, and why is it important for the longest path in
a DAG?</h3>
<p>Topological sorting is when we order the points in a DAG. In this
order, if there is a connection from point A to point B, A comes before
B. This order is very important for solving the longest path problem. It
helps us look at the points in a way that respects their order. We need
to consider all the points that come before a point before we look at
that point. Doing topological sorting well can make our algorithm run
faster.</p>
<h3
id="can-you-provide-a-sample-implementation-of-the-longest-path-in-a-dag-using-python">Can
you provide a sample implementation of the longest path in a DAG using
Python?</h3>
<p>Sure! Here is a simple Python code for the longest path in a directed
acyclic graph using dynamic programming:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_path_dag(graph, start):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    top_order <span class="op">=</span> topological_sort(graph)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    distances <span class="op">=</span> {node: <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">for</span> node <span class="kw">in</span> graph}</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    distances[start] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> node <span class="kw">in</span> top_order:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> graph[node]:</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> distances[neighbor] <span class="op">&lt;</span> distances[node] <span class="op">+</span> graph[node][neighbor]:</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>                distances[neighbor] <span class="op">=</span> distances[node] <span class="op">+</span> graph[node][neighbor]</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(distances.values())</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> topological_sort(graph):</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    in_degree <span class="op">=</span> {node: <span class="dv">0</span> <span class="cf">for</span> node <span class="kw">in</span> graph}</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> edges <span class="kw">in</span> graph.values():</span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> edges:</span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>            in_degree[neighbor] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> [node <span class="cf">for</span> node <span class="kw">in</span> in_degree <span class="cf">if</span> in_degree[node] <span class="op">==</span> <span class="dv">0</span>]</span>
<span id="cb15-20"><a href="#cb15-20" aria-hidden="true" tabindex="-1"></a>    top_order <span class="op">=</span> []</span>
<span id="cb15-21"><a href="#cb15-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-22"><a href="#cb15-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb15-23"><a href="#cb15-23" aria-hidden="true" tabindex="-1"></a>        node <span class="op">=</span> queue.pop(<span class="dv">0</span>)</span>
<span id="cb15-24"><a href="#cb15-24" aria-hidden="true" tabindex="-1"></a>        top_order.append(node)</span>
<span id="cb15-25"><a href="#cb15-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> graph[node]:</span>
<span id="cb15-26"><a href="#cb15-26" aria-hidden="true" tabindex="-1"></a>            in_degree[neighbor] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb15-27"><a href="#cb15-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> in_degree[neighbor] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-28"><a href="#cb15-28" aria-hidden="true" tabindex="-1"></a>                queue.append(neighbor)</span>
<span id="cb15-29"><a href="#cb15-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-30"><a href="#cb15-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> top_order</span></code></pre></div>
<p>This code finds the longest path in a DAG. First, it gets the
topological order, then it calculates the longest distances.</p>
<h3
id="how-does-space-complexity-optimization-work-in-the-longest-path-problem">How
does space complexity optimization work in the longest path
problem?</h3>
<p>In the longest path problem for a directed acyclic graph (DAG), we
can save space by reducing how much we store. Instead of keeping a full
DP array, we can save only what we need or update values in place. This
helps us use less memory. This also makes the algorithm easier to write
and can make it run faster, especially for big graphs.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            