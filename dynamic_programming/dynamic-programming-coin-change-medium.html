
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Coin Change - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn dynamic programming with our Coin Change problem guide. Discover efficient solutions and coding techniques. Start now!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Coin Change - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Coin Change problem is a well-known challenge in algorithms. It
asks how many ways we can make change for a certain amount using
different coin types. We can solve this problem in many ways. These
include recursive methods and dynamic programming techniques. By using
dynamic programming, we can find the number of combinations faster. This
approach is better than using simple recursive solutions.</p>
<p>In this article, we will look into the Coin Change problem closely.
First, we will understand the problem. Then, we will explore recursive
solutions and dynamic programming methods in Java, Python, and C++. We
will also talk about ways to make space usage better for the Coin Change
problem. Lastly, we will answer common questions to help clear up any
confusion.</p>
<ul>
<li>Dynamically Solving the Coin Change Problem - Medium Level</li>
<li>Understanding the Coin Change Problem</li>
<li>Recursive Solution to Coin Change Problem in Java</li>
<li>Dynamic Programming Approach for Coin Change in Java</li>
<li>Recursive Solution to Coin Change Problem in Python</li>
<li>Dynamic Programming Approach for Coin Change in Python</li>
<li>Recursive Solution to Coin Change Problem in C++</li>
<li>Dynamic Programming Approach for Coin Change in C++</li>
<li>Optimizing Space Complexity in Coin Change Problem</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to get better at dynamic programming, we can check out
more resources. The articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a> will give us more helpful ideas.</p>
<h2 id="understanding-the-coin-change-problem">Understanding the Coin
Change Problem</h2>
<p>The Coin Change Problem is a common challenge in dynamic programming.
We want to find out how many ways we can make change for a certain
amount using a set of coin types. Here is how we can define the
problem:</p>
<ul>
<li><strong>Input</strong>: A list of coin types and a target
amount.</li>
<li><strong>Output</strong>: The number of ways to reach the target
amount with the coins.</li>
</ul>
<h3 id="problem-statement">Problem Statement</h3>
<p>We are given a list of different integers called <code>coins</code>.
These represent the coin types. We also have an integer
<code>amount</code>. Our goal is to return how many combinations can
make that amount. We can assume we have unlimited coins of each
type.</p>
<h3 id="example">Example</h3>
<ul>
<li>Input: <code>coins = [1, 2, 5]</code>, <code>amount = 5</code></li>
<li>Output: <code>4</code> (the combinations are: [1,1,1,1,1],
[1,1,1,2], [1,2,2], [5])</li>
</ul>
<h3 id="key-properties">Key Properties</h3>
<ol type="1">
<li><strong>Recursion</strong>: The problem has parts that repeat. We
can define the solution using smaller parts.</li>
<li><strong>Dynamic Programming</strong>: When we save results of the
smaller parts, we can build the solution faster. This helps us avoid
doing the same work again.</li>
<li><strong>Combinatorial Nature</strong>: The order of the coins does
not change the outcome. This is a combination problem, not a permutation
problem.</li>
</ol>
<h3 id="use-cases">Use Cases</h3>
<ul>
<li>In finance, where we deal with different types of money.</li>
<li>In inventory management, where we need to calculate item
combinations.</li>
<li>In any case where we need to reach a specific total using different
units.</li>
</ul>
<p>The Coin Change Problem is a basic example that helps us learn about
dynamic programming. It is also linked to other problems like the
Fibonacci sequence. We can find more about it in articles such as <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number (Easy)</a>.</p>
<h2 id="recursive-solution-to-coin-change-problem-in-java">Recursive
Solution to Coin Change Problem in Java</h2>
<p>We can solve the Coin Change problem using a recursive method. We
will look at each coin and make calls to find the number of ways to make
the target amount. Here is a simple Java code for the recursive
solution.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CoinChange <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> coins<span class="op">,</span> <span class="dt">int</span> amount<span class="op">,</span> <span class="dt">int</span> index<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: if amount is 0, there&#39;s one way to make change (use no coins)</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>amount <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: if amount is less than 0 or no coins left, no way to make change</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>amount <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> index <span class="op">&gt;=</span> coins<span class="op">.</span><span class="fu">length</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Include the coin at index and exclude it</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">countWays</span><span class="op">(</span>coins<span class="op">,</span> amount <span class="op">-</span> coins<span class="op">[</span>index<span class="op">],</span> index<span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>coins<span class="op">,</span> amount<span class="op">,</span> index <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> coins <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="fu">countWays</span><span class="op">(</span>coins<span class="op">,</span> amount<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to make change: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Function <code>countWays</code></strong>:
<ul>
<li>Gets an array of coin types, the target amount, and the current coin
index.</li>
<li>Returns how many ways we can make change for the amount.</li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li>If the amount is <code>0</code>, we return <code>1</code> because
there is one way to make change.</li>
<li>If the amount is less than <code>0</code> or the index is more than
the number of coins, we return <code>0</code> because we can’t make
change.</li>
</ul></li>
<li><strong>Recursive Calls</strong>:
<ul>
<li>We include the current coin by reducing the amount and keep the same
index.</li>
<li>We also exclude the current coin by moving to the next index.</li>
</ul></li>
</ul>
<p>This recursive way has a time complexity of O(2^n). It explores all
subsets of the coin types. This method is simple but not very efficient
for big inputs. For better solutions, we can look at dynamic programming
methods in the next sections.</p>
<h2 id="dynamic-programming-approach-for-coin-change-in-java">Dynamic
Programming Approach for Coin Change in Java</h2>
<p>The Coin Change problem is a well-known example of dynamic
programming. We need to find the least number of coins to make a
specific amount with a set of coin values. Here is a simple dynamic
programming solution in Java.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>We use a 1D array to keep track of the minimum number of coins needed
for each amount up to our target amount.</p>
<h3 id="code-implementation">Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CoinChange <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">coinChange</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> coins<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Set dp array with a big number</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> amount <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> coin <span class="op">:</span> coins<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x <span class="op">=</span> coin<span class="op">;</span> x <span class="op">&lt;=</span> amount<span class="op">;</span> x<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>x<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>x<span class="op">],</span> dp<span class="op">[</span>x <span class="op">-</span> coin<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>amount<span class="op">]</span> <span class="op">&gt;</span> amount <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> dp<span class="op">[</span>amount<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> coins <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="fu">coinChange</span><span class="op">(</span>coins<span class="op">,</span> amount<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>result<span class="op">);</span> <span class="co">// Output: 3</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Initialization</strong>: We start the <code>dp</code> array
with <code>amount + 1</code>. This means it is an impossible number of
coins.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to 0 because
we do not need any coins to make the amount 0.</li>
<li><strong>Dynamic Programming Loop</strong>: For each coin, we update
the <code>dp</code> array for all amounts that can be made with that
coin.</li>
<li><strong>Result</strong>: If <code>dp[amount]</code> is still more
than <code>amount</code>, then it means we cannot make that amount with
the coins we have. So we return -1.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for this solution is O(n * m). Here n is the
number of coins and m is the target amount. The space complexity is O(m)
because of the <code>dp</code> array.</p>
<p>For more problems about dynamic programming, we can check these
articles: - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a></p>
<h2 id="recursive-solution-to-coin-change-problem-in-python">Recursive
Solution to Coin Change Problem in Python</h2>
<p>The Coin Change problem is about finding how many ways we can make a
certain amount using some coin types. We can use a recursive method to
look at all possible ways to use coins.</p>
<h3 id="recursive-function">Recursive Function</h3>
<p>This recursive function takes the target amount and a list of coin
types. It gives back the number of ways to make that amount.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coin_change_recursive(coins, amount):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: if amount is 0, there is one way to make that amount (using no coins)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> amount <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If amount is less than 0, there are no ways to make that amount</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> amount <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    ways <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> coin <span class="kw">in</span> coins:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recursively call for the remaining amount</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        ways <span class="op">+=</span> coin_change_recursive(coins, amount <span class="op">-</span> coin)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ways</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>amount <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> coin_change_recursive(coins, amount)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Number of ways to make </span><span class="sc">{</span>amount<span class="sc">}</span><span class="ss"> using coins </span><span class="sc">{</span>coins<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Base Case</strong>: If amount is 0, we return 1 because
there is one way to do that (using no coins).</li>
<li><strong>Recursive Case</strong>: For each coin, we reduce the amount
and add the results together.</li>
<li>This method takes a lot of time because it has overlapping
problems.</li>
</ul>
<p>This recursive solution is easy to understand but not fast for big
amounts or many coins. If we want to make it better, we can use the
dynamic programming method we will talk about next.</p>
<p>For more information on dynamic programming methods, you can check
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2 id="dynamic-programming-approach-for-coin-change-in-python">Dynamic
Programming Approach for Coin Change in Python</h2>
<p>The Coin Change problem helps us find the fewest coins needed to make
a certain amount using a set of coins. The dynamic programming approach
is quick. It avoids repeating calculations like in the recursive
method.</p>
<h3 id="dynamic-programming-solution-1">Dynamic Programming
Solution</h3>
<p>We can use a 1D array to keep track of the minimum number of coins
needed for each amount from 0 to our target amount. We build the
solution by using values we already calculated.</p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Here is how we can use the dynamic programming method for the Coin
Change problem in Python:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coinChange(coins, amount):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the dp array with infinity</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)] <span class="op">*</span> (amount <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Base case: 0 coins are needed to make the amount 0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp array</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> coin <span class="kw">in</span> coins:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">range</span>(coin, amount <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            dp[x] <span class="op">=</span> <span class="bu">min</span>(dp[x], dp[x <span class="op">-</span> coin] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If we have found a solution, return it; otherwise, return -1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[amount] <span class="cf">if</span> dp[amount] <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>) <span class="cf">else</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>coins <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>amount <span class="op">=</span> <span class="dv">11</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(coinChange(coins, amount))  <span class="co"># Output: 3 (11 = 5 + 5 + 1)</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create an array called
<code>dp</code>. It is the size of <code>amount + 1</code>, and we set
all values to infinity (<code>float('inf')</code>). The first element
<code>dp[0]</code> is set to 0 because we need 0 coins to make 0
amount.</li>
<li><strong>Filling the dp array</strong>: For every coin, we check all
amounts from the coin value to the target amount. We update the
<code>dp</code> array with the minimum coins we need to reach each
amount.</li>
<li><strong>Result</strong>: If <code>dp[amount]</code> is still
infinity, it means we cannot make that amount with the coins we have. So
we return -1. If we can make it, we return <code>dp[amount]</code>.</li>
</ul>
<p>This dynamic programming way is much faster than the simple recursive
way. It works better for bigger inputs. For more practice on dynamic
programming, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">dynamic
programming climbing stairs</a>.</p>
<h2 id="recursive-solution-to-coin-change-problem-in-c">Recursive
Solution to Coin Change Problem in C++</h2>
<p>We can solve the Coin Change problem using a recursive method. This
method looks at all the ways to use coins to get a certain amount. The
recursive function checks each coin. It calls itself with the new amount
until it reaches zero or less.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ code for the recursive solution of the Coin
Change problem:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> coins<span class="op">[],</span> <span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base case: if amount is 0, there&#39;s one way to make change</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>amount <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base case: if amount is less than 0, there&#39;s no way to make change</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>amount <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If no coins left</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Count the solutions including the last coin + excluding the last coin</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> countWays<span class="op">(</span>coins<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> amount<span class="op">)</span> <span class="op">+</span> countWays<span class="op">(</span>coins<span class="op">,</span> n<span class="op">,</span> amount <span class="op">-</span> coins<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> coins<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>coins<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>coins<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to make change: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>coins<span class="op">,</span> n<span class="op">,</span> amount<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Function Signature</strong>:
<code>countWays(int coins[], int n, int amount)</code> takes an array of
coin types, the number of coins, and the target amount.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>If <code>amount</code> is 0, we return 1. This means there is one
way to make change.</li>
<li>If <code>amount</code> is negative, we return 0. This means there is
no way to make change.</li>
<li>If we have no coins left (<code>n &lt;= 0</code>), we return 0.</li>
</ul></li>
<li><strong>Recursive Calls</strong>: The function returns the total of
two cases:
<ul>
<li>We do not use the last coin and solve the same amount.</li>
<li>We use the last coin and solve for the new amount (amount - last
coin).</li>
</ul></li>
</ul>
<p>This recursive way is simple. But it has a problem with time because
it takes too long for big inputs. So for bigger numbers, we usually use
a dynamic programming method to make it faster.</p>
<p>For more learning about dynamic programming, we can check out
articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="dynamic-programming-approach-for-coin-change-in-c">Dynamic
Programming Approach for Coin Change in C++</h2>
<p>We can solve the Coin Change problem well with a Dynamic Programming
approach in C++. Our goal is to find the least number of coins needed to
make a target amount from a set of coin denominations.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have an array of coin denominations and a target amount. We need
to find the minimum number of coins to make that amount. If we can’t
make the amount, we will return -1.</p>
<h3 id="dynamic-programming-solution-2">Dynamic Programming
Solution</h3>
<ol type="1">
<li><p><strong>Create a DP Array</strong>: We will define a DP array. In
this array, <code>dp[i]</code> is the minimum number of coins to get the
amount <code>i</code>. We set <code>dp[0] = 0</code> because we need 0
coins to make amount 0. We set all other values to <code>INT_MAX</code>
to show they are unreachable.</p></li>
<li><p><strong>Fill the DP Array</strong>: For each coin in our
denominations, we will update the DP array for all amounts from the coin
value to the target amount.</p></li>
<li><p><strong>Return Result</strong>: The result will be in
<code>dp[amount]</code>. If this value is still <code>INT_MAX</code>, we
return -1.</p></li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;climits&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> coinChange<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> coins<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> INT_MAX<span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> coin <span class="op">:</span> coins<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> coin<span class="op">;</span> j <span class="op">&lt;=</span> amount<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>j <span class="op">-</span> coin<span class="op">]</span> <span class="op">!=</span> INT_MAX<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> coin<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>amount<span class="op">]</span> <span class="op">==</span> INT_MAX <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> dp<span class="op">[</span>amount<span class="op">];</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> coins <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> coinChange<span class="op">(</span>coins<span class="op">,</span> amount<span class="op">);</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Minimum coins needed: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="time-complexity-1">Time Complexity</h3>
<p>The time complexity for this method is O(n * amount). Here,
<code>n</code> is the number of coin denominations.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity is O(amount) because we use the DP array to
store results.</p>
<p>This dynamic programming way helps to solve the Coin Change problem
well. It is good for cases where we need to use coins in the best way.
If you want to learn more about dynamic programming, you can check out
related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="optimizing-space-complexity-in-coin-change-problem">Optimizing
Space Complexity in Coin Change Problem</h2>
<p>To make space better in the Coin Change problem, we can use a
one-dimensional array. This is better than using a two-dimensional array
for our dynamic programming solution. We see that the current state only
needs the previous state. So, we can save space by storing fewer
results.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<ol type="1">
<li><strong>1D Array Utilization</strong>: Instead of using a 2D array
<code>dp[i][j]</code> where <code>i</code> is the number of coins and
<code>j</code> is the amount, we use a single array <code>dp[j]</code>.
This array keeps track of the number of ways to make change for amounts
from <code>0</code> to <code>n</code>.</li>
</ol>
<h3 id="dynamic-programming-approach-in-java">Dynamic Programming
Approach in Java</h3>
<p>Here is how we can do this space saving in Java:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CoinChange <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">coinChange</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> coins<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> coin <span class="op">:</span> coins<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> coin<span class="op">;</span> j <span class="op">&lt;=</span> amount<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> coin<span class="op">];</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>amount<span class="op">];</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> coins <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to make change: &quot;</span> <span class="op">+</span> <span class="fu">coinChange</span><span class="op">(</span>coins<span class="op">,</span> amount<span class="op">));</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming-approach-in-python">Dynamic Programming
Approach in Python</h3>
<p>The same way in Python would look like this:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> coin_change(coins, amount):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (amount <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> coin <span class="kw">in</span> coins:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(coin, amount <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> coin]</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[amount]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    coins <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    amount <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Number of ways to make change:&quot;</span>, coin_change(coins, amount))</span></code></pre></div>
<h3 id="dynamic-programming-approach-in-c">Dynamic Programming Approach
in C++</h3>
<p>In C++, we can write the solution like this:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> coinChange<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> coins<span class="op">,</span> <span class="dt">int</span> amount<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>amount <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> coin <span class="op">:</span> coins<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> coin<span class="op">;</span> j <span class="op">&lt;=</span> amount<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> coin<span class="op">];</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>amount<span class="op">];</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> coins <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> amount <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to make change: &quot;</span> <span class="op">&lt;&lt;</span> coinChange<span class="op">(</span>coins<span class="op">,</span> amount<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-benefits">Key Benefits</h3>
<ul>
<li><strong>Reduced Space Complexity</strong>: The space needed for the
algorithm is less now. It goes from O(n * m) to O(n). Here
<code>n</code> is the amount and <code>m</code> is the types of
coins.</li>
<li><strong>Improved Efficiency</strong>: The time complexity stays O(n
* m). But now with less space, we can manage larger amounts without
using too much memory.</li>
</ul>
<p>For more information about dynamic programming techniques, you can
check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> article.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-coin-change-problem-in-dynamic-programming">What is
the Coin Change Problem in Dynamic Programming?</h3>
<p>The Coin Change Problem is a well-known challenge in algorithms. We
need to find out how many ways we can make change for a certain amount
using different coins. We can solve this problem well with dynamic
programming. We break the problem into smaller parts. Then we build the
solution step by step. This method is much faster than just using a
simple recursive way.</p>
<h3 id="how-do-i-implement-the-coin-change-problem-in-java">How do I
implement the Coin Change Problem in Java?</h3>
<p>To implement the Coin Change Problem in Java, we will make a dynamic
programming table. Each spot in the table shows how many ways we can
make change for that amount. We go through each coin and update the
table using earlier values we calculated. This way, we consider all
combinations without doing extra work. For a detailed guide, check our
<strong><a href="#">Dynamic Programming Approach for Coin Change in
Java</a></strong>.</p>
<h3
id="what-are-the-differences-between-recursive-and-dynamic-programming-solutions-for-coin-change">What
are the differences between recursive and dynamic programming solutions
for Coin Change?</h3>
<p>The main difference between the recursive way and the dynamic
programming way for the Coin Change Problem is how fast they work. The
recursive way can take a long time because it has repeating problems.
The dynamic programming way uses a table to keep track of results. This
makes it much faster and reduces the time to a polynomial level. If you
want to see how they compare, look at our sections on <strong><a
href="#">Recursive Solution to Coin Change Problem in Java</a></strong>
and <strong><a href="#">Dynamic Programming Approach for Coin Change in
Java</a></strong>.</p>
<h3
id="is-there-a-space-efficient-way-to-solve-the-coin-change-problem">Is
there a space-efficient way to solve the Coin Change Problem?</h3>
<p>Yes, we can save space in the Coin Change Problem. Instead of using a
two-dimensional table, we can use a one-dimensional array. This works
because each step only depends on the last steps. This change brings the
space needed down from O(n*m) to O(n). Here, n is the target amount and
m is the number of coin types. For more details, check our section on
<strong><a href="#">Optimizing Space Complexity in Coin Change
Problem</a></strong>.</p>
<h3 id="can-the-coin-change-problem-be-solved-in-python">Can the Coin
Change Problem be solved in Python?</h3>
<p>Yes, for sure! We can solve the Coin Change Problem in Python using
both recursive and dynamic programming methods. The dynamic programming
way uses a list to keep track of how many ways we can make change for
each amount up to the target. You can read more about how to do this in
our <strong><a href="#">Dynamic Programming Approach for Coin Change in
Python</a></strong> section.</p>
<p>These FAQs give a short overview of the Coin Change Problem and its
solutions. They help learners and developers who want to understand
dynamic programming better. For more topics like this, you can check out
our articles on <strong><a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a></strong> and <strong><a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a></strong>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            