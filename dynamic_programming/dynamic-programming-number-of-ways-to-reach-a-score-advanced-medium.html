
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Number of Ways to Reach a Score (Advanced) - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Explore advanced dynamic programming techniques to calculate the number of ways to reach a score. Master your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Number of Ways to Reach a Score (Advanced) - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong technique. It helps us solve hard
problems by breaking them into easier parts. Then we use the solutions
of these parts. When we want to count how many ways we can reach a
certain score, dynamic programming gives us a smart way. It remembers
results that we already found. This way, we do not calculate the same
thing over and over. This method can make our work much faster,
especially when we have big inputs. It helps us find different
combinations that can lead to a specific score.</p>
<p>In this article, we will look at different ways to use dynamic
programming to count how we can reach a score. We will cover recursive
solutions with memoization. We will also check out a dynamic programming
tabulation method and an iterative bottom-up method. We will talk about
how to save space to make our solutions better. We will compare the time
and space needs of these methods. Also, we will go through the code step
by step. We will answer often asked questions to help us understand
dynamic programming better in this area.</p>
<ul>
<li>Dynamic Programming Approaches to Count Ways to Reach a Score
(Advanced) - Medium</li>
<li>Understanding the Problem Statement</li>
<li>Optimal Substructure and Overlapping Subproblems</li>
<li>Recursive Solution with Memoization in Java</li>
<li>Dynamic Programming Tabulation Approach in Python</li>
<li>Iterative Bottom-Up Solution in C++</li>
<li>Space Optimization Techniques for Dynamic Programming</li>
<li>Comparing Time and Space Complexities of Solutions</li>
<li>Code Walkthrough and Explanation</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on dynamic programming, you can check these
articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a>.</p>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>In the problem of counting how many ways we can reach a specific
score, we have a target score and a list of allowed scores. These are
like points we can get in a game. Our goal is to find out how many
different combinations of these scores can add up to the target
score.</p>
<h3 id="example">Example:</h3>
<ul>
<li><strong>Target Score</strong>: 5</li>
<li><strong>Scoring Options</strong>: 1, 2, and 3 points</li>
</ul>
<p>The possible combinations to score 5 are: - (1, 1, 1, 1, 1) - (1, 1,
1, 2) - (1, 2, 2) - (2, 3) - (1, 1, 3)</p>
<p>So, we have a total of 5 ways to reach a score of 5.</p>
<h3 id="problem-constraints">Problem Constraints:</h3>
<ul>
<li>The target score (n) is a number that is not negative.</li>
<li>The scoring options must be positive numbers and can be of any
size.</li>
<li>The order of scoring options is important. Different sequences are
different combinations.</li>
</ul>
<h3 id="input-and-output">Input and Output:</h3>
<ul>
<li><strong>Input</strong>:
<ul>
<li>A number <code>n</code> (the target score).</li>
<li>An array of numbers <code>scores</code> that shows the scoring
options.</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>A number that tells us how many ways we can reach the target score
using the given scoring options.</li>
</ul></li>
</ul>
<p>This problem is a classic case of dynamic programming. We can break
it down into smaller parts that overlap. This makes it easier to solve
with memoization or tabulation methods. Knowing this problem statement
is important for us to create a solution and look into dynamic
programming methods to count how to reach a score effectively.</p>
<h2 id="optimal-substructure-and-overlapping-subproblems">Optimal
Substructure and Overlapping Subproblems</h2>
<p>When we count how many ways we can reach a score using dynamic
programming, we see that the problem has both optimal substructure and
overlapping subproblems.</p>
<h3 id="optimal-substructure">Optimal Substructure</h3>
<p>Optimal substructure means that we can find the best solution by
using the best solutions of smaller parts of the problem. For our
score-reaching problem, if we want to reach a score <code>n</code> with
step sizes like 1, 2, and 3, we can write the number of ways to reach
score <code>n</code> like this:</p>
<p>[ (n) = (n-1) + (n-2) + (n-3) ]</p>
<p>In this formula, <code>ways(n)</code> depends on the smaller
problems: <code>ways(n-1)</code>, <code>ways(n-2)</code>, and
<code>ways(n-3)</code>. These represent the last step we took to reach
score <code>n</code>.</p>
<h3 id="overlapping-subproblems">Overlapping Subproblems</h3>
<p>Overlapping subproblems mean that we can break the problem into
smaller parts that we can use again. In our case, when we call
<code>ways(n-k)</code> for different <code>n</code>, we often calculate
the same values again and again. This can make our solution slow if we
just use recursion.</p>
<p>For example:</p>
<ul>
<li>When we calculate <code>ways(5)</code>, it will call
<code>ways(4)</code>, <code>ways(3)</code>, and also
<code>ways(0)</code>.</li>
<li>We will call <code>ways(2)</code> and <code>ways(3)</code> many
times because we need them for different <code>n</code>.</li>
</ul>
<p>To fix this, we can use dynamic programming methods like memoization
or tabulation. These methods let us save results we have already
calculated. This way, we do not have to calculate the same value
again.</p>
<h3 id="example-1">Example</h3>
<p>Letâ€™s say <code>n = 4</code> and our step sizes are 1, 2, and 3. We
can break it down like this:</p>
<ul>
<li><code>ways(4) = ways(3) + ways(2) + ways(1)</code></li>
<li>Each of these calls can break down into even smaller calls.</li>
</ul>
<p>If we use memoization, we can save our results:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> steps<span class="op">,</span> <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> totalWays <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> step <span class="op">:</span> steps<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        totalWays <span class="op">+=</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> step<span class="op">,</span> steps<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> totalWays<span class="op">);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> totalWays<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this example, by saving results in a map, we can handle
overlapping subproblems better. This helps us find an efficient way to
count how many ways we can reach a score. This shows us why it is
important to see optimal substructure and overlapping subproblems in
dynamic programming.</p>
<h2 id="recursive-solution-with-memoization-in-java">Recursive Solution
with Memoization in Java</h2>
<p>In this part, we will look at the recursive way to count how many
ways we can reach a certain score. We will use dynamic programming with
memoization in Java. The problem is simple. We have a target score and
an array of possible scores. Our goal is to find the total number of
ways to reach that score.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>Letâ€™s say <code>targetScore</code> is the score we want to reach. The
<code>scores</code> is an array of possible scores. The recursive
function will check each score in the <code>scores</code> array. Then it
will add the ways to reach the remaining score which is
(<code>targetScore - score</code>).</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<p>Here is how we can write the memoized recursive solution in Java:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ScoreCounter <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">ScoreCounter</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> targetScore<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>targetScore <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>targetScore <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>targetScore<span class="op">))</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>targetScore<span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> totalWays <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> score <span class="op">:</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            totalWays <span class="op">+=</span> <span class="fu">countWays</span><span class="op">(</span>targetScore <span class="op">-</span> score<span class="op">,</span> scores<span class="op">);</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>targetScore<span class="op">,</span> totalWays<span class="op">);</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> totalWays<span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        ScoreCounter counter <span class="op">=</span> <span class="kw">new</span> <span class="fu">ScoreCounter</span><span class="op">();</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> targetScore <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> scores <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="co">// Possible scores to reach the target</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> counter<span class="op">.</span><span class="fu">countWays</span><span class="op">(</span>targetScore<span class="op">,</span> scores<span class="op">);</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to reach the score: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Memoization</strong>: We use a <code>HashMap</code> to keep
results that we already calculated. This helps us not to do the same
work again.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>If <code>targetScore</code> is less than 0, we return 0.</li>
<li>If <code>targetScore</code> is 0, we return 1. This means there is
one way to reach the score which is by not taking any steps.</li>
</ul></li>
<li><strong>Recursive Case</strong>: We loop through each score in the
<code>scores</code> array. We call <code>countWays</code> again for the
smaller score and add the results.</li>
<li>We store the result in the memoization map. This helps us to make
the process faster.</li>
</ul>
<p>This method helps a lot to reduce the time we need compared to a
basic recursive way. We store results that we already found. This makes
it work better for bigger inputs. For more on dynamic programming, you
can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-reach-a-score-basic-easy.html">dynamic
programming - count ways to reach a score (basic)</a>.</p>
<h2 id="dynamic-programming-tabulation-approach-in-python">Dynamic
Programming Tabulation Approach in Python</h2>
<p>We use the dynamic programming tabulation approach as a bottom-up way
to solve the problem of counting how many ways we can reach a specific
score with a given set of scores. This method needs us to make a table,
or an array, to keep the results of smaller problems. We solve each
smaller problem only one time. This helps us save time and space.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a score <code>n</code> and a list of possible scores like [1,
2, 3]. Our goal is to find the total number of different ways to get the
score <code>n</code> using these scores.</p>
<h3 id="tabulation-approach">Tabulation Approach</h3>
<p>In the tabulation method, we start by making a list <code>dp</code>.
Here, <code>dp[i]</code> shows how many ways we can reach the score
<code>i</code>. We fill this list step by step based on the values we
calculated before.</p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Here is an example of how we can implement the dynamic programming
tabulation approach in Python:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysToReachScore(n, scores):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize a list to store the number of ways to reach each score</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case: one way to reach score 0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp array</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> score <span class="kw">in</span> scores:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(score, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> score]</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to reach score&quot;</span>, n, <span class="st">&quot;is:&quot;</span>, countWaysToReachScore(n, scores))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create a list <code>dp</code>
with size <code>n + 1</code> and set it to zero. We also set
<code>dp[0]</code> to 1. This shows there is one way to get a score of
0.</li>
<li><strong>Filling the Table</strong>: For each score in our list of
possible scores, we go from that score to <code>n</code>. We update the
number of ways to reach each score <code>i</code> by adding the ways to
reach <code>i - score</code>.</li>
<li><strong>Final Output</strong>: The function gives us
<code>dp[n]</code>, which is the total ways to reach the score
<code>n</code>.</li>
</ol>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n * m), where <code>n</code> is
the target score and <code>m</code> is the number of possible
scores.</li>
<li><strong>Space Complexity</strong>: O(n), because of the list
<code>dp</code>.</li>
</ul>
<p>This tabulation approach is good and gives us a clear way to solve
the problem of counting ways to reach a specific score. If we want to
read more about dynamic programming, we can check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-reach-a-score-basic-easy.html">Dynamic
Programming - Count Ways to Reach a Score (Basic)</a>.</p>
<h2 id="iterative-bottom-up-solution-in-c">Iterative Bottom-Up Solution
in C++</h2>
<p>We can use the iterative bottom-up approach to solve the problem of
counting how many ways we can reach a specific score using given points.
This method builds the solution by solving smaller parts first. Then, we
store their answers in a table.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a score <code>n</code> and a set of points like
<code>{1, 2, 3}</code>. Our goal is to find out how many different ways
we can reach the score <code>n</code>.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is how we can write the iterative bottom-up dynamic programming
solution in C++:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: 1 way to reach score 0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> points<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> points<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> points<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span> <span class="co">// Return the number of ways to reach score n</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Example score</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> points <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">,</span> points<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We create a <code>dp</code> array
with size <code>n + 1</code> to store how many ways we can reach each
score from <code>0</code> to <code>n</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to
<code>1</code>. This is because there is one way to reach a score of
<code>0</code> (by not using any points).</li>
<li><strong>Dynamic Programming Loop</strong>: We use two loops:
<ul>
<li>The first loop goes through each score from <code>1</code> to
<code>n</code>.</li>
<li>The second loop goes through each point. If the current score
<code>i</code> is greater than or equal to the point, we add the number
of ways to reach <code>i - points[j]</code> to <code>dp[i]</code>.</li>
</ul></li>
<li><strong>Result</strong>: The answer we want is <code>dp[n]</code>,
which tells us how many ways we can reach the score <code>n</code>.</li>
</ul>
<p>This method has a time cost of O(n * m), where <code>m</code> is the
number of different points, and a space cost of O(n) because of the
<code>dp</code> array.</p>
<p>For more about dynamic programming and similar algorithms, we can
check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-reach-a-score-basic-easy.html">Dynamic
Programming - Number of Ways to Reach a Score (Basic)</a>.</p>
<h2 id="space-optimization-techniques-for-dynamic-programming">Space
Optimization Techniques for Dynamic Programming</h2>
<p>In dynamic programming, space optimization is very important. It
helps make our algorithms run better, especially when we work with big
input sizes. When we cut down the space we use, we can make our
solutions run faster and use less memory.</p>
<h3 id="techniques-for-space-optimization">Techniques for Space
Optimization</h3>
<ol type="1">
<li><strong>In-Place Updates</strong>:
<ul>
<li>Change the original data we use for results. This helps us avoid
using extra space.</li>
<li>For example, when we calculate the Fibonacci sequence, we can track
just the last two numbers. No need for an array.</li>
</ul></li>
<li><strong>Rolling Arrays</strong>:
<ul>
<li>Instead of keeping a full DP table, we can use two arrays or just
one. This lets us track only what we need.</li>
<li>For example, in the 0/1 Knapsack problem, we can use a single array
of size <code>N</code> and update it from the end. This way, we do not
overwrite values.</li>
</ul></li>
<li><strong>State Compression</strong>:
<ul>
<li>We can compress how we show state by finding patterns or
similarities in the problem.</li>
<li>This works well in grid problems where we can guess some states from
others.</li>
</ul></li>
<li><strong>Bit Manipulation</strong>:
<ul>
<li>For problems that use true or false states, we can use bits. This
saves us from using bigger data types.</li>
<li>This works great in problems like counting subsets or making
combinations.</li>
</ul></li>
<li><strong>Iterative Approaches</strong>:
<ul>
<li>We should use iterative methods instead of recursive ones. This
helps us avoid the extra space from the recursive stack.</li>
<li>For example, if we change a recursive backtracking solution to an
iterative one, we can lower the space we need a lot.</li>
</ul></li>
</ol>
<h3 id="example-fibonacci-sequence-with-space-optimization">Example:
Fibonacci Sequence with Space Optimization</h3>
<p>Here is a simple example with the Fibonacci sequence where we use
space better:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">fib</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> prev2<span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-01-knapsack-with-rolling-array">Example: 0/1 Knapsack
with Rolling Array</h3>
<p>This C++ code shows the rolling array method for the 0/1 Knapsack
problem:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> knapsack<span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> wt<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> val<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> W<span class="op">;</span> j <span class="op">&gt;=</span> wt<span class="op">[</span>i<span class="op">];</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> wt<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>W<span class="op">];</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By using these space optimization techniques, we can make our
performance in dynamic programming problems a lot better. This makes our
solutions more efficient and able to handle more data. For more on
dynamic programming, we can read articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2 id="comparing-time-and-space-complexities-of-solutions">Comparing
Time and Space Complexities of Solutions</h2>
<p>When we look at different ways to solve the problem of counting how
many ways we can reach a score using dynamic programming, we need to
know about the time and space complexities for each method.</p>
<h3 id="recursive-solution-with-memoization">Recursive Solution with
Memoization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n * m). Here, <code>n</code> is
the target score and <code>m</code> is the number of different scores or
steps we can use.</li>
<li><strong>Space Complexity</strong>: O(n). This is because of the
recursion stack and the memory we need for memoization.</li>
</ul>
<h3 id="dynamic-programming-tabulation-approach">Dynamic Programming
Tabulation Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n * m). This is the same as the
recursive method. We check each score up to <code>n</code> and each
step.</li>
<li><strong>Space Complexity</strong>: O(n). We usually use a
one-dimensional array to keep results for each score.</li>
</ul>
<h3 id="iterative-bottom-up-solution">Iterative Bottom-Up Solution</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n * m). This follows the same
idea as the tabulation method.</li>
<li><strong>Space Complexity</strong>: O(1). We can save space by using
only a few variables. We only need the last few results to calculate the
current score.</li>
</ul>
<h3 id="space-optimization-techniques">Space Optimization
Techniques</h3>
<ul>
<li>We can lower the space we use in the tabulation method. We can make
it O(1) by only keeping the last two or three states we need. This way,
we do not need to keep the whole array.</li>
</ul>
<h3 id="summary">Summary</h3>
<ul>
<li>The recursive solution is clear. But it uses more space because of
the recursion depth.</li>
<li>The tabulation and iterative solutions have similar time
complexities. However, they are very different in space usage. The
iterative solution can use constant space. This makes it better for
memory.</li>
</ul>
<p>We need to understand these complexities. This helps us choose the
best method based on the problemâ€™s limits. This is especially important
when we work with larger scores or many score combinations.</p>
<h2 id="code-walkthrough-and-explanation">Code Walkthrough and
Explanation</h2>
<p>In this part, we will talk about how to solve the problem of counting
the ways to reach a certain score. We use dynamic programming
techniques. We will look at recursive solutions with memoization,
dynamic programming tabulation, and iterative bottom-up methods in Java,
Python, and C++.</p>
<h3 id="recursive-solution-with-memoization-in-java-1">Recursive
Solution with Memoization in Java</h3>
<p>The recursive way uses a top-down method. We add memoization to make
repeated calculations faster. We have a cache to save results of smaller
problems.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ScoreWays <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> score<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span><span class="op">[]</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">Integer</span><span class="op">[</span>score <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">countWaysRecursive</span><span class="op">(</span>score<span class="op">,</span> points<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">countWaysRecursive</span><span class="op">(</span><span class="dt">int</span> score<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> points<span class="op">,</span> <span class="bu">Integer</span><span class="op">[]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>score<span class="op">]</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>score<span class="op">];</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>score<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> point <span class="op">:</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            memo<span class="op">[</span>score<span class="op">]</span> <span class="op">+=</span> <span class="fu">countWaysRecursive</span><span class="op">(</span>score <span class="op">-</span> point<span class="op">,</span> points<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>score<span class="op">];</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming-tabulation-approach-in-python-1">Dynamic
Programming Tabulation Approach in Python</h3>
<p>The tabulation method builds a table. It solves the problem step by
step from the bottom up. This way, we make sure all smaller problems are
solved.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(score, points):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, score <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> point <span class="kw">in</span> points:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> point <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> point]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[score]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countWays(<span class="dv">5</span>, [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]))  <span class="co"># Output: 5</span></span></code></pre></div>
<h3 id="iterative-bottom-up-solution-in-c-1">Iterative Bottom-Up
Solution in C++</h3>
<p>The bottom-up method in C++ works like the Python tabulation method.
It gives us a quick way to count the ways.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> score<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>score <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> score<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> point <span class="op">:</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> point <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> point<span class="op">];</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>score<span class="op">];</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="co">// Example usage</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> points <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> countWays<span class="op">(</span><span class="dv">5</span><span class="op">,</span> points<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// Output: 5</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="space-optimization-techniques-for-dynamic-programming-1">Space
Optimization Techniques for Dynamic Programming</h3>
<p>To save space, we can make the size of the array smaller. By keeping
only the last two rows or using one array, we can use space better.</p>
<h4 id="python-space-optimized-example">Python Space Optimized
Example</h4>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysOptimized(score, points):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (score <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> point <span class="kw">in</span> points:</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(point, score <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> point]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[score]</span></code></pre></div>
<h4 id="c-space-optimized-example">C++ Space Optimized Example</h4>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWaysOptimized<span class="op">(</span><span class="dt">int</span> score<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>score <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> point <span class="op">:</span> points<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> point<span class="op">;</span> i <span class="op">&lt;=</span> score<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> point<span class="op">];</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>score<span class="op">];</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By using these clear methods, we can count the ways to reach a
specific score with dynamic programming. For more information, you can
check related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-reach-a-score-basic-easy.html">Dynamic
Programming - Count Ways to Reach a Score (Basic)</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-dynamic-programming-and-how-does-it-apply-to-counting-ways-to-reach-a-score">1.
What is dynamic programming, and how does it apply to counting ways to
reach a score?</h3>
<p>Dynamic programming is a method we use to solve problems. We break
these problems into smaller parts. Then we keep the results of these
parts. This helps us not to do the same work again. When we count ways
to reach a score, dynamic programming helps us find the number of ways
to score a specific target.</p>
<h3
id="what-are-the-key-differences-between-memoization-and-tabulation-in-dynamic-programming">2.
What are the key differences between memoization and tabulation in
dynamic programming?</h3>
<p>Memoization is a top-down way. We make recursive calls and save
results in a cache. This helps us avoid doing the same calculations. On
the other hand, tabulation is a bottom-up way. We create a table step by
step while solving smaller problems. Both methods help improve
performance. But which one to choose depends on the problem we are
solving.</p>
<h3
id="how-can-i-optimize-space-in-dynamic-programming-solutions-for-counting-scores">3.
How can I optimize space in dynamic programming solutions for counting
scores?</h3>
<p>To save space in dynamic programming, we can reduce how much we
store. Instead of keeping a full table, we only keep the last few states
we need. For counting ways to reach a score, we can use one or two
arrays. Sometimes we can even use just a few variables. This helps us
save memory and still be efficient.</p>
<h3
id="what-is-the-time-complexity-of-different-approaches-to-count-ways-to-reach-a-score">4.
What is the time complexity of different approaches to count ways to
reach a score?</h3>
<p>The time complexity changes based on the approach we use. A naive
recursive solution can take a lot of time, even exponential time. But
with memoization, it goes down to O(n), where n is the target score. In
tabulation, the time complexity is also O(n). It is important for us to
understand these complexities to make our solutions better.</p>
<h3
id="are-there-other-related-dynamic-programming-problems-i-can-explore-to-improve-my-understanding">5.
Are there other related dynamic programming problems I can explore to
improve my understanding?</h3>
<p>Yes, there are many related problems we can look at. They can help us
understand dynamic programming better. For example, we can check out the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-basic-dice-throw-problem-easy.html">basic
dice throw problem</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">coin
change problem</a>. These problems have similar ideas to counting ways
to reach a score and can help us learn more about dynamic
programming.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            