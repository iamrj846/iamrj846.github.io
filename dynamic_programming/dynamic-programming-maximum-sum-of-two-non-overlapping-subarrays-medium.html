
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Two Non-Overlapping Subarrays - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Sum of Two Non-Overlapping Subarrays problem using dynamic programming techniques.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Two Non-Overlapping Subarrays - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Sum of Two Non-Overlapping Subarrays problem is a
well-known challenge in dynamic programming. We want to find two
subarrays in a given array of integers. These subarrays should not
overlap, and when we add their sums together, we want the total to be
the biggest possible. This problem needs us to think carefully about
where the two subarrays start and end to make sure they do not touch
each other, while also getting the highest sum from their elements.</p>
<p>In this article, we will look at the Maximum Sum of Two
Non-Overlapping Subarrays problem in detail. First, we will give an
overview of the dynamic programming method. Then, we will break down the
problem statement and its limits. After that, we will show how to
implement this in Java, Python, and C++. We will also look at ways to
make the solution better and discuss how long it takes to run. We will
talk about other ways to solve the problem, point out common mistakes,
and answer questions we often hear. Here are the topics we will
cover:</p>
<ul>
<li>Dynamic Programming Maximum Sum of Two Non-Overlapping Subarrays
Solution Overview</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach for Maximum Sum of Two Non-Overlapping
Subarrays</li>
<li>Java Implementation of Maximum Sum of Two Non-Overlapping
Subarrays</li>
<li>Python Implementation of Maximum Sum of Two Non-Overlapping
Subarrays</li>
<li>C++ Implementation of Maximum Sum of Two Non-Overlapping
Subarrays</li>
<li>Optimizations and Time Complexity Analysis</li>
<li>Alternative Approaches to Solve the Problem</li>
<li>Common Mistakes and How to Avoid Them</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about related dynamic programming ideas,
you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>. These can help improve your understanding
of this important problem-solving method.</p>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>We have a problem. We need to find the maximum sum of two subarrays
that do not overlap. Here is what we need to know:</p>
<p>We are given an array of integers called <code>nums</code>. We also
have two numbers, <code>firstLen</code> and <code>secondLen</code>. Our
job is to find two subarrays that are non-overlapping. These subarrays
must meet these rules:</p>
<ul>
<li>The first subarray must be <code>firstLen</code> long.</li>
<li>The second subarray must be <code>secondLen</code> long.</li>
</ul>
<p>We want to make the sum of these two subarrays as large as
possible.</p>
<h3 id="constraints">Constraints:</h3>
<ol type="1">
<li>The length of the array <code>nums</code> must be at least
<code>firstLen + secondLen</code>.</li>
<li>The numbers in <code>nums</code> can be both positive and
negative.</li>
<li>The two subarrays cannot overlap. This means the end of the first
subarray must come before the start of the second subarray.</li>
</ol>
<h3 id="example">Example:</h3>
<p>Let’s take an example. If we have an array
<code>nums = [0, 6, 5, 2, 2, 5, 1, 9, 4]</code>, with
<code>firstLen = 1</code> and <code>secondLen = 2</code>, the two
subarrays that give the highest sum are <code>[6]</code> and
<code>[9, 4]</code>. These add up to a maximum sum of
<code>19</code>.</p>
<p>We can solve this problem using a dynamic programming method. We will
keep track of running sums. We will also use prefix sums to help us
quickly find the maximum sums we need for our conditions.</p>
<h2
id="dynamic-programming-approach-for-maximum-sum-of-two-non-overlapping-subarrays">Dynamic
Programming Approach for Maximum Sum of Two Non-Overlapping
Subarrays</h2>
<p>To solve the problem of finding the maximum sum of two
non-overlapping subarrays, we can use dynamic programming. The main idea
is to track the maximum sums of subarrays on both sides while we go
through the array.</p>
<h3 id="steps-to-approach">Steps to Approach:</h3>
<ol type="1">
<li><strong>Prefix Maximum Sums</strong>: We make an array
<code>left_max</code>. Here, <code>left_max[i]</code> shows the maximum
sum of a subarray that ends at index <code>i</code>.</li>
<li><strong>Suffix Maximum Sums</strong>: We create another array
<code>right_max</code>. This one tells us the maximum sum of a subarray
that starts at index <code>i</code>.</li>
<li><strong>Iterate to Find Maximum Sum</strong>: We loop through the
array. For each index <code>i</code>, we add <code>left_max[i]</code>
and <code>right_max[i + 1]</code> to find the maximum sum of two
non-overlapping subarrays.</li>
</ol>
<h3 id="code-implementation">Code Implementation:</h3>
<p>Here is how we can do this in Java, Python, and C++.</p>
<h4 id="java-implementation">Java Implementation</h4>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumTwoNonOverlapping <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumTwoNoOverlap</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> L<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> leftMax <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> rightMax <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate left max sums</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sumL <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            sumL <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> L<span class="op">)</span> sumL <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> L<span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> L <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> leftMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> leftMax<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">,</span> sumL<span class="op">);</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate right max sums</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sumM <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            sumM <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> M <span class="op">&lt;</span> n<span class="op">)</span> sumM <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">+</span> M<span class="op">];</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> M <span class="op">&lt;=</span> n<span class="op">)</span> rightMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span> <span class="op">?</span> rightMax<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">,</span> sumM<span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate the maximum sum of two non-overlapping subarrays</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> leftMax<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> rightMax<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python-implementation">Python Implementation</h4>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumTwoNoOverlap(nums, L, M):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    left_max <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    right_max <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate left max sums</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    sum_L <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        sum_L <span class="op">+=</span> nums[i]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;=</span> L:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            sum_L <span class="op">-=</span> nums[i <span class="op">-</span> L]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;=</span> L <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            left_max[i] <span class="op">=</span> <span class="bu">max</span>(left_max[i <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>, sum_L)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate right max sums</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    sum_M <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        sum_M <span class="op">+=</span> nums[i]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> M <span class="op">&lt;</span> n:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            sum_M <span class="op">-=</span> nums[i <span class="op">+</span> M]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">+</span> M <span class="op">&lt;=</span> n:</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            right_max[i] <span class="op">=</span> <span class="bu">max</span>(right_max[i <span class="op">+</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>, sum_M)</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate the maximum sum of two non-overlapping subarrays</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, left_max[i] <span class="op">+</span> right_max[i <span class="op">+</span> <span class="dv">1</span>])</span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div>
<h4 id="c-implementation">C++ Implementation</h4>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSumTwoNoOverlap<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> L<span class="op">,</span> <span class="dt">int</span> M<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> leftMax<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> rightMax<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate left max sums</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sumL <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            sumL <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> L<span class="op">)</span> sumL <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> L<span class="op">];</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> L <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> leftMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> leftMax<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">,</span> sumL<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate right max sums</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sumM <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            sumM <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> M <span class="op">&lt;</span> n<span class="op">)</span> sumM <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">+</span> M<span class="op">];</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> M <span class="op">&lt;=</span> n<span class="op">)</span> rightMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span> <span class="op">?</span> rightMax<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">,</span> sumM<span class="op">);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate the maximum sum of two non-overlapping subarrays</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> max<span class="op">(</span>maxSum<span class="op">,</span> leftMax<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> rightMax<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This dynamic programming way helps us find the maximum sum of two
non-overlapping subarrays in a quick way. The time is O(n), which is
good for big input sizes. For more information on dynamic programming
methods, you can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2
id="java-implementation-of-maximum-sum-of-two-non-overlapping-subarrays">Java
Implementation of Maximum Sum of Two Non-Overlapping Subarrays</h2>
<p>We want to find the maximum sum of two non-overlapping subarrays in a
given array. We can do this using dynamic programming in Java. Our goal
is to keep track of two maximum sums for the two subarrays. We make sure
they do not overlap.</p>
<p>Here is a simple Java implementation for this:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumOfTwoNonOverlapping <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumTwoNoOverlap</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> firstLen<span class="op">,</span> <span class="dt">int</span> secondLen<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> prefixSum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate prefix sums</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            prefixSum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate max sum for firstLen and secondLen in both orders</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> <span class="fu">getMaxSum</span><span class="op">(</span>prefixSum<span class="op">,</span> firstLen<span class="op">,</span> secondLen<span class="op">));</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> <span class="fu">getMaxSum</span><span class="op">(</span>prefixSum<span class="op">,</span> secondLen<span class="op">,</span> firstLen<span class="op">));</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">getMaxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> prefixSum<span class="op">,</span> <span class="dt">int</span> firstLen<span class="op">,</span> <span class="dt">int</span> secondLen<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxFirstSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> currentMax <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate the maximum sum of the first subarray of length firstLen</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> firstLen<span class="op">;</span> i <span class="op">&lt;=</span> prefixSum<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> secondLen<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            currentMax <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>currentMax<span class="op">,</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>i <span class="op">-</span> firstLen<span class="op">]);</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            maxFirstSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxFirstSum<span class="op">,</span> currentMax <span class="op">+</span> <span class="op">(</span>prefixSum<span class="op">[</span>i <span class="op">+</span> secondLen<span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>i<span class="op">]));</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxFirstSum<span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        MaxSumOfTwoNonOverlapping solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaxSumOfTwoNonOverlapping</span><span class="op">();</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span><span class="dv">6</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">2</span><span class="op">,</span><span class="dv">5</span><span class="op">,</span><span class="dv">1</span><span class="op">,</span><span class="dv">9</span><span class="op">,</span><span class="dv">4</span><span class="op">};</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> firstLen <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> secondLen <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> solution<span class="op">.</span><span class="fu">maxSumTwoNoOverlap</span><span class="op">(</span>nums<span class="op">,</span> firstLen<span class="op">,</span> secondLen<span class="op">);</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Sum of Two Non-Overlapping Subarrays: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The method <code>maxSumTwoNoOverlap</code> finds the maximum sum of
two non-overlapping subarrays with lengths <code>firstLen</code> and
<code>secondLen</code>.</li>
<li>We use the <code>prefixSum</code> array to make quick sum
calculations for the subarrays.</li>
<li>The helper method <code>getMaxSum</code> finds the best sum of the
two non-overlapping subarrays with given lengths.</li>
<li>The main method shows a sample run with an array and the lengths of
the two subarrays.</li>
</ul>
<p>This code runs in O(n) time. Here, n is the length of the input
array. It processes the input in one pass. We also handle the prefix
sums in a smart way.</p>
<h2
id="python-implementation-of-maximum-sum-of-two-non-overlapping-subarrays">Python
Implementation of Maximum Sum of Two Non-Overlapping Subarrays</h2>
<p>We can solve the problem of finding the maximum sum of two
non-overlapping subarrays using dynamic programming. Here is the Python
code that follows this method.</p>
<h3 id="python-code">Python Code</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumTwoNoOverlap(nums, firstLen, secondLen):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> maxSum(length):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">=</span> <span class="bu">sum</span>(nums[:length])</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> current_sum</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length, <span class="bu">len</span>(nums)):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            current_sum <span class="op">+=</span> nums[i] <span class="op">-</span> nums[i <span class="op">-</span> length]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, current_sum)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_sum</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nums) <span class="op">-</span> firstLen <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        first_sum <span class="op">=</span> <span class="bu">sum</span>(nums[i:i <span class="op">+</span> firstLen])</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        second_max_sum <span class="op">=</span> maxSum(secondLen)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, first_sum <span class="op">+</span> second_max_sum)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nums) <span class="op">-</span> secondLen <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        second_sum <span class="op">=</span> <span class="bu">sum</span>(nums[i:i <span class="op">+</span> secondLen])</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        first_max_sum <span class="op">=</span> maxSum(firstLen)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, first_sum <span class="op">+</span> second_max_sum)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">0</span>,<span class="dv">6</span>,<span class="dv">5</span>,<span class="dv">2</span>,<span class="dv">2</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">9</span>,<span class="dv">4</span>]</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>firstLen <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>secondLen <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> maxSumTwoNoOverlap(nums, firstLen, secondLen)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 20</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>The function <code>maxSumTwoNoOverlap</code> takes the input array
and the lengths of the two subarrays.</li>
<li>There is a nested function <code>maxSum</code> that finds the
maximum sum of a subarray with a certain length.</li>
<li>The outer loop goes through the array to look at the first subarray.
The inner function finds the maximum possible sum of the second subarray
that does not overlap with the first.</li>
<li>The final result is the maximum sum we find by checking both orders
of the subarray lengths.</li>
</ul>
<p>We use dynamic programming here to make the search for maximum sums
better. This way, the two subarrays do not overlap, and we get the
result quickly.</p>
<p>For more problems and techniques in dynamic programming, we can check
these articles: - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Dynamic
Programming: Minimum Path Sum in a Grid</a></p>
<h2
id="c-implementation-of-maximum-sum-of-two-non-overlapping-subarrays">C++
Implementation of Maximum Sum of Two Non-Overlapping Subarrays</h2>
<p>To solve the problem of finding the maximum sum of two
non-overlapping subarrays in C++, we use a dynamic programming method.
We will keep two arrays to track the maximum sums of the first subarray
and the second subarray.</p>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<p>Here is a simple code to show the solution:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSumTwoNoOverlap<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> firstLen<span class="op">,</span> <span class="dt">int</span> secondLen<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> firstMax<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> secondMax<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate max sum of the first subarray of length firstLen</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> firstLen<span class="op">)</span> sum <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> firstLen<span class="op">];</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> firstLen <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> firstMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>firstMax<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> sum<span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Now calculate max sum of the second subarray of length secondLen</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> secondLen<span class="op">)</span> sum <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> secondLen<span class="op">];</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> secondLen <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                maxSum <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>maxSum<span class="op">,</span> sum <span class="op">+</span> <span class="op">(</span>i <span class="op">&gt;=</span> firstLen <span class="op">?</span> firstMax<span class="op">[</span>i <span class="op">-</span> secondLen<span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Reset and calculate for the case where second subarray comes first</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> secondLen<span class="op">)</span> sum <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> secondLen<span class="op">];</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> secondLen <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> secondMax<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>secondMax<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> sum<span class="op">);</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>        sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> firstLen<span class="op">)</span> sum <span class="op">-=</span> nums<span class="op">[</span>i <span class="op">-</span> firstLen<span class="op">];</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> firstLen <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>                maxSum <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>maxSum<span class="op">,</span> sum <span class="op">+</span> <span class="op">(</span>i <span class="op">&gt;=</span> secondLen <span class="op">?</span> secondMax<span class="op">[</span>i <span class="op">-</span> firstLen<span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create two vectors called
<code>firstMax</code> and <code>secondMax</code> to store the maximum
sums of two non-overlapping subarrays.</li>
<li><strong>First Subarray Calculation</strong>: We go through the array
to find the maximum sum of the first subarray of length
<code>firstLen</code> using a sliding window.</li>
<li><strong>Second Subarray Calculation</strong>: After we find the
first subarray sums, we go through the array again to find the maximum
sum of the second subarray of length <code>secondLen</code>. We add the
maximum from the first subarray that ends before the current index.</li>
<li><strong>Reverse Order</strong>: We repeat the steps where we swap
the roles of <code>firstLen</code> and <code>secondLen</code>. This way,
we check both configurations.</li>
<li><strong>Return Result</strong>: Finally, we return the maximum sum
we found.</li>
</ol>
<p>This code works well and runs in O(n) time with O(n) extra space for
the maximum sums. It is good for large inputs. For more about dynamic
programming, you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2 id="optimizations-and-time-complexity-analysis">Optimizations and
Time Complexity Analysis</h2>
<p>When we want to find the biggest sum of two non-overlapping
subarrays, we can use some tricks to make our dynamic programming
solution work better.</p>
<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>
<ol type="1">
<li><strong>Space Complexity</strong>:
<ul>
<li>Our algorithm mainly uses two arrays. One array keeps track of the
biggest sum up to each index for the first subarray. The other array
does the same for the second subarray. So, we have a space complexity of
(O(n)). Here, (n) means the length of the input array.</li>
</ul></li>
<li><strong>Time Complexity</strong>:
<ul>
<li>The total time complexity is (O(n)). We go through the array a few
times, usually three times. We do this by keeping track of total sums
and using prefix maximums. This way, we avoid doing calculations again
and again.</li>
</ul></li>
</ol>
<h3 id="optimizations">Optimizations</h3>
<ul>
<li><p><strong>Prefix Maximums</strong>: We can calculate the maximum
sum of subarrays that end at each index ahead of time. This helps us use
these values quickly and reduces the need for nested loops.</p></li>
<li><p><strong>Single Pass Calculation</strong>: Instead of using nested
loops to check every possible pair of subarrays, we can find the maximum
sums in one go. This cuts down the number of operations a lot.</p></li>
</ul>
<h3 id="example-implementation">Example Implementation</h3>
<p>Here is an optimized code in Python:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumTwoNoOverlap(nums, firstLen, secondLen):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    first_max <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    second_max <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate first_max</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    curr_sum <span class="op">=</span> <span class="bu">sum</span>(nums[:firstLen])</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    first_max[firstLen <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> curr_sum</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(firstLen, n):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        curr_sum <span class="op">+=</span> nums[i] <span class="op">-</span> nums[i <span class="op">-</span> firstLen]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        first_max[i] <span class="op">=</span> <span class="bu">max</span>(first_max[i <span class="op">-</span> <span class="dv">1</span>], curr_sum)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate second_max and find the maximum sum</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    curr_sum <span class="op">=</span> <span class="bu">sum</span>(nums[:secondLen])</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(secondLen <span class="op">-</span> <span class="dv">1</span>, n):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;=</span> secondLen:</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            curr_sum <span class="op">+=</span> nums[i] <span class="op">-</span> nums[i <span class="op">-</span> secondLen]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, curr_sum <span class="op">+</span> (first_max[i <span class="op">-</span> secondLen] <span class="cf">if</span> i <span class="op">&gt;=</span> secondLen <span class="cf">else</span> <span class="dv">0</span>))</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li><strong>Dynamic Programming</strong>: This way uses dynamic
programming ideas. We store and get maximum sums easily.</li>
<li><strong>Avoiding Redundant Calculations</strong>: By separating the
two non-overlapping subarray sums, we cut down on unneeded calculations.
This makes our algorithm faster.</li>
</ul>
<p>With these optimizations, our algorithm stays fast and can handle
bigger datasets well. For more information, check out related articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-increasing-subsequence-medium.html">Dynamic
Programming Maximum Sum Increasing Subsequence</a>.</p>
<h2 id="alternative-approaches-to-solve-the-problem">Alternative
Approaches to Solve the Problem</h2>
<p>We know the dynamic programming method is good for finding the
maximum sum of two non-overlapping subarrays. But, there are other ways
we can try. Here are a few important methods:</p>
<ol type="1">
<li><p><strong>Brute Force Approach</strong>:</p>
<ul>
<li>This method checks all possible pairs of non-overlapping subarrays.
We do this by going through the array many times.</li>
<li>We choose all possible pairs of subarray indices. Then, we calculate
the sum for each pair.</li>
</ul>
<p><strong>Time Complexity</strong>: O(n^3) - This method is not good
for large arrays.</p>
<p><strong>Example</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumTwoNoOverlap(arr, L, M):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> L, n):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            sum_L <span class="op">=</span> <span class="bu">sum</span>(arr[i:i <span class="op">+</span> L])</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            sum_M <span class="op">=</span> <span class="bu">sum</span>(arr[j:j <span class="op">+</span> M])</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, sum_L <span class="op">+</span> sum_M)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div></li>
<li><p><strong>Prefix Sum Array</strong>:</p>
<ul>
<li>We can use the prefix sum technique to prepare the input array. This
helps us quickly calculate the sum of any subarray.</li>
<li>This method makes a prefix sum array. Each element at index
<code>i</code> shows the sum from the start of the array to index
<code>i</code>.</li>
</ul>
<p><strong>Implementation</strong>:</p>
<ul>
<li>First, we calculate prefix sums. Then we check possible split points
to find the best sums of two non-overlapping subarrays.</li>
</ul>
<p><strong>Time Complexity</strong>: O(n^2) - This is better than brute
force but still not the best.</p>
<p><strong>Example</strong>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumTwoNoOverlap(arr, L, M):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        prefix_sum[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> prefix_sum[i] <span class="op">+</span> arr[i]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> L, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            sum_L <span class="op">=</span> prefix_sum[i <span class="op">+</span> L] <span class="op">-</span> prefix_sum[i]</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            sum_M <span class="op">=</span> prefix_sum[j] <span class="op">-</span> prefix_sum[j <span class="op">-</span> M]</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, sum_L <span class="op">+</span> sum_M)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div></li>
<li><p><strong>Sliding Window Technique</strong>:</p>
<ul>
<li>We can keep a sliding window of sums for L and M lengths. This helps
us change our indices to find non-overlapping subarrays faster.</li>
<li>This method needs less nested loops, so it is quicker.</li>
</ul>
<p><strong>Implementation</strong>:</p>
<ul>
<li>We use two pointers to keep the sum of the current window. We also
update the maximum sums as we go.</li>
</ul>
<p><strong>Time Complexity</strong>: O(n) - This is better for big
datasets.</p></li>
</ol>
<p>We can also explore more ways to improve this. For example, we can
use hash maps to store sums we already calculated. This stops us from
calculating them again. For more on dynamic programming, you can check
out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming Fibonacci with Memoization</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2 id="common-mistakes-and-how-to-avoid-them">Common Mistakes and How
to Avoid Them</h2>
<p>When we work on the Maximum Sum of Two Non-Overlapping Subarrays
problem, we can make some common mistakes. These mistakes can lead to
wrong results or slow solutions. Here are some mistakes to watch out for
and how we can avoid them.</p>
<ol type="1">
<li><strong>Incorrect Subarray Boundaries</strong>:
<ul>
<li>We need to make sure the two subarrays do not overlap. A common
mistake is thinking the end of one subarray can be the same as the start
of the other.</li>
<li><strong>Avoidance</strong>: We should check that the indices for the
two subarrays always follow the non-overlapping rule.</li>
</ul></li>
<li><strong>Mismanagement of Prefix Sums</strong>:
<ul>
<li>Sometimes, we might not calculate prefix sums correctly. This can
lead to wrong subarray sums.</li>
<li><strong>Avoidance</strong>: We can test our prefix sum array with
known input values to make sure it adds sums right.</li>
</ul></li>
<li><strong>Not Considering All Possible Combinations</strong>:
<ul>
<li>If we don’t check all possible pairs of subarrays, we might miss the
best solution.</li>
<li><strong>Avoidance</strong>: We can use nested loops or a clear
method to check all combinations of subarrays.</li>
</ul></li>
<li><strong>Inefficient Time Complexity</strong>:
<ul>
<li>A simple solution might have O(n^2) time complexity, which is not
the best.</li>
<li><strong>Avoidance</strong>: We can use dynamic programming to keep
track of maximum sums. This way we can reach a linear time
complexity.</li>
</ul></li>
<li><strong>Off-By-One Errors</strong>:
<ul>
<li>We can make indexing mistakes, like starting from the wrong index or
using wrong bounds in loops. This can give wrong results.</li>
<li><strong>Avoidance</strong>: We should double-check loop limits and
make sure they match the expected indices of the array.</li>
</ul></li>
<li><strong>Failing to Handle Edge Cases</strong>:
<ul>
<li>Edge cases like arrays with less than two elements can cause
problems if we do not handle them well.</li>
<li><strong>Avoidance</strong>: We can add checks at the start of our
function to handle these cases properly or return early.</li>
</ul></li>
<li><strong>Inadequate Testing</strong>:
<ul>
<li>If we only test with a few cases, we might miss some bugs.</li>
<li><strong>Avoidance</strong>: We should create a full test suite to
cover many situations, including edge cases and large inputs.</li>
</ul></li>
</ol>
<p>By knowing these common mistakes and using ways to avoid them, we can
make our solutions for the Maximum Sum of Two Non-Overlapping Subarrays
problem better and faster.</p>
<p>For more insights into dynamic programming, we can look at articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-two-non-overlapping-subarrays-problem">1.
What is the maximum sum of two non-overlapping subarrays problem?</h3>
<p>The maximum sum of two non-overlapping subarrays problem is about
finding two subarrays in a given array. These subarrays should not
overlap. We need to find the highest sum when we add them together. This
task needs us to think carefully about where we place the subarrays. It
is a well-known dynamic programming problem. To learn more, please check
our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-increasing-subsequence-medium.html">Dynamic
Programming</a>.</p>
<h3 id="how-can-dynamic-programming-help-solve-this-problem">2. How can
dynamic programming help solve this problem?</h3>
<p>We can use dynamic programming to solve the maximum sum of two
non-overlapping subarrays problem. We break the problem into smaller
parts. We find the maximum sum up to each index for both left and right
subarrays. This way, we can find the best places to split the array and
get the highest total sum. For more details, look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h3 id="what-is-the-time-complexity-of-the-solution">3. What is the time
complexity of the solution?</h3>
<p>The time complexity of the dynamic programming solution for this
problem is O(n). Here, n is the size of the input array. We achieve this
by going through the array a few times to get the sums we need. This
makes the method good for large datasets. For more on time complexity in
dynamic programming, read our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Dynamic
Programming - Minimum Path Sum</a>.</p>
<h3 id="can-we-solve-the-problem-using-a-brute-force-approach">4. Can we
solve the problem using a brute force approach?</h3>
<p>Yes, we can solve the problem with a brute force method but it is not
a good idea. This way would check all pairs of subarrays. This leads to
a time complexity of O(n^3). This is much slower than the best dynamic
programming solution. For more on how to think about algorithm
efficiency, see our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h3 id="what-are-some-common-mistakes-when-solving-this-problem">5. What
are some common mistakes when solving this problem?</h3>
<p>Common mistakes when we solve the maximum sum of two non-overlapping
subarrays problem include not handling special cases well. For example,
arrays with less than two elements or those with negative numbers. Also,
not understanding that the subarrays should not overlap can cause wrong
answers. It is very important to define the subarray limits correctly.
For more tips to avoid errors in dynamic programming, check our article
on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            