
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Repeating Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Explore the Longest Repeating Subsequence in Dynamic Programming. Learn algorithms, examples, and tips for mastering this concept!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Repeating Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Repeating Subsequence (LRS) problem is a classic dynamic
programming challenge. The goal is to find the longest subsequence that
appears at least twice in a string. Unlike substrings, we get
subsequences by removing some characters from the original string. We do
this without changing the order of the remaining characters.</p>
<p>To solve this problem well, we can use a dynamic programming
approach. This method helps us build a solution step by step. We will
store results we find along the way. This way, we avoid doing the same
calculations again. In the end, we will know the length of the longest
repeating subsequence.</p>
<p>In this article, we will look closely at the Longest Repeating
Subsequence problem. We will start with a clear explanation of the
problem. Then, we will go through a complete dynamic programming
approach. We will share Java, Python, and C++ code examples for real
use.</p>
<p>We will also look at ways to save space, check the time it takes to
run, point out common mistakes we can make, and answer some frequently
asked questions. The sections we will cover include:</p>
<ul>
<li>Dynamic Programming Longest Repeating Subsequence Problem
Explained</li>
<li>Understanding the Problem Statement</li>
<li>Dynamic Programming Approach for Longest Repeating Subsequence</li>
<li>Java Implementation of Longest Repeating Subsequence</li>
<li>Python Code for Longest Repeating Subsequence</li>
<li>C++ Solution for Longest Repeating Subsequence</li>
<li>Optimizing Space Complexity in Longest Repeating Subsequence</li>
<li>Analyzing Time Complexity for Longest Repeating Subsequence</li>
<li>Common Mistakes in Longest Repeating Subsequence Implementation</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>The Longest Repeating Subsequence (LRS) problem is about finding the
longest subsequence in a string that shows up at least two times but
does not overlap. This is different from the Longest Common Subsequence
(LCS). In LCS, we compare two different sequences. But in LRS, we use
the same sequence for both times. This means the characters must come
from different places.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have a string <code>X</code>. Our job is to find the length of the
longest subsequence <code>Y</code> such that:</p>
<ul>
<li><code>Y</code> is a subsequence of <code>X</code></li>
<li>The occurrences of <code>Y</code> in <code>X</code> do not
overlap</li>
</ul>
<h3 id="example">Example</h3>
<p>For the string “AABEBCDD”, the longest repeating subsequence is
“ABD”. Its length is 3.</p>
<ul>
<li>The subsequence “ABD” shows up in the original string like this:
<ul>
<li>First occurrence: A <strong>A</strong> B <strong>B</strong> C
<strong>D</strong> <strong>D</strong></li>
<li>Second occurrence: <strong>A</strong> A <strong>B</strong> B
<strong>C</strong> <strong>D</strong> <strong>D</strong></li>
</ul></li>
</ul>
<h3 id="input-and-output">Input and Output</h3>
<ul>
<li><strong>Input</strong>: A string <code>X</code></li>
<li><strong>Output</strong>: An integer which tells the length of the
longest repeating subsequence</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The input string can be up to 1000 characters long.</li>
<li>The characters can be any printable ASCII character.</li>
</ul>
<p>We often solve this problem using dynamic programming. We make a 2D
table to keep track of our results and build up to the final answer. The
dynamic programming method looks at all pairs of indices in the string.
It checks if characters match while making sure they are not from the
same instance.</p>
<p>This LRS problem is similar to other dynamic programming problems,
like the Longest Common Subsequence (LCS). For more details on dynamic
programming techniques, you can visit the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2
id="dynamic-programming-approach-for-longest-repeating-subsequence">Dynamic
Programming Approach for Longest Repeating Subsequence</h2>
<p>The Longest Repeating Subsequence (LRS) problem is about finding the
longest part of a string that appears at least two times. We can have
repeated characters but we cannot use the same character from the same
position. For example, if we take the string “AABBC”, the longest
repeating subsequence is “AB”.</p>
<p>To solve this problem, we can use a dynamic programming method. We
will create a 2D table called <code>dp</code>. In this table,
<code>dp[i][j]</code> will hold the length of the longest repeating
subsequence for the first <code>i</code> characters of the string
<code>X</code> and the first <code>j</code> characters of the same
string <code>X</code>. We need to make sure that <code>i</code> and
<code>j</code> do not point to the same position in the string.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>First, we create a 2D array <code>dp</code> with size
<code>(n+1) x (n+1)</code>. Here, <code>n</code> is the length of the
string.</li>
<li>We set all the elements in this array to 0.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>Next, we loop through the string with two loops. For each pair of
indices <code>i</code> and <code>j</code>:
<ul>
<li>If <code>X[i-1]</code> is equal to <code>X[j-1]</code> and
<code>i</code> is not equal to <code>j</code>, we add 1 to
<code>dp[i][j]</code> from <code>dp[i-1][j-1]</code>.</li>
<li>If not, we take the bigger value between <code>dp[i-1][j]</code> and
<code>dp[i][j-1]</code>.</li>
</ul></li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>Finally, the value at <code>dp[n][n]</code> tells us the length of
the longest repeating subsequence.</li>
</ul></li>
</ol>
<h3 id="dynamic-programming-table-update">Dynamic Programming Table
Update:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">longestRepeatingSubsequence</span><span class="op">(</span><span class="bu">String</span> X<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> X<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> X<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This algorithm works in O(n^2) time and uses O(n^2) space. For better
performance, check the next section about space complexity.</p>
<h2 id="java-implementation-of-longest-repeating-subsequence">Java
Implementation of Longest Repeating Subsequence</h2>
<p>We can solve the Longest Repeating Subsequence (LRS) problem in Java
using a simple dynamic programming method. We will create a 2D array
that helps us store the lengths of the longest repeating subsequences at
different points.</p>
<p>Here is the Java code for the Longest Repeating Subsequence:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestRepeatingSubsequence <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestRepeatingSubseq</span><span class="op">(</span><span class="bu">String</span> str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>str<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> str<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> str <span class="op">=</span> <span class="st">&quot;AABEBCDD&quot;</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;The length of the longest repeating subsequence is: &quot;</span> <span class="op">+</span> <span class="fu">longestRepeatingSubseq</span><span class="op">(</span>str<span class="op">));</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Input:</strong> We pass the input string to the
<code>longestRepeatingSubseq</code> method.</li>
<li><strong>DP Table Initialization:</strong> We create a 2D array
<code>dp</code> of size <code>(n+1) x (n+1)</code>. Here <code>n</code>
is the length of the input string.</li>
<li><strong>Filling the DP Table:</strong>
<ul>
<li>If the characters at positions <code>i-1</code> and <code>j-1</code>
are the same and the indices are not the same, we add one to the count
from the diagonal (<code>dp[i-1][j-1]</code>).</li>
<li>If not, we take the maximum from either the left
(<code>dp[i][j-1]</code>) or from above (<code>dp[i-1][j]</code>).</li>
</ul></li>
<li><strong>Output:</strong> The value in <code>dp[n][n]</code> gives us
the length of the longest repeating subsequence.</li>
</ul>
<p>This way, the program runs with O(n^2) time and uses O(n^2) space. It
is good for moderate input sizes. If you want to see more dynamic
programming problems, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2 id="python-code-for-longest-repeating-subsequence">Python Code for
Longest Repeating Subsequence</h2>
<p>We can solve the Longest Repeating Subsequence problem using dynamic
programming in Python. We will write a function that uses a 2D array.
This array will help us store the lengths of the longest repeating
subsequences for different parts of the input string.</p>
<p>Here is a simple code to do it:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_repeating_subsequence(seq):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(seq)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a 2D array to store lengths of longest repeating subsequence</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build the dp array</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If characters match and indexes are not the same</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> seq[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> seq[j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> i <span class="op">!=</span> j:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The length of the longest repeating subsequence</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][n]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>sequence <span class="op">=</span> <span class="st">&quot;AABEBCDD&quot;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Repeating Subsequence is&quot;</span>, longest_repeating_subsequence(sequence))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li><strong>Input:</strong> We take a string <code>seq</code> to find
the longest repeating subsequence.</li>
<li><strong>DP Table:</strong> We make a 2D list <code>dp</code>. This
list has size (n+1)x(n+1) to hold lengths based on subsequences.</li>
<li><strong>Nested Loop:</strong> We go through each character of the
string. We check if characters match and update the <code>dp</code>
table when needed.</li>
<li><strong>Result:</strong> The value at <code>dp[n][n]</code> tells us
the length of the longest repeating subsequence.</li>
</ul>
<p>This method has a time complexity of O(n^2) and space complexity of
O(n^2).</p>
<p>If we want to learn more about dynamic programming, we can read other
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2 id="c-solution-for-longest-repeating-subsequence">C++ Solution for
Longest Repeating Subsequence</h2>
<p>The Longest Repeating Subsequence (LRS) problem is to find the
longest part of a string that shows up at least two times. But we have
to make sure that the two parts do not come from the same place in the
original string.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ solution using dynamic programming:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestRepeatingSubsequence<span class="op">(</span>string str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>str<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> str<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    string str <span class="op">=</span> <span class="st">&quot;aabb&quot;</span><span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Repeating Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> longestRepeatingSubsequence<span class="op">(</span>str<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Dynamic Programming Table Initialization</strong>: We create
a 2D vector <code>dp</code> that has size <code>(n+1) x (n+1)</code>. We
set all values to zero. Here <code>n</code> is the length of the input
string.</li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>If the characters match and their positions are not the same, we add
one to the value from the diagonal cell <code>dp[i-1][j-1]</code>.</li>
<li>If they do not match, we take the bigger value from either the left
cell or the cell above.</li>
</ul></li>
<li><strong>Result</strong>: The length of the longest repeating
subsequence will be in <code>dp[n][n]</code>.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). This is because we have
nested loops, where n is the length of the input string.</li>
<li><strong>Space Complexity</strong>: O(n^2). This is for keeping the
DP table.</li>
</ul>
<p>This C++ solution works well to find the length of the longest
repeating subsequence. It works best for strings that are not too long.
To save more space, we can use a rolling array technique to reduce the
space needed to O(n).</p>
<p>For more problems on dynamic programming, check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2
id="optimizing-space-complexity-in-longest-repeating-subsequence">Optimizing
Space Complexity in Longest Repeating Subsequence</h2>
<p>When we work on the Longest Repeating Subsequence (LRS) problem using
Dynamic Programming, space complexity can be a problem. This is true
especially for bigger strings. The usual way uses a 2D array to keep
track of the lengths of subsequences. This leads to a space complexity
of O(n^2), where n is the length of the input string. But we can make
this better to O(n) space by using a 1D array.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<ol type="1">
<li><p><strong>Observation</strong>: The current state of the DP array
only needs the previous row. So, instead of keeping a full 2D table, we
can just store the current and previous rows.</p></li>
<li><p><strong>Implementation Steps</strong>:</p>
<ul>
<li>First, we create two 1D arrays called <code>current</code> and
<code>previous</code>, each of size n+1 for the lengths of
subsequences.</li>
<li>Next, we go through the string and update the <code>current</code>
array using the values from the <code>previous</code> array.</li>
<li>Once we finish processing, we swap the references of
<code>current</code> and <code>previous</code>.</li>
</ul></li>
</ol>
<p>Here is the optimized Java code:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestRepeatingSubsequence <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestRepeatingSubsequence</span><span class="op">(</span><span class="bu">String</span> str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> previous <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> current <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>str<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> str<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                    current<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> previous<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                    current<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>previous<span class="op">[</span>j<span class="op">],</span> current<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Swap references for the next iteration</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span><span class="op">[]</span> temp <span class="op">=</span> previous<span class="op">;</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> previous<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> str <span class="op">=</span> <span class="st">&quot;AABEBCDD&quot;</span><span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Repeating Subsequence is &quot;</span> <span class="op">+</span> <span class="fu">longestRepeatingSubsequence</span><span class="op">(</span>str<span class="op">));</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-benefits">Key Benefits</h3>
<ul>
<li><strong>Reduced Space Complexity</strong>: We lower the space
complexity from O(n^2) to O(n).</li>
<li><strong>Maintains Time Complexity</strong>: The time complexity
stays O(n^2) since we still check each character pair.</li>
</ul>
<p>By using this space optimization method, we can solve the Longest
Repeating Subsequence problem without using too much memory. If you want
to learn more about dynamic programming, you can check out related
problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2
id="analyzing-time-complexity-for-longest-repeating-subsequence">Analyzing
Time Complexity for Longest Repeating Subsequence</h2>
<p>We can find the time complexity of the Longest Repeating Subsequence
(LRS) problem using dynamic programming. We solve the LRS problem with a
2D table. The size of the table depends on the length of the input
string.</p>
<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>
<ol type="1">
<li><strong>Dynamic Programming Table Construction</strong>:
<ul>
<li>We make a 2D array called <code>dp</code>. Its size is
<code>(n+1) x (n+1)</code>, where <code>n</code> is the length of the
input string.</li>
<li>We need to look at each character of the input string with itself.
This makes a loop inside a loop.</li>
</ul></li>
<li><strong>Iterations</strong>:
<ul>
<li>The first loop goes for <code>n</code> times (for each character in
the string).</li>
<li>The second loop also goes for <code>n</code> times.</li>
<li>So, the total number of loops is <code>O(n^2)</code>.</li>
</ul></li>
<li><strong>Final Complexity</strong>:
<ul>
<li>Each time we do something in the loops (like checking characters and
changing the <code>dp</code> table) takes a constant time of
<code>O(1)</code>.</li>
<li>So, the total time complexity for the Longest Repeating Subsequence
is: [ O(n^2) ]</li>
</ul></li>
</ol>
<h3 id="example-1">Example</h3>
<p>For a string <code>s = "AABBC"</code>, we fill the dynamic
programming table by comparing the characters of the string. This gives
us a time complexity of <code>O(n^2)</code> as we said before.</p>
<h3 id="related-articles">Related Articles</h3>
<p>If we want to learn more about dynamic programming, we can check out
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>.</p>
<h2
id="common-mistakes-in-longest-repeating-subsequence-implementation">Common
Mistakes in Longest Repeating Subsequence Implementation</h2>
<p>When we implement the Longest Repeating Subsequence (LRS) with
dynamic programming, we can make some common mistakes. It is important
to see and avoid these mistakes for a good solution.</p>
<ol type="1">
<li><p><strong>Incorrect Initialization of DP Array</strong>:<br />
We need to make sure the DP table starts right. The first row and first
column should be zero. This shows subsequences of length zero.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// m and n are lengths of the input strings</span></span></code></pre></div></li>
<li><p><strong>Misunderstanding the Problem Definition</strong>:<br />
The LRS is not the same as the Longest Common Subsequence (LCS). The LRS
counts the same character only once in each subsequence. We must check
that indices are not the same when we compare.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>str1<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> str2<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">&amp;&amp;</span> i <span class="op">!=</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Improper Transition Logic</strong>:<br />
If we do not write the transition logic correctly, it can give wrong
values in the DP table. The transition must handle both cases: when
characters match and when they do not.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Boundary Conditions</strong>:<br />
We must pay attention to the array boundaries during looping. Small
mistakes can lead to errors or bad results.</p></li>
<li><p><strong>Not Returning the Correct Result</strong>:<br />
We find the final result for the LRS in <code>dp[m][n]</code>. We must
return this value correctly after we fill the DP table.</p></li>
<li><p><strong>Space Optimization Neglect</strong>:<br />
If space usage is important, we can use a rolling array. This reduces
space from O(m*n) to O(n). We can do this by only saving the current and
previous rows of the DP table.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> prev <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> curr <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span></code></pre></div></li>
<li><p><strong>Failure to Handle Edge Cases</strong>:<br />
We should always test our code with edge cases. This means checking
empty strings or strings with no repeating characters. This helps us
make sure our code is strong.</p></li>
<li><p><strong>Ignoring Time Complexity</strong>:<br />
The usual time complexity for LRS is O(m*n). We must make sure our code
follows this rule. We should not add extra loops or unneeded
calculations.</p></li>
</ol>
<p>By knowing these common mistakes, we can implement the Longest
Repeating Subsequence better. This helps both our accuracy and
performance in dynamic programming. For more knowledge on dynamic
programming, check out this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming article</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-longest-repeating-subsequence">What is the Longest
Repeating Subsequence?</h3>
<p>The Longest Repeating Subsequence (LRS) problem is about finding the
longest part in a string that appears at least two times and does not
overlap. We can solve this problem well using dynamic programming. We
make a table to keep track of the lengths of the longest repeating
subsequences. It is important to know how we can solve this problem to
get better at dynamic programming.</p>
<h3
id="how-is-dynamic-programming-used-in-longest-repeating-subsequence">How
is Dynamic Programming Used in Longest Repeating Subsequence?</h3>
<p>Dynamic Programming (DP) plays a key role in solving the Longest
Repeating Subsequence problem. We create a 2D array. Each cell (i, j)
shows the length of the longest repeating subsequence we have found. We
compare characters and update the DP table based on what we found
before. This way, we can find the final answer in a good way. This
method helps us avoid doing the same calculations again, so it is
faster.</p>
<h3 id="what-are-common-mistakes-made-in-lrs-implementation">What are
Common Mistakes Made in LRS Implementation?</h3>
<p>When we implement the Longest Repeating Subsequence, we often make
some mistakes. One common mistake is not setting up the DP table
correctly. We might forget to think about non-overlapping subsequences.
Another mistake is not understanding when to update the DP table. This
can give us wrong results. We need to pay close attention to these
points to make sure our implementation works well.</p>
<h3
id="can-the-longest-repeating-subsequence-be-optimized-for-space-complexity">Can
the Longest Repeating Subsequence be Optimized for Space
Complexity?</h3>
<p>Yes, we can make the space used by the Longest Repeating Subsequence
algorithm better. Instead of using a 2D DP array, we can use two 1D
arrays. These will hold the current and previous states of our
calculations. This way, we lower the space complexity from O(n^2) to
O(n). It makes our solution faster while keeping the same time
complexity.</p>
<h3
id="what-is-the-time-complexity-of-the-longest-repeating-subsequence-algorithm">What
is the Time Complexity of the Longest Repeating Subsequence
Algorithm?</h3>
<p>The time complexity for the Longest Repeating Subsequence algorithm
with dynamic programming is O(n^2). Here, n is the length of the input
string. This complexity comes from filling an n x n DP table. We compare
each character in the string to every other character. It is important
to understand this complexity to see how efficient our implementation
is.</p>
<p>For more insight into dynamic programming concepts, check out related
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            