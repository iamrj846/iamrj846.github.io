
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Binary Strings Without Consecutive Ones - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn to count binary strings without consecutive ones using dynamic programming. Simplify your coding skills with our guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Binary Strings Without Consecutive Ones - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Counting binary strings without consecutive ones is a well-known
dynamic programming problem. Our goal is to find how many valid binary
strings of a certain length <code>n</code> do not have the substring
“11”. We can solve this problem using dynamic programming. We will keep
an array to store the counts of valid strings based on their lengths. We
will use previous results to help us build the solution easily.</p>
<p>In this article, we will look closely at this problem. First, we will
make sure we understand the problem statement. Then, we will look at a
dynamic programming approach in Java. After that, we will see how to do
it in Python and C++. We will also talk about ways to make it use less
space. We will look at recursive methods with memoization and iterative
methods too. Finally, we will compare different strategies to solve the
problem. We will end with some frequently asked questions about counting
binary strings without consecutive ones.</p>
<ul>
<li>[Dynamic Programming] Count Binary Strings Without Consecutive Ones
Solution Guide</li>
<li>Understanding the Problem Statement for Count Binary Strings Without
Consecutive Ones</li>
<li>Dynamic Programming Approach for Count Binary Strings Without
Consecutive Ones in Java</li>
<li>Dynamic Programming Solution for Count Binary Strings Without
Consecutive Ones in Python</li>
<li>C++ Implementation of Count Binary Strings Without Consecutive Ones
Using Dynamic Programming</li>
<li>Optimizing Space Complexity in Count Binary Strings Without
Consecutive Ones</li>
<li>Recursive Approach with Memoization for Count Binary Strings Without
Consecutive Ones</li>
<li>Iterative Approach for Count Binary Strings Without Consecutive
Ones</li>
<li>Comparative Analysis of Different Approaches for Count Binary
Strings Without Consecutive Ones</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">this
article on the Fibonacci number</a>. Also, understanding the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">dynamic
programming approach to climbing stairs</a> can help us with similar
problems that use recursive structures.</p>
<h2
id="understanding-the-problem-statement-for-count-binary-strings-without-consecutive-ones">Understanding
the Problem Statement for Count Binary Strings Without Consecutive
Ones</h2>
<p>The problem “Count Binary Strings Without Consecutive Ones” asks us
to find how many binary strings of length <code>n</code> do not have
consecutive <code>1</code>s.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an integer <code>n</code>. Our goal is to count the valid
binary strings of length <code>n</code> that follow these rules:</p>
<ul>
<li>The string can only use <code>0</code> and <code>1</code>.</li>
<li>There cannot be two <code>1</code>s next to each other in the
string.</li>
</ul>
<h3 id="examples">Examples</h3>
<ol type="1">
<li>For <code>n = 2</code>, the valid binary strings are:
<ul>
<li>“00”</li>
<li>“01”</li>
<li>“10”</li>
<li>Total: 3 valid strings.</li>
</ul></li>
<li>For <code>n = 3</code>, the valid binary strings are:
<ul>
<li>“000”</li>
<li>“001”</li>
<li>“010”</li>
<li>“100”</li>
<li>“101”</li>
<li>Total: 5 valid strings.</li>
</ul></li>
</ol>
<h3 id="observations">Observations</h3>
<ul>
<li>The first character of the string can be <code>0</code> or
<code>1</code>.</li>
<li>If the first character is <code>0</code>, the rest <code>n-1</code>
characters can be any valid string of length <code>n-1</code>.</li>
<li>If the first character is <code>1</code>, the next character must be
<code>0</code>. This leaves us with <code>n-2</code> characters to make
a valid string of length <code>n-2</code>.</li>
</ul>
<h3 id="recursive-relation">Recursive Relation</h3>
<p>Let <code>f(n)</code> be the number of valid binary strings of length
<code>n</code>. We can write the relation like this:</p>
<pre><code>f(n) = f(n-1) + f(n-2)</code></pre>
<ul>
<li><code>f(n-1)</code>: This is when the first character is
<code>0</code>.</li>
<li><code>f(n-2)</code>: This is when the first two characters are
<code>10</code>.</li>
</ul>
<h3 id="base-cases">Base Cases</h3>
<p>To solve this problem using recursion or dynamic programming, we need
base cases: - <code>f(1) = 2</code> (strings are: “0”, “1”) -
<code>f(2) = 3</code> (strings are: “00”, “01”, “10”)</p>
<p>This understanding of the problem is important for us to start
implementing the solution using dynamic programming methods.</p>
<h2
id="dynamic-programming-approach-for-count-binary-strings-without-consecutive-ones-in-java">Dynamic
Programming Approach for Count Binary Strings Without Consecutive Ones
in Java</h2>
<p>To count binary strings without consecutive ones using dynamic
programming in Java, we need to set our state and transition rules. We
want to find out how many valid binary strings of length <code>n</code>
do not have consecutive <code>1</code>s.</p>
<h3 id="state-definition">State Definition</h3>
<p>Let: - <code>dp[i]</code> be the count of valid binary strings of
length <code>i</code>.</p>
<h3 id="transition-relations">Transition Relations</h3>
<ol type="1">
<li>If the last character of the string is <code>0</code>, then the
first <code>i-1</code> characters can be any valid string of length
<code>i-1</code>.</li>
<li>If the last character is <code>1</code>, then the character before
it must be <code>0</code>, and the first <code>i-2</code> characters can
be any valid string of length <code>i-2</code>.</li>
</ol>
<p>So, we can get the relation: [ dp[i] = dp[i-1] + dp[i-2] ]</p>
<h3 id="base-cases-1">Base Cases</h3>
<ul>
<li><code>dp[1] = 2</code>: The valid strings are <code>0</code>,
<code>1</code>.</li>
<li><code>dp[2] = 3</code>: The valid strings are <code>00</code>,
<code>01</code>, <code>10</code>.</li>
</ul>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a simple Java code to implement the above logic:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountBinaryStrings <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countBinaryStrings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// &quot;00&quot;, &quot;01&quot;, &quot;10&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// 0, 1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// 00, 01, 10</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Count of binary strings of length &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; without consecutive ones is: &quot;</span> <span class="op">+</span> <span class="fu">countBinaryStrings</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The <code>countBinaryStrings</code> method finds the count of binary
strings of length <code>n</code> using dynamic programming.</li>
<li>We start by setting the base cases. Then, a loop fills the
<code>dp</code> array based on the transition rules we defined
before.</li>
<li>The main method shows how to use this function with example input
<code>n</code>.</li>
</ul>
<p>This dynamic programming method is efficient. It has a time
complexity of ( O(n) ) and a space complexity of ( O(n) ). We can make
it even better. We can reduce the space complexity to ( O(1) ) by
keeping only the last two values instead of the whole array.</p>
<p>For more information on dynamic programming methods, you can read
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2
id="dynamic-programming-solution-for-count-binary-strings-without-consecutive-ones-in-python">Dynamic
Programming Solution for Count Binary Strings Without Consecutive Ones
in Python</h2>
<p>We want to count binary strings that do not have consecutive ones. We
will use dynamic programming in Python to solve this problem. We can do
this with a simple formula based on how valid binary strings look.</p>
<h3 id="problem-understanding">Problem Understanding</h3>
<p>We have a binary string that is <code>n</code> long. Our goal is to
count all valid strings that do not have consecutive ’1’s.</p>
<h3 id="recurrence-relation">Recurrence Relation</h3>
<p>Let: - <code>dp[i]</code> be the number of valid binary strings that
are length <code>i</code>.</p>
<p>The formula is: - <code>dp[i] = dp[i-1] + dp[i-2]</code> -
<code>dp[i-1]</code> counts all binary strings of length
<code>i-1</code> that end with ‘0’. - <code>dp[i-2]</code> counts adding
‘10’ to all valid binary strings of length <code>i-2</code>.</p>
<h3 id="base-cases-2">Base Cases</h3>
<ul>
<li><code>dp[1] = 2</code> (Valid strings: “0”, “1”)</li>
<li><code>dp[2] = 3</code> (Valid strings: “00”, “01”, “10”)</li>
</ul>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is how we can write this in Python:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countBinaryStrings(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Count of binary strings of length </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> without consecutive ones: </span><span class="sc">{</span>countBinaryStrings(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>We create a function <code>countBinaryStrings</code> that takes a
number <code>n</code>.</li>
<li>We check base cases for <code>n = 1</code> and
<code>n = 2</code>.</li>
<li>We make an array <code>dp</code> to store counts of valid strings
for each length up to <code>n</code>.</li>
<li>We fill the <code>dp</code> array using our formula.</li>
<li>In the end, the function gives the count for the length
<code>n</code>.</li>
</ul>
<p>This method runs in O(n) time and needs O(n) space. So it is good for
this problem.</p>
<p>For more ideas on related dynamic programming problems, we can look
at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2
id="c-implementation-of-count-binary-strings-without-consecutive-ones-using-dynamic-programming">C++
Implementation of Count Binary Strings Without Consecutive Ones Using
Dynamic Programming</h2>
<p>We can count the number of binary strings of length <code>n</code>
without consecutive ones by using Dynamic Programming. We define two
states:</p>
<ol type="1">
<li><code>zero[n]</code>: This counts binary strings of length
<code>n</code> that end with 0.</li>
<li><code>one[n]</code>: This counts binary strings of length
<code>n</code> that end with 1.</li>
</ol>
<p>We can find relationships like this:</p>
<ul>
<li><code>zero[n] = zero[n-1] + one[n-1]</code> (We can add a ‘0’ to
both types of strings of length <code>n-1</code>)</li>
<li><code>one[n] = zero[n-1]</code> (We can only add a ‘1’ to strings
that end with ‘0’)</li>
</ul>
<p>The total count of valid binary strings of length <code>n</code>
is:</p>
<pre><code>count[n] = zero[n] + one[n]</code></pre>
<p>The base cases are: - <code>zero[1] = 1</code> (This is just “0”) -
<code>one[1] = 1</code> (This is just “1”)</p>
<p>Here is the C++ code:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countBinaryStrings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> zero<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> one<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    zero<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// &quot;0&quot;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    one<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// &quot;1&quot;</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        zero<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> zero<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> one<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        one<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> zero<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> zero<span class="op">[</span>n<span class="op">]</span> <span class="op">+</span> one<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter the length of binary strings: &quot;</span><span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Count of binary strings of length &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; without consecutive ones: &quot;</span> <span class="op">&lt;&lt;</span> countBinaryStrings<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code:</h3>
<p>We have a function called <code>countBinaryStrings</code>. It finds
the number of binary strings without consecutive ones for a length
<code>n</code>.</p>
<p>First, it sets up two vectors <code>zero</code> and <code>one</code>.
These keep track of counts for each length up to <code>n</code>.</p>
<p>Then, a loop goes from 2 to <code>n</code>, calculating the counts
based on the relationships we defined before.</p>
<p>In the end, it gives back the total count of valid binary
strings.</p>
<p>This way, we can solve the problem in (O(n)) time. The space needed
is also (O(n)). This makes it good for larger values of
<code>n</code>.</p>
<p>For more information on similar dynamic programming problems, you can
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2
id="optimizing-space-complexity-in-count-binary-strings-without-consecutive-ones">Optimizing
Space Complexity in Count Binary Strings Without Consecutive Ones</h2>
<p>We want to optimize space complexity for counting binary strings
without consecutive ones. We can use a dynamic programming method that
saves space. The important point is that the state at position
<code>n</code> only relies on the last two positions (<code>n-1</code>
and <code>n-2</code>). So we can lower the space complexity from O(n) to
O(1) by keeping only the last two values.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<ol type="1">
<li><strong>Define Variables</strong>: We use two variables to track the
last two counts. This is better than using a full array.</li>
<li><strong>Iterate and Update</strong>: We update these variables as we
find the current count based on the earlier two counts.</li>
</ol>
<h3 id="code-implementation-in-java">Code Implementation in Java</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountBinaryStrings <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countBinaryStrings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev2 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Count for n=1</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Count for n=2</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span> <span class="co">// Current count using the last two counts</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> prev1<span class="op">;</span>            <span class="co">// Update prev2 to prev1</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> current<span class="op">;</span>          <span class="co">// Update prev1 to current</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example for n=5</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Count of binary strings of length &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; without consecutive ones: &quot;</span> <span class="op">+</span> <span class="fu">countBinaryStrings</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="code-implementation-in-python">Code Implementation in
Python</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_binary_strings(n):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">2</span>  <span class="co"># &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    prev2, prev1 <span class="op">=</span> <span class="dv">1</span>, <span class="dv">2</span>  <span class="co"># Counts for n=1 and n=2</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2  <span class="co"># Current count using the last two counts</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1            <span class="co"># Update prev2 to prev1</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current          <span class="co"># Update prev1 to current</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Example for n=5</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Count of binary strings of length </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> without consecutive ones: </span><span class="sc">{</span>count_binary_strings(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="code-implementation-in-c">Code Implementation in C++</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countBinaryStrings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev2 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Count for n=1</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Count for n=2</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span> <span class="co">// Current count using the last two counts</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span>            <span class="co">// Update prev2 to prev1</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span>          <span class="co">// Update prev1 to current</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example for n=5</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Count of binary strings of length &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; without consecutive ones: &quot;</span> <span class="op">&lt;&lt;</span> countBinaryStrings<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This way, we cut down the space complexity to O(1). The time
complexity stays at O(n). This makes it fast for bigger <code>n</code>.
If we want more info on dynamic programming, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> article.</p>
<h2
id="recursive-approach-with-memoization-for-count-binary-strings-without-consecutive-ones">Recursive
Approach with Memoization for Count Binary Strings Without Consecutive
Ones</h2>
<p>We can use a recursive method to count binary strings that do not
have consecutive ones. This method combines a top-down approach with
memoization. The main goal is to find the number of valid binary strings
of length <code>n</code>. We store the results we calculate so we do not
do the same work again.</p>
<h3 id="recursive-function-definition">Recursive Function
Definition</h3>
<p>Let’s define <code>countBinaryStrings(n)</code> as the function that
gives us the count of valid binary strings of length <code>n</code>. We
can break down the problem like this:</p>
<ul>
<li>If the last digit is <code>0</code>, the digit before it can be
either <code>0</code> or <code>1</code>. So we can add <code>0</code> to
the valid strings of length <code>n-1</code>.</li>
<li>If the last digit is <code>1</code>, the digit before it must be
<code>0</code>. In this case, we can only add <code>1</code> to valid
strings of length <code>n-2</code>.</li>
</ul>
<p>This gives us the following relation:</p>
<pre><code>countBinaryStrings(n) = countBinaryStrings(n-1) + countBinaryStrings(n-2)</code></pre>
<p>We have some base cases: - <code>countBinaryStrings(1) = 2</code>
(valid strings: “0”, “1”) - <code>countBinaryStrings(2) = 3</code>
(valid strings: “00”, “01”, “10”)</p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Here is how we can implement the recursive approach with memoization
in Python:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countBinaryStrings(n, memo<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> memo <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        memo <span class="op">=</span> {}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> countBinaryStrings(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> countBinaryStrings(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countBinaryStrings(n))  <span class="co"># Output: 8</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li>The function <code>countBinaryStrings</code> takes a number
<code>n</code> and an optional dictionary <code>memo</code> to keep the
results.</li>
<li>If <code>n</code> is already in <code>memo</code>, it just gives
back that value.</li>
<li>For <code>n = 1</code> and <code>n = 2</code>, it returns the known
results.</li>
<li>For other numbers, it calculates the result using recursion and
saves it in <code>memo</code> before giving it back.</li>
</ul>
<p>This recursive approach with memoization makes the time it takes much
lower. We can now find the count of binary strings without consecutive
ones for bigger values of <code>n</code> easily.</p>
<h2
id="iterative-approach-for-count-binary-strings-without-consecutive-ones">Iterative
Approach for Count Binary Strings Without Consecutive Ones</h2>
<p>We use an iterative way to count binary strings without consecutive
ones. This method is based on dynamic programming. The main idea is to
have two variables. One variable counts valid strings that end with ‘0’
and the other counts those that end with ‘1’.</p>
<h3 id="dynamic-programming-array-representation">Dynamic Programming
Array Representation</h3>
<p>Let: - <code>dp[i]</code> be the number of valid binary strings of
length <code>i</code>.</p>
<p>We can define the relation like this: -
<code>dp[i] = dp[i-1] + dp[i-2]</code> - <code>dp[i-1]</code>: This is
when we add ‘0’ to all valid strings of length <code>i-1</code>. -
<code>dp[i-2]</code>: This is when we add ‘10’ to all valid strings of
length <code>i-2</code>.</p>
<h3 id="base-cases-3">Base Cases</h3>
<ul>
<li><code>dp[1] = 2</code> (the strings are “0” and “1”)</li>
<li><code>dp[2] = 3</code> (the strings are “00”, “01”, “10”)</li>
</ul>
<h3 id="iterative-implementation">Iterative Implementation</h3>
<p>Here is the Python code to implement this:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countBinaryStrings(n):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span>  <span class="co"># &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span>  <span class="co"># &quot;00&quot;, &quot;01&quot;, &quot;10&quot;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countBinaryStrings(n))  <span class="co"># Output: 13</span></span></code></pre></div>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) because we calculate each
<code>dp[i]</code> just once.</li>
<li><strong>Space Complexity</strong>: O(n) to keep the <code>dp</code>
array.</li>
</ul>
<h3 id="optimized-space-complexity">Optimized Space Complexity</h3>
<p>If we want to save space, we can change the space complexity to O(1).
We just need to keep the last two results:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countBinaryStringsOptimized(n):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    prev2, prev1 <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span>  <span class="co"># dp[1] and dp[2]</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countBinaryStringsOptimized(n))  <span class="co"># Output: 13</span></span></code></pre></div>
<p>This way, we can count binary strings without consecutive ones. We do
it in a smart way while using less space.</p>
<h2
id="comparative-analysis-of-different-approaches-for-count-binary-strings-without-consecutive-ones">Comparative
Analysis of Different Approaches for Count Binary Strings Without
Consecutive Ones</h2>
<p>When we solve the problem of counting binary strings without
consecutive ones, we can use different ways. Each way has its own pros
and cons in terms of time complexity, space complexity, and how simple
the code is. Here, we look at the main methods: Dynamic Programming,
Recursive Approach with Memoization, and Iterative Approach.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) (we can make it O(1))</li>
</ul>
<p>This method uses an array to save the results of smaller problems. We
define the recurrence relation like this:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countBinaryStrings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// &quot;00&quot;, &quot;01&quot;, &quot;10&quot;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// &quot;0&quot;, &quot;1&quot;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// &quot;00&quot;, &quot;01&quot;, &quot;10&quot;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recursive-approach-with-memoization">2. Recursive Approach with
Memoization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
</ul>
<p>In this method, we use recursion and a cache to keep results of
already computed states. It is not as fast as the pure DP way because of
function call overhead but is easier to understand.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countBinaryStrings(n, memo<span class="op">=</span>{}):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">3</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> countBinaryStrings(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> countBinaryStrings(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span></code></pre></div>
<h3 id="iterative-approach">3. Iterative Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
</ul>
<p>This way uses less space. We only keep track of the last two computed
values. So, we do not need a full array.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countBinaryStrings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev2 <span class="op">=</span> <span class="dv">2</span><span class="op">,</span> prev1 <span class="op">=</span> <span class="dv">3</span><span class="op">,</span> current<span class="op">;</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comparative-summary">Comparative Summary</h3>
<ul>
<li><strong>Dynamic Programming</strong> gives a simple way to implement
that is efficient but uses more space.</li>
<li><strong>Recursive with Memoization</strong> is clear but can be slow
because of recursion, which might cause stack overflow with big
inputs.</li>
<li><strong>Iterative</strong> is the best for space and time while
still being simple.</li>
</ul>
<p>When we choose the right method, it depends on the specific needs of
the problem and the environment where the algorithm will run. For more
reading about dynamic programming, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-problem-statement-for-counting-binary-strings-without-consecutive-ones">1.
What is the problem statement for counting binary strings without
consecutive ones?</h3>
<p>The problem is to count binary strings without consecutive ones. We
need to find how many valid binary strings of length <code>n</code> can
be made so that no two ‘1’s are next to each other. This is a well-known
problem in dynamic programming. We can solve it by keeping track of
counts of valid strings that end in ’0’ and ‘1’. This way, we can avoid
having two ’1’s together. You can use dynamic programming methods
similar to those in problems like the Fibonacci sequence.</p>
<h3 id="how-can-dynamic-programming-be-applied-to-this-problem">2. How
can dynamic programming be applied to this problem?</h3>
<p>Dynamic programming (DP) works well for counting binary strings
without consecutive ones. We can define two states:
<code>countZero[n]</code> and <code>countOne[n]</code>. We can build our
solution step by step. A valid string of length <code>n</code> that ends
in ‘0’ can follow any valid string of length `n-1’. But a string that
ends in ‘1’ can only come after a string that ends in ‘0’. This method
helps us find the answer quickly in linear time.</p>
<h3
id="what-is-the-space-complexity-of-the-dynamic-programming-solution">3.
What is the space complexity of the dynamic programming solution?</h3>
<p>When we use dynamic programming to count binary strings without
consecutive ones, we can make the space complexity better from
<code>O(n)</code> to <code>O(1)</code>. We do not need to keep the
entire DP table. Instead, we can just keep the last two values we
calculated. This is enough because the current value only depends on the
last two. This change helps a lot when <code>n</code> is big. It uses
less memory and still works well.</p>
<h3
id="can-you-explain-the-recursive-approach-with-memoization-for-this-problem">4.
Can you explain the recursive approach with memoization for this
problem?</h3>
<p>The recursive approach with memoization means we solve the problem by
calling a function that counts valid strings. We store the results we
already found so we do not calculate them again. This method helps us
understand the problem better. We can write this in languages like
Python and Java, using dictionaries or arrays to save results. This
makes the time needed to solve the problem <code>O(n)</code> while
keeping the recursive logic clear.</p>
<h3
id="how-does-the-iterative-approach-compare-to-the-recursive-approach-for-counting-binary-strings">5.
How does the iterative approach compare to the recursive approach for
counting binary strings?</h3>
<p>The iterative approach to count binary strings without consecutive
ones is usually better than the recursive one. It does not use the call
stack. We can use a simple loop to build the count step by step. This
avoids the slowdowns that come from recursive calls. Both methods have
the same time complexity, but the iterative way uses less space and has
less chance of causing stack overflow. This makes it better for bigger
inputs. To understand more, we can look at dynamic programming solutions
for similar problems like the Fibonacci sequence.</p>
<p>For more information, you can check related dynamic programming
articles, like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            