
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Stone Game - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Master dynamic programming with our in-depth guide on the Stone Game. Learn strategies, solutions, and tips for success!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Stone Game - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Stone Game - Medium is a problem in dynamic programming. It
involves two players. They take turns to remove stones from a pile. The
goal is to get the highest score. To solve this problem, we can use many
methods like recursion, memoization, and bottom-up dynamic programming.
Each player’s strategy can change the game. So, it is very important to
think about the moves and what will happen next to find the best
solution.</p>
<p>In this article, we will look at different ways to solve the Stone
Game - Medium problem using dynamic programming. First, we will
understand what the problem is. Then, we will explore recursive
solutions in Java. Next, we will see dynamic programming methods in
Python and C++. We will talk about memoization techniques and a
bottom-up approach too. We will also discuss the best strategy with code
examples. Finally, we will check the time and space complexity. We will
end with common mistakes and questions that people often have about the
Stone Game - Medium.</p>
<ul>
<li>Dynamic Programming Approach to Solve Stone Game - Medium</li>
<li>Understanding the Problem Statement for Stone Game - Medium</li>
<li>Recursive Solution for Stone Game - Medium in Java</li>
<li>Dynamic Programming Solution for Stone Game - Medium in Python</li>
<li>Memoization Technique for Stone Game - Medium in C++</li>
<li>Bottom-Up Dynamic Programming Approach for Stone Game - Medium</li>
<li>Optimal Strategy for Stone Game - Medium with Code Examples</li>
<li>Time and Space Complexity Analysis for Stone Game - Medium</li>
<li>Common Pitfalls and Mistakes in Stone Game - Medium</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-stone-game---medium">Understanding
the Problem Statement for Stone Game - Medium</h2>
<p>In the Stone Game - Medium problem, we have an array of numbers that
show piles of stones. Two players take turns to pick stones. They can
choose stones from either the left end or the right end of the piles.
The goal is to collect the most stones by the end of the game. Here are
the rules:</p>
<ol type="1">
<li>Players can only take stones from the ends of the array.</li>
<li>Both players play their best, so they will always make the best
choice on their turn.</li>
<li>We need to find out who will win based on how the piles start.</li>
</ol>
<p>The game has some important parts:</p>
<ul>
<li><code>piles</code>: This is an array of numbers. Each
<code>piles[i]</code> shows how many stones are in the <code>i-th</code>
pile.</li>
<li>We have Player 1 and Player 2. Player 1 always goes first.</li>
</ul>
<p>The main challenge is to see if Player 1 can win the game by using
dynamic programming. We find out the result by looking at how many
stones each player has after they take all the piles.</p>
<h3 id="example">Example</h3>
<p>Let’s look at the piles array: <code>[5, 3, 4, 5]</code>.</p>
<ul>
<li>Player 1 can take either 5 stones from the left or 5 stones from the
right.</li>
<li>If Player 1 takes 5 from the left, then Player 2 can take 5 from the
right.</li>
<li>This leaves the piles as <code>[3, 4]</code>, and then Player 1 can
take 4, which gives the final counts.</li>
</ul>
<p>We want to create a plan that helps Player 1 get the most stones
while also making it hard for Player 2 to get stones. This way, we can
see if Player 1 can win when both play their best.</p>
<h2 id="recursive-solution-for-stone-game---medium-in-java">Recursive
Solution for Stone Game - Medium in Java</h2>
<p>The Stone Game problem has two players. They take stones from a pile.
The goal is to get the most stones. We can use a recursive method to
look at all the possible results for both players.</p>
<p>Here is how we can write the recursive solution in Java:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> StoneGame <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">stoneGame</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> piles<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">helper</span><span class="op">(</span>piles<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> piles<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">helper</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> piles<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">,</span> <span class="dt">int</span> aliceScore<span class="op">,</span> <span class="dt">int</span> bobScore<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>left <span class="op">&gt;</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> aliceScore <span class="op">&gt;</span> bobScore<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Alice picks the left pile</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> pickLeft <span class="op">=</span> <span class="fu">helper</span><span class="op">(</span>piles<span class="op">,</span> left <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> right<span class="op">,</span> aliceScore <span class="op">+</span> piles<span class="op">[</span>left<span class="op">],</span> bobScore<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Alice picks the right pile</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> pickRight <span class="op">=</span> <span class="fu">helper</span><span class="op">(</span>piles<span class="op">,</span> left<span class="op">,</span> right <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> aliceScore <span class="op">+</span> piles<span class="op">[</span>right<span class="op">],</span> bobScore<span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> pickLeft <span class="op">||</span> pickRight<span class="op">;</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        StoneGame game <span class="op">=</span> <span class="kw">new</span> <span class="fu">StoneGame</span><span class="op">();</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> piles <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>game<span class="op">.</span><span class="fu">stoneGame</span><span class="op">(</span>piles<span class="op">));</span> <span class="co">// Output: true</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>stoneGame</code> method starts the recursion. It calls the
<code>helper</code> function with the first game values.</li>
<li>The <code>helper</code> function checks if all stones are picked. It
does this by seeing if <code>left &gt; right</code>.</li>
<li>The function looks at two choices. It can pick stones from the left
or the right.</li>
<li>We keep track of scores for Alice and Bob. This helps us see if
Alice can win.</li>
</ul>
<p>This recursive solution is easy to understand. But it may not work
well for larger inputs. It has an exponential time complexity. For
better speed, we can think about using dynamic programming or
memoization.</p>
<h2
id="dynamic-programming-solution-for-stone-game---medium-in-python">Dynamic
Programming Solution for Stone Game - Medium in Python</h2>
<p>We can solve the Stone Game problem well using dynamic programming in
Python. This problem has two players. They take turns removing stones
from either end of a pile. Their goal is to get the highest score. We
want to find out the maximum score a player can get when both play their
best.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We define
<code>dp[i][j]</code> as the maximum score the first player can get from
the stones between indices <code>i</code> and <code>j</code>.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>If the first player takes the left stone (<code>stones[i]</code>),
the second player can choose between:
<ul>
<li><code>dp[i+2][j]</code> (if the second player takes the left stone
next) or</li>
<li><code>dp[i+1][j-1]</code> (if the second player takes the right
stone next).</li>
</ul></li>
<li>If the first player takes the right stone (<code>stones[j]</code>),
the second player can choose between:
<ul>
<li><code>dp[i][j-1]</code> (if the second player takes the left stone
next) or</li>
<li><code>dp[i+1][j-1]</code> (if the second player takes the right
stone next).</li>
</ul></li>
</ul>
<p>So, we can write the recurrence relation like this:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> <span class="bu">max</span>(stones[i] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">+</span><span class="dv">2</span>][j], dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]),</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>               stones[j] <span class="op">+</span> <span class="bu">min</span>(dp[i][j<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">+</span><span class="dv">1</span>][j<span class="op">-</span><span class="dv">1</span>]))</span></code></pre></div></li>
<li><p><strong>Base Case</strong>:</p>
<ul>
<li><code>dp[i][i] = stones[i]</code> (when there is only one
stone).</li>
<li><code>dp[i][i+1] = max(stones[i], stones[i+1])</code> (when there
are two stones).</li>
</ul></li>
</ol>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Here is a simple code for the dynamic programming solution for the
Stone Game:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stoneGame(stones):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(stones)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> stones[i]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(stones[i] <span class="op">+</span> <span class="bu">min</span>(dp[i <span class="op">+</span> <span class="dv">2</span>][j] <span class="cf">if</span> i <span class="op">+</span> <span class="dv">2</span> <span class="op">&lt;=</span> j <span class="cf">else</span> <span class="dv">0</span>, </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                                            dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> j <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>),</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                           stones[j] <span class="op">+</span> <span class="bu">min</span>(dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">&lt;=</span> j <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>,</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                                            dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> i <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;=</span> j <span class="op">-</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">0</span>))</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>stones <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(stoneGame(stones))  <span class="co"># Output: The maximum score the first player can achieve</span></span></code></pre></div>
<p>This code makes a 2D list <code>dp</code> to keep track of the
maximum scores for each group of stones. In the end, it returns the
maximum score we can get from the entire array.</p>
<p>For more reading on dynamic programming, we can check articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a> for more examples and tips.</p>
<h2 id="memoization-technique-for-stone-game---medium-in-c">Memoization
Technique for Stone Game - Medium in C++</h2>
<p>The Memoization technique helps us make recursive solutions faster.
We do this by saving results we already calculated. For the Stone Game
problem, we use memoization to skip repeated work. This makes our
program run better.</p>
<h3 id="problem-overview">Problem Overview</h3>
<p>In the Stone Game, players take turns to take stones from either end
of a row. The aim is to get the most stones. Each player knows the total
stones and how their opponent will play.</p>
<h3 id="c-implementation-with-memoization">C++ Implementation with
Memoization</h3>
<p>Here is a simple code example of the Stone Game with memoization in
C++:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;utility&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stoneGame<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> piles<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;,</span> <span class="dt">int</span><span class="op">,</span> pair_hash<span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">(</span>piles<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> piles<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> piles<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">,</span> <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;,</span> <span class="dt">int</span><span class="op">,</span> pair_hash<span class="op">&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>left <span class="op">==</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> piles<span class="op">[</span>left<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> key <span class="op">=</span> <span class="bu">std::</span>make_pair<span class="op">(</span>left<span class="op">,</span> right<span class="op">);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span>find<span class="op">(</span>key<span class="op">)</span> <span class="op">!=</span> memo<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">[</span>key<span class="op">];</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> takeLeft <span class="op">=</span> piles<span class="op">[</span>left<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>total<span class="op">(</span>piles<span class="op">,</span> left <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> right<span class="op">)</span> <span class="op">-</span> dp<span class="op">(</span>piles<span class="op">,</span> left <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> right<span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> takeRight <span class="op">=</span> piles<span class="op">[</span>right<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>total<span class="op">(</span>piles<span class="op">,</span> left<span class="op">,</span> right <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">-</span> dp<span class="op">(</span>piles<span class="op">,</span> left<span class="op">,</span> right <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>key<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>takeLeft<span class="op">,</span> takeRight<span class="op">);</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>key<span class="op">];</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> piles<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> left<span class="op">;</span> i <span class="op">&lt;=</span> right<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            sum <span class="op">+=</span> piles<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sum<span class="op">;</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> pair_hash <span class="op">{</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="kw">template</span> <span class="op">&lt;</span><span class="kw">class</span> T1<span class="op">,</span> <span class="kw">class</span> T2<span class="op">&gt;</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>size_t<span class="op"> </span><span class="kw">operator</span> <span class="op">()</span> <span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>pair<span class="op">&lt;</span>T1<span class="op">,</span> T2<span class="op">&gt;&amp;</span> pair<span class="op">)</span> <span class="at">const</span> <span class="op">{</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> hash1 <span class="op">=</span> <span class="bu">std::</span>hash<span class="op">&lt;</span>T1<span class="op">&gt;{}(</span>pair<span class="op">.</span>first<span class="op">);</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> hash2 <span class="op">=</span> <span class="bu">std::</span>hash<span class="op">&lt;</span>T2<span class="op">&gt;{}(</span>pair<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> hash1 <span class="op">^</span> hash2<span class="op">;</span> <span class="co">// Combine hashes</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Memoization Structure</strong>: We use an unordered map to
save results based on current left and right index.</li>
<li><strong>Recursive Function</strong>: The <code>dp</code> function
finds the most stones we can take starting from <code>left</code> and
<code>right</code>.</li>
<li><strong>Total Calculation</strong>: The <code>total</code> function
adds up stones between two indices to help us choose best.</li>
<li><strong>Pair Hashing</strong>: We define a custom hash function to
use pairs as keys in the unordered map.</li>
</ul>
<p>This code makes sure we only calculate the game state once for each
unique pair of indices. This cuts down the time it takes from very high
to much lower.</p>
<p>For more about dynamic programming techniques, check this article on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2
id="bottom-up-dynamic-programming-approach-for-stone-game---medium">Bottom-Up
Dynamic Programming Approach for Stone Game - Medium</h2>
<p>In the Stone Game problem, players take turns to remove stones from
either end of a row. Our goal is to collect the most stones possible.
The Bottom-Up Dynamic Programming method builds a table to keep track of
the results of smaller problems. This way, we can ensure we perform
well.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an array called <code>piles</code>. Each
<code>piles[i]</code> tells us how many stones are in the
<code>i-th</code> pile. We want to find out the maximum stones the first
player can collect if both players play their best.</p>
<h3 id="bottom-up-dynamic-programming-solution">Bottom-Up Dynamic
Programming Solution</h3>
<ol type="1">
<li><p><strong>DP Table Initialization</strong>: We create a 2D DP table
<code>dp[i][j]</code>. This table shows the maximum stones the current
player can collect from piles <code>i</code> to <code>j</code>.</p></li>
<li><p><strong>Base Case</strong>: If there is only one pile left, we
set <code>dp[i][i] = piles[i]</code>.</p></li>
<li><p><strong>Transition</strong>: For piles from <code>i</code> to
<code>j</code>, the player can choose pile <code>i</code> or pile
<code>j</code>. The best choice depends on the remaining stones: [
dp[i][j] = (piles[i] - dp[i+1][j], piles[j] - dp[i][j-1]) ] If the
player picks <code>piles[i]</code>, they take away the best result from
the next state. The same goes if they pick
<code>piles[j]</code>.</p></li>
<li><p><strong>Final Result</strong>: The maximum stones the first
player can collect is in <code>dp[0][n-1]</code>, where <code>n</code>
is the total number of piles.</p></li>
</ol>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stoneGame(piles):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(piles)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> piles[i]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of the subarray</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(piles[i] <span class="op">-</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j], piles[j] <span class="op">-</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>piles <span class="op">=</span> [<span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(stoneGame(piles))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The code starts by making a DP table and fills it based on the best
choices for each part of the piles.</li>
<li>It goes through all possible lengths of parts and updates the DP
table.</li>
<li>Finally, it gives us the maximum stones the first player can
collect.</li>
</ul>
<p>This Bottom-Up Dynamic Programming method works well to find the
answer in <code>O(n^2)</code> time and uses <code>O(n^2)</code> space.
This gives us a clear and good solution to the Stone Game problem. For
more about dynamic programming, you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2
id="optimal-strategy-for-stone-game---medium-with-code-examples">Optimal
Strategy for Stone Game - Medium with Code Examples</h2>
<p>In the Stone Game - Medium problem, two players take turns. They can
remove stones from either end of a row of stones. The goal is to collect
the most stones. We can find the best strategy using dynamic
programming. This helps us see how many stones a player can collect from
the current game state.</p>
<h3 id="optimal-strategy">Optimal Strategy</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We define
<code>dp[i][j]</code> to show the maximum number of stones the current
player can collect from the subarray <code>stones[i]</code> to
<code>stones[j]</code>.</p></li>
<li><p><strong>Transition</strong>:</p>
<ul>
<li>If the player takes the left stone <code>stones[i]</code>, the other
player can take stones from <code>i+1</code> to <code>j</code>. The
current player will then collect
<code>stones[i] + (total stones from i+1 to j - dp[i+1][j])</code>.</li>
<li>If the player takes the right stone <code>stones[j]</code>, the
other player can take stones from <code>i</code> to <code>j-1</code>.
The current player will collect
<code>stones[j] + (total stones from i to j-1 - dp[i][j-1])</code>.</li>
</ul>
<p>So, we can write the formula like this:</p>
<pre class="plaintext"><code>dp[i][j] = max(stones[i] + (sum(i+1, j) - dp[i+1][j]), stones[j] + (sum(i, j-1) - dp[i][j-1]))</code></pre></li>
<li><p><strong>Base Case</strong>: When <code>i == j</code>,
<code>dp[i][j] = stones[i]</code>. This is because there is only one
stone to take.</p></li>
</ol>
<h3 id="python-code-example">Python Code Example</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> stoneGame(stones):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(stones)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> stones[i]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># Length of the subarray</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(stones[i] <span class="op">+</span> (<span class="bu">sum</span>(stones[i<span class="op">+</span><span class="dv">1</span>:j<span class="op">+</span><span class="dv">1</span>]) <span class="op">-</span> dp[i<span class="op">+</span><span class="dv">1</span>][j]),</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                           stones[j] <span class="op">+</span> (<span class="bu">sum</span>(stones[i:j]) <span class="op">-</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]))</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="java-code-example">Java Code Example</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> StoneGame <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">stoneGame</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>stones<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="fu">sum</span><span class="op">(</span>stones<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">)</span> <span class="op">-</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]),</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                                    stones<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="op">(</span><span class="fu">sum</span><span class="op">(</span>stones<span class="op">,</span> i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">-</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]));</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">sum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="c-code-example">C++ Code Example</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> stoneGame<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stones<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>stones<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>sum<span class="op">(</span>stones<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">)</span> <span class="op">-</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]),</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                               stones<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>sum<span class="op">(</span>stones<span class="op">,</span> i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">-</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]));</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sum<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stones<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This code shows how to use the best strategy with dynamic
programming. It helps players to get the most stones in the Stone Game -
Medium problem.</p>
<h2 id="time-and-space-complexity-analysis-for-stone-game---medium">Time
and Space Complexity Analysis for Stone Game - Medium</h2>
<p>In the Stone Game - Medium problem, we take turns to pick stones from
both ends of a row. Our goal is to collect the most stones possible. It
is important to look at the time and space complexity of different
methods. This helps us to understand how well our solution works.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ol type="1">
<li><strong>Recursive Solution</strong>:
<ul>
<li>The simple recursive method checks all possible outcomes. It
branches into two choices each time we make a move. This causes the time
complexity to be (O(2^N)). Here, (N) is the number of stones.</li>
<li>This method is not good for larger numbers of stones.</li>
</ul></li>
<li><strong>Dynamic Programming with Memoization</strong>:
<ul>
<li>We can use memoization to make the recursive solution better. It
saves the results of already solved states. This reduces the time
complexity to (O(N^2)). This is because we solve each state only one
time.</li>
</ul></li>
<li><strong>Bottom-Up Dynamic Programming</strong>:
<ul>
<li>The bottom-up method also has a time complexity of (O(N^2). It
builds the DP table step by step using values we already
calculated.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ol type="1">
<li><strong>Recursive Solution</strong>:
<ul>
<li>The space complexity for the simple recursive method is (O(N)). This
is because of the call stack.</li>
</ul></li>
<li><strong>Dynamic Programming with Memoization</strong>:
<ul>
<li>The space complexity here is (O(N^2)). We need this to save the
memoization table, which keeps results for all pairs of indices.</li>
</ul></li>
<li><strong>Bottom-Up Dynamic Programming</strong>:
<ul>
<li>We can make the space complexity better to (O(N)) if we only keep
the states we need to find the current state. We do not need to save the
whole table.</li>
</ul></li>
</ol>
<h3 id="summary-of-complexities">Summary of Complexities</h3>
<table>
<colgroup>
<col style="width: 45%" />
<col style="width: 27%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Recursive</td>
<td>(O(2^N))</td>
<td>(O(N))</td>
</tr>
<tr class="even">
<td>Dynamic Programming (Memoization)</td>
<td>(O(N^2))</td>
<td>(O(N^2))</td>
</tr>
<tr class="odd">
<td>Bottom-Up Dynamic Programming</td>
<td>(O(N^2))</td>
<td>(O(N))</td>
</tr>
</tbody>
</table>
<p>We pick our approach based on the problem limits and how big the
input is. For real tasks, we like to use dynamic programming methods
because they have better time complexity. If we want to learn more about
dynamic programming, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>
<h2 id="common-pitfalls-and-mistakes-in-stone-game---medium">Common
Pitfalls and Mistakes in Stone Game - Medium</h2>
<p>When we solve the Stone Game - Medium problem, we often find some
common mistakes. Knowing these can help us create a good and quick
solution.</p>
<ol type="1">
<li><strong>Misunderstanding the Game Dynamics</strong>:
<ul>
<li>Many of us get confused about the game rules. It is very important
to know that players can only take stones from the ends of the array.
Their aim is to get the highest total score.</li>
</ul></li>
<li><strong>Ignoring Base Cases</strong>:
<ul>
<li>In our recursive solutions, we must define base cases. If we forget
this, we might get infinite loops or wrong answers. We should handle
cases for one stone and two stones clearly.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> <span class="cf">return</span> stones<span class="op">[</span>i<span class="op">];</span> <span class="co">// Only one stone left</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span> <span class="op">==</span> j<span class="op">)</span> <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>stones<span class="op">[</span>i<span class="op">],</span> stones<span class="op">[</span>j<span class="op">]);</span> <span class="co">// Two stones left</span></span></code></pre></div></li>
<li><strong>Incorrect Recursive Formulas</strong>:
<ul>
<li>Our recursive formula must show the right choices for players. A big
mistake is not looking at both options correctly.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>stones<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="fu">dp</span><span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">),</span> stones<span class="op">[</span>j<span class="op">]</span> <span class="op">-</span> <span class="fu">dp</span><span class="op">(</span>i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span></code></pre></div></li>
<li><strong>Not Considering Memoization or Dynamic Programming</strong>:
<ul>
<li>If we ignore memoization, we will do too many calculations again. We
should check if we solve subproblems many times and use an array or
hashmap to save results.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>memo <span class="op">=</span> {}</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dp(i, j):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (i, j) <span class="kw">in</span> memo:</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    memo[(i, j)] <span class="op">=</span> <span class="bu">max</span>(stones[i] <span class="op">-</span> dp(i <span class="op">+</span> <span class="dv">1</span>, j), stones[j] <span class="op">-</span> dp(i, j <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[(i, j)]</span></code></pre></div></li>
<li><strong>Misapplying Dynamic Programming</strong>:
<ul>
<li>When we use a bottom-up method, we must fill the table correctly.
The order of filling the DP table is very important. If we do it wrong,
we might use values that are not ready.</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        dp[i][j] <span class="op">=</span> <span class="bu">max</span>(stones[i] <span class="op">-</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j], stones[j] <span class="op">-</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span></code></pre></div></li>
<li><strong>Overlooking Time Complexity</strong>:
<ul>
<li>We need to look at the time complexity of our solution. A simple
recursive way can lead to very long times for big inputs. We should make
sure our DP runs in O(n^2) time.</li>
</ul></li>
<li><strong>Space Complexity Issues</strong>:
<ul>
<li>We must think about space complexity too. Using a full DP table can
take a lot of memory. We can try to use just a 1D array if we can.</li>
</ul></li>
<li><strong>Failing to Test Edge Cases</strong>:
<ul>
<li>We should always check our solution against edge cases like:
<ul>
<li>An empty array.</li>
<li>Arrays with one element.</li>
<li>Arrays with two elements where both are the same or different.</li>
</ul></li>
</ul></li>
</ol>
<p>By knowing these common pitfalls and mistakes, we can do better in
solving the Stone Game - Medium problem. For more about dynamic
programming, we can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-stone-game-in-dynamic-programming">1. What is the
Stone Game in dynamic programming?</h3>
<p>The Stone Game is a game for two players. They take turns to remove
stones from either end of a row. The goal is to collect as many stones
as possible. We need to understand how to use dynamic programming to
solve the Stone Game. This helps us make better strategies and do better
in similar problems.</p>
<h3 id="how-do-you-apply-dynamic-programming-to-solve-the-stone-game">2.
How do you apply dynamic programming to solve the Stone Game?</h3>
<p>We can use dynamic programming for the Stone Game by creating a 2D
table. This table shows the maximum stones a player can collect from a
part of the stones. We break the problem into smaller parts that
overlap. This helps us calculate faster. For more details, look at our
Dynamic Programming Solution for Stone Game in Python.</p>
<h3 id="what-is-the-recursive-solution-for-the-stone-game-in-java">3.
What is the recursive solution for the Stone Game in Java?</h3>
<p>The recursive solution for the Stone Game means we write a function.
This function finds the maximum stones a player can collect by looking
at all possible moves. This method can repeat calculations. So we should
use memoization or dynamic programming to make it faster. Check our
Recursive Solution for Stone Game - Medium in Java for a full code
example.</p>
<h3 id="what-are-the-common-pitfalls-when-solving-the-stone-game">4.
What are the common pitfalls when solving the Stone Game?</h3>
<p>Common mistakes in solving the Stone Game are forgetting about good
play strategies and not using memoization well. This can make the time
to solve go up a lot. We need to know the game well and manage the
states properly. For more tips, read our article on Common Pitfalls and
Mistakes in Stone Game - Medium.</p>
<h3
id="how-can-i-analyze-the-time-and-space-complexity-of-the-stone-game">5.
How can I analyze the time and space complexity of the Stone Game?</h3>
<p>To analyze the time and space complexity of the Stone Game, we look
at the number of states and moves in our dynamic programming solution.
Usually, the time complexity is O(n^2) because we have nested loops over
moves. The space complexity is also O(n^2) for storing results. For more
information, see our Time and Space Complexity Analysis for Stone Game -
Medium.</p>
<p>For more on similar dynamic programming problems, you can check out
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            