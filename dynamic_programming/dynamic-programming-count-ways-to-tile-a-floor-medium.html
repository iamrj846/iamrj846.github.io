
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Tile a Floor - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to use dynamic programming to count the ways to tile a floor efficiently. Unlock coding techniques and examples!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Tile a Floor - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong technique we use to solve problems by
breaking them down into easier parts. For example, when we tile a floor,
we want to find out how many ways we can tile a rectangle that is
<code>n x 2</code> using <code>1 x 2</code> dominoes. We can use dynamic
programming to find the solution. The number of ways to fill the floor
comes from the number of ways to fill smaller areas of the floor.</p>
<p>In this article, we will look at the dynamic programming solution for
counting the ways to tile a floor. First, we will understand the problem
in detail. Then, we will show how to implement the dynamic programming
approach in Java, Python, and C++. We will also talk about ways to save
space, using recursion with memoization, and iterative methods for
counting the ways to tile the floor. At the end, we will compare the
different approaches and answer common questions about the topic.</p>
<ul>
<li>[Dynamic Programming] Counting Ways to Tile a Floor Using Dynamic
Programming</li>
<li>Understanding the Problem Statement for Tiling a Floor</li>
<li>Dynamic Programming Approach to Count Floor Tiling Ways in Java</li>
<li>Dynamic Programming Approach to Count Floor Tiling Ways in
Python</li>
<li>Dynamic Programming Approach to Count Floor Tiling Ways in C++</li>
<li>Optimizing Space Complexity for Floor Tiling Problem</li>
<li>Recursive Approach with Memoization for Floor Tiling</li>
<li>Iterative Approach for Counting Tiling Ways</li>
<li>Comparative Analysis of Different Approaches for Tiling</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-tiling-a-floor">Understanding
the Problem Statement for Tiling a Floor</h2>
<p>We have a problem. It is about counting how many ways we can tile a
floor. We want to know how many different ways we can cover a floor
using tiles of certain sizes. The common sizes of tiles are 1xN (which
we call dominoes) or 2xN (which are rectangles). Our main goal is to
find out how many ways we can fill a floor of size 2xN with these
tiles.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: We take an integer <code>N</code> that shows
the length of the floor.</li>
<li><strong>Output</strong>: We need to find the total number of
different ways to tile the floor.</li>
</ul>
<h3 id="example">Example</h3>
<p>Letâ€™s say we have a floor with length <code>N = 3</code>: - We can
tile it in these ways: 1. Three vertical 1x2 tiles. 2. One vertical 1x2
tile and one horizontal 2x2 tile. 3. One horizontal 2x2 tile then one
vertical 1x2 tile.</p>
<p>So, we find that the total ways to tile a 2x3 floor is
<code>3</code>.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The value of <code>N</code> must be a non-negative integer.</li>
<li>The ways we can tile must consider the order of tiles. The
arrangement matters.</li>
</ul>
<h3 id="mathematical-formulation">Mathematical Formulation</h3>
<p>To explain the problem in math, we can see that: - If we place a
vertical tile last, we have a floor of size <code>N-1</code> left. - If
we place a horizontal tile last, we have a floor of size
<code>N-2</code> left.</p>
<p>We can write this with a simple formula: [ (N) = (N-1) + (N-2) ] We
also have base cases: - <code>ways(0) = 1</code> (There is 1 way to tile
a floor of length 0 - we do nothing) - <code>ways(1) = 1</code> (Only
one vertical tile can fit)</p>
<p>This formula is like the Fibonacci sequence. We can solve it well
using dynamic programming methods.</p>
<h3 id="applications">Applications</h3>
<ul>
<li>In architectural design, we need to calculate different ways to
tile.</li>
<li>In game development, we deal with tile-based layouts.</li>
<li>In construction projects, we manage resources for tiling.</li>
</ul>
<p>If you want to learn more about similar dynamic programming problems,
you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Counting Ways to Climb Stairs</a>.</p>
<h2
id="dynamic-programming-approach-to-count-floor-tiling-ways-in-java">Dynamic
Programming Approach to Count Floor Tiling Ways in Java</h2>
<p>We will solve the problem of counting ways to tile a floor using
dynamic programming in Java. We can break the problem into smaller
parts. We notice that the number of ways to tile a floor of length
<code>n</code> comes from the ways to tile floors of length
<code>n-1</code> and <code>n-2</code>. This happens because we can use a
1x1 tile or a 1x2 tile.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>Let <code>ways(n)</code> be the number of ways to tile a floor of
length <code>n</code>. We can write the recursive formula as: -
<code>ways(n) = ways(n-1) + ways(n-2)</code> - Base cases:
<code>ways(0) = 1</code> (1 way to tile a floor of length 0) and
<code>ways(1) = 1</code> (1 way to tile a floor of length 1).</p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> FloorTiling <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base cases</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create an array to store results of subproblems</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to tile a floor of length 0</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// 1 way to tile a floor of length 1</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the dp array using the recurrence relation</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example floor length</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to tile a floor of length &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; is: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<p>We start with the <code>countWays</code> method that makes a dynamic
programming array <code>dp</code> to save the number of ways for each
length up to <code>n</code>. We set base values for <code>ways(0)</code>
and <code>ways(1)</code>.</p>
<p>Then, we use a loop to calculate the number of ways for lengths from
2 to <code>n</code>. We use the formula we established.</p>
<p>At the end, the main method shows an example of how to use the
function. You can change the value of <code>n</code> to see how many
ways we can tile for different lengths.</p>
<p>This dynamic programming method quickly finds the number of ways to
tile a floor. The time complexity is O(n) and space complexity is also
O(n). We can make it better by reducing space to O(1). We only need to
store the last two results instead of the whole array.</p>
<p>For more understanding of dynamic programming, you can check articles
like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs</a>.</p>
<h2
id="dynamic-programming-approach-to-count-floor-tiling-ways-in-python">Dynamic
Programming Approach to Count Floor Tiling Ways in Python</h2>
<p>To find how many ways we can tile a floor of size <code>2 x n</code>
with tiles of size <code>1 x 2</code> or <code>2 x 1</code>, we can use
a dynamic programming method. This problem is easy to break down into
smaller parts. This helps us build the solution step by step.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>Letâ€™s say <code>dp[i]</code> is the number of ways to tile a
<code>2 x i</code> floor. We can find a formula based on these
points:</p>
<ul>
<li>If the last tile is vertical, it covers a <code>1 x 2</code> area.
This leaves a floor of size <code>2 x (i-1)</code>.</li>
<li>If the last tile is horizontal, it covers a <code>2 x 1</code> area.
This leaves a floor of size <code>2 x (i-2)</code>.</li>
</ul>
<p>So, we can write this relationship like this:</p>
<pre><code>dp[i] = dp[i-1] + dp[i-2]</code></pre>
<p>We also have base cases: - <code>dp[0] = 1</code>: There is one way
to tile a floor of length 0 (no tiles). - <code>dp[1] = 1</code>: There
is one way to tile a <code>2 x 1</code> floor (one vertical tile).</p>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is the Python code to count the ways to tile a floor using the
dynamic programming method:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_tiling_ways(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Length of the floor</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;The number of ways to tile a 2 x </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> floor is: </span><span class="sc">{</span>count_tiling_ways(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ol type="1">
<li><strong>Base Cases</strong>: We start with <code>dp[0]</code> and
<code>dp[1]</code>.</li>
<li><strong>DP Array</strong>: We use an array called <code>dp</code> to
keep the number of ways for each length.</li>
<li><strong>Iterative Calculation</strong>: We go from <code>2</code> to
<code>n</code>, using the formula to fill the <code>dp</code>
array.</li>
<li><strong>Return Value</strong>: At the end, we return
<code>dp[n]</code>, which tells us how many ways to tile the
<code>2 x n</code> floor.</li>
</ol>
<p>This method works in O(n) time and uses O(n) space. It is good for
bigger values of <code>n</code>. We can even make it better by using
O(1) space by just keeping the last two results.</p>
<h2
id="dynamic-programming-approach-to-count-floor-tiling-ways-in-c">Dynamic
Programming Approach to Count Floor Tiling Ways in C++</h2>
<p>To count the ways to tile a floor of size <code>n x 2</code> using
<code>1 x 2</code> dominoes, we can use a dynamic programming method.
The rule for this problem is:</p>
<ul>
<li>Let <code>dp[i]</code> be the number of ways to tile a floor of
width <code>i</code>.</li>
<li>The rule can be written as:
<ul>
<li><code>dp[i] = dp[i-1] + dp[i-2]</code>
<ul>
<li><code>dp[i-1]</code> is for placing a vertical domino.</li>
<li><code>dp[i-2]</code> is for placing two horizontal dominoes.</li>
</ul></li>
</ul></li>
</ul>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: 1 way to tile a 0 width floor</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: 1 way to tile a 1 width floor</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter the width of the floor (n): &quot;</span><span class="op">;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to tile a &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; x 2 floor: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li>The function <code>countWays(int n)</code> starts a vector
<code>dp</code> to keep the number of ways to tile the floor for each
width from <code>0</code> to <code>n</code>.</li>
<li>It sets the base cases for <code>dp[0]</code> and
<code>dp[1]</code>.</li>
<li>The loop finds the number of ways for each width using the rule we
wrote before.</li>
<li>The answer is given for <code>dp[n]</code>, which is the number of
ways to tile the <code>n x 2</code> floor.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) because we fill the
<code>dp</code> array up to <code>n</code>.</li>
<li><strong>Space Complexity</strong>: O(n) because of the
<code>dp</code> array used to store results.</li>
</ul>
<p>This dynamic programming method counts the ways to tile a floor
quickly. It works well even for bigger values of <code>n</code>. If you
want to read more about similar problems, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> article.</p>
<h2 id="optimizing-space-complexity-for-floor-tiling-problem">Optimizing
Space Complexity for Floor Tiling Problem</h2>
<p>To make space usage better for the floor tiling problem, we can lower
the storage needs while keeping the dynamic programming method. Instead
of using a big array to keep results for all smaller problems, we can
use the fact that the current result only needs a few past results.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<ol type="1">
<li><strong>Reduce Array Size</strong>: Instead of using an array of
size <code>n</code>, we just need to track the last two results because
the current result only depends on these two.</li>
</ol>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> TilingProblem <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(n):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    first, second <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> first <span class="op">+</span> second</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current</span></code></pre></div>
<h3 id="implementation-in-c">Implementation in C++</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TilingProblem <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) - We go through the length of
the floor.</li>
<li><strong>Space Complexity</strong>: O(1) - We only use a small amount
of space no matter how big the input is.</li>
</ul>
<p>This better method helps to use much less space while still counting
the ways to tile the floor. This makes it good for larger inputs. For
more related ideas in dynamic programming, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">count
ways to climb stairs</a>.</p>
<h2 id="recursive-approach-with-memoization-for-floor-tiling">Recursive
Approach with Memoization for Floor Tiling</h2>
<p>We can use a recursive approach with memoization to solve the floor
tiling problem. This method helps us break down the problem into smaller
parts. We store results of these parts to avoid doing the same work
again.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a floor that is <code>n x 2</code>. We need to find out how
many different ways we can tile this floor using <code>1 x 2</code>
dominoes or <code>2 x 1</code> dominoes.</p>
<h3 id="recursive-formula">Recursive Formula</h3>
<p>We can define the number of ways to tile the floor using a recursive
formula: - If we place a vertical domino, the problem becomes
<code>n-1</code>. - If we place two horizontal dominoes, the problem
becomes <code>n-2</code>.</p>
<p>So, our recursive relation is: [ f(n) = f(n-1) + f(n-2) ] We also
have base cases: - ( f(1) = 1 ) (there is one way to place a vertical
domino) - ( f(2) = 2 ) (we can use either two vertical or two horizontal
dominoes)</p>
<h3 id="implementation-in-java-1">Implementation in Java</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> FloorTiling <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ways <span class="op">=</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> ways<span class="op">);</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ways<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        FloorTiling ft <span class="op">=</span> <span class="kw">new</span> <span class="fu">FloorTiling</span><span class="op">();</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example floor size</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to tile a &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot;x2 floor: &quot;</span> <span class="op">+</span> ft<span class="op">.</span><span class="fu">countWays</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python-1">Implementation in Python</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FloorTiling:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.memo <span class="op">=</span> {}</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> count_ways(<span class="va">self</span>, n):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">in</span> <span class="va">self</span>.memo:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">self</span>.memo[n]</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        ways <span class="op">=</span> <span class="va">self</span>.count_ways(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> <span class="va">self</span>.count_ways(n <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.memo[n] <span class="op">=</span> ways</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ways</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    ft <span class="op">=</span> FloorTiling()</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Example floor size</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Number of ways to tile a </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">x2 floor: </span><span class="sc">{</span>ft<span class="sc">.</span>count_ways(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="implementation-in-c-1">Implementation in C++</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> FloorTiling <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span>find<span class="op">(</span>n<span class="op">)</span> <span class="op">!=</span> memo<span class="op">.</span>end<span class="op">())</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> countWays<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> countWays<span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    FloorTiling ft<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example floor size</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of ways to tile a &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot;x2 floor: &quot;</span> <span class="op">&lt;&lt;</span> ft<span class="op">.</span>countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We see that this memoized recursive approach makes the time needed go
down from exponential to linear. This change makes it good for larger
values of <code>n</code>. For more information on similar problems, we
can check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number article</a>.</p>
<h2 id="iterative-approach-for-counting-tiling-ways">Iterative Approach
for Counting Tiling Ways</h2>
<p>We can count the ways to tile a floor of size <code>n</code> using
tiles of size <code>1 x 2</code> with an iterative method. We use a
dynamic programming table to keep track of the number of ways to fill
the floor for each size. The main idea is that to tile a floor of size
<code>n</code>, we can put a vertical tile at the end or two horizontal
tiles.</p>
<h3 id="dynamic-programming-transition">Dynamic Programming
Transition</h3>
<p>We can define the recurrence relation as follows: -
<code>dp[n] = dp[n-1] + dp[n-2]</code></p>
<p>In this relation: - <code>dp[n-1]</code> means we put a vertical
tile. - <code>dp[n-2]</code> means we put two horizontal tiles.</p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code>: There is one way to tile a floor of size 0
(doing nothing).</li>
<li><code>dp[1] = 1</code>: There is one way to tile a floor of size 1
(one vertical tile).</li>
</ul>
<h3 id="implementation">Implementation</h3>
<p>We will show how to implement this in Java, Python, and C++.</p>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> TilingWays <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example size of the floor</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to tile a floor of size &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot;: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(n):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Example size of the floor</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Number of ways to tile a floor of size </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>count_ways(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example size of the floor</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to tile a floor of size &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This iterative method calculates the number of ways to tile a floor
of size <code>n</code>. It uses dynamic programming. The time complexity
is O(n) and the space complexity is O(n). We can also improve the space
complexity to O(1) by only keeping the last two states if we need.</p>
<h2
id="comparative-analysis-of-different-approaches-for-tiling">Comparative
Analysis of Different Approaches for Tiling</h2>
<p>When we solve the problem of counting ways to tile a floor with
Dynamic Programming, we can use different methods. Each method has its
own good points and how well it performs. Here, we will compare the main
techniques for this problem.</p>
<h3 id="recursive-approach">1. Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: Exponential (O(2^n))</li>
<li><strong>Space Complexity</strong>: O(n) because of the recursion
stack</li>
<li><strong>Description</strong>: This method builds the solution step
by step. For a floor of length <code>n</code>, it has two choices: place
a tile of size <code>1x1</code> or <code>1x2</code>.</li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWaysRecursive</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">countWaysRecursive</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">countWaysRecursive</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recursive-with-memoization">2. Recursive with Memoization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) for the memoization
array</li>
<li><strong>Description</strong>: This improves the recursive method by
saving results we already computed. This way, we do not do the same
calculations again.</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWaysMemoization</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="bu">Integer</span><span class="op">[]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">]</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> <span class="fu">countWaysMemoization</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">countWaysMemoization</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="iterative-dynamic-programming">3. Iterative Dynamic
Programming</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
<li><strong>Description</strong>: This method uses an array to keep the
results of smaller problems. It builds up to the final solution.</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWaysDP</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="space-optimized-dynamic-programming">4. Space Optimized Dynamic
Programming</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
<li><strong>Description</strong>: This method saves space by only
keeping the last two results needed for calculations instead of the
whole array.</li>
</ul>
<div class="sourceCode" id="cb17"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWaysSpaceOptimized</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comparative-summary">5. Comparative Summary</h3>
<ul>
<li><strong>Efficiency</strong>: The iterative method and
space-optimized method are best for both time and space.</li>
<li><strong>Simplicity</strong>: The recursive method is easy to
understand but not good for large <code>n</code>.</li>
<li><strong>Flexibility</strong>: The recursive with memoization gives a
balance between being clear and how well it performs. It works well for
moderate input sizes.</li>
</ul>
<p>Each method has its own use depending on what we need, like input
size and how many resources we have. For more about dynamic programming
techniques, we can check out other topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-in-counting-ways-to-tile-a-floor">1.
What is the dynamic programming approach in counting ways to tile a
floor?</h3>
<p>We use dynamic programming to solve complex problems by breaking them
into easier parts. When we count ways to tile a floor, we can store and
reuse results we found before. This helps us do less work and makes our
solution faster for bigger floors. You can learn more about dynamic
programming in our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>.</p>
<h3 id="how-can-i-implement-the-floor-tiling-problem-in-python">2. How
can I implement the floor tiling problem in Python?</h3>
<p>To solve the floor tiling problem in Python, we can write a function
that uses dynamic programming. We can keep an array where each spot
shows the number of ways to tile a floor of that length. By using values
we computed earlier, we can build the solution for the floor we want.
For a full example, check our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Counting Ways to Climb Stairs</a>.</p>
<h3
id="what-are-the-time-and-space-complexities-of-the-floor-tiling-problem">3.
What are the time and space complexities of the floor tiling
problem?</h3>
<p>The time complexity for the floor tiling problem with dynamic
programming is O(n). Here n is the length of the floor. We compute each
state just once and keep it for later. The space complexity can also be
O(n) if we use an array for results. But we can make it O(1) if we only
keep the last two values. We can learn more about space optimization in
our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming: Minimum Cost Climbing Stairs</a>.</p>
<h3
id="can-i-solve-the-floor-tiling-problem-using-a-recursive-approach">4.
Can I solve the floor tiling problem using a recursive approach?</h3>
<p>Yes, we can solve the floor tiling problem with a recursive approach.
But this way can cause us to do too much work again on the same parts.
To make this better, we can use memoization to save results of parts we
computed before. This mix of recursion and dynamic programming makes it
work better. For more on recursion and dynamic programming, check our
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h3
id="how-does-the-iterative-approach-compare-to-the-recursive-approach-in-floor-tiling">5.
How does the iterative approach compare to the recursive approach in
floor tiling?</h3>
<p>The iterative way to count ways to tile a floor is usually better
than the recursive way. It does not have the extra cost of calling
functions over and over. By using a loop to build the solution step by
step, we can get better speed and use less memory. This makes the
iterative method a good choice for bigger inputs. To understand
iterative methods better, visit our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber Problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            