
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Non-Overlapping Bridges - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Non-Overlapping Bridges problem using dynamic programming techniques. Tips, examples, and solutions!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Non-Overlapping Bridges - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Non-Overlapping Bridges problem is a well-known challenge
in dynamic programming. It is about finding the most bridges we can
build without any of them crossing each other. Each bridge is shown as a
pair of coordinates. Our goal is to pick the most pairs that do not
overlap. We want to make sure the bridges do not touch or cross.
Usually, we use a dynamic programming method to solve this. In this
method, we keep track of the most bridges we can build up to a certain
point, while looking at the bridges we built before.</p>
<p>In this article, we will look deeper into the Maximum Non-Overlapping
Bridges problem. We will begin by explaining what the problem is and
what the rules are. Then, we will explore how to use dynamic programming
to find the best solution. We will also give examples in Java, Python,
and C++. We will talk about ways to make the solution better and compare
different methods. At the end, we will answer common questions to help
clear up any confusion.</p>
<ul>
<li>Dynamic Programming Maximum Non-Overlapping Bridges Problem
Explanation</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach for Maximum Non-Overlapping
Bridges</li>
<li>Java Implementation of Maximum Non-Overlapping Bridges</li>
<li>Python Solution for Maximum Non-Overlapping Bridges</li>
<li>C++ Code for Maximum Non-Overlapping Bridges</li>
<li>Optimizing the Dynamic Programming Solution</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>We have a problem called Maximum Non-Overlapping Bridges. This
problem is about connecting points on two parallel lines. We want to
build bridges between these points without any two bridges crossing each
other.</p>
<p>We are given two arrays, <code>A</code> and <code>B</code>. The value
<code>A[i]</code> shows the position on the first line. The value
<code>B[i]</code> shows the position on the second line. Our goal is to
find out the most bridges we can build without them overlapping.</p>
<h3 id="problem-constraints">Problem Constraints:</h3>
<ul>
<li>Each bridge is made by a pair <code>(A[i], B[i])</code>.</li>
<li>Two bridges <code>(A[i], B[i])</code> and <code>(A[j], B[j])</code>
do not overlap if these two things are true:
<ul>
<li><code>A[i] &lt; A[j]</code> and <code>B[i] &lt; B[j]</code>. This
means they do not cross going up and down.</li>
<li><code>A[j] &lt; A[i]</code> and <code>B[j] &lt; B[i]</code>. This
means they do not cross going left and right.</li>
</ul></li>
</ul>
<h3 id="input">Input:</h3>
<ul>
<li>We have two arrays, <code>A</code> and <code>B</code>, with length
<code>n</code>, where <code>1 &lt;= n &lt;= 1000</code>.</li>
<li>The numbers in the arrays can be from <code>0</code> to
<code>10^9</code>.</li>
</ul>
<h3 id="output">Output:</h3>
<ul>
<li>We need to give an integer that shows the highest number of
non-overlapping bridges we can build.</li>
</ul>
<p>By knowing these constraints and the problem statement, we can use
dynamic programming techniques to solve the Maximum Non-Overlapping
Bridges problem. Our solution will find the longest increasing
subsequence of the sorted endpoints of the bridges that follow the
non-overlapping rules.</p>
<h2
id="dynamic-programming-approach-for-maximum-non-overlapping-bridges">Dynamic
Programming Approach for Maximum Non-Overlapping Bridges</h2>
<p>The Maximum Non-Overlapping Bridges problem is a well-known problem.
We can solve it fast using a dynamic programming method. In this
problem, we get some bridges shown as pairs of numbers (start, end). Our
goal is to find the most non-overlapping bridges we can make.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ol type="1">
<li><strong>Input</strong>: A list of pairs showing the start and end
points of bridges.</li>
<li><strong>Output</strong>: The most non-overlapping bridges.</li>
</ol>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>To solve the Maximum Non-Overlapping Bridges problem with dynamic
programming, we will do these steps:</p>
<ul>
<li><p><strong>Sorting</strong>: First, we sort the bridges by their end
points. This way, when we pick a bridge, we can only think about those
that start after the current bridge ends.</p></li>
<li><p><strong>DP Array</strong>: We create a DP array. Here,
<code>dp[i]</code> will show the most non-overlapping bridges we can
make using the first <code>i</code> bridges.</p></li>
<li><p><strong>Recurrence Relation</strong>: For each bridge, we have
two choices:</p>
<ul>
<li>Include the current bridge. This means we must find the last bridge
that does not overlap with the current one.</li>
<li>Exclude the current bridge and keep the value from the last
state.</li>
</ul></li>
</ul>
<p>The recurrence relation is:</p>
<pre class="plaintext"><code>dp[i] = max(dp[i-1], dp[last_non_overlapping_bridge] + 1)</code></pre>
<p>Where <code>last_non_overlapping_bridge</code> is the last bridge
that does not overlap with the current bridge.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is a Java code for this dynamic programming method:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bridge <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start<span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> end<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Bridge</span><span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">start</span> <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">end</span> <span class="op">=</span> end<span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumNonOverlappingBridges <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxBridges</span><span class="op">(</span>Bridge<span class="op">[]</span> bridges<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sort bridges based on end points</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>bridges<span class="op">,</span> <span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">-&gt;</span> a<span class="op">.</span><span class="fu">end</span> <span class="op">-</span> b<span class="op">.</span><span class="fu">end</span><span class="op">);</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> bridges<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// The first bridge can always be included</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Exclude the current bridge</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Check for non-overlapping bridges</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>bridges<span class="op">[</span>j<span class="op">].</span><span class="fu">end</span> <span class="op">&lt;</span> bridges<span class="op">[</span>i<span class="op">].</span><span class="fu">start</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>We can also use a similar method in Python:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Bridge:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, start, end):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start <span class="op">=</span> start</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.end <span class="op">=</span> end</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_bridges(bridges):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort bridges based on end points</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    bridges.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x.end)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(bridges)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># The first bridge can always be included</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># Exclude the current bridge</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check for non-overlapping bridges</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> bridges[j].end <span class="op">&lt;</span> bridges[i].start:</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a C++ version of the same idea:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Bridge <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start<span class="op">,</span> end<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxBridges<span class="op">(</span>vector<span class="op">&lt;</span>Bridge<span class="op">&gt;&amp;</span> bridges<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort bridges based on end points</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>bridges<span class="op">.</span>begin<span class="op">(),</span> bridges<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span>Bridge a<span class="op">,</span> Bridge b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">.</span>end <span class="op">&lt;</span> b<span class="op">.</span>end<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> bridges<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// The first bridge can always be included</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Exclude the current bridge</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Check for non-overlapping bridges</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>bridges<span class="op">[</span>j<span class="op">].</span>end <span class="op">&lt;</span> bridges<span class="op">[</span>i<span class="op">].</span>start<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This dynamic programming method works well to find the most
non-overlapping bridges. It is a good solution for this problem. If we
want to learn more about dynamic programming, we can read the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> article.</p>
<h2 id="java-implementation-of-maximum-non-overlapping-bridges">Java
Implementation of Maximum Non-Overlapping Bridges</h2>
<p>We can solve the Maximum Non-Overlapping Bridges problem well with
dynamic programming. Here is a simple Java code to find the maximum
number of non-overlapping bridges between two banks using the given
bridge coordinates.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have some bridges. Each bridge has two endpoints on two parallel
banks. We can show a bridge as a pair of numbers (x1, y1) and (x2, y2).
For a bridge to be “non-overlapping”, its endpoints must meet this rule:
if bridge A connects (x1, y1) to (x2, y2) and bridge B connects (x3, y3)
to (x4, y4), then: - x1 &lt; x3 and y1 &lt; y3, or - x3 &lt; x1 and y4
&lt; y2.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Comparator</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumNonOverlappingBridges <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxEnvelopes</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sort by first element, and by second element in reverse order if first elements are equal</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>envelopes<span class="op">,</span> <span class="kw">new</span> <span class="bu">Comparator</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">[]&gt;()</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compare</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">:</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Dynamic programming array to store the maximum count of bridges</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> envelopes<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Each envelope can contain itself</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Check if the current envelope can be placed on top of the previous one</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            maxCount <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxCount<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxCount<span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        MaximumNonOverlappingBridges solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaximumNonOverlappingBridges</span><span class="op">();</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> bridges <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">}};</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Non-Overlapping Bridges: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">maxEnvelopes</span><span class="op">(</span>bridges<span class="op">));</span> <span class="co">// Output: 3</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Input:</strong> The input is a 2D array. Each inner array
shows the coordinates of the bridges.</li>
<li><strong>Sorting:</strong> We sort the bridges based on the
x-coordinates. If two bridges have the same x-coordinate, we sort by
their y-coordinates in reverse order.</li>
<li><strong>Dynamic Programming Array:</strong> We use an array
<code>dp</code> to track the maximum number of non-overlapping bridges
that can include each bridge.</li>
<li><strong>Nested Loop:</strong> The outer loop goes through each
bridge. The inner loop checks the previous bridges to find ones that can
fit.</li>
<li><strong>Output:</strong> We print the maximum number of
non-overlapping bridges to the console.</li>
</ul>
<p>This Java code gives us an easy way to solve the Maximum
Non-Overlapping Bridges problem using dynamic programming.</p>
<h2 id="python-solution-for-maximum-non-overlapping-bridges">Python
Solution for Maximum Non-Overlapping Bridges</h2>
<p>We can solve the Maximum Non-Overlapping Bridges problem using
Python. We will use a simple dynamic programming method. The problem is
about finding the most non-overlapping bridges between two banks. Each
bridge has a pair of coordinates.</p>
<h3 id="problem-approach">Problem Approach</h3>
<ol type="1">
<li><strong>Data Structure</strong>: We use a list of tuples for the
bridges.</li>
<li><strong>Sorting</strong>: First, we sort the bridges by their end
coordinates.</li>
<li><strong>Dynamic Programming Array</strong>: We keep an array to
store the maximum count of non-overlapping bridges up to each
bridge.</li>
<li><strong>Iterate and Update</strong>: For each bridge, we check
previous bridges that do not overlap. Then, we update the DP array.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxNonOverlappingBridges(bridges):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Sort bridges based on their end coordinates</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    bridges.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(bridges)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n  <span class="co"># Initialize the DP array</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Iterate over each bridge</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Step 3: Check for non-overlapping condition</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> bridges[j][<span class="dv">1</span>] <span class="op">&lt;</span> bridges[i][<span class="dv">0</span>]:</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 4: Return the maximum number of non-overlapping bridges</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>bridges <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">2</span>), (<span class="dv">2</span>, <span class="dv">3</span>), (<span class="dv">3</span>, <span class="dv">4</span>), (<span class="dv">5</span>, <span class="dv">6</span>)]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxNonOverlappingBridges(bridges))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<p>We sort the bridges by their end points. This helps us choose
non-overlapping bridges easier.</p>
<p>We start a DP array where each spot shows the maximum count of
non-overlapping bridges ending at that spot.</p>
<p>We use a nested loop to compare each bridge with all previous
bridges. This helps us find valid pairs that do not overlap.</p>
<p>Finally, we return the highest value from the DP array as the
result.</p>
<p>This Python solution works well for finding the maximum number of
non-overlapping bridges using a dynamic programming method. If you want
to learn more about dynamic programming, you can check out articles on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci numbers</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">dynamic
programming with memoization</a>.</p>
<h2 id="c-code-for-maximum-non-overlapping-bridges">C++ Code for Maximum
Non-Overlapping Bridges</h2>
<p>We can solve the Maximum Non-Overlapping Bridges problem in C++ using
dynamic programming. This problem is about finding the most
non-overlapping bridges we can build with pairs of coordinates for each
bridge’s ends.</p>
<h3 id="problem-overview">Problem Overview</h3>
<p>We have two arrays <code>A</code> and <code>B</code>. The
<code>i-th</code> bridge connects the point <code>(A[i], B[i])</code>.
Two bridges <code>(A[i], B[i])</code> and <code>(A[j], B[j])</code> do
not overlap if <code>A[i] &lt; A[j]</code> and
<code>B[i] &lt; B[j]</code>.</p>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxNonOverlappingBridges<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> A<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> B<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> A<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&gt;</span> bridges<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Pair the coordinates</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        bridges<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> make_pair<span class="op">(</span>A<span class="op">[</span>i<span class="op">],</span> B<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort the bridges by starting point, and then by ending point</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>bridges<span class="op">.</span>begin<span class="op">(),</span> bridges<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="co">// DP array to find the maximum count of non-overlapping bridges</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// Each bridge can at least form a bridge by itself</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build the DP array</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>bridges<span class="op">[</span>i<span class="op">].</span>second <span class="op">&gt;</span> bridges<span class="op">[</span>j<span class="op">].</span>second<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The answer is the maximum value in dp</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>max_element<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> A <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> B <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> maxNonOverlappingBridges<span class="op">(</span>A<span class="op">,</span> B<span class="op">);</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Non-Overlapping Bridges: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<p>We first make pairs of coordinates for the bridges. Then we sort the
bridges by their starting points. If two bridges have the same start, we
sort them by their end points.</p>
<p>We create a dynamic programming array <code>dp</code>. The value
<code>dp[i]</code> shows the most non-overlapping bridges we can have
with the <code>i-th</code> bridge as the last one.</p>
<p>The nested loop checks if bridges overlap and updates the
<code>dp</code> values. Finally, we get the maximum value from the
<code>dp</code> array to find the result.</p>
<p>This C++ code calculates the maximum number of non-overlapping
bridges using dynamic programming. For more on dynamic programming, you
can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> for some basic ideas.</p>
<h2 id="optimizing-the-dynamic-programming-solution">Optimizing the
Dynamic Programming Solution</h2>
<p>We want to make the dynamic programming solution better for the
Maximum Non-Overlapping Bridges problem. Our goal is to lower the space
needed while keeping the time the same. The original way uses a
two-dimensional DP array. We can change it to a one-dimensional
array.</p>
<h3 id="key-observations">Key Observations:</h3>
<ul>
<li>We can think of the problem as finding the longest increasing
sequence based on the bridge endpoints.</li>
<li>If we sort the bridges by their ending points, it becomes easier to
check if they overlap.</li>
<li>We can use binary search to keep track of the longest sequence. This
works well because we have sorted the bridges.</li>
</ul>
<h3 id="approach">Approach:</h3>
<ol type="1">
<li><strong>Sort the Bridges</strong>: First, we sort the bridges by
their ending points.</li>
<li><strong>Use a One-Dimensional Array</strong>: Instead of using a
two-dimensional DP table, we will have one array. This array keeps the
maximum number of non-overlapping bridges for each position.</li>
<li><strong>Binary Search for Optimization</strong>: We will use binary
search to find the last bridge that can connect without overlapping with
the current bridge. This helps us keep the solution fast.</li>
</ol>
<h3 id="pseudocode">Pseudocode:</h3>
<pre class="plaintext"><code>function maxNonOverlappingBridges(bridges):
    sort(bridges based on ending coordinate)
    dp = array of size n initialized to 1
    
    for i from 1 to n-1:
        for j from 0 to i-1:
            if bridges[i][0] &gt; bridges[j][1]: // non-overlapping condition
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)</code></pre>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Comparator</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumNonOverlappingBridges <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxEnvelopes</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>envelopes<span class="op">,</span> <span class="bu">Comparator</span><span class="op">.</span><span class="fu">comparingInt</span><span class="op">(</span>a <span class="op">-&gt;</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]));</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> envelopes<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>dp<span class="op">).</span><span class="fu">max</span><span class="op">().</span><span class="fu">getAsInt</span><span class="op">();</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-1">Python Implementation:</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_non_overlapping_bridges(bridges):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    bridges.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(bridges)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> bridges[i][<span class="dv">0</span>] <span class="op">&gt;</span> bridges[j][<span class="dv">1</span>]:  <span class="co"># non-overlapping condition</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)</span></code></pre></div>
<h3 id="c-implementation-2">C++ Implementation:</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxEnvelopes<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        sort<span class="op">(</span>envelopes<span class="op">.</span>begin<span class="op">(),</span> envelopes<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> envelopes<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">*</span>max_element<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="final-insights">Final Insights:</h3>
<p>We focus on sorting and using a one-dimensional DP array. This
changes reduce space a lot. We still keep the time complexity at
O(n^2).</p>
<p>We can make it even better. We can use binary search in the dynamic
programming method. This will lower the overall time complexity to O(n
log n).</p>
<p>For more insights on dynamic programming techniques, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or other topics linked above.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>In solving the <strong>Maximum Non-Overlapping Bridges</strong>
problem, we can use different methods. Each method has its own good
points and downsides. Here is a simple comparison of these methods.</p>
<h3 id="greedy-approach">1. Greedy Approach</h3>
<ul>
<li><strong>Description</strong>: This method picks the most
non-overlapping bridges by looking at sorted end points. After we sort
the bridges by their end points, we choose bridges one by one that do
not overlap with the last chosen bridge.</li>
<li><strong>Time Complexity</strong>: It takes O(n log n) because of
sorting and O(n) for picking the bridges.</li>
<li><strong>Space Complexity</strong>: It uses O(1) if we sort the
bridges in-place.</li>
</ul>
<h3 id="dynamic-programming-approach-1">2. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Description</strong>: The dynamic programming (DP) method is
more organized. We keep a DP array where <code>dp[i]</code> shows the
most non-overlapping bridges we can get from the first <code>i</code>
bridges. We either take the current bridge or skip it based on whether
they overlap.</li>
<li><strong>Time Complexity</strong>: It takes O(n^2) if we use a loop
inside a loop to check overlaps.</li>
<li><strong>Space Complexity</strong>: It uses O(n) for the DP
array.</li>
</ul>
<h3 id="binary-search-with-dynamic-programming">3. Binary Search with
Dynamic Programming</h3>
<ul>
<li><strong>Description</strong>: This is a smarter version of the DP
method. It uses binary search to find the last bridge that does not
overlap when we include the current bridge. This makes it faster by not
using a loop inside a loop.</li>
<li><strong>Time Complexity</strong>: It takes O(n log n) because of
sorting and binary search.</li>
<li><strong>Space Complexity</strong>: It uses O(n) for the DP
array.</li>
</ul>
<h3 id="segment-tree-approach">4. Segment Tree Approach</h3>
<ul>
<li><strong>Description</strong>: This method uses a segment tree to
keep track of bridge intervals. It allows fast range checks and updates.
This is useful if the list of bridges changes over time.</li>
<li><strong>Time Complexity</strong>: It takes O(n log n) for both
updates and checks.</li>
<li><strong>Space Complexity</strong>: It uses O(n) for the segment
tree.</li>
</ul>
<h3 id="performance-summary">Performance Summary</h3>
<ul>
<li><strong>Greedy vs. DP</strong>: Greedy is faster and easier but may
not always give the best results like DP can.</li>
<li><strong>DP vs. Binary Search</strong>: We should prefer binary
search for big datasets because it is faster.</li>
<li><strong>Segment Tree</strong>: This is good for changing data but
can be more complicated for fixed problems.</li>
</ul>
<h3 id="practical-usage">Practical Usage</h3>
<p>When we choose a method for the Maximum Non-Overlapping Bridges
problem, we should think about: - <strong>Input Size</strong>: For small
to medium datasets, greedy or basic DP methods work well. - <strong>Need
for Efficiency</strong>: For larger datasets, we should use the binary
search + DP method. - <strong>Dynamic Data</strong>: If the problem
needs updates, a segment tree might be the best choice.</p>
<p>For more reading on dynamic programming, you can check articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-non-overlapping-bridges-problem-in-dynamic-programming">1.
What is the Maximum Non-Overlapping Bridges problem in dynamic
programming?</h3>
<p>The Maximum Non-Overlapping Bridges problem is about finding the most
bridges we can build without them crossing. Each bridge has two ends.
Our goal is to pick the biggest group of bridges that do not overlap.
This problem shows how dynamic programming works. It helps us find the
best answer by breaking the problem down into smaller parts.</p>
<h3
id="how-is-dynamic-programming-applied-to-solve-the-maximum-non-overlapping-bridges-problem">2.
How is dynamic programming applied to solve the Maximum Non-Overlapping
Bridges problem?</h3>
<p>We use dynamic programming to solve the Maximum Non-Overlapping
Bridges problem by splitting it into smaller problems. First, we sort
the bridges by one end. Then we can use a DP array to keep track of the
most bridges we can build up to each bridge. This way, we only look at
bridges that do not overlap. It helps us find the best solution in a
smart way.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-maximum-non-overlapping-bridges">3.
What is the time complexity of the dynamic programming solution for
Maximum Non-Overlapping Bridges?</h3>
<p>The time complexity for the dynamic programming solution to the
Maximum Non-Overlapping Bridges problem is O(n log n). This is mainly
because of the sorting step. After we sort, we can fill the DP array in
linear time O(n). We check each bridge to see how many non-overlapping
bridges we can make. This makes it fast enough for bigger datasets.</p>
<h3
id="can-the-maximum-non-overlapping-bridges-problem-be-solved-using-other-techniques-besides-dynamic-programming">4.
Can the Maximum Non-Overlapping Bridges problem be solved using other
techniques besides dynamic programming?</h3>
<p>Yes, we can solve the Maximum Non-Overlapping Bridges problem using
other methods too. For example, we can use greedy algorithms. By picking
bridges based on their endpoints, we can make sure they do not overlap.
But dynamic programming gives us a better way to find the best answer,
especially when things get complicated.</p>
<h3
id="where-can-i-find-example-implementations-of-the-maximum-non-overlapping-bridges-problem">5.
Where can I find example implementations of the Maximum Non-Overlapping
Bridges problem?</h3>
<p>For example implementations, we can check many coding websites. For
example, this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-two-non-overlapping-subarrays-medium.html">Java
Implementation of Maximum Non-Overlapping Bridges</a> shows a clear way
to do it. Also, we can look for Python and C++ examples to help us
understand this dynamic programming problem better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            