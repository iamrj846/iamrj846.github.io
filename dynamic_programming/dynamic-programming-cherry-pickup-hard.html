
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Cherry Pickup - Hard</title>
            <meta name="description" content=""Master dynamic programming with our in-depth guide on the Cherry Pickup problem. Solve complex challenges easily!"">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Cherry Pickup - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Cherry Pickup problem is a tricky dynamic programming task. The
goal is to collect as many cherries as possible on a grid. We start from
two points and must move around obstacles.</p>
<p>To solve this problem, we need to make a dynamic programming table.
This table helps us find the best paths to collect cherries while
following the rules of movement on the grid. This problem tests our
algorithm skills and helps us learn more about dynamic programming. It
is especially useful for situations with more than one agent.</p>
<p>In this article, we will look closely at the Cherry Pickup dynamic
programming problem. First, we will give an overview of the problem and
its rules. Then, we will discuss how to use dynamic programming to solve
it. We will share code examples in Java, Python, and C++. We will also
talk about ways to improve the solution and compare different code
versions. Lastly, we will look at common problems people face when
solving the Cherry Pickup problem and answer some frequently asked
questions.</p>
<ul>
<li>Dynamic Programming Cherry Pickup Problem Overview</li>
<li>Understanding the Problem Constraints</li>
<li>Dynamic Programming Approach Overview</li>
<li>Java Implementation of Cherry Pickup</li>
<li>Python Implementation of Cherry Pickup</li>
<li>C++ Implementation of Cherry Pickup</li>
<li>Optimizing the Dynamic Programming Solution</li>
<li>Comparative Analysis of Different Implementations</li>
<li>Common Challenges and Solutions in Cherry Pickup</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, we can recommend
some useful articles. You might like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number - Easy</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs - Easy</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-edit-distance-hard.html">Dynamic
Programming Edit Distance - Hard</a>. These resources can help us
understand dynamic programming better and connect to the Cherry Pickup
problem.</p>
<h2 id="understanding-the-problem-constraints">Understanding the Problem
Constraints</h2>
<p>The Cherry Pickup problem is about moving in a grid. In this grid,
two players start at opposite corners. They need to pick up cherries
while they move. Here are the main rules of the problem:</p>
<ul>
<li><p><strong>Grid Dimensions</strong>: The grid is a square. Its size
is <code>n x n</code>, where <code>n</code> can be from 1 to
50.</p></li>
<li><p><strong>Cell Values</strong>: Each cell can have:</p>
<ul>
<li><code>0</code>: This means the cell is empty.</li>
<li><code>1</code>: This means the cell has a cherry.</li>
<li><code>-1</code>: This means the cell has an obstacle. Players cannot
go through obstacles.</li>
</ul></li>
<li><p><strong>Movement</strong>: Players can only move down or right.
They start at the top-left corner (0, 0) and finish at the bottom-right
corner (n-1, n-1).</p></li>
<li><p><strong>Collecting Cherries</strong>: As the players move, they
can collect cherries. The goal is to get the most cherries when they
meet.</p></li>
<li><p><strong>Meeting Point</strong>: The players have to meet at the
same cell after they finish moving. We need to count the total cherries
they collected from that cell.</p></li>
<li><p><strong>No Backtracking</strong>: Once players move past a cell,
they cannot go back to it.</p></li>
<li><p><strong>Dynamic Programming Storage</strong>: We usually
represent the state of the dynamic programming solution as
<code>dp[x1][y1][x2]</code>. In this, <code>(x1, y1)</code> is where
Player 1 is. The position of Player 2 can be found by
<code>y2 = x1 + y1 - x2</code>.</p></li>
</ul>
<p>Knowing these rules is very important. It helps us create a good
dynamic programming solution. This way, we can improve how we collect
cherries while moving in the grid.</p>
<h2 id="dynamic-programming-approach-overview">Dynamic Programming
Approach Overview</h2>
<p>The <strong>Cherry Pickup problem</strong> is a well-known dynamic
programming challenge. We can describe it like this: We have a grid that
shows a cherry orchard. Some cells have cherries, marked by 1, and some
cells are empty or have obstacles, marked by 0. Two players begin from
the top-left and bottom-left corners of the grid. They can only move
right or down. The goal is to collect the most cherries possible when
both players meet at the bottom-right corner.</p>
<h3 id="dynamic-programming-state-definition">Dynamic Programming State
Definition</h3>
<ul>
<li><strong>State</strong>: We use <code>dp[r1][c1][c2]</code> to show
the most cherries collected when player 1 is at <code>(r1, c1)</code>
and player 2 is at <code>(r2, c2)</code>. Here,
<code>r2 = r1 + c1 - c2</code>.</li>
</ul>
<h3 id="transition">Transition</h3>
<ul>
<li>For each valid state <code>(r1, c1, c2)</code>, we calculate the
next states by moving either player one step to the right or down:</li>
</ul>
<pre class="plaintext"><code>dp[r1][c1][c2] = max(dp[r1-1][c1][c2]    // player 1 moves up
                   dp[r1][c1-1][c2]    // player 1 moves left
                   dp[r1-1][c1][c2-1]  // player 2 moves up
                   dp[r1][c1-1][c2-1])  // player 2 moves left</code></pre>
<h3 id="base-case">Base Case</h3>
<ul>
<li>We start with <code>dp[0][0][0] = grid[0][0]</code>, collecting
cherries from the starting cell.</li>
</ul>
<h3 id="constraints-handling">Constraints Handling</h3>
<ul>
<li>We make sure both players do not move out of the grid. We also
handle obstacles, which are represented by 0 in the grid.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(N^3), where N is the grid size.
We look at each state based on previous states.</li>
<li><strong>Space Complexity</strong>: O(N^2) for the dp array. We can
make this better to O(N) with smart state management.</li>
</ul>
<p>The dynamic programming approach helps us find the most cherries
collected. We look at all possible paths and make sure both players get
the most cherries before they reach the end.</p>
<h2 id="java-implementation-of-cherry-pickup">Java Implementation of
Cherry Pickup</h2>
<p>To solve the Cherry Pickup problem with dynamic programming in Java,
we use a 3D array. This array helps us keep track of the maximum number
of cherries we can pick at each step. We simulate two paths. One path
goes from the top-left corner to the bottom-right corner. The other path
goes from the bottom-left corner to the top-right corner of the
grid.</p>
<p>Hereâ€™s the Java code:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CherryPickup <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">cherryPickup</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> k <span class="op">&lt;</span> n<span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">][</span>k<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> dp<span class="op">));</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">collectCherries</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">,</span> <span class="dt">int</span> x1<span class="op">,</span> <span class="dt">int</span> y1<span class="op">,</span> <span class="dt">int</span> y2<span class="op">,</span> <span class="dt">int</span><span class="op">[][][]</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x2 <span class="op">=</span> x1 <span class="op">+</span> y1 <span class="op">-</span> y2<span class="op">;</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">&gt;=</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">||</span> y1 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">||</span> x2 <span class="op">&gt;=</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">||</span> y2 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">||</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>x2<span class="op">][</span>y2<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">==</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> y1 <span class="op">==</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">];</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">];</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cherries <span class="op">=</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">];</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">!=</span> x2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>            cherries <span class="op">+=</span> grid<span class="op">[</span>x2<span class="op">][</span>y2<span class="op">];</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxCherries <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> x1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> y1<span class="op">,</span> y2<span class="op">,</span> dp<span class="op">),</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> x1<span class="op">,</span> y1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> y2<span class="op">,</span> dp<span class="op">)),</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> x1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> y1<span class="op">,</span> y2 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> dp<span class="op">),</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> x1<span class="op">,</span> y1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> y2 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> dp<span class="op">))</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">);</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> cherries <span class="op">+</span> maxCherries<span class="op">;</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">];</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a>        CherryPickup solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">CherryPickup</span><span class="op">();</span></span>
<span id="cb2-48"><a href="#cb2-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> grid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-49"><a href="#cb2-49" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb2-50"><a href="#cb2-50" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb2-51"><a href="#cb2-51" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span>  <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb2-52"><a href="#cb2-52" aria-hidden="true" tabindex="-1"></a>            <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">}</span></span>
<span id="cb2-53"><a href="#cb2-53" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb2-54"><a href="#cb2-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum cherries picked: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">cherryPickup</span><span class="op">(</span>grid<span class="op">));</span></span>
<span id="cb2-55"><a href="#cb2-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-56"><a href="#cb2-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Grid Initialization</strong>: We create a 3D array called
<code>dp</code> to store results of smaller problems.</li>
<li><strong>Recursive Function</strong>: The function
<code>collectCherries</code> finds out the maximum cherries we can
collect from the positions <code>(x1, y1)</code> for one path and
<code>(x2, y2)</code> for the other path.</li>
<li><strong>Base Cases</strong>: We check for out-of-bounds and
obstacles.</li>
<li><strong>Memoization</strong>: We save results in <code>dp</code> to
prevent recalculating.</li>
<li><strong>Main Method</strong>: It shows how to use the code with a
sample grid.</li>
</ul>
<p>This code works well and follows the rules of dynamic programming. It
is good for the Cherry Pickup problem. If we want to learn more about
similar ideas, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-product-subarray-easy.html">Dynamic
Programming - Maximum Product Subarray</a>.</p>
<h2 id="python-implementation-of-cherry-pickup">Python Implementation of
Cherry Pickup</h2>
<p>We can solve the Cherry Pickup problem with a simple dynamic
programming method in Python. The main idea is to use a 3D DP array.
This array helps to keep track of the most cherries we can collect from
the start to two different spots on the path. Our aim is to go from the
top-left corner to the bottom-right corner of a grid. We want to collect
as many cherries as possible.</p>
<p>Here is a simple Python code for this:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cherryPickup(grid):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid <span class="kw">or</span> <span class="kw">not</span> grid[<span class="dv">0</span>]:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(grid)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> step <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x1 <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">max</span>(<span class="dv">0</span>, step <span class="op">-</span> n <span class="op">+</span> <span class="dv">1</span>), <span class="bu">min</span>(n <span class="op">-</span> <span class="dv">1</span>, step) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x2 <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">max</span>(<span class="dv">0</span>, step <span class="op">-</span> n <span class="op">+</span> <span class="dv">1</span>), <span class="bu">min</span>(n <span class="op">-</span> <span class="dv">1</span>, step) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> grid[x1][step <span class="op">-</span> x1] <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> grid[x2][step <span class="op">-</span> x2] <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                cherries <span class="op">=</span> grid[x1][step <span class="op">-</span> x1] <span class="op">+</span> (x1 <span class="op">!=</span> x2) <span class="op">*</span> grid[x2][step <span class="op">-</span> x2]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> dx1 <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> dx2 <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                        prev_x1 <span class="op">=</span> x1 <span class="op">+</span> dx1</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                        prev_x2 <span class="op">=</span> x2 <span class="op">+</span> dx2</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> prev_x1 <span class="op">&lt;</span> n <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> prev_x2 <span class="op">&lt;</span> n <span class="kw">and</span> dp[step <span class="op">-</span> <span class="dv">1</span>][prev_x1][prev_x2] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                            dp[step][x1][x2] <span class="op">=</span> <span class="bu">max</span>(dp[step][x1][x2], dp[step <span class="op">-</span> <span class="dv">1</span>][prev_x1][prev_x2] <span class="op">+</span> cherries)</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, dp[<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">2</span>][n <span class="op">-</span> <span class="dv">1</span>][n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Initialization</strong>: We create a 3D list
<code>dp</code>. This list holds the most cherries we collect at each
step for the two players.</li>
<li><strong>Dynamic Programming Transition</strong>: For each step, we
find the most cherries by checking where both players can go and looking
at their previous positions.</li>
<li><strong>Final Result</strong>: The highest number in <code>dp</code>
at the last step shows the total cherries we can collect.</li>
</ul>
<p>This code uses dynamic programming to solve the Cherry Pickup
problem. It works well with the grid limits. If we want to learn more
about dynamic programming, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2 id="c-implementation-of-cherry-pickup">C++ Implementation of Cherry
Pickup</h2>
<p>We can solve the Cherry Pickup problem using dynamic programming.
Below is a simple C++ code that helps us understand the problem. It uses
a 3D DP array to keep track of the maximum cherries we collect as we
move through the grid from two starting points.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cherryPickup<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>m<span class="op">,</span> <span class="dv">0</span><span class="op">)));</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> x1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> x1 <span class="op">&lt;</span> n<span class="op">;</span> x1<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> y1 <span class="op">&lt;</span> m<span class="op">;</span> y1<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> y2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> y2 <span class="op">&lt;</span> m<span class="op">;</span> y2<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>x1<span class="op">][</span>y2<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>x1 <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="op">(</span>y1 <span class="op">==</span> y2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">];</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>x1<span class="op">][</span>y2<span class="op">];</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                        <span class="dt">int</span> maxCherries <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> prevY1 <span class="op">=</span> y1 <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> prevY1 <span class="op">&lt;=</span> y1 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> prevY1<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> prevY2 <span class="op">=</span> y2 <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> prevY2 <span class="op">&lt;=</span> y2 <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> prevY2<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                                <span class="cf">if</span> <span class="op">(</span>prevY1 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> prevY1 <span class="op">&lt;</span> m <span class="op">&amp;&amp;</span> prevY2 <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> prevY2 <span class="op">&lt;</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                                    maxCherries <span class="op">=</span> max<span class="op">(</span>maxCherries<span class="op">,</span> dp<span class="op">[</span>x1 <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>prevY1<span class="op">][</span>prevY2<span class="op">]);</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>                                <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>                            <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="op">(</span>maxCherries <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                            dp<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">][</span>y2<span class="op">]</span> <span class="op">=</span> maxCherries <span class="op">+</span> <span class="op">(</span>y1 <span class="op">==</span> y2 <span class="op">?</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">]</span> <span class="op">:</span> grid<span class="op">[</span>x1<span class="op">][</span>y1<span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>x1<span class="op">][</span>y2<span class="op">]);</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>                        <span class="op">}</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">][</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We create a 3D vector called
<code>dp</code>. It stores the maximum cherries we collect for each
position of the two players at each row.</li>
<li><strong>Dynamic Programming Transition</strong>:
<ul>
<li>For each cell <code>(x1, y1)</code> for the first player and
<code>(x1, y2)</code> for the second player, we check if either player
is out of bounds or if the cell has a thorn (<code>-1</code>).</li>
<li>We get the value of <code>dp[x1][y1][y2]</code> from the maximum
cherries collected from the previous row and the nearby columns.</li>
</ul></li>
<li><strong>Final Result</strong>: The answer is the maximum cherries
collected when both players reach the last row.</li>
</ul>
<p>This C++ code uses dynamic programming to find the best solution for
the Cherry Pickup problem. If we want to learn more about dynamic
programming and related algorithms, we can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/unique-paths-in-a-grid-easy.html">Dynamic
Programming on Grid Problems</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray Problem</a>.</p>
<h2 id="optimizing-the-dynamic-programming-solution">Optimizing the
Dynamic Programming Solution</h2>
<p>We can make the Cherry Pickup problem better by using different
methods. This helps us to lower the time and space needed. Here are some
good strategies:</p>
<ol type="1">
<li><p><strong>Space Optimization</strong>: Instead of using a 3D array
to keep results for each state, we can use only two 2D arrays. These
arrays hold the current and previous states. We can even use one array
if we change it in-place.</p></li>
<li><p><strong>Iterative DP with Memoization</strong>: We can use an
iterative bottom-up dynamic programming approach instead of the regular
recursive method. This way, we avoid the extra work from recursive
calls. It makes things simpler.</p></li>
<li><p><strong>Pruning Unnecessary States</strong>: We should find and
remove states that do not help with the best solution. For example, if
we collect more cherries than possible, we can stop checking
further.</p></li>
<li><p><strong>Utilize Symmetry</strong>: The Cherry Pickup problem is
symmetric because of the two paths the collectors take. We can use this
fact to do fewer calculations by mirroring results.</p></li>
<li><p><strong>Minimize State Representation</strong>: Instead of using
both positions of the collectors for each state, we can use the total
steps taken. This helps to make the state space smaller.</p></li>
</ol>
<h3 id="example-implementation-in-python">Example Implementation in
Python</h3>
<p>Here is a better way to solve the problem by reducing space:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cherryPickup(grid):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(grid)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> t <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        temp_dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x1 <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> x2 <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> grid[x1][t <span class="op">-</span> x1] <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> grid[x2][t <span class="op">-</span> x2] <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">continue</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                cherries <span class="op">=</span> grid[x1][t <span class="op">-</span> x1] <span class="op">+</span> (x1 <span class="op">!=</span> x2) <span class="op">*</span> grid[x2][t <span class="op">-</span> x2]</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> dx1 <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> dx2 <span class="kw">in</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>]:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                        nx1, nx2 <span class="op">=</span> x1 <span class="op">+</span> dx1, x2 <span class="op">+</span> dx2</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx1 <span class="op">&lt;</span> n <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx2 <span class="op">&lt;</span> n:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                            temp_dp[x1][x2] <span class="op">=</span> <span class="bu">max</span>(temp_dp[x1][x2], dp[nx1][nx2] <span class="op">+</span> cherries)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> temp_dp</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(<span class="dv">0</span>, dp[n <span class="op">-</span> <span class="dv">1</span>][n <span class="op">-</span> <span class="dv">1</span>])</span></code></pre></div>
<h3 id="performance-analysis">Performance Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: The better solution usually runs
in O(n^3) because of loops checking possible positions.</li>
<li><strong>Space Complexity</strong>: By using only two 2D arrays, we
lower the space needed from O(n^2) to O(n) if we optimize more.</li>
</ul>
<p>These improvements make the Cherry Pickup problem easier for bigger
inputs and better in time and space use. If you want to learn more about
dynamic programming methods, you might like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">this
article on Minimum Path Sum</a>.</p>
<h2 id="comparative-analysis-of-different-implementations">Comparative
Analysis of Different Implementations</h2>
<p>We can solve the Cherry Pickup problem using different programming
languages like Java, Python, and C++. Each way has its own features,
strengths, and how well it performs. We will look at how readable the
code is, how fast it runs, and how much memory it uses. Below, we will
check the different ways to implement the Cherry Pickup problem.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Java has a strong type system and useful collections that help us
create solutions for dynamic programming. Here is a typical example:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">cherryPickup</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> layer <span class="op">:</span> dp<span class="op">)</span> </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span><span class="op">[]</span> row <span class="op">:</span> layer<span class="op">)</span> </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>                <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>row<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> dp<span class="op">));</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">collectCherries</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">,</span> <span class="dt">int</span> r1<span class="op">,</span> <span class="dt">int</span> c1<span class="op">,</span> <span class="dt">int</span> c2<span class="op">,</span> <span class="dt">int</span><span class="op">[][][]</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> r2 <span class="op">=</span> r1 <span class="op">+</span> c1 <span class="op">-</span> c2<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r1 <span class="op">&gt;=</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">||</span> c1 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">||</span> r2 <span class="op">&gt;=</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">||</span> c2 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">||</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>r2<span class="op">][</span>c2<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r1 <span class="op">==</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> c1 <span class="op">==</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">];</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> </span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">];</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cherries <span class="op">=</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">];</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>c1 <span class="op">!=</span> c2<span class="op">)</span> </span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            cherries <span class="op">+=</span> grid<span class="op">[</span>r2<span class="op">][</span>c2<span class="op">];</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        cherries <span class="op">+=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> r1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c1<span class="op">,</span> c2<span class="op">),</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> r1<span class="op">,</span> c1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c2<span class="op">)),</span> </span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                             <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> r1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c1<span class="op">,</span> c2 <span class="op">+</span> <span class="dv">1</span><span class="op">),</span> <span class="fu">collectCherries</span><span class="op">(</span>grid<span class="op">,</span> r1<span class="op">,</span> c1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c2 <span class="op">+</span> <span class="dv">1</span><span class="op">)));</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">]</span> <span class="op">=</span> cherries<span class="op">;</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Python has a simple syntax. This makes the code easy to read. Here is
a common example:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> cherryPickup(<span class="va">self</span>, grid: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(grid)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [[[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(<span class="dv">0</span>, <span class="va">self</span>.collectCherries(grid, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, dp))</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> collectCherries(<span class="va">self</span>, grid, r1, c1, c2, dp):</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        r2 <span class="op">=</span> r1 <span class="op">+</span> c1 <span class="op">-</span> c2</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r1 <span class="op">&gt;=</span> <span class="bu">len</span>(grid) <span class="kw">or</span> c1 <span class="op">&gt;=</span> <span class="bu">len</span>(grid[<span class="dv">0</span>]) <span class="kw">or</span> r2 <span class="op">&gt;=</span> <span class="bu">len</span>(grid) <span class="kw">or</span> c2 <span class="op">&gt;=</span> <span class="bu">len</span>(grid[<span class="dv">0</span>]) <span class="kw">or</span> grid[r1][c1] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="kw">or</span> grid[r2][c2] <span class="op">==</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> r1 <span class="op">==</span> <span class="bu">len</span>(grid) <span class="op">-</span> <span class="dv">1</span> <span class="kw">and</span> c1 <span class="op">==</span> <span class="bu">len</span>(grid[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> grid[r1][c1]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> dp[r1][c1][c2] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dp[r1][c1][c2]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        cherries <span class="op">=</span> grid[r1][c1]</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> c1 <span class="op">!=</span> c2:</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            cherries <span class="op">+=</span> grid[r2][c2]</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        cherries <span class="op">+=</span> <span class="bu">max</span>(<span class="bu">max</span>(<span class="va">self</span>.collectCherries(grid, r1 <span class="op">+</span> <span class="dv">1</span>, c1, c2), <span class="va">self</span>.collectCherries(grid, r1, c1 <span class="op">+</span> <span class="dv">1</span>, c2)),</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                        <span class="bu">max</span>(<span class="va">self</span>.collectCherries(grid, r1 <span class="op">+</span> <span class="dv">1</span>, c1, c2 <span class="op">+</span> <span class="dv">1</span>), <span class="va">self</span>.collectCherries(grid, r1, c1 <span class="op">+</span> <span class="dv">1</span>, c2 <span class="op">+</span> <span class="dv">1</span>)))</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        dp[r1][c1][c2] <span class="op">=</span> cherries</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cherries</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<p>C++ is good for speed and managing memory, which makes it great for
big data:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cherryPickup<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">)));</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> collectCherries<span class="op">(</span>grid<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> dp<span class="op">));</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> collectCherries<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">,</span> <span class="dt">int</span> r1<span class="op">,</span> <span class="dt">int</span> c1<span class="op">,</span> <span class="dt">int</span> c2<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&gt;&amp;</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> r2 <span class="op">=</span> r1 <span class="op">+</span> c1 <span class="op">-</span> c2<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r1 <span class="op">&gt;=</span> grid<span class="op">.</span>size<span class="op">()</span> <span class="op">||</span> c1 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">||</span> r2 <span class="op">&gt;=</span> grid<span class="op">.</span>size<span class="op">()</span> <span class="op">||</span> c2 <span class="op">&gt;=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">||</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>r2<span class="op">][</span>c2<span class="op">]</span> <span class="op">==</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> INT_MIN<span class="op">;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>r1 <span class="op">==</span> grid<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span> <span class="op">&amp;&amp;</span> c1 <span class="op">==</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">];</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">];</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cherries <span class="op">=</span> grid<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">];</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>c1 <span class="op">!=</span> c2<span class="op">)</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            cherries <span class="op">+=</span> grid<span class="op">[</span>r2<span class="op">][</span>c2<span class="op">];</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        cherries <span class="op">+=</span> max<span class="op">(</span>max<span class="op">(</span>collectCherries<span class="op">(</span>grid<span class="op">,</span> r1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c1<span class="op">,</span> c2<span class="op">,</span> dp<span class="op">),</span> collectCherries<span class="op">(</span>grid<span class="op">,</span> r1<span class="op">,</span> c1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c2<span class="op">,</span> dp<span class="op">)),</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>                        max<span class="op">(</span>collectCherries<span class="op">(</span>grid<span class="op">,</span> r1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c1<span class="op">,</span> c2 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> dp<span class="op">),</span> collectCherries<span class="op">(</span>grid<span class="op">,</span> r1<span class="op">,</span> c1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> c2 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> dp<span class="op">)));</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>r1<span class="op">][</span>c1<span class="op">][</span>c2<span class="op">]</span> <span class="op">=</span> cherries<span class="op">;</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Readability</strong>: Python is usually the easiest to read
because of its simple syntax. Java is also clear but has more words. C++
is powerful but can be harder for beginners to understand.</li>
<li><strong>Execution Speed</strong>: C++ is often faster because it
controls memory better. Java and Python might be slower because they
have higher-level features and garbage collection.</li>
<li><strong>Memory Usage</strong>: C++ gives us more control over
memory, which can help us make it more efficient. Java has automatic
garbage collection, and Pythonâ€™s way of typing can use more memory.</li>
</ul>
<p>Each implementation has its own good parts. The choice of language
can depend on what we need and what the developer likes. For more
reading on dynamic programming problems, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-edit-distance-hard.html">Dynamic
Programming - Edit Distance</a>.</p>
<h2 id="common-challenges-and-solutions-in-cherry-pickup">Common
Challenges and Solutions in Cherry Pickup</h2>
<p>The Cherry Pickup problem has some challenges. These come from its
complexity and the rules for moving in the grid. Here we list some
common problems we face when we solve the Cherry Pickup problem using
dynamic programming. We also share some solutions.</p>
<h3 id="managing-multiple-paths">1. Managing Multiple Paths</h3>
<p>One big challenge is to manage the many paths that the two players
can take to collect the most cherries. Each playerâ€™s path can affect the
other. This is especially true when they meet or go to the same grid
cell.</p>
<p><strong>Solution:</strong> We can use a 3D dynamic programming array
<code>dp[x1][y1][x2]</code>. This array helps us keep track of the most
cherries collected. Player one is at <code>(x1, y1)</code> and player
two is at <code>(x2, y2)</code>. To find player twoâ€™s position, we use
<code>y2 = x1 + y1 - x2</code>.</p>
<h3 id="handling-obstacles">2. Handling Obstacles</h3>
<p>The grid may have obstacles that block movement. This makes it harder
to find paths.</p>
<p><strong>Solution:</strong> We should add checks to skip cells with
obstacles while we update the dynamic programming table. We can use a
boolean matrix to show where the obstacles are. The DP updates should
only happen in valid cells.</p>
<h3 id="memory-optimization">3. Memory Optimization</h3>
<p>Using a 3D array can use a lot of memory, especially for big
grids.</p>
<p><strong>Solution:</strong> We can save memory by using only two 2D
arrays (one for previous and one for current). We only need the previous
state to calculate the current one. This change can reduce space use
from O(n^3) to O(n^2).</p>
<h3 id="base-case-initialization">4. Base Case Initialization</h3>
<p>It is important to set up the base cases right. This is key for the
DP array to work.</p>
<p><strong>Solution:</strong> We start with both players at the top-left
corner of the grid. We also need to handle cases where a player starts
on an obstacle or outside the grid.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co">// Java Code Snippet for DP Initialization</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[][][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">],</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">],</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Start at top-left corner</span></span></code></pre></div>
<h3 id="correct-transition-logic">5. Correct Transition Logic</h3>
<p>Making the right transition logic to update the DP table based on
playersâ€™ moves is tricky.</p>
<p><strong>Solution:</strong> We need to define the transition states
carefully based on the last positions of both players. For each
position, we calculate the maximum cherries collected by looking at all
previous moves.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Python Code Snippet for Transition Logic</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x1 <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> y1 <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> x2 <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            y2 <span class="op">=</span> x1 <span class="op">+</span> y1 <span class="op">-</span> x2  <span class="co"># Calculate y2 based on x1, y1, x2</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> y2 <span class="op">&lt;</span> n:  <span class="co"># Check bounds</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Update dp[x1][y1][x2]</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                dp[x1][y1][x2] <span class="op">=</span> <span class="bu">max</span>(dp[x1][y1][x2], prev_dp[x1][y1][x2] <span class="op">+</span> cherries)</span></code></pre></div>
<h3 id="complexity-management">6. Complexity Management</h3>
<p>The time complexity can get very high with big grids. This makes it
hard to compute in a good time.</p>
<p><strong>Solution:</strong> We can use pruning techniques. This means
we skip unnecessary calculations. For example, we can stop loops early
if certain conditions are met, like if the cherry count is already less
than a known maximum.</p>
<p>These challenges are normal when we work on the dynamic programming
Cherry Pickup problem. But with smart solutions, we can manage them well
to create a good algorithm. To learn more about dynamic programming
techniques, we can check related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-edit-distance-hard.html">Dynamic
Programming Edit Distance</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-cherry-pickup-problem-in-dynamic-programming">1.
What is the Cherry Pickup problem in dynamic programming?</h3>
<p>The Cherry Pickup problem is a well-known challenge in dynamic
programming. In this problem, two players pick cherries from a grid.
They start from opposite corners and move to the center. The goal is to
collect the most cherries while avoiding obstacles. We need to
understand the limits and create a good algorithm to solve this
problem.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-the-cherry-pickup-problem">2.
How can dynamic programming be applied to solve the Cherry Pickup
problem?</h3>
<p>We can use dynamic programming to solve the Cherry Pickup problem by
breaking it into smaller parts. We can use a 3D DP array to keep track
of the maximum cherries collected by both players. This way, we can
improve the movements in the grid. We also need to think about the paths
they share and the obstacles they face.</p>
<h3
id="what-are-the-time-and-space-complexities-associated-with-the-cherry-pickup-algorithm">3.
What are the time and space complexities associated with the Cherry
Pickup algorithm?</h3>
<p>The time complexity for the Cherry Pickup algorithm usually goes from
O(n^3) to O(n^2). This depends on how we implement it and the
optimizations we use. The space complexity also changes, often needing
O(n^2) for the DP table. We need to optimize these complexities to
handle big grids well.</p>
<h3
id="can-the-cherry-pickup-problem-be-solved-using-other-programming-languages-apart-from-java">4.
Can the Cherry Pickup problem be solved using other programming
languages apart from Java?</h3>
<p>Yes, we can implement the Cherry Pickup problem in many programming
languages like Python and C++. Each language has its own strengths. The
choice of language can depend on what the developer is comfortable with
and the performance needed. For example, Python is simple and helps with
quick testing. C++ might give better performance for large data
sets.</p>
<h3
id="what-are-common-challenges-when-implementing-the-cherry-pickup-dynamic-programming-solution">5.
What are common challenges when implementing the Cherry Pickup dynamic
programming solution?</h3>
<p>One common challenge is managing the paths of the two players. This
can make it hard to transition states in the DP model. Also, we need to
optimize space to avoid using too much memory. Knowing these challenges
is important for a good implementation. They can lead us to creative
solutions in algorithms.</p>
<p>For more reading on dynamic programming and its challenges, we can
check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            