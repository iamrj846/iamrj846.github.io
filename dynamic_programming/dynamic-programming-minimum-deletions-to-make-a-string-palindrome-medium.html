
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Minimum Deletions to Make a String Palindrome - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn dynamic programming techniques to find the minimum deletions needed to transform a string into a palindrome.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Minimum Deletions to Make a String Palindrome - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The problem of minimum deletions to make a string palindrome is a
well-known task in dynamic programming. We want to find the least number
of deletions needed to change a string into a palindrome. A palindrome
is a string that looks the same when read from the start or the end. By
removing some characters, we can make this happen with few changes.</p>
<p>In this article, we will look at how to use dynamic programming to
solve the minimum deletions to make a string palindrome problem. We will
start with a simple overview of the solution. Then, we will talk about
the problem statement in detail. After that, we will check how to
implement this in Java, Python, and C++. We will also see ways to make
our space use better. In the end, we will compare different dynamic
programming solutions and answer common questions about this topic.</p>
<ul>
<li>Dynamic Programming Minimum Deletions to Make a String Palindrome
Solution Overview</li>
<li>Understanding the Problem Statement for Minimum Deletions to Make a
String Palindrome</li>
<li>Dynamic Programming Approach to Minimum Deletions to Make a String
Palindrome in Java</li>
<li>Dynamic Programming Approach to Minimum Deletions to Make a String
Palindrome in Python</li>
<li>Dynamic Programming Approach to Minimum Deletions to Make a String
Palindrome in C++</li>
<li>Optimizing Space Complexity for Minimum Deletions to Make a String
Palindrome</li>
<li>Comparative Analysis of Dynamic Programming Solutions for Minimum
Deletions to Make a String Palindrome</li>
<li>Testing and Validating the Minimum Deletions to Make a String
Palindrome Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-minimum-deletions-to-make-a-string-palindrome">Understanding
the Problem Statement for Minimum Deletions to Make a String
Palindrome</h2>
<p>We have a problem. We need to find the minimum deletions to make a
string a palindrome.</p>
<p>Given a string <code>s</code>, we want to know how many characters we
need to delete from <code>s</code> for it to be a palindrome. A
palindrome is a string that reads the same from the front and the
back.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ol type="1">
<li><p><strong>Palindrome Definition</strong>: A string <code>s</code>
is a palindrome if <code>s[i]</code> is the same as
<code>s[n-i-1]</code> for all valid numbers <code>i</code>. Here,
<code>n</code> is the length of the string.</p></li>
<li><p><strong>Dynamic Programming Approach</strong>: We can use dynamic
programming to solve this. We find the longest palindromic subsequence
in <code>s</code>. The minimum deletions we need can be found like this:
[ = s - ]</p></li>
<li><p><strong>Subproblems</strong>: To find the longest palindromic
subsequence, we create a 2D DP array <code>dp[i][j]</code>. This array
will keep the length of the longest palindromic subsequence in the part
of the string from <code>s[i]</code> to <code>s[j]</code>.</p></li>
</ol>
<h3 id="example">Example</h3>
<p>Letâ€™s look at an example. For the string <code>s = "abca"</code>: -
The longest palindromic subsequence is <code>aca</code>, and it has a
length of 3. - So, the minimum deletions we need is ( 4 - 3 = 1 ).</p>
<p>This method helps us find the result quickly. We break down the
problem and use memoization. This is important in dynamic programming
for string and subsequence problems.</p>
<h2
id="dynamic-programming-approach-to-minimum-deletions-to-make-a-string-palindrome-in-java">Dynamic
Programming Approach to Minimum Deletions to Make a String Palindrome in
Java</h2>
<p>To solve the problem of finding the least number of deletions to make
a string a palindrome using dynamic programming in Java, we follow these
steps:</p>
<ol type="1">
<li><p><strong>Understanding the concept</strong>: We find the minimum
deletions needed by looking at the longest palindromic subsequence (LPS)
of the string. The formula is: [ = - ]</p></li>
<li><p><strong>Dynamic Programming Table Setup</strong>: We will use a
2D array <code>dp</code>. Here, <code>dp[i][j]</code> means the length
of the longest palindromic subsequence in the substring from index
<code>i</code> to index <code>j</code>.</p></li>
<li><p><strong>Filling the DP Table</strong>:</p>
<ul>
<li>If the characters at the ends (i.e., <code>s[i]</code> and
<code>s[j]</code>) are the same, then: [ dp[i][j] = dp[i + 1][j - 1] + 2
]</li>
<li>If they are not the same, then: [ dp[i][j] = (dp[i + 1][j], dp[i][j
- 1]) ]</li>
</ul></li>
<li><p><strong>Java Implementation</strong>:</p></li>
</ol>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinDeletionsToPalindrome <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">minDeletions</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: single character palindromes</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP table</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The minimum deletions needed</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n <span class="op">-</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s <span class="op">=</span> <span class="st">&quot;abcde&quot;</span><span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum deletions to make the string a palindrome: &quot;</span> <span class="op">+</span> <span class="fu">minDeletions</span><span class="op">(</span>s<span class="op">));</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="5" type="1">
<li><strong>Time and Space Complexity</strong>:
<ul>
<li>Time Complexity: (O(n^2)) where (n) is the length of the
string.</li>
<li>Space Complexity: (O(n^2)) for the DP table.</li>
</ul></li>
</ol>
<p>This code helps us find the minimum deletions needed to change the
string into a palindrome using dynamic programming in Java. For more
about similar dynamic programming problems, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming: Longest Palindromic Subsequence</a>.</p>
<h2
id="dynamic-programming-approach-to-minimum-deletions-to-make-a-string-palindrome-in-python">Dynamic
Programming Approach to Minimum Deletions to Make a String Palindrome in
Python</h2>
<p>We want to find the minimum deletions needed to make a string a
palindrome. We can do this using dynamic programming in Python. We will
use a two-dimensional DP array. The main idea is to find the longest
palindromic subsequence (LPS) in the string. The minimum deletions
needed will be the difference between the length of the string and the
length of the LPS.</p>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li><p><strong>Initialize a DP Table</strong>: We create a 2D list
<code>dp</code>. In this list, <code>dp[i][j]</code> will hold the
length of the longest palindromic subsequence in the substring from
index <code>i</code> to index <code>j</code>.</p></li>
<li><p><strong>Base Cases</strong>: Each single character is a
palindrome with length 1. So we set <code>dp[i][i] = 1</code> for all
<code>i</code>.</p></li>
<li><p><strong>Fill the DP Table</strong>:</p>
<ul>
<li>For substrings of length 2 or more, we check if the characters at
both ends are the same:
<ul>
<li>If they are the same, we set
<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>.</li>
<li>If they are not the same, we set
<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>.</li>
</ul></li>
</ul></li>
<li><p><strong>Calculate Minimum Deletions</strong>: The result is
<code>len(s) - dp[0][len(s) - 1]</code>.</p></li>
</ol>
<h3 id="python-code">Python Code</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_deletions_to_make_palindrome(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Every single character is a palindrome</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">+</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Minimum deletions</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">-</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;abcde&quot;</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(min_deletions_to_make_palindrome(s))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The code defines a function
<code>min_deletions_to_make_palindrome</code>. This function takes a
string <code>s</code> as input.</li>
<li>We start by making a DP table with size <code>n x n</code>, where
<code>n</code> is the length of the string.</li>
<li>We fill the DP table based on if characters at the current indices
are the same or different.</li>
<li>Finally, we calculate the minimum deletions needed by subtracting
the length of the longest palindromic subsequence from the total length
of the string.</li>
</ul>
<p>This dynamic programming method gives us a good solution to find the
minimum deletions to make a string palindrome in Python. If you want to
learn more, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-insertions-to-form-a-palindrome-medium.html">Minimum
Insertions to Form a Palindrome</a>.</p>
<h2
id="dynamic-programming-approach-to-minimum-deletions-to-make-a-string-palindrome-in-c">Dynamic
Programming Approach to Minimum Deletions to Make a String Palindrome in
C++</h2>
<p>To find the minimum deletions needed to make a string a palindrome
using dynamic programming in C++, we can use a two-dimensional DP array.
We will find the longest palindromic subsequence (LPS) of the string.
The minimum deletions will be the difference between the length of the
string and the length of the LPS.</p>
<h3 id="implementation-steps-1">Implementation Steps:</h3>
<ol type="1">
<li>Create a DP table. Here <code>dp[i][j]</code> shows the length of
the longest palindromic subsequence in the substring from index
<code>i</code> to <code>j</code>.</li>
<li>Start the table: single characters are palindromes with length
1.</li>
<li>Fill the table with this logic:
<ul>
<li>If the characters at both ends are the same, we include them in the
LPS:<br />
<code>dp[i][j] = dp[i + 1][j - 1] + 2</code></li>
<li>If they are different, we take the maximum LPS by either leaving out
the left or the right character:<br />
<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code></li>
</ul></li>
<li>The length of the longest palindromic subsequence is found in
<code>dp[0][n - 1]</code>, where <code>n</code> is the length of the
string.</li>
<li>Return <code>n - dp[0][n - 1]</code> as the answer for minimum
deletions.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minDeletionsToPalindrome<span class="op">(</span>string str<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> str<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Single characters are palindromes</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the DP table</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>str<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> str<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The minimum deletions required</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> n <span class="op">-</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    string str <span class="op">=</span> <span class="st">&quot;abca&quot;</span><span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum deletions to make the string a palindrome: &quot;</span> </span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> minDeletionsToPalindrome<span class="op">(</span>str<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The <code>minDeletionsToPalindrome</code> function takes a string as
input and starts a DP table.</li>
<li>It goes through all possible lengths of substrings and fills the DP
table based on the rules given.</li>
<li>The answer is found by subtracting the length of the longest
palindromic subsequence from the length of the string.</li>
</ul>
<p>This way, we can find the minimum deletions needed to turn a string
into a palindrome using dynamic programming in C++. For more information
on similar problems, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Longest
Palindromic Subsequence</a>.</p>
<h2
id="optimizing-space-complexity-for-minimum-deletions-to-make-a-string-palindrome">Optimizing
Space Complexity for Minimum Deletions to Make a String Palindrome</h2>
<p>When we solve the problem of minimum deletions to change a string
into a palindrome using dynamic programming, we often face the challenge
of space complexity. The basic dynamic programming method usually needs
a 2D array to keep track of results. This leads to O(n^2) space usage,
where n is the length of the string.</p>
<p>To make space usage better, we can change the 2D array into a 1D
array. This works because we only need the current and previous rows of
the DP table at any step.</p>
<h3 id="optimized-algorithm">Optimized Algorithm</h3>
<ol type="1">
<li><p><strong>Define the Problem</strong>: Let <code>s</code> be the
input string with length <code>n</code>. We want to find how many
deletions we need to make <code>s</code> a palindrome.</p></li>
<li><p><strong>Use a 1D Array</strong>: We will use a 1D array
<code>dp</code>. Each <code>dp[j]</code> shows how many deletions we
need to change the substring <code>s[i..j]</code> into a
palindrome.</p></li>
<li><p><strong>Transition Formula</strong>:</p>
<ul>
<li>If <code>s[i]</code> equals <code>s[j]</code>, then
<code>dp[j]</code> equals <code>dp[j-1]</code> (no deletions needed for
these characters).</li>
<li>If <code>s[i]</code> does not equal <code>s[j]</code>, then
<code>dp[j]</code> equals 1 plus the minimum of <code>dp[j]</code> and
<code>dp[j-1]</code> (one deletion plus the least deletions needed for
the rest).</li>
</ul></li>
<li><p><strong>Implementation</strong>: Here is the optimized code in
Java:</p></li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumDeletions <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">minDeletions</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> prev <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// to store dp[j-1]</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> temp <span class="op">=</span> dp<span class="op">[</span>j<span class="op">];</span> <span class="co">// store current dp[j]</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> prev<span class="op">;</span> <span class="co">// no deletion needed</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// one deletion</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                prev <span class="op">=</span> temp<span class="op">;</span> <span class="co">// update prev for next iteration</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// minimum deletions for the whole string</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s <span class="op">=</span> <span class="st">&quot;abcde&quot;</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum deletions to make the string a palindrome: &quot;</span> <span class="op">+</span> <span class="fu">minDeletions</span><span class="op">(</span>s<span class="op">));</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="space-complexity-analysis">Space Complexity Analysis</h3>
<ul>
<li>The space complexity is now O(n) because we use a 1D array instead
of a 2D array.</li>
<li>This change is important for long strings. It gives a better
solution in both time and space.</li>
</ul>
<p>By making space complexity better for the minimum deletions problem,
we can handle longer strings more easily. It also keeps the code clear.
For more reading on similar dynamic programming topics, check these
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming: Longest Palindromic Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-insertions-to-form-a-palindrome-medium.html">Dynamic
Programming: Minimum Insertions to Form a Palindrome</a>.</p>
<h2
id="comparative-analysis-of-dynamic-programming-solutions-for-minimum-deletions-to-make-a-string-palindrome">Comparative
Analysis of Dynamic Programming Solutions for Minimum Deletions to Make
a String Palindrome</h2>
<p>Finding the minimum deletions to make a string a palindrome can be
done in many ways using dynamic programming. We will look at different
methods. We will compare them based on how complex they are, how fast
they run, and how easy they are to use.</p>
<h3 id="approaches">Approaches</h3>
<ol type="1">
<li><strong>Basic Dynamic Programming Table Approach</strong>:
<ul>
<li><strong>Time Complexity</strong>: O(n^2)</li>
<li><strong>Space Complexity</strong>: O(n^2)</li>
<li><strong>Description</strong>: We make a 2D table. Here,
<code>dp[i][j]</code> shows the minimum deletions needed to turn the
substring <code>s[i:j+1]</code> into a palindrome. We fill the table by
comparing characters and using results we already have.</li>
</ul>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minDeletions</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> len <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Optimized Space Complexity Approach</strong>:
<ul>
<li><strong>Time Complexity</strong>: O(n^2)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
<li><strong>Description</strong>: We use only two arrays called
<code>current</code> and <code>previous</code> to keep the results of
the last two rows. This helps us use much less space.</li>
</ul>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_deletions(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    current <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        previous <span class="op">=</span> current.copy()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                current[j] <span class="op">=</span> previous[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                current[j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(previous[j], current[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> current[n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div></li>
<li><strong>Recursive with Memoization Approach</strong>:
<ul>
<li><strong>Time Complexity</strong>: O(n^2)</li>
<li><strong>Space Complexity</strong>: O(n^2)</li>
<li><strong>Description</strong>: We can use a recursive function with
memoization. This means we save results we already calculated to avoid
doing the same work again.</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> helper<span class="op">(</span>string <span class="op">&amp;</span>s<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="dt">int</span> j<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> <span class="op">&amp;</span>memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> j<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> helper<span class="op">(</span>s<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> min<span class="op">(</span>helper<span class="op">(</span>s<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> j<span class="op">,</span> memo<span class="op">),</span> helper<span class="op">(</span>s<span class="op">,</span> i<span class="op">,</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minDeletions<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> memo<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> helper<span class="op">(</span>s<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Speed</strong>: All methods have the same time complexity.
But the optimized space method usually runs faster because it uses less
memory.</li>
<li><strong>Memory Usage</strong>: The basic DP method needs more
memory. The optimized version needs only O(n).</li>
<li><strong>Ease of Implementation</strong>: The basic DP and recursive
methods are often easier to understand and use. The space-optimized
method may need careful work with arrays.</li>
</ul>
<h3 id="practical-considerations">Practical Considerations</h3>
<ul>
<li><strong>Input Size</strong>: For bigger input sizes, we should
choose the space-optimized method to use memory better.</li>
<li><strong>Code Clarity</strong>: Choosing which method to use can
depend on whether we want clear code or fast performance.</li>
<li>If we want to learn more about similar dynamic programming problems,
we can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-insertions-to-form-a-palindrome-medium.html">Minimum
Insertions to Form a Palindrome</a> and other related algorithms.</li>
</ul>
<h2
id="testing-and-validating-the-minimum-deletions-to-make-a-string-palindrome-solutions">Testing
and Validating the Minimum Deletions to Make a String Palindrome
Solutions</h2>
<p>We need to test and validate the dynamic programming solutions for
finding the minimum deletions to make a string a palindrome. This step
is important to make sure our solution is correct and works well. We
will create different test cases. These cases will include edge cases,
normal situations, and tests for performance.</p>
<h3 id="test-cases">Test Cases</h3>
<ol type="1">
<li><strong>Basic Cases</strong>
<ul>
<li>Input: <code>"abca"</code>
<ul>
<li>Expected Output: <code>1</code> (removing either â€˜bâ€™ or â€˜câ€™ makes it
a palindrome)</li>
</ul></li>
<li>Input: <code>"racecar"</code>
<ul>
<li>Expected Output: <code>0</code> (it is already a palindrome)</li>
</ul></li>
<li>Input: <code>"abcd"</code>
<ul>
<li>Expected Output: <code>3</code> (removing â€˜aâ€™, â€˜bâ€™, and â€˜câ€™ leaves
â€˜dâ€™)</li>
</ul></li>
</ul></li>
<li><strong>Edge Cases</strong>
<ul>
<li>Input: <code>""</code> (empty string)
<ul>
<li>Expected Output: <code>0</code></li>
</ul></li>
<li>Input: <code>"a"</code> (single character)
<ul>
<li>Expected Output: <code>0</code></li>
</ul></li>
<li>Input: <code>"aa"</code> (two same characters)
<ul>
<li>Expected Output: <code>0</code></li>
</ul></li>
<li>Input: <code>"abcdeedcba"</code>
<ul>
<li>Expected Output: <code>0</code> (it is already a palindrome)</li>
</ul></li>
</ul></li>
<li><strong>Longer Strings</strong>
<ul>
<li>Input: <code>"abcdefghijklmno"</code>
<ul>
<li>Expected Output: <code>13</code> (removing all but one
character)</li>
</ul></li>
<li>Input: <code>"aabbccddeeffgg"</code>
<ul>
<li>Expected Output: <code>7</code> (removing to form â€˜abcdefgâ€™)</li>
</ul></li>
</ul></li>
</ol>
<h3 id="performance-testing">Performance Testing</h3>
<p>We should test the algorithm with big strings. This helps us check if
it runs in a good time:</p>
<ul>
<li><strong>Input:</strong> A string of 1000 characters, all the same.
<ul>
<li>Expected Output: <code>0</code></li>
</ul></li>
<li><strong>Input:</strong> A string of 1000 characters, all different.
<ul>
<li>Expected Output: <code>999</code></li>
</ul></li>
</ul>
<h3 id="validation-code-example">Validation Code Example</h3>
<p>Here is a simple code in Python to check the minimum deletions
solution using dynamic programming:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_deletions_to_palindrome(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i <span class="op">+</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing the function</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>test_cases <span class="op">=</span> [<span class="st">&quot;abca&quot;</span>, <span class="st">&quot;racecar&quot;</span>, <span class="st">&quot;abcd&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;aa&quot;</span>, <span class="st">&quot;abcdefghijklmno&quot;</span>, <span class="st">&quot;aabbccddeeffgg&quot;</span>]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> test <span class="kw">in</span> test_cases:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Input: </span><span class="sc">{</span>test<span class="sc">}</span><span class="ss">, Minimum Deletions: </span><span class="sc">{</span>min_deletions_to_palindrome(test)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="automated-testing">Automated Testing</h3>
<p>We can use automated testing tools like <code>unittest</code> in
Python or JUnit in Java. This way we can create tests that run by
themselves. This ensures that changes we make to the dynamic programming
solution do not break what already works.</p>
<h3 id="considerations">Considerations</h3>
<ul>
<li>We must check if the algorithm works with strings that have mixed
cases and special characters.</li>
<li>Test how the algorithm performs with the biggest input size. For
example, a string with 10,000 characters. This helps us see its time
complexity, which should ideally be O(n^2).</li>
<li>We should compare results with known solutions or results calculated
by hand to make sure they are correct.</li>
</ul>
<p>This way of testing and validating the minimum deletions to make a
string palindrome solutions helps us keep it reliable and correct in
different situations.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-minimum-number-of-deletions-needed-to-make-a-string-a-palindrome">1.
What is the minimum number of deletions needed to make a string a
palindrome?</h3>
<p>We need to find how many deletions we must do to change a string into
a palindrome. We can use dynamic programming for this. First, we find
the longest palindromic subsequence in the string. Then, we can find the
minimum deletions by taking the total length of the string and
subtracting the length of this subsequence. This method works well and
runs in O(n^2) time.</p>
<h3
id="how-does-the-dynamic-programming-approach-work-for-minimum-deletions-to-make-a-string-palindrome">2.
How does the dynamic programming approach work for minimum deletions to
make a string palindrome?</h3>
<p>In the dynamic programming approach, we make a 2D table. Each cell
shows if a substring is a palindrome. We fill this table by checking the
characters at both ends of the substrings. We also use results we found
before to get the minimum deletions. This way, we get the best solutions
by using smaller parts of the problem.</p>
<h3
id="can-you-provide-a-sample-implementation-of-minimum-deletions-to-make-a-string-palindrome-in-python">3.
Can you provide a sample implementation of minimum deletions to make a
string palindrome in Python?</h3>
<p>Sure! Here is a simple Python code that finds the minimum deletions
to make a string a palindrome using dynamic programming:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minDeletions(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> <span class="bu">min</span>(dp[i <span class="op">+</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<p>This code uses a 2D array to keep results and finds the minimum
deletions in a smart way.</p>
<h3
id="how-can-we-optimize-space-complexity-for-the-minimum-deletions-to-make-a-string-palindrome">4.
How can we optimize space complexity for the minimum deletions to make a
string palindrome?</h3>
<p>To make the space usage better in the dynamic programming solution,
we can change the 2D array into a 1D array. We only need the current and
previous rows at any time. This change lowers the space from O(n^2) to
O(n) but keeps the same time complexity.</p>
<h3
id="is-there-a-relationship-between-minimum-deletions-to-make-a-string-palindrome-and-longest-palindromic-subsequence">5.
Is there a relationship between minimum deletions to make a string
palindrome and longest palindromic subsequence?</h3>
<p>Yes, there is a clear link between the minimum deletions needed to
create a palindrome and the length of the longest palindromic
subsequence. To find the minimum deletions, we can subtract the length
of the longest palindromic subsequence from the length of the string.
Knowing this helps us use dynamic programming to solve similar problems
well.</p>
<p>If you want to learn more about dynamic programming, you can check
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">longest
palindromic subsequence</a> or related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-insertions-to-form-a-palindrome-medium.html">minimum
insertions to form a palindrome</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            