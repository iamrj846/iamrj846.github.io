
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Optimal Path in a Grid with Obstacles - Medium</title>
            <meta name="description" content="Discover how to solve the optimal path in a grid with obstacles using dynamic programming. Enhance your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Optimal Path in a Grid with Obstacles - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong technique we use to solve problems by
breaking them into simpler parts. When we want to find the best path in
a grid with obstacles, we need to find the quickest way from the
top-left corner to the bottom-right corner. We must do this while
avoiding obstacles. We can solve this problem well using dynamic
programming. We create a 2D array to track how many ways we can reach
each cell while avoiding the obstacles.</p>
<p>In this article, we will look at how to find the best path in a grid
with obstacles using dynamic programming. First, we will understand the
problem. Then we will go into the dynamic programming method for solving
this problem in Java, Python, and C++. We will also talk about how to
make our solution use less space. We will handle special cases and
compare different methods. Finally, we will analyze the complexity of
our dynamic programming solution and answer common questions about the
optimal path problem.</p>
<ul>
<li>[Dynamic Programming] Finding the Optimal Path in a Grid with
Obstacles</li>
<li>Understanding the Problem Statement for Optimal Path in a Grid</li>
<li>Dynamic Programming Approach to Solve Grid Obstacles Problem in
Java</li>
<li>Dynamic Programming Approach to Solve Grid Obstacles Problem in
Python</li>
<li>Dynamic Programming Approach to Solve Grid Obstacles Problem in
C++</li>
<li>Optimizing Space Complexity in Grid Pathfinding</li>
<li>Handling Edge Cases in Optimal Path Problem</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Complexity Analysis of the Dynamic Programming Solution</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information on dynamic programming, we can check articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>
<h2
id="understanding-the-problem-statement-for-optimal-path-in-a-grid">Understanding
the Problem Statement for Optimal Path in a Grid</h2>
<p>The optimal path in a grid with obstacles problem is about finding
the shortest way from the top-left corner to the bottom-right corner of
a grid. The grid has cells that can be passable (0) or blocked by
obstacles (1). Our goal is to check if a valid path exists. If it does,
we want to find the path that takes the least steps or is the
longest.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: A 2D grid shown as an array of integers.
Here:
<ul>
<li><code>0</code> means a free cell.</li>
<li><code>1</code> means an obstacle.</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>A boolean that shows if a path exists.</li>
<li>The length of the path if it exists or -1 if no path is found.</li>
</ul></li>
</ul>
<h3 id="example">Example</h3>
<p>Look at this grid:</p>
<pre><code>[
  [0, 0, 0],
  [0, 1, 0],
  [0, 0, 0]
]</code></pre>
<p>There is a valid path. We can move from the top-left (0,0) to the
bottom-right (2,2), going around the obstacle at (1,1).</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The grid can be size m x n where 1 &lt;= m, n &lt;= 100.</li>
<li>The starting point and the destination are always free.</li>
</ul>
<h3 id="key-considerations">Key Considerations</h3>
<ul>
<li>We can only move right, down, left, and up.</li>
<li>We need to think about edge cases like completely blocked paths or
single-cell grids.</li>
<li>Our solution should look through the grid quickly to avoid too much
time.</li>
</ul>
<p>We can solve this problem well using dynamic programming techniques.
This helps us find the best path even with obstacles. We can implement
this in different programming languages like Java, Python, and C++. Each
will use arrays to keep track of the cells. For more details, we can
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II - Grid with Obstacles</a>.</p>
<h2
id="dynamic-programming-approach-to-solve-grid-obstacles-problem-in-java">Dynamic
Programming Approach to Solve Grid Obstacles Problem in Java</h2>
<p>We want to solve the problem of finding the best path in a grid with
obstacles using dynamic programming in Java. We will make a 2D array to
save the number of ways to reach each cell. We will go through each cell
in the grid. We will count the ways to get to that cell from the left or
from above.</p>
<h3 id="java-code-implementation">Java Code Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> GridPathWithObstacles <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePathsWithObstacles</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>obstacleGrid <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> obstacleGrid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Start point</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the first column</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span> <span class="co">// If we meet an obstacle</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the first row</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">break</span><span class="op">;</span> <span class="co">// If we meet an obstacle</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the dp table</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// No path if there&#39;s an obstacle</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Sum paths from top and left</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Return the number of ways to reach the bottom-right corner</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        GridPathWithObstacles solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridPathWithObstacles</span><span class="op">();</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> obstacleGrid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">}</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Unique Paths: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">uniquePathsWithObstacles</span><span class="op">(</span>obstacleGrid<span class="op">));</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-47"><a href="#cb2-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<p>We check initial conditions. We return 0 if the starting cell is
blocked. We set up a <code>dp</code> array. In this array,
<code>dp[i][j]</code> shows the number of unique paths to reach cell
<code>(i, j)</code>.</p>
<p>We fill the first row and the first column based on obstacles. For
each other cell, if it is not an obstacle, we find the value by adding
the values from the cell above and the cell to the left. Finally, we
return the number of unique paths to the bottom-right corner.</p>
<p>This dynamic programming solution calculates the number of unique
paths in a grid with obstacles. It keeps a time complexity of (O(m n))
and a space complexity of (O(m n)).</p>
<p>For more related dynamic programming problems, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Unique
Paths in a Grid</a>.</p>
<h2
id="dynamic-programming-approach-to-solve-grid-obstacles-problem-in-python">Dynamic
Programming Approach to Solve Grid Obstacles Problem in Python</h2>
<p>We can solve the optimal path problem in a grid with obstacles by
using dynamic programming in Python. We will use a 2D list to keep track
of how many ways we can reach each cell. The main idea is to go through
each cell and see if we can extend the path based on the cell’s value
and if there are any obstacles.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a grid that is <code>m x n</code> size. In this grid,
<code>0</code> means an empty cell and <code>1</code> means an obstacle.
We need to find how many unique paths go from the top-left corner to the
bottom-right corner. We can only move down or right.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create a 2D list <code>dp</code>
that has the size <code>m x n</code>. We start with all values set to
<code>0</code>.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>We set <code>dp[0][0]</code> to <code>1</code> if the starting cell
is not an obstacle.</li>
<li>For the first row and first column, if there are no obstacles, we
can inherit paths from the previous cell.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>: For each cell, if it is not
an obstacle, we set <code>dp[i][j]</code> to the sum of the values from
the cell above and the cell to the left.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obstacleGrid <span class="kw">or</span> obstacleGrid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Starting point</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill first column</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="cf">if</span> obstacleGrid[i][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill first row</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> obstacleGrid[<span class="dv">0</span>][j] <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the rest of the dp table</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>obstacleGrid <span class="op">=</span> [</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>],</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(uniquePathsWithObstacles(obstacleGrid))  <span class="co"># Output: 2</span></span></code></pre></div>
<p>This code helps us find the number of unique paths in a grid with
obstacles. We use dynamic programming to make sure we count blocked
paths correctly while building the solution. If we want to learn more
about related dynamic programming problems, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming - Unique Paths II</a>.</p>
<h2
id="dynamic-programming-approach-to-solve-grid-obstacles-problem-in-c">Dynamic
Programming Approach to Solve Grid Obstacles Problem in C++</h2>
<p>To solve the best path problem in a grid with obstacles using dynamic
programming in C++, we will make a 2D DP array. This array will store
the number of ways to reach each cell in the grid. The grid has
obstacles that we show as <code>1</code> (blocked) and free spaces as
<code>0</code>. Our goal is to find how many different paths go from the
top-left corner (0,0) to the bottom-right corner (m-1,n-1).</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li>First, we create a 2D vector <code>dp</code> with size
<code>m x n</code> and fill it with zeros.</li>
<li>We set <code>dp[0][0]</code> to <code>1</code> if the starting cell
is not blocked.</li>
<li>Next, we go through each cell in the grid:
<ul>
<li>If the cell is an obstacle, we set <code>dp[i][j]</code> to
<code>0</code>.</li>
<li>If the cell is not blocked, we update <code>dp[i][j]</code> by
adding the ways to come from the top and left cells. That means
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code>.</li>
</ul></li>
<li>Finally, we return the value in <code>dp[m-1][n-1]</code>. This
value shows the number of different paths to the bottom-right
corner.</li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation:</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> uniquePathsWithObstacles<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> obstacleGrid<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// cell is blocked</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span> <span class="co">// from top</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span> <span class="co">// from left</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span> <span class="co">// return number of unique paths to the bottom-right corner</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-1">Example:</h3>
<p>For a grid like this, where <code>0</code> means free space and
<code>1</code> means obstacles:</p>
<pre><code>0 0 0
0 1 0
0 0 0</code></pre>
<p>The number of unique paths is <code>2</code>, as we can see below: -
(0,0) → (0,1) → (0,2) → (1,2) → (2,2) - (0,0) → (1,0) → (2,0) → (2,1) →
(2,2)</p>
<p>This dynamic programming way helps us find the number of unique paths
while managing obstacles. It works well for practical grid sizes. If we
want to read more about similar problems, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Unique
Paths II - Grid with Obstacles</a>.</p>
<h2 id="optimizing-space-complexity-in-grid-pathfinding">Optimizing
Space Complexity in Grid Pathfinding</h2>
<p>In dynamic programming for pathfinding in grids with obstacles, we
need to optimize space complexity. This is very important, especially
for large grids. Here are some easy methods to optimize space.</p>
<h3 id="space-reduction-techniques">1. Space Reduction Techniques</h3>
<h4 id="a.-using-1d-arrays">a. Using 1D Arrays</h4>
<p>Instead of using a full 2D DP array, we can use a single 1D array.
The optimal path only needs the current and previous rows. This can help
us save a lot of space.</p>
<p><strong>Example in Java:</strong></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="b.-using-two-rows">b. Using Two Rows</h4>
<p>If we can’t use a single array because we need multiple references,
we can keep only two rows. This is also a good way to reduce space.</p>
<p><strong>Example in Python:</strong></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>)]</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        dp[i <span class="op">%</span> <span class="dv">2</span>][<span class="dv">0</span>] <span class="op">=</span> dp[(i <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">2</span>][<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            dp[i <span class="op">%</span> <span class="dv">2</span>][j] <span class="op">=</span> <span class="bu">min</span>(dp[(i <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">2</span>][j], dp[i <span class="op">%</span> <span class="dv">2</span>][j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> grid[i][j]</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[(m <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> <span class="dv">2</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="in-place-updates">2. In-Place Updates</h3>
<p>When we can change the input grid, we can do calculations directly on
the grid. This helps to save space.</p>
<p><strong>Example in C++:</strong></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Fill first row</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Fill first column</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> min<span class="op">(</span>grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span> <span class="co">// Update current cell</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grid<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="complexity-analysis">3. Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity:</strong> O(m * n), where m is the number of
rows and n is the number of columns.</li>
<li><strong>Space Complexity:</strong> We can optimize to O(n) or O(1)
based on the method we use.</li>
</ul>
<p>By using these space-saving techniques, we can do pathfinding in
grids with obstacles while using less memory. If you want to learn more
about dynamic programming and grid problems, you can check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II - Grid with Obstacles</a>.</p>
<h2 id="handling-edge-cases-in-optimal-path-problem">Handling Edge Cases
in Optimal Path Problem</h2>
<p>When we solve the optimal path problem in a grid with obstacles using
dynamic programming, we must think about some edge cases. These cases
help make sure our solution works well. Here are some common edge cases
to think about:</p>
<ol type="1">
<li><strong>Empty Grid</strong>:
<ul>
<li>If the grid has no rows or no columns, we should return 0. There are
no paths in an empty grid.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span></code></pre></div></li>
<li><strong>Start or End Blocked</strong>:
<ul>
<li>If the starting point at the top-left corner or the ending point at
the bottom-right corner has an obstacle, there is no valid path.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> grid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> grid[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span></code></pre></div></li>
<li><strong>All Blocks are Obstacles</strong>:
<ul>
<li>If all cells in the grid are obstacles except for the start and end
points, we should return 0.</li>
</ul></li>
<li><strong>Single Row or Column</strong>:
<ul>
<li>If the grid has only one row or one column, we need to check if we
can form a path if there are no obstacles in that straight line.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> cell <span class="op">:</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>cell <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Large Grids</strong>:
<ul>
<li>For large grids, we must make sure our algorithm uses memory and
time well. Using memoization or iterative methods can help with
speed.</li>
</ul></li>
<li><strong>Non-square Grids</strong>:
<ul>
<li>We need to handle grids that are not square. If rows do not equal
columns, our dynamic programming logic should work for a rectangular
grid.</li>
</ul></li>
<li><strong>Multiple Paths</strong>:
<ul>
<li>If there are many paths, we must make sure our algorithm counts all
valid paths. This is important when paths can be blocked or
unblocked.</li>
</ul></li>
<li><strong>Dynamic Obstacles</strong>:
<ul>
<li>If the grid can change and obstacles can come and go, our solution
needs to find the best path again quickly.</li>
</ul></li>
</ol>
<p>By keeping these edge cases in mind, we can make sure our dynamic
programming solution for finding the best path in a grid with obstacles
is strong and works well. If you want to learn more about related
dynamic programming topics, you can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II - Grid with Obstacles</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we look at the optimal path problem in a grid with obstacles
using dynamic programming, we can compare different methods. We will
think about their speed, how easy they are to use, and how much space
they need. The two main methods are the <strong>Dynamic Programming
(DP)</strong> approach and the <strong>Depth-First Search (DFS) with
Memoization</strong> approach.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><strong>Functionality</strong>:
<ul>
<li>We use a 2D array called <code>dp</code>. Here,
<code>dp[i][j]</code> shows the number of different paths to reach cell
<code>(i, j)</code>.</li>
<li>We fill this array step by step based on values from previous cells.
We also make sure to consider any obstacles.</li>
</ul></li>
<li><strong>Time Complexity</strong>:
<ul>
<li>It is (O(m n)). Here, (m) is the number of rows and (n) is the
number of columns in the grid.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>It is (O(m n)) for the DP table. But, we can make it better to
(O(n)) by using a rolling array.</li>
</ul></li>
<li><strong>Implementation Example in Python</strong>:</li>
</ol>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obstacleGrid <span class="kw">or</span> obstacleGrid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="depth-first-search-with-memoization">Depth-First Search with
Memoization</h3>
<ol type="1">
<li><strong>Functionality</strong>:
<ul>
<li>This method looks at all possible paths one by one and uses
memoization to remember results of paths we already found. This helps us
not to calculate them again.</li>
</ul></li>
<li><strong>Time Complexity</strong>:
<ul>
<li>In the worst case, it is (O(2^{(m+n)})) because it checks many
paths. But, memoization makes this much faster.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>It needs (O(m n)) for the memoization table and the call stack of
recursion.</li>
</ul></li>
<li><strong>Implementation Example in Python</strong>:</li>
</ol>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstaclesDFS(obstacleGrid):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(i, j):</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> j <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i, j) <span class="kw">in</span> memo:</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>        memo[(i, j)] <span class="op">=</span> dfs(i<span class="op">-</span><span class="dv">1</span>, j) <span class="op">+</span> dfs(i, j<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(m<span class="op">-</span><span class="dv">1</span>, n<span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h3 id="comparative-summary">Comparative Summary</h3>
<ul>
<li><strong>Dynamic Programming</strong> is usually easier to use for
grid problems. It also makes sure we have the best time complexity.</li>
<li><strong>DFS with Memoization</strong> can feel more natural for
problems that need recursive checking. But it can have higher time
complexity if we do not optimize it well.</li>
<li>When we have limited space, the optimized DP method gives a big
advantage by using less space.</li>
</ul>
<p>If you want to read more about dynamic programming problems, you can
check these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II (Grid with Obstacles)</a>.</p>
<h2
id="complexity-analysis-of-the-dynamic-programming-solution">Complexity
Analysis of the Dynamic Programming Solution</h2>
<p>When we look at the complexity of the dynamic programming solution
for finding the best path in a grid with obstacles, we should think
about both time and space complexities.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for the dynamic programming method in this
problem is O(m * n). Here, <code>m</code> is the number of rows and
<code>n</code> is the number of columns in the grid. We visit each cell
of the grid one time. While we do this, we calculate how many ways we
can reach that cell. We also use the results we saved in our DP table
before.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity can change depending on how we implement it:</p>
<ol type="1">
<li><strong>Using a 2D DP Array</strong>:
<ul>
<li>If we use a 2D array to keep track of how many ways to reach each
cell, the space complexity is O(m * n).</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span></code></pre></div></li>
<li><strong>Optimized Space with a 1D DP Array</strong>:
<ul>
<li>We can make the space complexity smaller to O(n) by using a single
array. This array holds the results for the current row and we update it
as we go.</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span></code></pre></div>
In this case, we only keep the current state and a previous state. We
update the current state as we move through the grid.</li>
</ol>
<h3 id="example-analysis">Example Analysis</h3>
<p>Let’s think about a grid that looks like this:</p>
<pre><code>1 0 0
0 1 0
0 0 1</code></pre>
<ul>
<li>We fill the DP table based on these rules:
<ul>
<li>If a cell has an obstacle (0), it stays 0.</li>
<li>If there is no obstacle, the value is the sum of the paths from the
top and left cells.</li>
</ul></li>
</ul>
<p>When we analyze the grid, we see that filling each cell takes a
constant amount of work. This gives us the overall time complexity of
O(m * n).</p>
<h3 id="summary-of-complexity">Summary of Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n)</li>
<li><strong>Space Complexity</strong>:
<ul>
<li>O(m * n) for the full DP table</li>
<li>O(n) for the optimized 1D DP array</li>
</ul></li>
</ul>
<p>This complexity analysis helps us understand how well the dynamic
programming solution works for the best path in a grid with obstacles.
It shows that it can manage larger grids easily. For more reading on
similar dynamic programming problems, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II - Grid with Obstacles</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-best-algorithm-for-finding-an-optimal-path-in-a-grid-with-obstacles">1.
What is the best algorithm for finding an optimal path in a grid with
obstacles?</h3>
<p>We can find the best path in a grid with obstacles using dynamic
programming. This method makes a solution step by step. It saves results
along the way. This helps us perform better than simple methods. The
algorithm finds the lowest cost to reach each cell while looking at
obstacles. This makes it good for different grid pathfinding problems.
For more details, read our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h3
id="how-can-i-implement-a-dynamic-programming-solution-in-python-for-grid-obstacles">2.
How can I implement a dynamic programming solution in Python for grid
obstacles?</h3>
<p>To make a dynamic programming solution in Python for the best path in
a grid with obstacles, we usually keep a 2D list. This list saves the
lowest costs to get to each cell. We will go through the grid and update
the costs based on nearby cells while thinking about obstacles. For a
full guide, see our section on the <a
href="#dynamic-programming-approach-to-solve-grid-obstacles-problem-in-python">Dynamic
Programming Approach in Python</a>.</p>
<h3
id="what-are-the-time-and-space-complexities-for-the-dynamic-programming-approach-in-grid-pathfinding">3.
What are the time and space complexities for the dynamic programming
approach in grid pathfinding?</h3>
<p>The time complexity for the dynamic programming method to find the
best path in a grid with obstacles is O(m * n). Here, m is the number of
rows and n is the number of columns in the grid. We can make the space
complexity better to O(n) by only saving the last row’s data. This helps
us use less memory. Look at our complexity analysis section for more
info on this topic.</p>
<h3
id="can-dynamic-programming-be-used-to-solve-other-grid-related-problems">4.
Can dynamic programming be used to solve other grid-related
problems?</h3>
<p>Yes, dynamic programming is a flexible method. It can solve many grid
problems like the Minimum Path Sum, Unique Paths II, and others. Each
problem needs a special approach. But the main idea is to break the
problem into smaller parts. For examples of similar grid problems, check
our resources on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>
<h3
id="how-do-i-handle-edge-cases-when-implementing-a-grid-pathfinding-algorithm">5.
How do I handle edge cases when implementing a grid pathfinding
algorithm?</h3>
<p>We need to handle edge cases in a grid pathfinding algorithm. This is
important for strong solutions. Common edge cases are empty grids, grids
with only obstacles, or when the start and end points are the same. We
should check for these situations before we run the main logic. For more
examples and edge case handling, look at our guide on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-ii-grid-with-obstacles-medium.html">Dynamic
Programming: Unique Paths II with Obstacles</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            