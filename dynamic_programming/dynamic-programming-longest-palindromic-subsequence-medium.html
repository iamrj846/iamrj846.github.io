
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Palindromic Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Longest Palindromic Subsequence problem using dynamic programming techniques. Boost your coding skills!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Palindromic Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <h3 id="longest-palindromic-subsequence-lps">Longest Palindromic
Subsequence (LPS)</h3>
<p>The Longest Palindromic Subsequence (LPS) problem is about finding
the longest part of a string that reads the same way backward and
forward. We can solve this problem using dynamic programming. We will
use a 2D table to keep track of the results from smaller problems. This
will help us find the length of the longest palindromic subsequence.</p>
<p>The main idea of LPS is to find characters that make a palindrome. We
will skip characters that do not match. This method helps us reduce the
search area.</p>
<p>In this article, we will talk about the Longest Palindromic
Subsequence problem. We will explain what it is and why it is important
in dynamic programming. We will go over different ways to solve this
problem. This includes using dynamic programming in Java, Python, and
C++. We will also discuss how to save space, use recursion with
memoization, and use iterative methods. Finally, we will compare these
different ways to solve the problem. Here are the topics we will
cover:</p>
<ul>
<li>Dynamic Programming Longest Palindromic Subsequence Solution</li>
<li>Understanding the Longest Palindromic Subsequence Problem</li>
<li>Dynamic Programming Approach for Longest Palindromic Subsequence in
Java</li>
<li>Dynamic Programming Approach for Longest Palindromic Subsequence in
Python</li>
<li>Dynamic Programming Approach for Longest Palindromic Subsequence in
C++</li>
<li>Optimizing Space Complexity for Longest Palindromic Subsequence</li>
<li>Recursive Approach with Memoization for Longest Palindromic
Subsequence</li>
<li>Iterative Approach for Longest Palindromic Subsequence</li>
<li>Comparing Different Approaches for Longest Palindromic
Subsequence</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, you can check
out these articles. They are about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a>.</p>
<h2
id="understanding-the-longest-palindromic-subsequence-problem">Understanding
the Longest Palindromic Subsequence Problem</h2>
<p>The Longest Palindromic Subsequence (LPS) problem is about finding
the longest subsequence in a string that is a palindrome. A palindrome
is a word that reads the same from both sides. Examples are “racecar”
and “level”. Our task is to find this subsequence in a quick way,
especially when the string is long.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have a string <code>s</code>. Our job is to find out how long the
longest subsequence is that can be a palindrome. The subsequence does
not need to have characters next to each other. But it must keep the
original order.</p>
<h3 id="example">Example</h3>
<ul>
<li>Input: <code>s = "bbabcbcab"</code></li>
<li>Output: <code>7</code></li>
<li>Explanation: The longest palindromic subsequence is “babcbab”.</li>
</ul>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><strong>Dynamic Programming Table</strong>: We will use a 2D DP
table. Here, <code>dp[i][j]</code> shows the length of the longest
palindromic subsequence in the substring <code>s[i...j]</code>.</li>
<li><strong>Base Case</strong>: If <code>i == j</code>, then
<code>dp[i][j] = 1</code>. A single character is always a
palindrome.</li>
<li><strong>Recurrence Relation</strong>:
<ul>
<li>If characters match: If <code>s[i] == s[j]</code>, then we can say
<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>.</li>
<li>If they do not match: We take the bigger value, so
<code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>.</li>
</ul></li>
</ol>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). Here n is the length of
the string.</li>
<li><strong>Space Complexity</strong>: O(n^2) for the DP table.</li>
</ul>
<p>This basic understanding of the Longest Palindromic Subsequence
problem helps us to create solutions in different programming languages
using dynamic programming methods.</p>
<h2
id="dynamic-programming-approach-for-longest-palindromic-subsequence-in-java">Dynamic
Programming Approach for Longest Palindromic Subsequence in Java</h2>
<p>We can solve the Longest Palindromic Subsequence problem using
dynamic programming in Java. We use a 2D array to save the lengths of
palindromic subsequences. The idea is to create a solution by using
values we already calculated.</p>
<h3 id="step-by-step-approach">Step-by-Step Approach:</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: We make a 2D array
<code>dp</code> of size <code>n x n</code>. Here, <code>n</code> is the
length of the input string. We set all <code>dp[i][i] = 1</code> because
a single character is a palindrome of length 1.</p></li>
<li><p><strong>Filling the DP Table</strong>:</p>
<ul>
<li><p>We go through the length of subsequences from 2 to
<code>n</code>.</p></li>
<li><p>For each length, we check the starting index <code>i</code> and
find the ending index <code>j = i + length - 1</code>.</p></li>
<li><p>If the characters at <code>i</code> and <code>j</code> are the
same, we do:</p>
<pre><code>dp[i][j] = dp[i + 1][j - 1] + 2</code></pre></li>
<li><p>If they are different, we take the bigger of the two options:</p>
<pre><code>dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1])</code></pre></li>
</ul></li>
<li><p><strong>Result</strong>: The length of the longest palindromic
subsequence is in <code>dp[0][n - 1]</code>.</p></li>
</ol>
<h3 id="java-code-implementation">Java Code Implementation:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestPalindromicSubsequence <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestPalindromicSubseq</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Every single character is a palindrome</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Build the table</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s <span class="op">=</span> <span class="st">&quot;bbbab&quot;</span><span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Palindromic Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">longestPalindromicSubseq</span><span class="op">(</span>s<span class="op">));</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The method <code>longestPalindromicSubseq</code> finds the length of
the longest palindromic subsequence in the string <code>s</code>.</li>
<li>The dynamic programming table <code>dp</code> keeps the lengths of
palindromic subsequences for different parts of the string.</li>
<li>We print the result in the <code>main</code> method, showing how it
works with an example input.</li>
</ul>
<p>This approach has time complexity of O(n^2) and space complexity of
O(n^2). If you want to read more about dynamic programming, you can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2
id="dynamic-programming-approach-for-longest-palindromic-subsequence-in-python">Dynamic
Programming Approach for Longest Palindromic Subsequence in Python</h2>
<p>We can solve the Longest Palindromic Subsequence (LPS) problem using
dynamic programming in Python. We will use a 2D array to keep track of
the lengths of palindromic subsequences.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li><strong>Initialize a 2D array</strong>: We create a 2D array called
<code>dp</code> with size <code>n x n</code>. Here, <code>n</code> is
the length of the input string. Each <code>dp[i][j]</code> will show the
length of the longest palindromic subsequence from index <code>i</code>
to <code>j</code>.</li>
<li><strong>Base case</strong>: Every single character is a palindrome
with length 1. So, we set <code>dp[i][i] = 1</code> for all
<code>i</code>.</li>
<li><strong>Build the table</strong>: We go through the substring
lengths and fill the <code>dp</code> table:
<ul>
<li>If the characters at both ends of the substring are the same, we
expand the palindrome:
<code>dp[i][j] = dp[i + 1][j - 1] + 2</code>.</li>
<li>If they are different, we take the maximum by excluding either
character: <code>dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])</code>.</li>
</ul></li>
<li><strong>Result</strong>: The length of the longest palindromic
subsequence for the whole string will be at
<code>dp[0][n - 1]</code>.</li>
</ol>
<h3 id="python-code">Python Code:</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindromic_subsequence(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: single character palindromes</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># Length of the substring</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">+</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;bbabcbcab&quot;</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Palindromic Subsequence is:&quot;</span>, longest_palindromic_subsequence(s))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="complexity-1">Complexity:</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). Here, <code>n</code> is
the length of the string.</li>
<li><strong>Space Complexity</strong>: O(n^2) because of the 2D
<code>dp</code> array.</li>
</ul>
<p>We use this dynamic programming method to find the longest
palindromic subsequence length in Python. This makes it good for
medium-level problems in competitive programming and interviews. For
more information about dynamic programming, you can check articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2
id="dynamic-programming-approach-for-longest-palindromic-subsequence-in-c">Dynamic
Programming Approach for Longest Palindromic Subsequence in C++</h2>
<p>We can solve the Longest Palindromic Subsequence (LPS) problem using
dynamic programming. This problem is to find the longest subsequence in
a string that reads the same from start to end and end to start.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ code to solve the LPS problem using dynamic
programming:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestPalindromicSubsequence<span class="op">(</span><span class="at">const</span> string <span class="op">&amp;</span>s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Every single character is a palindrome of length 1</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build the DP table</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// The length of the longest palindromic subsequence</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>    string s <span class="op">=</span> <span class="st">&quot;bbabcbcab&quot;</span><span class="op">;</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Palindromic Subsequence: &quot;</span> </span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> longestPalindromicSubsequence<span class="op">(</span>s<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a 2D vector
<code>dp</code> to store lengths of palindromic subsequences. Each
single character is set to 1 because it is a palindrome by itself.</li>
<li><strong>Filling the DP Table</strong>: We go through all possible
lengths of substrings. If the characters at both ends of the substring
are the same, we update <code>dp[i][j]</code> to
<code>2 + dp[i + 1][j - 1]</code>. If they are not the same, we take the
bigger value from the two possible substrings by removing either the
first or the last character.</li>
<li><strong>Result</strong>: The answer for the length of the longest
palindromic subsequence is at <code>dp[0][n-1]</code>, which covers the
whole string.</li>
</ul>
<p>This dynamic programming method runs in O(n^2) time and uses O(n^2)
space. It is good for strings that are not too long. For better
performance, we can look into ways to reduce space usage.</p>
<p>For more learning about dynamic programming methods, you can see the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a> article.</p>
<h2
id="optimizing-space-complexity-for-longest-palindromic-subsequence">Optimizing
Space Complexity for Longest Palindromic Subsequence</h2>
<p>When we solve the Longest Palindromic Subsequence (LPS) problem using
dynamic programming, we often make a 2D array. This array helps us store
the lengths of palindromic subsequences. But this method can use a lot
of space. The space complexity is O(n^2), where n is the length of the
input string. To save space, we can use a better approach that cuts the
space needed down to O(n).</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>We notice that to find the value of <code>dp[i][j]</code> (the length
of the longest palindromic subsequence from index <code>i</code> to
<code>j</code>), we only need values from the row before
(<code>dp[i+1][...]</code>) and the current row
(<code>dp[i][...]</code>). Because of this, we only need two arrays. We
do not need a full matrix.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is the optimized code in Python:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindromic_subsequence(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create two arrays to store results of the current and previous row</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    curr <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        curr[i] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Single character is a palindrome of length 1</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                curr[j] <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> prev[j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> j <span class="op">&gt;</span> i <span class="op">+</span> <span class="dv">1</span> <span class="cf">else</span> <span class="dv">2</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                curr[j] <span class="op">=</span> <span class="bu">max</span>(prev[j], curr[j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> curr[:]  <span class="co"># Move to the next row</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev[n <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;bbabcbab&quot;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Palindromic Subsequence:&quot;</span>, longest_palindromic_subsequence(s))</span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>We use two arrays <code>prev</code> and <code>curr</code> to keep
the lengths of palindromic subsequences.</li>
<li>We go backward through the string. Each character can be a center of
a palindromic subsequence.</li>
<li>For each pair of indices <code>i</code> and <code>j</code>, we
check:
<ul>
<li>If the characters match (<code>s[i] == s[j]</code>), we update the
current value based on the previous values.</li>
<li>If they do not match, we take the maximum value from previous
calculations.</li>
</ul></li>
<li>In the end, the length of the longest palindromic subsequence is in
<code>prev[n - 1]</code>.</li>
</ul>
<h3 id="benefits-of-this-approach">Benefits of This Approach</h3>
<ul>
<li><strong>Space Complexity</strong>: We cut it from O(n^2) to
O(n).</li>
<li><strong>Time Complexity</strong>: It stays O(n^2), because we still
need to check each substring.</li>
</ul>
<p>This better way is great for larger inputs where memory use matters.
It helps us compute the Longest Palindromic Subsequence without needing
a full 2D array. If we want to learn more about dynamic programming, we
can check out related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a>.</p>
<h2
id="recursive-approach-with-memoization-for-longest-palindromic-subsequence">Recursive
Approach with Memoization for Longest Palindromic Subsequence</h2>
<p>We use the recursive approach to find the Longest Palindromic
Subsequence. This approach breaks the problem into smaller parts. We
want to find the longest palindromic subsequence by looking at
characters from both ends of the string.</p>
<h3 id="recursive-relation">Recursive Relation</h3>
<ol type="1">
<li>If the characters at the two ends match (<code>s[i] == s[j]</code>),
we get <code>2 + LPS(s, i+1, j-1)</code>.</li>
<li>If they do not match, we use
<code>max(LPS(s, i+1, j), LPS(s, i, j-1))</code>.</li>
</ol>
<h3 id="base-case">Base Case</h3>
<ul>
<li>If <code>i &gt; j</code>, we return <code>0</code>.</li>
<li>If <code>i == j</code>, we return <code>1</code> because a single
character is a palindrome.</li>
</ul>
<h3 id="memoization">Memoization</h3>
<p>To make the recursive approach faster, we can use memoization. This
means we store the results of subproblems. This way, we do not have to
calculate the same thing again. We can use a 2D array for this.</p>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_palindromic_subsequence(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lps(i: <span class="bu">int</span>, j: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> j:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> j:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memo[i][j] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[i][j]</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            memo[i][j] <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> lps(i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            memo[i][j] <span class="op">=</span> <span class="bu">max</span>(lps(i <span class="op">+</span> <span class="dv">1</span>, j), lps(i, j <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[i][j]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lps(<span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;bbbab&quot;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_palindromic_subsequence(s))  <span class="co"># Output: 4</span></span></code></pre></div>
<p>This code works well to find the length of the longest palindromic
subsequence. The time it takes is O(n^2) and the space we use is also
O(n^2) because of the memoization table. The recursive way helps us
understand the problem better before we try harder dynamic programming
solutions.</p>
<p>For more learning on dynamic programming, we can look at other
problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci Number with Memoization</a>.</p>
<h2
id="iterative-approach-for-longest-palindromic-subsequence">Iterative
Approach for Longest Palindromic Subsequence</h2>
<p>We can solve the Longest Palindromic Subsequence (LPS) problem with
an iterative approach. This method uses dynamic programming to create a
solution step by step. We build a 2D table. Each entry ( dp[i][j] )
shows the length of the longest palindromic subsequence in the substring
from index ( i ) to index ( j ).</p>
<h3 id="algorithm-steps-1">Algorithm Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>We create a 2D array <code>dp</code> of size ( n n ) (where ( n ) is
the length of the input string) and set it to 0.</li>
<li>Each character is a palindrome of length 1. So we set ( dp[i][i] = 1
) for all ( i ).</li>
</ul></li>
<li><strong>Filling the Table</strong>:
<ul>
<li>We look at substring lengths from 2 to ( n ):
<ul>
<li>For each starting index ( i ):
<ul>
<li>We calculate the ending index ( j = i + length - 1 ).</li>
<li>If the characters at ( i ) and ( j ) are the same, we update (
dp[i][j] ):
<ul>
<li>( dp[i][j] = dp[i+1][j-1] + 2 )</li>
</ul></li>
<li>If they are not the same, we take the maximum from the two possible
palindromic subsequences:
<ul>
<li>( dp[i][j] = (dp[i+1][j], dp[i][j-1]) )</li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>We find the length of the longest palindromic subsequence at (
dp[0][n-1] ).</li>
</ul></li>
</ol>
<h3 id="example-implementation-in-java">Example Implementation in
Java:</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestPalindromicSubsequence <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">longestPalindromeSubseq</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Every single character is a palindrome of length 1</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Build the table in a bottom-up manner</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-implementation-in-python">Example Implementation in
Python:</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> longestPalindromeSubseq(<span class="va">self</span>, s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Every single character is a palindrome of length 1</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            dp[i][i] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Build the table in a bottom-up manner</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">2</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span>:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">+</span> <span class="dv">1</span>][j], dp[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="example-implementation-in-c">Example Implementation in C++:</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> longestPalindromeSubseq<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Every single character is a palindrome of length 1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Build the table in a bottom-up manner</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>We use this iterative approach to find the longest palindromic
subsequence in ( O(n^2) ) time and with ( O(n^2) ) space. For better
space use, we can look at techniques that help reduce space in the next
sections.</p>
<h2
id="comparing-different-approaches-for-longest-palindromic-subsequence">Comparing
Different Approaches for Longest Palindromic Subsequence</h2>
<p>When we solve the Longest Palindromic Subsequence (LPS) problem, we
can use different methods. Each method has its good and bad sides. Here
we look at three common ways: Dynamic Programming, Recursive with
Memoization, and Iterative.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>The Dynamic Programming (DP) method gives us a quick solution. It has
a time complexity of O(n^2) and a space complexity of O(n^2). The main
idea is to create a DP table. In this table, dp[i][j] shows the length
of the longest palindromic subsequence in the substring from index i to
j.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">longestPalindromicSubseq</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Each character is a palindrome of length 1</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">))</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Characters match</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span> <span class="co">// Characters do not match</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recursive-approach-with-memoization">Recursive Approach with
Memoization</h3>
<p>We can also use recursion and improve it with memoization. This way,
we do not calculate the same things again. The time complexity stays
O(n^2), but the space complexity gets better to O(n) because of the
memoization array.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longestPalindromicSubseq(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> recurse(i, j):</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&gt;</span> j:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> j:</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i, j) <span class="kw">in</span> memo:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[j]:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            memo[(i, j)] <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> recurse(i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            memo[(i, j)] <span class="op">=</span> <span class="bu">max</span>(recurse(i <span class="op">+</span> <span class="dv">1</span>, j), recurse(i, j <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> recurse(<span class="dv">0</span>, <span class="bu">len</span>(s) <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<h3 id="iterative-approach">Iterative Approach</h3>
<p>We can also do an iterative approach. This way, we use just one array
to keep the intermediate results. This helps to lower the space
complexity to O(n).</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestPalindromicSubseq<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> dp<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Single character</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> prev <span class="op">+</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Characters match</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span> <span class="co">// Characters do not match</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<ul>
<li><strong>Dynamic Programming</strong>: Best for big strings with
O(n^2) time and O(n^2) space.</li>
<li><strong>Recursive with Memoization</strong>: Easy to understand but
still O(n^2) time and O(n) space.</li>
<li><strong>Iterative</strong>: Good space use with O(n^2) time and O(n)
space.</li>
</ul>
<p>We choose the best way based on the problem needs. This includes
string size and memory we have. For more about dynamic programming
methods, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming - Longest Common Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-longest-palindromic-subsequence">1. What is the
Longest Palindromic Subsequence?</h3>
<p>The Longest Palindromic Subsequence problem is about finding the
longest subsequence in a string that is a palindrome. A palindrome is a
sequence that looks the same backward and forward. For example, in the
string “character”, the longest palindromic subsequence is “carac”. It
has a length of 5. We need to understand this problem well to learn
dynamic programming techniques.</p>
<h3
id="how-do-i-solve-the-longest-palindromic-subsequence-using-dynamic-programming">2.
How do I solve the Longest Palindromic Subsequence using Dynamic
Programming?</h3>
<p>To solve the Longest Palindromic Subsequence with dynamic
programming, we can make a 2D array. This array stores the lengths of
palindromic subsequences for different parts of the string. We fill this
table by checking character matches and using values we calculated
before. For more details and code examples, you can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming Approach for Longest Palindromic Subsequence in
Java</a>.</p>
<h3
id="what-are-the-time-and-space-complexities-of-the-longest-palindromic-subsequence-algorithm">3.
What are the time and space complexities of the Longest Palindromic
Subsequence algorithm?</h3>
<p>The time complexity of the Longest Palindromic Subsequence algorithm
with dynamic programming is O(n^2). Here n is the length of the string
we give. The space complexity is also O(n^2). This is because we use a
2D table to save results. But if we use some optimization tricks, we can
lower the space complexity to O(n) while keeping the same time
complexity.</p>
<h3
id="can-i-use-a-recursive-approach-to-solve-the-longest-palindromic-subsequence-problem">4.
Can I use a recursive approach to solve the Longest Palindromic
Subsequence problem?</h3>
<p>Yes, we can use a recursive approach with memoization to solve the
Longest Palindromic Subsequence problem. This means we check characters
one by one and store the results of smaller problems. This way, we avoid
counting the same thing again. This method has a time complexity of
O(n^2) too. But some programmers find it easier to understand. For more
details, check the section on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Recursive
Approach with Memoization for Longest Palindromic Subsequence</a>.</p>
<h3
id="how-can-i-compare-different-approaches-for-solving-the-longest-palindromic-subsequence">5.
How can I compare different approaches for solving the Longest
Palindromic Subsequence?</h3>
<p>To compare different ways of solving the Longest Palindromic
Subsequence, we should look at time complexity, space complexity, and
how easy it is to use. Dynamic programming gives a good balance of speed
and efficiency. Meanwhile, recursive methods with memoization can be
easier to understand. For more ideas on different methods, visit the
section titled <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Comparing
Different Approaches for Longest Palindromic Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            