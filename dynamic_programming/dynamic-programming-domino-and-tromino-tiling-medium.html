
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Domino and Tromino Tiling - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve Domino and Tromino tiling problems using dynamic programming techniques in this insightful blog post.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Domino and Tromino Tiling - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic Programming is a strong technique we use in algorithms. It
helps us solve tough problems by breaking them into easier parts. The
Domino and Tromino Tiling problem is about finding how many ways we can
cover a 2 x n board. We can use 1 x 2 dominoes and L-shaped trominoes
for this. We can solve this problem easily with dynamic programming. We
define a state that shows how many ways we can fill the board up to a
certain length. This way, we can build our solutions step by step.</p>
<p>In this article, we will look closely at the Domino and Tromino
Tiling problem. We will talk about different dynamic programming methods
in Java, Python, and C++. We will also see how to make space usage
better. We will compare different strategies. This includes recursive
solutions with memoization and iterative dynamic programming. We will
also answer common questions about this topic.</p>
<ul>
<li>Dynamic Programming Domino and Tromino Tiling Solutions</li>
<li>Understanding the Problem Statement for Domino and Tromino
Tiling</li>
<li>Dynamic Programming Approach in Java for Domino and Tromino
Tiling</li>
<li>Dynamic Programming Approach in Python for Domino and Tromino
Tiling</li>
<li>Dynamic Programming Approach in C++ for Domino and Tromino
Tiling</li>
<li>Optimizing Space Complexity in Domino and Tromino Tiling</li>
<li>Recursive Solution with Memoization for Domino and Tromino
Tiling</li>
<li>Iterative Dynamic Programming Solution for Domino and Tromino
Tiling</li>
<li>Comparing Different Approaches for Domino and Tromino Tiling</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check out
related topics. You may find <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a> helpful.</p>
<h2
id="understanding-the-problem-statement-for-domino-and-tromino-tiling">Understanding
the Problem Statement for Domino and Tromino Tiling</h2>
<p>The Domino and Tromino Tiling problem is about filling a 2 x n board.
We use dominoes (1 x 2 tiles) and trominoes (L-shaped tiles). Our goal
is to find out how many ways we can cover the board completely without
any overlaps or gaps.</p>
<h3 id="problem-breakdown">Problem Breakdown:</h3>
<ul>
<li><strong>Input</strong>: An integer <code>n</code>, which is the
length of the board.</li>
<li><strong>Output</strong>: The total number of ways to tile the 2 x n
board.</li>
</ul>
<h3 id="key-points">Key Points:</h3>
<ol type="1">
<li><strong>Tiles</strong>:
<ul>
<li>A <strong>domino</strong> covers two squares (2 x 1).</li>
<li>A <strong>tromino</strong> covers three squares and can be placed in
different ways.</li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li>For <code>n = 0</code>: There is 1 way to tile an empty board (we do
nothing).</li>
<li>For <code>n = 1</code>: There is 1 way to tile a 2 x 1 board (one
vertical domino).</li>
<li>For <code>n = 2</code>: There are 2 ways to tile a 2 x 2 board (two
vertical dominoes or two horizontal dominoes).</li>
</ul></li>
<li><strong>Recursive Relation</strong>:
<ul>
<li>To cover a board of length <code>n</code>, we think about:
<ul>
<li>Placing a vertical domino on the left (this makes the problem
<code>n-1</code>).</li>
<li>Placing two horizontal dominoes (this makes it
<code>n-2</code>).</li>
<li>Placing a tromino in different ways (this makes it
<code>n-3</code>).</li>
</ul></li>
</ul>
So, we can write the recurrence relation like this: [ dp[n] = dp[n-1] +
dp[n-2] + 2 dp[n-3] ]</li>
</ol>
<h3 id="example">Example:</h3>
<p>For a board of length 3: - The ways to arrange tiles include: - Three
vertical dominoes. - One vertical domino and one tromino. - One tromino
and one vertical domino. - We get the total count using our recurrence
relation.</p>
<p>We can solve this problem well using dynamic programming. It helps us
find the number of ways to tile the board for bigger values of
<code>n</code> in a smart way.</p>
<h2
id="dynamic-programming-approach-in-java-for-domino-and-tromino-tiling">Dynamic
Programming Approach in Java for Domino and Tromino Tiling</h2>
<p>The Domino and Tromino Tiling problem is about finding how many ways
we can fill a <code>2 x n</code> board. We can use <code>1 x 2</code>
dominoes and <code>2 x 1</code> trominoes. We can solve this problem
easily with dynamic programming.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a simple Java code that uses dynamic programming:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DominoTrominoTiling <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numTilings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case for 0-length</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case for 2x1</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Two ways to fill a 2x2 board</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">*</span> <span class="dv">2</span><span class="op">)</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span> <span class="co">// Modulo for big numbers</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        DominoTrominoTiling tiling <span class="op">=</span> <span class="kw">new</span> <span class="fu">DominoTrominoTiling</span><span class="op">();</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to tile 2 x &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; board: &quot;</span> <span class="op">+</span> tiling<span class="op">.</span><span class="fu">numTilings</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Base Cases</strong>:
<ul>
<li><code>dp[0] = 1</code>: There is one way to fill a board of length 0
(we do nothing).</li>
<li><code>dp[1] = 1</code>: One way to fill a <code>2 x 1</code> board
(one vertical domino).</li>
<li><code>dp[2] = 2</code>: Two ways to fill a <code>2 x 2</code> board
(either two vertical dominoes or two horizontal).</li>
</ul></li>
<li><strong>Recurrence Relation</strong>:
<ul>
<li>For <code>i &gt;= 3</code>, we use this relation: [ dp[i] = dp[i-1]
+ 2 dp[i-2] ]</li>
<li>This means we can put a domino vertically or fill the last two
columns with trominoes.</li>
</ul></li>
<li><strong>Modulo Operation</strong>: We take the results modulo (10^9
+ 7) to stop integer overflow.</li>
</ul>
<p>This way runs in (O(n)) time and uses (O(n)) space for the dynamic
programming array.</p>
<h2
id="dynamic-programming-approach-in-python-for-domino-and-tromino-tiling">Dynamic
Programming Approach in Python for Domino and Tromino Tiling</h2>
<p>We can solve the Domino and Tromino Tiling problem using dynamic
programming in Python. The problem is about finding how many ways we can
tile a 2 x n board with 1 x 2 dominoes and 2 x 1 trominoes.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>Given an integer <code>n</code>, we want to find the number of ways
to cover a 2 x n board using:</p>
<ul>
<li>1 x 2 dominoes (they cover two squares)</li>
<li>2 x 1 trominoes (they cover three squares)</li>
</ul>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>We create a dynamic programming array called <code>dp</code>. Here
<code>dp[i]</code> shows the number of ways to tile a 2 x i board. We
can find the solution with this relation:</p>
<ul>
<li><code>dp[i] = dp[i - 1] + dp[i - 2] * 2</code>
<ul>
<li><code>dp[i - 1]</code>: This is when we add a vertical domino.</li>
<li><code>dp[i - 2] * 2</code>: This is for adding two horizontal
dominoes or one tromino.</li>
</ul></li>
</ul>
<p>The base cases are: - <code>dp[0] = 1</code>: There is one way to
tile a board of width 0 (which is doing nothing). -
<code>dp[1] = 1</code>: There is one way to tile a board of width 1
(using one vertical domino).</p>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numTilings(n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>] <span class="op">*</span> <span class="dv">2</span>) <span class="op">%</span> (<span class="dv">10</span><span class="op">**</span><span class="dv">9</span> <span class="op">+</span> <span class="dv">7</span>)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<p>To use the function, we just call it with the board width
<code>n</code> we want:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(numTilings(<span class="dv">3</span>))  <span class="co"># Output: 5</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(numTilings(<span class="dv">4</span>))  <span class="co"># Output: 11</span></span></code></pre></div>
<p>This code runs in O(n) time and uses O(n) space. The result is
computed with modulo (10^9 + 7) to avoid overflow and to handle big
numbers well.</p>
<p>For more learning about dynamic programming methods, we can check
these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number - Easy</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change - Medium</a>.</p>
<h2
id="dynamic-programming-approach-in-c-for-domino-and-tromino-tiling">Dynamic
Programming Approach in C++ for Domino and Tromino Tiling</h2>
<p>We can solve the Domino and Tromino Tiling problem using dynamic
programming in C++. We define the smaller problems based on the board
length. Our main goal is to find how many ways we can tile a 2 x n board
with 1 x 2 dominoes and 2 x 1 trominoes.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>Let <code>dp[n]</code> be the number of ways to fill a 2 x n board.
We can set up the recurrence relation like this:</p>
<ul>
<li>For a 2 x n board:
<ul>
<li>If we put a vertical domino, we have a 2 x (n-1) board left.</li>
<li>If we put two horizontal dominoes, we have a 2 x (n-2) board
left.</li>
<li>If we put a tromino, we can place it in three different ways,
leaving us with a 2 x (n-3) board.</li>
</ul></li>
</ul>
<p>So, we can write the recurrence relation as: [ dp[n] = dp[n-1] +
dp[n-2] + 2 dp[n-3] ]</p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code>: There is 1 way to tile a board of length 0
(doing nothing).</li>
<li><code>dp[1] = 1</code>: There is only 1 way to tile a 2 x 1 board
(one vertical domino).</li>
<li><code>dp[2] = 2</code>: There are two ways to tile a 2 x 2 board
(two vertical dominoes or two horizontal dominoes).</li>
<li><code>dp[3] = 4</code>: There are four ways to tile a 2 x 3 board
(different combinations of dominoes and trominoes).</li>
</ul>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is the C++ code for this dynamic programming solution:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> numTilings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">3</span><span class="op">];</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter the length of the board: &quot;</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to tile the board: &quot;</span> <span class="op">&lt;&lt;</span> numTilings<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>We create a vector <code>dp</code> to keep track of how many ways we
can tile boards of different lengths up to <code>n</code>.</li>
<li>We start with the base cases.</li>
<li>Then we loop from 4 to <code>n</code> to calculate the number of
ways using our recurrence relation.</li>
<li>At the end, we return <code>dp[n]</code>, which gives us the total
number of ways to tile a 2 x n board.</li>
</ul>
<p>This C++ dynamic programming method works well to find the number of
tiling ways. It runs in O(n) time and uses O(n) space.</p>
<h2
id="optimizing-space-complexity-in-domino-and-tromino-tiling">Optimizing
Space Complexity in Domino and Tromino Tiling</h2>
<p>In the Domino and Tromino Tiling problem, we can make space usage
better by using a rolling array technique. This method is good because
the current solution only needs the last few solutions.</p>
<h3 id="space-optimization-approach">Space Optimization Approach</h3>
<p>Instead of keeping a big DP array of size <code>n</code>, we can use
a small array of size 3. This array will hold the last three values we
calculated. This change can reduce space usage from O(n) to O(1).</p>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Tiling <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numTilings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">3</span><span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// dp[0] for n=0</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// dp[1] for n=1</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// dp[2] for n=2</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> temp<span class="op">)</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span> <span class="co">// Modulo for big numbers</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numTilings(n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>] <span class="co"># dp[0] for n=0, dp[1] for n=1, dp[2] for n=2</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>], dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> dp[<span class="dv">1</span>], dp[<span class="dv">2</span>], (dp[<span class="dv">1</span>] <span class="op">+</span> dp[<span class="dv">2</span>] <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp[<span class="dv">0</span>]) <span class="op">%</span> <span class="dv">1000000007</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">2</span>]</span></code></pre></div>
<h3 id="implementation-in-c">Implementation in C++</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numTilings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> dp<span class="op">[</span><span class="dv">3</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span> <span class="co">// dp[0] for n=0, dp[1] for n=1, dp[2] for n=2</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> temp<span class="op">)</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="summary-of-space-optimization-benefits">Summary of Space
Optimization Benefits</h3>
<ul>
<li><strong>Space Complexity</strong>: We lower it from O(n) to
O(1).</li>
<li><strong>Performance</strong>: We use less memory for big
<code>n</code>, this helps speed.</li>
<li><strong>Simplicity</strong>: The code stays clean and easy to read
while using the problem’s features.</li>
</ul>
<p>This improved method keeps the main logic of the dynamic programming
solution but makes it better by using less space. For more on dynamic
programming methods, see articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming</a>.</p>
<h2
id="recursive-solution-with-memoization-for-domino-and-tromino-tiling">Recursive
Solution with Memoization for Domino and Tromino Tiling</h2>
<p>We can solve the Domino and Tromino Tiling problem using a recursive
method with memoization. This helps us run the code faster by saving
results we have already calculated. The task is to find out how many
ways we can fill a 2 x n board using 1 x 2 dominoes and 2 x 1
trominoes.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>We have an integer <code>n</code>. Our goal is to find the number of
ways to fill a 2 x n board using: - 1 x 2 dominoes (that we can place
either horizontally or vertically) - 2 x 1 trominoes (that we can place
in a straight line)</p>
<h3 id="recursive-function">Recursive Function</h3>
<p>We can define our recursive relationship like this:</p>
<ol type="1">
<li>If the board length is 0 (<code>n=0</code>), there is 1 way to tile
the board (we do nothing).</li>
<li>If the board length is 1 (<code>n=1</code>), there is 1 way to tile
the board (we use one vertical domino).</li>
<li>For <code>n &gt;= 2</code>, we can get the number of ways from:
<ul>
<li>Placing a vertical domino, which reduces the problem to a board of
size <code>n-1</code>.</li>
<li>Placing two horizontal dominoes, which reduces the problem to a
board of size <code>n-2</code>.</li>
<li>Placing a tromino, which reduces the problem to a board of size
<code>n-3</code>.</li>
</ul></li>
</ol>
<p>The recursive formula looks like this:</p>
<pre><code>dp[n] = dp[n-1] + dp[n-2] + dp[n-3]</code></pre>
<h3 id="implementation-in-python-1">Implementation in Python</h3>
<p>Here is a simple Python code for our recursive solution with
memoization:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> domino_tromino_tiling(n):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(n):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[n]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">4</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> helper(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> helper(n <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> helper(n <span class="op">-</span> <span class="dv">3</span>)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> helper(n)</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(domino_tromino_tiling(n))  <span class="co"># This will show the number of ways to tile a 2 x n board</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>We create a helper function that checks if we already calculated the
result for <code>n</code> (this is memoization).</li>
<li>The base cases deal with the smallest board sizes directly.</li>
<li>For bigger <code>n</code>, the function calculates the number of
ways to tile by using smaller problems.</li>
<li>The memo dictionary saves results. This cuts down the number of
calls we need to make and makes the code faster.</li>
</ul>
<p>This recursive way with memoization works well and can handle bigger
values of <code>n</code>. It helps us solve the Domino and Tromino
Tiling problem in a good amount of time.</p>
<h2
id="iterative-dynamic-programming-solution-for-domino-and-tromino-tiling">Iterative
Dynamic Programming Solution for Domino and Tromino Tiling</h2>
<p>We can use an iterative dynamic programming solution for the Domino
and Tromino Tiling problem. This method calculates how many ways we can
tile a <code>2 x n</code> board with dominoes (<code>1 x 2</code>) and
trominoes (<code>1 x 3</code>). This way, we do not have to deal with
the extra work of recursion and memoization. We build the solution step
by step.</p>
<h3 id="problem-definition-3">Problem Definition</h3>
<p>We have an integer <code>n</code>. We want to find out how many ways
we can fill a <code>2 x n</code> board using:</p>
<ul>
<li>Dominoes that cover <code>2</code> squares.</li>
<li>Trominoes that cover <code>3</code> squares.</li>
</ul>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>We set up a dynamic programming array <code>dp</code>. Here,
<code>dp[i]</code> shows the number of ways to tile a <code>2 x i</code>
board. We can define the relations like this:</p>
<ul>
<li><strong>Base Cases:</strong>
<ul>
<li><code>dp[0] = 1</code> (1 way to tile an empty board)</li>
<li><code>dp[1] = 1</code> (1 way to tile <code>2 x 1</code> with a
domino)</li>
<li><code>dp[2] = 2</code> (2 ways: two dominoes or one tromino)</li>
</ul></li>
<li><strong>Recurrence Relation:</strong>
<ul>
<li>For <code>i &gt;= 3</code>:
<ul>
<li><code>dp[i] = dp[i-1] + dp[i-2] + dp[i-3]</code>
<ul>
<li><code>dp[i-1]</code>: Place a domino vertically.</li>
<li><code>dp[i-2]</code>: Place two dominoes horizontally.</li>
<li><code>dp[i-3]</code>: Place one tromino.</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DominoTrominoTiling <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numTilings</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">3</span><span class="op">])</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numTilings(n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">3</span>]) <span class="op">%</span> <span class="dv">1000000007</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numTilings<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">3</span><span class="op">])</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity:</strong> O(n) because we go through the
array one time.</li>
<li><strong>Space Complexity:</strong> O(n) since we need space for the
<code>dp</code> array.</li>
</ul>
<p>This iterative dynamic programming solution helps us calculate the
number of ways to tile the board. It gives good performance for bigger
values of <code>n</code>. We can learn more about similar dynamic
programming problems in <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2
id="comparing-different-approaches-for-domino-and-tromino-tiling">Comparing
Different Approaches for Domino and Tromino Tiling</h2>
<p>When we solve the Domino and Tromino Tiling problem, we can look at
different methods. Each method has its own good and bad points. Here, we
compare recursive solutions, dynamic programming, and memoization
techniques. We will focus on their time complexity, space complexity,
and how easy they are to use.</p>
<h3 id="recursive-approach">1. Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: Exponential (O(3^n)). It checks
every way to tile.</li>
<li><strong>Space Complexity</strong>: O(n) because of the recursion
stack.</li>
<li><strong>Implementation</strong>: It is easy to understand but not
good for big values of <code>n</code>.</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiling(n):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tiling(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> tiling(n <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> (tiling(n <span class="op">-</span> <span class="dv">3</span>) <span class="cf">if</span> n <span class="op">&gt;=</span> <span class="dv">3</span> <span class="cf">else</span> <span class="dv">0</span>)</span></code></pre></div>
<h3 id="dynamic-programming-approach-1">2. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n). It builds solutions from
earlier results.</li>
<li><strong>Space Complexity</strong>: O(n) for the DP array.</li>
<li><strong>Implementation</strong>: This method is better than
recursion. It works well for larger inputs.</li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiling_dp(n):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">3</span>]</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="dynamic-programming-with-space-optimization">3. Dynamic
Programming with Space Optimization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n), same as standard DP.</li>
<li><strong>Space Complexity</strong>: O(1) since it only keeps the last
three values.</li>
<li><strong>Implementation</strong>: This is good for saving space while
keeping speed.</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiling_optimized(n):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    a, b, c <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        a, b, c <span class="op">=</span> b, c, a <span class="op">+</span> b <span class="op">+</span> c</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> c</span></code></pre></div>
<h3 id="recursive-solution-with-memoization">4. Recursive Solution with
Memoization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n). It saves results of smaller
problems.</li>
<li><strong>Space Complexity</strong>: O(n) for the memoization
table.</li>
<li><strong>Implementation</strong>: This mixes the simplicity of
recursion with better speed.</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> tiling_memo(n, memo<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> memo <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>        memo <span class="op">=</span> {}</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> tiling_memo(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> tiling_memo(n <span class="op">-</span> <span class="dv">2</span>, memo) <span class="op">+</span> (tiling_memo(n <span class="op">-</span> <span class="dv">3</span>, memo) <span class="cf">if</span> n <span class="op">&gt;=</span> <span class="dv">3</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span></code></pre></div>
<h3 id="comparison-summary">Comparison Summary</h3>
<ul>
<li><strong>Recursive</strong>: Simple but not good for large
<code>n</code>.</li>
<li><strong>Dynamic Programming</strong>: Efficient and easy. Good for
medium <code>n</code>.</li>
<li><strong>Space Optimized DP</strong>: Best for big <code>n</code>,
saves memory.</li>
<li><strong>Memoization</strong>: Mixes recursion with better speed.
Works for many input sizes.</li>
</ul>
<p>By knowing these methods, we can pick the right one based on the
needs of the problem. For more about dynamic programming, we can check
this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-domino-and-tromino-tiling-problem">What is the
Domino and Tromino Tiling problem?</h3>
<p>The Domino and Tromino Tiling problem is a well-known problem in
dynamic programming. Our goal is to count how many ways we can
completely cover a 2 x n board using 1 x 2 dominoes and 2 x 1 trominoes.
This problem helps us understand how to do combinatorial tiling. It also
gives us ideas about solving problems with recursion. This makes it a
good topic for programmers and computer scientists to study.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-the-domino-and-tromino-tiling-problem">How
can dynamic programming be applied to solve the Domino and Tromino
Tiling problem?</h3>
<p>We can use dynamic programming to solve the Domino and Tromino Tiling
problem. We break the problem into smaller parts. The main point is to
create a recurrence relation. This relation shows how to fill the board
based on what we did before. With this method, we can compute and store
results quickly. This helps us save time compared to using simple
recursion.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-domino-and-tromino-tiling">What
is the time complexity of the dynamic programming solution for Domino
and Tromino Tiling?</h3>
<p>The time complexity for the dynamic programming solution of the
Domino and Tromino Tiling problem is O(n). Here, n is the length of the
board. This speed comes from the fact that we calculate each state in
the dynamic programming table based on a fixed number of previous
states. This way, we build the solution step by step without doing extra
calculations.</p>
<h3
id="can-the-domino-and-tromino-tiling-problem-be-solved-using-recursion-and-memoization">Can
the Domino and Tromino Tiling problem be solved using recursion and
memoization?</h3>
<p>Yes, we can solve the Domino and Tromino Tiling problem using
recursion with memoization. This method saves the results of states we
calculated before. It stops us from calculating the same thing again,
making it faster. By using memoization, we can also reduce the
complexity to O(n), just like the dynamic programming method.</p>
<h3
id="are-there-other-combinatorial-problems-similar-to-domino-and-tromino-tiling">Are
there other combinatorial problems similar to Domino and Tromino
Tiling?</h3>
<p>Yes, there are many combinatorial problems that are like the Domino
and Tromino Tiling problem. Some examples include the Fibonacci number
problem and the Climbing Stairs problem. They also use dynamic
programming techniques. For more similar ideas, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Numbers</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            