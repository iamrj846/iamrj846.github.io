
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Unbounded Knapsack Problem - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to solve the Unbounded Knapsack Problem using Dynamic Programming. Master this essential algorithm with clear examples!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Unbounded Knapsack Problem - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Unbounded Knapsack Problem is a well-known problem in computer
science. It falls under dynamic programming. In this problem, we have a
list of items. Each item has a value and a weight. Our job is to find
the maximum value we can get by picking items. We can pick each item as
many times as we want. To solve this, we create a dynamic programming
table. This table keeps track of the best value we can get for every
weight limit. This way, we build our solution step by step.</p>
<p>In this article, we will look at the Unbounded Knapsack Problem. We
will explain what it is and how to solve it. We will focus on the
dynamic programming way to solve this problem. We will use different
programming languages like Java, Python, and C++. We will also discuss
how to make the space we use more efficient in these languages. Lastly,
we will analyze the code complexity of the problem. We will answer
common questions to help us understand better. The topics we will cover
are:</p>
<ul>
<li>[Dynamic Programming] Unbounded Knapsack Problem Solutions
Overview</li>
<li>Understanding the Unbounded Knapsack Problem</li>
<li>Dynamic Programming Approach to Unbounded Knapsack in Java</li>
<li>Dynamic Programming Approach to Unbounded Knapsack in Python</li>
<li>Dynamic Programming Approach to Unbounded Knapsack in C++</li>
<li>Optimized Space Complexity for Unbounded Knapsack in Java</li>
<li>Optimized Space Complexity for Unbounded Knapsack in Python</li>
<li>Optimized Space Complexity for Unbounded Knapsack in C++</li>
<li>Code Complexity Analysis of Unbounded Knapsack Problem</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check out
articles on related topics. For example, we can read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack Problem</a> or different strategies like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
Number</a>.</p>
<h2 id="understanding-the-unbounded-knapsack-problem">Understanding the
Unbounded Knapsack Problem</h2>
<p>The Unbounded Knapsack Problem is a well-known problem in
optimization. We have a set of items. Each item has a weight and a
value. Our goal is to find the highest value we can carry in a knapsack
with a certain capacity. We can take as many of each item as we
want.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Items</strong>: Each item has a weight ( w[i] ) and a value
( v[i] ).</li>
<li><strong>Capacity</strong>: The knapsack can carry a maximum weight
of ( W ).</li>
<li><strong>Objective</strong>: We want to maximize the total value in
the knapsack without going over the weight limit.</li>
</ul>
<h3 id="example">Example</h3>
<p>Let us look at three items: - Item 1: Weight = 1, Value = 1 - Item 2:
Weight = 2, Value = 2 - Item 3: Weight = 3, Value = 5</p>
<p>If the knapsack capacity ( W = 5 ), we can combine items like this: -
We take 2 of Item 2 (Weight = 4, Value = 4) and 1 of Item 1 (Weight = 1,
Value = 1). This gives us a total of Weight = 5 and Value = 5.</p>
<h3 id="key-properties">Key Properties</h3>
<ul>
<li><strong>No Limit on Quantity</strong>: Unlike the 0/1 Knapsack
problem, we can use any item many times.</li>
<li><strong>Dynamic Programming Approach</strong>: We can solve this
problem well using dynamic programming. It helps us build solutions for
small problems to solve bigger ones.</li>
</ul>
<p>The Unbounded Knapsack Problem is useful in many areas like resource
allocation, budget management, and inventory strategies. This makes it
an important topic in dynamic programming. For more insights into
similar problems, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0/1
Knapsack Problem</a>.</p>
<h2
id="dynamic-programming-approach-to-unbounded-knapsack-in-java">Dynamic
Programming Approach to Unbounded Knapsack in Java</h2>
<p>The Unbounded Knapsack problem lets us include an unlimited number of
each item in the knapsack. We want to maximize the total value without
going over the weight limit. The dynamic programming approach helps us
solve this problem well using a bottom-up method.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li><strong>Define the DP array</strong>: <code>dp[i]</code> will keep
the maximum value we can get with a knapsack capacity of
<code>i</code>.</li>
<li><strong>Initialization</strong>: We set <code>dp[0]</code> to
<code>0</code> because no items give zero value.</li>
<li><strong>Iterate over each capacity</strong>: We go from
<code>1</code> to <code>W</code> (the maximum weight) and check each
item.</li>
<li><strong>Update the DP array</strong>: For each item, if it fits in
the current capacity, we update the DP value by thinking about including
the item many times.</li>
</ol>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UnboundedKnapsack <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">unboundedKnapsack</span><span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> weights<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> values<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> W<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>weights<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;=</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> weights<span class="op">[</span>j<span class="op">]]</span> <span class="op">+</span> values<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>W<span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> values <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">40</span><span class="op">};</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> W <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> values<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">+</span> <span class="fu">unboundedKnapsack</span><span class="op">(</span>W<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The function <code>unboundedKnapsack</code> takes the maximum weight
<code>W</code>, arrays of item <code>weights</code> and
<code>values</code>, and the number of items <code>n</code>.</li>
<li>We start a DP array <code>dp</code> to store the maximum
values.</li>
<li>We use nested loops to go through each weight and item, updating
<code>dp[i]</code> based on if we can include the item.</li>
</ul>
<p>This method has a time complexity of <code>O(n * W)</code> and a
space complexity of <code>O(W)</code>. This makes it good for normal
problems we see. If you want to learn more about similar problems, check
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack Problem</a>.</p>
<h2
id="dynamic-programming-approach-to-unbounded-knapsack-in-python">Dynamic
Programming Approach to Unbounded Knapsack in Python</h2>
<p>The Unbounded Knapsack Problem lets us add an unlimited number of
each item. We want to get the most value in the knapsack without going
over its weight limit. The dynamic programming method helps us solve
this problem. It creates a table that keeps track of the best value we
can get for each weight limit.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is how we can solve the Unbounded Knapsack problem using dynamic
programming in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unbounded_knapsack(capacity, weights, values):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a DP array to store maximum value for each capacity</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (capacity <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Iterate over each capacity from 1 to the given capacity</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, capacity <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(weights)):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weights[j] <span class="op">&lt;=</span> i:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[i <span class="op">-</span> weights[j]] <span class="op">+</span> values[j])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[capacity]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]  <span class="co"># weights of items</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">70</span>]  <span class="co"># corresponding values of items</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> <span class="dv">8</span>  <span class="co"># maximum weight capacity of the knapsack</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>max_value <span class="op">=</span> unbounded_knapsack(capacity, weights, values)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;Maximum value achievable: </span><span class="sc">{</span>max_value<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>The function <code>unbounded_knapsack</code> takes
<code>capacity</code>, <code>weights</code>, and <code>values</code> as
input.</li>
<li>We start with a list <code>dp</code>. Here <code>dp[i]</code> shows
the best value we can have with a capacity of <code>i</code>.</li>
<li>The first loop goes through each capacity. The second loop checks
each item.</li>
<li>If the item’s weight is less or equal to the current capacity, we
update the maximum value. We compare the current value with the value we
get by adding the item.</li>
<li>At the end, we return the best value for the given capacity.</li>
</ul>
<p>This code runs in O(n * capacity) time. Here <code>n</code> is the
number of items. It uses O(capacity) space which makes it good for
bigger input sizes.</p>
<p>For more lessons on dynamic programming techniques, we can look at
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">Dynamic
Programming: 0/1 Knapsack Problem</a>.</p>
<h2 id="dynamic-programming-approach-to-unbounded-knapsack-in-c">Dynamic
Programming Approach to Unbounded Knapsack in C++</h2>
<p>The Unbounded Knapsack Problem lets us put in as many items as we
want into the knapsack. Our goal is to get the highest total value
without going over the weight limit. We can solve this problem well
using dynamic programming.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ code that shows the dynamic programming way to
solve the Unbounded Knapsack Problem:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> unboundedKnapsack<span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>val<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> <span class="op">&amp;</span>wt<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> W<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;=</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> wt<span class="op">[</span>j<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>W<span class="op">];</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> W <span class="op">=</span> <span class="dv">100</span><span class="op">;</span> <span class="co">// Capacity of knapsack</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> val <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span> <span class="co">// Values of items</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> wt <span class="op">=</span> <span class="op">{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">};</span> <span class="co">// Weights of items</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> val<span class="op">.</span>size<span class="op">();</span> <span class="co">// Number of items</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">&lt;&lt;</span> unboundedKnapsack<span class="op">(</span>W<span class="op">,</span> val<span class="op">,</span> wt<span class="op">,</span> n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Input Parameters</strong>:
<ul>
<li><code>W</code>: This is the maximum weight the knapsack can
hold.</li>
<li><code>val</code>: This is a list that holds the values of the
items.</li>
<li><code>wt</code>: This is a list that holds the weights of the
items.</li>
<li><code>n</code>: This is the number of items we have.</li>
</ul></li>
<li><strong>Dynamic Programming Table</strong>:
<ul>
<li>We create an array <code>dp</code> of size <code>W + 1</code> to
keep track of the best value we can get for each weight up to
<code>W</code>.</li>
</ul></li>
<li><strong>Nested Loops</strong>:
<ul>
<li>The first loop goes through all weights from <code>0</code> to
<code>W</code>.</li>
<li>The second loop checks each item to see if it can fit in the current
weight. If it fits, we update the best value in the <code>dp</code>
array.</li>
</ul></li>
<li><strong>Result</strong>:
<ul>
<li>The best value we can get with the weight limit is in
<code>dp[W]</code>.</li>
</ul></li>
</ul>
<p>This code runs in O(n * W) time, where <code>n</code> is the number
of items and <code>W</code> is the weight limit of the knapsack. This
makes it good for medium-sized inputs.</p>
<p>If we want to learn more about similar dynamic programming problems,
we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack Problem</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Coin
Change problem</a>.</p>
<h2
id="optimized-space-complexity-for-unbounded-knapsack-in-java">Optimized
Space Complexity for Unbounded Knapsack in Java</h2>
<p>In the Unbounded Knapsack problem, we want to get the most value from
items we can put in a knapsack with a certain capacity. The optimized
space complexity method helps us lower the space used in the dynamic
programming solution. We go from O(n * W) to O(W). Here n is the number
of items and W is the knapsack capacity.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<p>Here is how we can implement the optimized space complexity solution
for the Unbounded Knapsack problem in Java:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UnboundedKnapsack <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">unboundedKnapsack</span><span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> val<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> wt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> wt<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> wt<span class="op">[</span>i<span class="op">];</span> j <span class="op">&lt;=</span> W<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> wt<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>W<span class="op">];</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> val <span class="op">=</span> <span class="op">{</span><span class="dv">20</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">40</span><span class="op">};</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> wt <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> W <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">+</span> <span class="fu">unboundedKnapsack</span><span class="op">(</span>W<span class="op">,</span> val<span class="op">,</span> wt<span class="op">));</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><p><strong>Initialization</strong>: We make a one-dimensional array
<code>dp</code> that has a size of <code>W + 1</code>. This array will
keep the maximum value we can get for each capacity from 0 to
W.</p></li>
<li><p><strong>Filling the dp array</strong>: For each item, we go
through all capacities starting from the item’s weight up to W. We
change <code>dp[j]</code> to be the biggest value between its current
value and the value we get by adding the current item.</p></li>
<li><p><strong>Final result</strong>: The highest value for the knapsack
of capacity W is in <code>dp[W]</code>.</p></li>
</ul>
<p>This implementation saves space by using just one array and updating
it step by step. This gives us better memory use while still keeping the
time complexity at O(n * W).</p>
<p>If you want to learn more, you can read more about dynamic
programming in <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">this
article on the Unbounded Knapsack Problem</a>.</p>
<h2
id="optimized-space-complexity-for-unbounded-knapsack-in-python">Optimized
Space Complexity for Unbounded Knapsack in Python</h2>
<p>To make space better for the Unbounded Knapsack problem in Python, we
can use a one-dimensional array instead of a two-dimensional array. We
can keep a single array. Each index shows the maximum value we can get
with that weight.</p>
<h3 id="implementation-1">Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unbounded_knapsack(weights, values, capacity):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (capacity <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, capacity <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(weights)):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weights[j] <span class="op">&lt;=</span> i:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[i <span class="op">-</span> weights[j]] <span class="op">+</span> values[j])</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[capacity]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">40</span>, <span class="dv">50</span>, <span class="dv">70</span>]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>capacity <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(unbounded_knapsack(weights, values, capacity))  <span class="co"># Output: 110</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ul>
<li>The function <code>unbounded_knapsack</code> takes three inputs: a
list of item weights, a list of item values, and the knapsack’s
capacity.</li>
<li>We start with a list <code>dp</code> of size
<code>capacity + 1</code>, and all values are 0. This list shows the
maximum value we can get for each capacity from 0 to
<code>capacity</code>.</li>
<li>We loop through each capacity from <code>1</code> to
<code>capacity</code>. For each weight, we check if it fits into the
current capacity. If it fits, we update the <code>dp[i]</code> value. We
take the highest value between its current value or the value we get by
adding the item (<code>dp[i - weights[j]] + values[j]</code>).</li>
<li>The maximum value we can get with the given capacity is at
<code>dp[capacity]</code>.</li>
</ul>
<p>This method reduces the space we use from O(n * capacity) to
O(capacity). It is better but keeps the same time complexity of
O(capacity * n).</p>
<p>For more insights on dynamic programming techniques, we can look at
topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0/1
Knapsack Problem</a>.</p>
<h2
id="optimized-space-complexity-for-unbounded-knapsack-in-c">Optimized
Space Complexity for Unbounded Knapsack in C++</h2>
<p>We can make the Unbounded Knapsack problem use less space. Instead of
using a two-dimensional array, we can use a one-dimensional array to
store results. This works because to find the maximum value for a
specific capacity, we just need the results from the previous
capacities.</p>
<h3 id="c-implementation-1">C++ Implementation</h3>
<p>Here is how we can use the optimized space approach for the Unbounded
Knapsack problem in C++:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> unboundedKnapsack<span class="op">(</span><span class="dt">int</span> capacity<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> weights<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> values<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>capacity <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> weights<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> weights<span class="op">[</span>i<span class="op">];</span> j <span class="op">&lt;=</span> capacity<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> weights<span class="op">[</span>i<span class="op">]]</span> <span class="op">+</span> values<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>capacity<span class="op">];</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> capacity <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="co">// Item weights</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> values <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">40</span><span class="op">};</span> <span class="co">// Corresponding values</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_value <span class="op">=</span> unboundedKnapsack<span class="op">(</span>capacity<span class="op">,</span> weights<span class="op">,</span> values<span class="op">);</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">&lt;&lt;</span> max_value <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-2">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We make a one-dimensional array
<code>dp</code> with size <code>capacity + 1</code> and set all values
to zero.</li>
<li><strong>Outer Loop</strong>: We go through each item.</li>
<li><strong>Inner Loop</strong>: We check all capacities from the item’s
weight to the maximum capacity.</li>
<li><strong>DP Update</strong>: For each capacity, we update the maximum
value by looking at the current item.</li>
</ul>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity is O(capacity). We only need one array
<code>dp</code> instead of a 2D array. This helps us to save space,
especially when the capacity is large.</p>
<p>This optimized way is good in cases where the knapsack’s capacity is
much bigger than the number of items. It keeps the space we use small
and still gives us the best value we can get.</p>
<h2 id="code-complexity-analysis-of-unbounded-knapsack-problem">Code
Complexity Analysis of Unbounded Knapsack Problem</h2>
<p>We can solve the Unbounded Knapsack Problem using dynamic
programming. The time and space complexity can change based on how we
implement it. Below, we look at the complexities when we use a dynamic
programming method.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ol type="1">
<li><strong>Dynamic Programming Table Approach</strong>:
<ul>
<li>In the normal dynamic programming solution, we keep a table
<code>dp[]</code>. Here, <code>dp[i]</code> shows the maximum value we
can get with a knapsack capacity of <code>i</code>.</li>
<li>When we go through each item and update the <code>dp</code> table,
we get a time complexity of <strong>O(n * W</strong>). Here,
<code>n</code> is the number of items and <code>W</code> is the maximum
weight or capacity of the knapsack.</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">unboundedKnapsack</span><span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> val<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> wt<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> val<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> W<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>j<span class="op">]</span> <span class="op">&lt;=</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> wt<span class="op">[</span>j<span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>j<span class="op">]);</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>W<span class="op">];</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Optimized Space Complexity Approach</strong>:
<ul>
<li>We can make it better by using a one-dimensional array and going in
reverse order when we update. This way, we reduce space complexity to
O(W).</li>
<li>The time complexity stays <strong>O(n * W)</strong>.</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unbounded_knapsack(W, val, wt):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (W <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(W <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(val)):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> wt[j] <span class="op">&lt;=</span> i:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[i <span class="op">-</span> wt[j]] <span class="op">+</span> val[j])</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[W]</span></code></pre></div></li>
</ol>
<h3 id="space-complexity-1">Space Complexity</h3>
<ul>
<li>The space complexity of the dynamic programming solution mainly
depends on the size of the <code>dp</code> array.</li>
<li>For the table method, the space complexity is <strong>O(W)</strong>,
where W is the capacity of the knapsack.</li>
<li>With the optimized method, we still have <strong>O(W)</strong>,
because we just need one array to keep the intermediate results.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>In conclusion, the Unbounded Knapsack Problem has a time complexity
of O(n * W) and a space complexity of O(W) for both the normal and
optimized dynamic programming methods. This makes dynamic programming a
good way to solve the Unbounded Knapsack Problem well.</p>
<p>For more insights on dynamic programming methods, we can check this
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change Problem</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-unbounded-knapsack-problem">What is the Unbounded
Knapsack Problem?</h3>
<p>The Unbounded Knapsack Problem is a well-known problem in dynamic
programming. In this problem, we can use as many items as we want to get
the most value in a knapsack with a set size. This is different from the
0/1 Knapsack Problem. In the 0/1 version, we can only use each item
once. But in the Unbounded version, we can use the same item many times.
This is important for many uses like managing resources and
budgeting.</p>
<h3
id="how-does-the-dynamic-programming-approach-solve-the-unbounded-knapsack-problem">How
does the dynamic programming approach solve the Unbounded Knapsack
Problem?</h3>
<p>To solve the Unbounded Knapsack Problem with dynamic programming, we
make a table. This table tracks the maximum values for each size from 0
to the biggest size we have. We look at each item one by one. We update
the table if adding the item gives us a higher total value. This way, we
can find the answer quickly. This method makes the problem much simpler
to solve.</p>
<h3
id="what-is-the-time-complexity-of-the-unbounded-knapsack-problem-using-dynamic-programming">What
is the time complexity of the Unbounded Knapsack Problem using dynamic
programming?</h3>
<p>The time it takes to solve the Unbounded Knapsack Problem with
dynamic programming is O(n * W). Here, n is the number of items and W is
the maximum size of the knapsack. We get this speed by filling a table
that keeps answers for smaller problems. This helps us find the overall
answer without doing the same work again.</p>
<h3
id="can-the-unbounded-knapsack-problem-be-solved-in-python-java-and-c">Can
the Unbounded Knapsack Problem be solved in Python, Java, and C++?</h3>
<p>Yes, we can solve the Unbounded Knapsack Problem in many programming
languages like Python, Java, and C++. Each language has its own rules
and ways to write code. But the basic logic of dynamic programming stays
the same. We can find examples of the Unbounded Knapsack Problem in
Java, Python, and C++ in this article.</p>
<h3
id="what-are-some-common-variations-of-the-unbounded-knapsack-problem">What
are some common variations of the Unbounded Knapsack Problem?</h3>
<p>Common variations of the Unbounded Knapsack Problem include the
bounded version. In this version, each item can only be used a certain
number of times. There are also variations with different rules like
weight limits, maximum item amounts, or certain item combinations.
Knowing these differences can help us solve real-life problems in
optimization, resource management, and logistics.</p>
<p>For more on related dynamic programming ideas, check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">Dynamic
Programming: 0/1 Knapsack Problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            