
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Weighted Independent Set in a Tree - Hard</title>
            <meta name="description" content="Discover how to solve the Maximum Weighted Independent Set in a tree using dynamic programming techniques. Learn strategies & examples!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Weighted Independent Set in a Tree - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Weighted Independent Set in a Tree problem is about
finding the biggest set of points in a tree. In this set, no two points
can be next to each other. We also want to make the total weight of the
chosen points as high as possible. We can solve this problem well by
using dynamic programming. We take advantage of the special shape of the
tree. This way, we can make an algorithm that works in a quick time
based on the number of nodes.</p>
<p>In this article, we will look closely at the Maximum Weighted
Independent Set in a Tree problem. We will talk about the problem
itself, dynamic programming methods, and how to code it in Java, Python,
and C++. We will also share tips to make space use better. We will
compare different ways to solve it. Plus, we will give a full code
example for all the languages. We will also answer some common questions
about this topic.</p>
<ul>
<li>[Dynamic Programming] Maximum Weighted Independent Set in a Tree -
Hard Overview</li>
<li>Understanding the Problem Statement for Maximum Weighted Independent
Set</li>
<li>Dynamic Programming Approach to Maximum Weighted Independent Set in
a Tree</li>
<li>Recursive Solution for Maximum Weighted Independent Set in Java</li>
<li>Dynamic Programming Solution for Maximum Weighted Independent Set in
Python</li>
<li>C++ Implementation of Maximum Weighted Independent Set using Dynamic
Programming</li>
<li>Optimizing Space Complexity in Maximum Weighted Independent Set
Solutions</li>
<li>Comparative Analysis of Different Approaches for Maximum Weighted
Independent Set</li>
<li>Code Walkthrough for Maximum Weighted Independent Set in All
Languages</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information on dynamic programming ideas and similar
problems, you can read articles on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber problem</a>.</p>
<h2
id="understanding-the-problem-statement-for-maximum-weighted-independent-set">Understanding
the Problem Statement for Maximum Weighted Independent Set</h2>
<p>The Maximum Weighted Independent Set (MWIS) problem in a tree is a
famous problem in combinatorial optimization. Our goal is to find a set
of vertices. In this set, no two vertices are next to each other. Also,
we want to make the sum of the weights of these vertices as big as
possible.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: A tree ( T ) with weights for each
vertex.</li>
<li><strong>Output</strong>: The highest weight of an independent set in
the tree.</li>
</ul>
<h3 id="properties">Properties</h3>
<ul>
<li>An independent set is a group of vertices in a graph where no two
are next to each other.</li>
<li>In a tree structure, we can find the maximum independent set using
dynamic programming. This works well because trees do not have
cycles.</li>
</ul>
<h3 id="example">Example</h3>
<p>Let us look at a tree with this structure and weights:</p>
<pre><code>       1 (3)
      / \
   2 (2)  3 (4)
   / \
 4 (1) 5 (5)</code></pre>
<p>The independent sets can have combinations like: - {1, 4, 5} which
gives a total weight of (3 + 1 + 5 = 9) - {2, 3} which gives a total
weight of (2 + 4 = 6)</p>
<p>So, the MWIS here is {1, 4, 5} with a maximum weight of
<strong>9</strong>.</p>
<h3 id="constraints">Constraints</h3>
<ol type="1">
<li>The tree must be connected and not have cycles.</li>
<li>Weights can be zero or more.</li>
</ol>
<p>We can solve this problem quickly using dynamic programming. We use
the tree’s recursive structure to help us.</p>
<h2
id="dynamic-programming-approach-to-maximum-weighted-independent-set-in-a-tree">Dynamic
Programming Approach to Maximum Weighted Independent Set in a Tree</h2>
<p>We can solve the Maximum Weighted Independent Set (MWIS) problem in a
tree using dynamic programming. This method takes advantage of the
tree’s structure. It helps us find the best solution starting from the
bottom and working our way up.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a tree where each node has a weight. Our goal is to find a
group of nodes. No two nodes in this group should be next to each other.
We want the total weight of these nodes to be as high as possible.</p>
<h3 id="dynamic-programming-solution-outline">Dynamic Programming
Solution Outline</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We define
<code>dp[node][0]</code> as the maximum weight of the independent set
that does not include the current <code>node</code>. We define
<code>dp[node][1]</code> as the maximum weight that includes this
<code>node</code>.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>If we include the node:
<ul>
<li><code>dp[node][1] = weight[node] + sum(dp[child][0] for each child of node)</code></li>
</ul></li>
<li>If we do not include the node:
<ul>
<li><code>dp[node][0] = sum(max(dp[child][0], dp[child][1]) for each child of node)</code></li>
</ul></li>
</ul></li>
<li><p><strong>Base Case</strong>: For leaf nodes, we have:</p>
<ul>
<li><code>dp[leaf][0] = 0</code></li>
<li><code>dp[leaf][1] = weight[leaf]</code></li>
</ul></li>
<li><p><strong>Traversal</strong>: We will use a depth-first search
(DFS) to go through the tree and find the <code>dp</code>
values.</p></li>
</ol>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, weight<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weight <span class="op">=</span> weight</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mwis(node):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    include_node <span class="op">=</span> node.weight</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    exclude_node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> child <span class="kw">in</span> node.children:</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        child_include, child_exclude <span class="op">=</span> mwis(child)</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        include_node <span class="op">+=</span> child_exclude</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        exclude_node <span class="op">+=</span> <span class="bu">max</span>(child_include, child_exclude)</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (include_node, exclude_node)</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(root):</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    include, exclude <span class="op">=</span> mwis(root)</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(include, exclude)</span></code></pre></div>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> weight<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">List</span><span class="op">&lt;</span><span class="bu">TreeNode</span><span class="op">&gt;</span> children<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span><span class="op">(</span><span class="dt">int</span> weight<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">weight</span> <span class="op">=</span> weight<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">children</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">ArrayList</span><span class="op">&lt;&gt;();</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MWIS <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">mwis</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[]{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> includeNode <span class="op">=</span> node<span class="op">.</span><span class="fu">weight</span><span class="op">;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> excludeNode <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="bu">TreeNode</span> child <span class="op">:</span> node<span class="op">.</span><span class="fu">children</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span><span class="op">[]</span> childResult <span class="op">=</span> <span class="fu">mwis</span><span class="op">(</span>child<span class="op">);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            includeNode <span class="op">+=</span> childResult<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            excludeNode <span class="op">+=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>childResult<span class="op">[</span><span class="dv">0</span><span class="op">],</span> childResult<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[]{</span>includeNode<span class="op">,</span> excludeNode<span class="op">};</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxWeightedIndependentSet</span><span class="op">(</span><span class="bu">TreeNode</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="fu">mwis</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>result<span class="op">[</span><span class="dv">0</span><span class="op">],</span> result<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li>The dynamic programming method makes sure we only process each node
one time. This gives us a time complexity of O(n), where n is the number
of nodes in the tree.</li>
<li>We can improve space complexity to O(h) by using the recursion stack
space, where h is the height of the tree.</li>
<li>This approach works very well for tree structures because of their
natural hierarchy.</li>
</ul>
<p>For more on dynamic programming ideas and similar problems, we can
check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-weighted-independent-set-in-a-path-graph-medium.html">Maximum
Weighted Independent Set in a Path Graph</a> article.</p>
<h2
id="recursive-solution-for-maximum-weighted-independent-set-in-java">Recursive
Solution for Maximum Weighted Independent Set in Java</h2>
<p>The Maximum Weighted Independent Set (MWIS) problem in a tree can be
solved with a simple recursive method and memoization to make it faster.
We will find the best weight of the independent set by including or
excluding a node. We will also use the special properties of tree
structures.</p>
<h3 id="recursive-function-outline">Recursive Function Outline</h3>
<ol type="1">
<li><strong>Base Case</strong>: If the node is null, we return 0.</li>
<li><strong>Include the Node</strong>: If we include the current node,
we add its weight and call the function for its grandchildren. This is
to avoid selecting adjacent nodes.</li>
<li><strong>Exclude the Node</strong>: If we do not include the current
node, we call the function for its children.</li>
<li><strong>Return the Maximum</strong>: The result for the current node
is the best of including or excluding it.</li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a simple Java code showing the recursive method with
memoization:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Map</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> value<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> left<span class="op">,</span> right<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span><span class="op">(</span><span class="dt">int</span> val<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        value <span class="op">=</span> val<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> right <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumWeightedIndependentSet <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">TreeNode</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>node<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>node<span class="op">);</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Include current node</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> includeNode <span class="op">=</span> node<span class="op">.</span><span class="fu">value</span><span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node<span class="op">.</span><span class="fu">left</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            includeNode <span class="op">+=</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">left</span><span class="op">)</span> <span class="op">+</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            includeNode <span class="op">+=</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">left</span><span class="op">)</span> <span class="op">+</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Exclude current node</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> excludeNode <span class="op">=</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">)</span> <span class="op">+</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Store the result in memo</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>includeNode<span class="op">,</span> excludeNode<span class="op">);</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>node<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">TreeNode</span> root <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">left</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">4</span><span class="op">);</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        root<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">right</span> <span class="op">=</span> <span class="kw">new</span> <span class="bu">TreeNode</span><span class="op">(</span><span class="dv">5</span><span class="op">);</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>        MaximumWeightedIndependentSet mwis <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaximumWeightedIndependentSet</span><span class="op">();</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxWeight <span class="op">=</span> mwis<span class="op">.</span><span class="fu">maxWeightIndependentSet</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Weight of Independent Set: &quot;</span> <span class="op">+</span> maxWeight<span class="op">);</span></span>
<span id="cb4-55"><a href="#cb4-55" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-56"><a href="#cb4-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>TreeNode Class</strong>: This class defines how a node in
the tree looks.</li>
<li>The <code>maxWeightIndependentSet(TreeNode node)</code> method finds
the maximum weight independent set for the tree starting from
<code>node</code>.</li>
<li>The <code>memo</code> map stores results for nodes we already
calculated. This helps us to not do the same work again.</li>
<li>The main method creates a sample tree and calls the function to find
the maximum weight of the independent set, printing the result.</li>
</ul>
<p>This recursive solution helps us find the maximum weighted
independent set in a tree. We also use memoization to make it
faster.</p>
<h2
id="dynamic-programming-solution-for-maximum-weighted-independent-set-in-python">Dynamic
Programming Solution for Maximum Weighted Independent Set in Python</h2>
<p>We solve the Maximum Weighted Independent Set problem in a tree with
dynamic programming. We can use a recursive method with memoization. The
goal is to find the maximum weight by either including or not including
a node and its children.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>We have a tree where each node has a weight. An independent set is a
group of vertices where no two vertices are next to each other. We want
to find the independent set that has the highest total weight.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We say <code>dp[node]</code>
is the maximum weight of the independent set we can make starting from
<code>node</code>.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>If we take the current node, we cannot take its children:<br />
<code>dp[node] = weight[node] + sum(dp[children of node])</code></li>
<li>If we do not take the current node, we can take the children:<br />
<code>dp[node] = sum(dp[children of node])</code></li>
<li>So, the relation is:<br />
<code>dp[node] = max(weight[node] + sum(dp[children of node]), sum(dp[children of node]))</code></li>
</ul></li>
<li><p><strong>Base Case</strong>: If a node is a leaf, then
<code>dp[node] = weight[node]</code>.</p></li>
</ol>
<h3 id="implementation-in-python-1">Implementation in Python</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, weight<span class="op">=</span><span class="dv">0</span>):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weight <span class="op">=</span> weight</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.children <span class="op">=</span> []</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(node):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(n):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[n]</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        include_node <span class="op">=</span> n.weight</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> n.children:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            include_node <span class="op">+=</span> dp(child) <span class="cf">if</span> child <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        exclude_node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> n.children:</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            exclude_node <span class="op">+=</span> dp(child) <span class="cf">if</span> child <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> <span class="bu">max</span>(include_node, exclude_node)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(node)</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> TreeNode(<span class="dv">5</span>)</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>child1 <span class="op">=</span> TreeNode(<span class="dv">3</span>)</span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>child2 <span class="op">=</span> TreeNode(<span class="dv">4</span>)</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>child3 <span class="op">=</span> TreeNode(<span class="dv">2</span>)</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>root.children <span class="op">=</span> [child1, child2]</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>child1.children <span class="op">=</span> [child3]</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> max_weighted_independent_set(root)</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum Weighted Independent Set:&quot;</span>, result)  <span class="co"># Output: Maximum Weighted Independent Set: 9</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<p>We have a <code>TreeNode</code> class to show each node in the tree
with its weight and a list of children.</p>
<p>The function <code>max_weighted_independent_set</code> starts a
memoization dictionary. It also has a helper function <code>dp</code>
that finds the maximum weight for the independent set from a node.</p>
<p>The function checks the memoization dictionary. This way, we avoid
doing the same calculations again. It makes the process faster.</p>
<p>This dynamic programming solution for the Maximum Weighted
Independent Set problem uses recursion and memoization. This leads to a
time complexity of O(n), where n is the number of nodes in the tree.</p>
<h2
id="c-implementation-of-maximum-weighted-independent-set-using-dynamic-programming">C++
Implementation of Maximum Weighted Independent Set using Dynamic
Programming</h2>
<p>To solve the Maximum Weighted Independent Set problem in a tree, we
can use dynamic programming in C++. We will use depth-first search (DFS)
to go through the tree and find the best solution. We will keep track of
two states for each node:</p>
<ol type="1">
<li><strong>Including the node</strong>: If we include a node in the
independent set, we cannot include its children.</li>
<li><strong>Excluding the node</strong>: If we exclude a node, we can
include its children.</li>
</ol>
<p>We can define how to move between these states like this: - If we
include the current node, the total weight is the weight of this node
plus the total weights of excluding its children. - If we exclude the
current node, the total weight is the best weights of including or
excluding each child.</p>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TreeNode <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> weight<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>TreeNode<span class="op">*&gt;</span> children<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">(</span><span class="dt">int</span> w<span class="op">)</span> <span class="op">:</span> weight<span class="op">(</span>w<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> dfs<span class="op">(</span>TreeNode<span class="op">*</span> node<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> include<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> exclude<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> included <span class="op">=</span> node<span class="op">-&gt;</span>weight<span class="op">;</span> <span class="co">// Include current node</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> excluded <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Exclude current node</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span> child <span class="op">:</span> node<span class="op">-&gt;</span>children<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> includeChild <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> excludeChild <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        dfs<span class="op">(</span>child<span class="op">,</span> includeChild<span class="op">,</span> excludeChild<span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If we include the current node, we cannot include the child</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        included <span class="op">+=</span> excludeChild<span class="op">;</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If we exclude the current node, we can choose to include or exclude the child</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        excluded <span class="op">+=</span> max<span class="op">(</span>includeChild<span class="op">,</span> excludeChild<span class="op">);</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> included<span class="op">;</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> excluded<span class="op">;</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxWeightedIndependentSet<span class="op">(</span>TreeNode<span class="op">*</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> include <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    dfs<span class="op">(</span>root<span class="op">,</span> include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Example usage</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> root <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">10</span><span class="op">);</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> child1 <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> child2 <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a>    root<span class="op">-&gt;</span>children<span class="op">.</span>push_back<span class="op">(</span>child1<span class="op">);</span></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    root<span class="op">-&gt;</span>children<span class="op">.</span>push_back<span class="op">(</span>child2<span class="op">);</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Weighted Independent Set: &quot;</span> <span class="op">&lt;&lt;</span> maxWeightedIndependentSet<span class="op">(</span>root<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> root<span class="op">;</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> child1<span class="op">;</span></span>
<span id="cb6-54"><a href="#cb6-54" aria-hidden="true" tabindex="-1"></a>    <span class="kw">delete</span> child2<span class="op">;</span></span>
<span id="cb6-55"><a href="#cb6-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-56"><a href="#cb6-56" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The <code>TreeNode</code> structure shows a node in the tree with a
weight and a list of children.</li>
<li>The <code>dfs</code> function does a depth-first search on the tree.
It finds the maximum weights for including and excluding the current
node.</li>
<li>The <code>maxWeightedIndependentSet</code> function starts with the
include and exclude values set to zero and calls the <code>dfs</code>
function from the root node.</li>
<li>The main function shows how to make a tree and calculate the maximum
weighted independent set.</li>
</ul>
<p>This C++ code works well to find the maximum weighted independent set
in a tree using simple dynamic programming ideas.</p>
<h2
id="optimizing-space-complexity-in-maximum-weighted-independent-set-solutions">Optimizing
Space Complexity in Maximum Weighted Independent Set Solutions</h2>
<p>When we solve the Maximum Weighted Independent Set in a Tree problem
using dynamic programming, it is important to optimize space. This helps
us work better, especially with bigger trees. In this section, we will
talk about ways to use less space while keeping the solution
correct.</p>
<h3 id="space-optimization-techniques">Space Optimization
Techniques</h3>
<ol type="1">
<li><strong>Use of State Compression:</strong>
<ul>
<li>We do not need to keep a full array for dynamic programming states.
We can keep only the states that matter for the current and the last
levels of the tree.</li>
<li>This works well in tree structures because only parent-child
connections are important.</li>
</ul></li>
<li><strong>Recursive Approach with Memoization:</strong>
<ul>
<li>We can use recursion with memoization to save results we already
calculated. This saves space compared to using a full DP table,
especially for trees that are not dense.</li>
</ul></li>
<li><strong>Bottom-Up DP with Reduced Storage:</strong>
<ul>
<li>We can use a bottom-up DP approach where we only store results from
the last two levels. Here is an example:</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(tree):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> node <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> dfs(tree[node].left)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> dfs(tree[node].right)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> tree[node].value <span class="op">+</span> left[<span class="dv">1</span>] <span class="op">+</span> right[<span class="dv">1</span>]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(left) <span class="op">+</span> <span class="bu">max</span>(right)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (include, exclude)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dfs(<span class="dv">0</span>))</span></code></pre></div></li>
<li><strong>Iterative Depth-First Search (DFS):</strong>
<ul>
<li>We can change recursive DFS to an iterative one using a stack. This
way we avoid the extra work of recursive calls and we can control memory
use better.</li>
</ul></li>
<li><strong>Bit Manipulation:</strong>
<ul>
<li>For trees that have a fixed height or a small number of nodes, we
can think about using bitmasks to encode states. This can help us use
much less memory.</li>
</ul></li>
</ol>
<h3 id="example-of-space-optimization">Example of Space
Optimization</h3>
<p>Here is a simple code that shows the techniques in Python:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, value):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> value</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(root):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node):</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> dfs(node.left)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> dfs(node.right)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> node.value <span class="op">+</span> left[<span class="dv">1</span>] <span class="op">+</span> right[<span class="dv">1</span>]</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(left) <span class="op">+</span> <span class="bu">max</span>(right)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (include, exclude)</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dfs(root))</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Tree Creation</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> TreeNode(<span class="dv">3</span>)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>root.left <span class="op">=</span> TreeNode(<span class="dv">2</span>)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>root.right <span class="op">=</span> TreeNode(<span class="dv">5</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>root.left.right <span class="op">=</span> TreeNode(<span class="dv">3</span>)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>root.right.right <span class="op">=</span> TreeNode(<span class="dv">1</span>)</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_weighted_independent_set(root))  <span class="co"># Output will be the maximum weighted independent set value</span></span></code></pre></div>
<p>By using these methods, we can lower the space complexity from O(n)
to O(h), where h is the height of the tree. This helps a lot with
performance for large inputs. These strategies are very important when
we work with the Maximum Weighted Independent Set in a tree. They help
us make our solutions work better and be more efficient.</p>
<h2
id="comparative-analysis-of-different-approaches-for-maximum-weighted-independent-set">Comparative
Analysis of Different Approaches for Maximum Weighted Independent
Set</h2>
<p>We can solve the Maximum Weighted Independent Set (MWIS) problem
using different ways. The main methods are brute force, recursive
methods, and dynamic programming. We will look at these methods. We will
compare them by time complexity, space complexity, and how well they
work for trees.</p>
<h3 id="brute-force-approach">1. Brute Force Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li><strong>Space Complexity</strong>: O(n) for recursion stack.</li>
<li><strong>Description</strong>: This method checks all possible
subsets of nodes to find the maximum weighted independent set. It takes
a lot of time and is not practical for big trees.</li>
</ul>
<h3 id="recursive-approach">2. Recursive Approach</h3>
<ul>
<li><p><strong>Time Complexity</strong>: O(n) with memoization.</p></li>
<li><p><strong>Space Complexity</strong>: O(n) for recursion stack and
memoization table.</p></li>
<li><p><strong>Description</strong>: This method uses recursion to
decide if we include or exclude each node. We can save results of
smaller problems to avoid doing the same work again.</p>
<p>Example in Java:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">MWIS</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">,</span> <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">TreeNode</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>node<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>node<span class="op">);</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> include <span class="op">=</span> node<span class="op">.</span><span class="fu">val</span> <span class="op">+</span> </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>node<span class="op">.</span><span class="fu">left</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">?</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">left</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">.</span><span class="fu">right</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">:</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> </span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">(</span>node<span class="op">.</span><span class="fu">right</span> <span class="op">!=</span> <span class="kw">null</span> <span class="op">?</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">left</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">.</span><span class="fu">right</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">:</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> exclude <span class="op">=</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">MWIS</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>node<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ul>
<h3 id="dynamic-programming-approach-1">3. Dynamic Programming
Approach</h3>
<ul>
<li><p><strong>Time Complexity</strong>: O(n)</p></li>
<li><p><strong>Space Complexity</strong>: O(n) if we use an array for
the DP table.</p></li>
<li><p><strong>Description</strong>: This method is better for solving
MWIS in trees. It fills a DP table from the bottom up based on choices
at every node. This method gives us good solutions in polynomial
time.</p>
<p>Example in Python:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> MWIS(root):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node):</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> dfs(node.left)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> dfs(node.right)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> node.val <span class="op">+</span> left[<span class="dv">1</span>] <span class="op">+</span> right[<span class="dv">1</span>]</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(left) <span class="op">+</span> <span class="bu">max</span>(right)</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (include, exclude)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dfs(root))</span></code></pre></div></li>
</ul>
<h3 id="space-optimization-techniques-1">4. Space Optimization
Techniques</h3>
<ul>
<li>In the dynamic programming method, we can save space from O(n) to
O(1). We only need to keep track of the last two states instead of a
whole DP table.</li>
</ul>
<h3 id="comparative-summary">5. Comparative Summary</h3>
<ul>
<li><strong>Brute Force</strong>: Not possible for large trees because
of high time complexity.</li>
<li><strong>Recursive with Memoization</strong>: Better than brute force
but still not as good as dynamic programming.</li>
<li><strong>Dynamic Programming</strong>: Best for trees. It balances
time and space well. It gives an optimal solution in polynomial
time.</li>
</ul>
<p>In conclusion, the dynamic programming method is the best for solving
the Maximum Weighted Independent Set problem in trees. It works better
than brute force and recursive methods. If we want to learn more about
dynamic programming, we can read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-weighted-independent-set-in-a-path-graph-medium.html">Maximum
Weighted Independent Set in a Path Graph</a>.</p>
<h2
id="code-walkthrough-for-maximum-weighted-independent-set-in-all-languages">Code
Walkthrough for Maximum Weighted Independent Set in All Languages</h2>
<p>We solve the Maximum Weighted Independent Set problem in a tree using
dynamic programming. We show the solution in different programming
languages. The main idea is to use a recursive method with memoization
or a bottom-up dynamic programming method. This helps us to store values
that we already calculated.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> left<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> right<span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span><span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumWeightedIndependentSet <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span><span class="bu">TreeNode</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="fu">helper</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>result<span class="op">[</span><span class="dv">0</span><span class="op">],</span> result<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">helper</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">2</span><span class="op">];</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> left <span class="op">=</span> <span class="fu">helper</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">);</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> right <span class="op">=</span> <span class="fu">helper</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">);</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> node<span class="op">.</span><span class="fu">val</span> <span class="op">+</span> left<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> right<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>left<span class="op">[</span><span class="dv">0</span><span class="op">],</span> left<span class="op">[</span><span class="dv">1</span><span class="op">])</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>right<span class="op">[</span><span class="dv">0</span><span class="op">],</span> right<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[]{</span>include<span class="op">,</span> exclude<span class="op">};</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x):</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.val <span class="op">=</span> x</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxWeightIndependentSet(root):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(node):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> (<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> helper(node.left)</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> helper(node.right)</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> node.val <span class="op">+</span> left[<span class="dv">1</span>] <span class="op">+</span> right[<span class="dv">1</span>]</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(left) <span class="op">+</span> <span class="bu">max</span>(right)</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (include, exclude)</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(helper(root))</span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>root <span class="op">=</span> TreeNode(<span class="dv">3</span>)</span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>root.left <span class="op">=</span> TreeNode(<span class="dv">2</span>)</span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>root.right <span class="op">=</span> TreeNode(<span class="dv">5</span>)</span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>root.left.right <span class="op">=</span> TreeNode(<span class="dv">3</span>)</span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>root.right.right <span class="op">=</span> TreeNode(<span class="dv">1</span>)</span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxWeightIndependentSet(root))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TreeNode <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> left<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> right<span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> left<span class="op">(</span>NULL<span class="op">),</span> right<span class="op">(</span>NULL<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxWeightIndependentSet<span class="op">(</span>TreeNode<span class="op">*</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> res <span class="op">=</span> helper<span class="op">(</span>root<span class="op">);</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>res<span class="op">.</span>first<span class="op">,</span> res<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    pair<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> helper<span class="op">(</span>TreeNode<span class="op">*</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span> <span class="cf">return</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">};</span></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> left <span class="op">=</span> helper<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">);</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> right <span class="op">=</span> helper<span class="op">(</span>node<span class="op">-&gt;</span>right<span class="op">);</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> node<span class="op">-&gt;</span>val <span class="op">+</span> left<span class="op">.</span>second <span class="op">+</span> right<span class="op">.</span>second<span class="op">;</span></span>
<span id="cb13-21"><a href="#cb13-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> max<span class="op">(</span>left<span class="op">.</span>first<span class="op">,</span> left<span class="op">.</span>second<span class="op">)</span> <span class="op">+</span> max<span class="op">(</span>right<span class="op">.</span>first<span class="op">,</span> right<span class="op">.</span>second<span class="op">);</span></span>
<span id="cb13-22"><a href="#cb13-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">{</span>include<span class="op">,</span> exclude<span class="op">};</span></span>
<span id="cb13-23"><a href="#cb13-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-24"><a href="#cb13-24" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>These code examples use a recursive method to find the maximum weight
independent set in a binary tree. We decide for each node if we want to
include it in the independent set or not. This gives us two choices for
each node: we can include the node and not include its children or we
can exclude the node and take the best from its children.</p>
<p>For more understanding of dynamic programming in different cases, we
can look at other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Numbers</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-weighted-independent-set-in-a-tree-problem">What
is the Maximum Weighted Independent Set in a Tree problem?</h3>
<p>The Maximum Weighted Independent Set in a Tree problem is about
finding a group of nodes in a tree. We want to make sure that no two
nodes are next to each other. We also want the total weight of the
chosen nodes to be as high as possible. We can solve this problem well
using dynamic programming. Trees are good for this because they do not
have cycles.</p>
<h3
id="how-does-dynamic-programming-apply-to-the-maximum-weighted-independent-set-in-a-tree">How
does dynamic programming apply to the Maximum Weighted Independent Set
in a Tree?</h3>
<p>Dynamic programming works great for the Maximum Weighted Independent
Set in a Tree problem. This is because it has overlapping subproblems
and optimal structure. We can break the problem into smaller parts. By
saving the results of these parts, we can avoid doing the same work
again. This makes our solution faster.</p>
<h3
id="can-you-provide-a-python-implementation-for-the-maximum-weighted-independent-set-in-a-tree">Can
you provide a Python implementation for the Maximum Weighted Independent
Set in a Tree?</h3>
<p>Sure! Here is a simple Python code to find the Maximum Weighted
Independent Set in a Tree using dynamic programming:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(tree, weights):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node, parent):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        include_node <span class="op">=</span> weights[node]</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        exclude_node <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> child <span class="kw">in</span> tree[node]:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> child <span class="op">!=</span> parent:</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>                exclude_node <span class="op">+=</span> dfs(child, node)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>                include_node <span class="op">+=</span> dfs(child, node)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(include_node, exclude_node)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)</span></code></pre></div>
<h3
id="what-are-the-space-optimization-techniques-for-the-maximum-weighted-independent-set-problem">What
are the space optimization techniques for the Maximum Weighted
Independent Set problem?</h3>
<p>Space optimization for the Maximum Weighted Independent Set in a Tree
helps to use less memory in dynamic programming. We can do this by using
loops instead of recursive methods. We can also save only the important
states instead of saving everything. This way, we can use less
memory.</p>
<h3
id="how-does-the-maximum-weighted-independent-set-in-a-tree-compare-to-other-dynamic-programming-problems">How
does the Maximum Weighted Independent Set in a Tree compare to other
dynamic programming problems?</h3>
<p>The Maximum Weighted Independent Set in a Tree is like other dynamic
programming problems. One example is the “House Robber” problem. In this
problem, we try to get the most total from selected values while
following some rules. It uses the same ideas of dynamic programming.
This includes optimal structure and overlapping parts. We can use
techniques from one problem for the other. For more details, check out
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">House
Robber problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            