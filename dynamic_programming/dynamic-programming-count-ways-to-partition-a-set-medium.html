
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Partition a Set - Medium</title>
            <meta name="description" content="Learn how to count ways to partition a set using dynamic programming techniques. Master this essential algorithmic concept today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Partition a Set - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Counting the ways to divide a set is about splitting it into smaller
groups that are not empty. We can solve this problem in a smart way
using dynamic programming. This method builds answers step by step based
on answers we found before. We use a table to keep track of how many
ways we can divide the set for each size. This makes it much faster than
using simple methods that repeat the same work.</p>
<p>In this article, we will look at different dynamic programming
methods for counting set partitions. We will show how to do this in
Java, Python, and C++. We will also talk about ways to save space in our
solutions. We will cover both iterative and recursive methods. We will
compare different algorithms too. At the end, we will answer some common
questions about set partitioning to help understand this topic
better.</p>
<ul>
<li>[Dynamic Programming] Counting Ways to Partition a Set Using Dynamic
Programming</li>
<li>Dynamic Programming Approach for Counting Set Partitions in
Java</li>
<li>Dynamic Programming Approach for Counting Set Partitions in
Python</li>
<li>Dynamic Programming Approach for Counting Set Partitions in C++</li>
<li>Optimized Space Complexity Solutions for Set Partitioning</li>
<li>Iterative Dynamic Programming Solutions for Counting Set
Partitions</li>
<li>Recursive Dynamic Programming Solutions for Counting Set
Partitions</li>
<li>Comparative Analysis of Set Partitioning Algorithms</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="dynamic-programming-approach-for-counting-set-partitions-in-java">Dynamic
Programming Approach for Counting Set Partitions in Java</h2>
<p>We can count the ways to partition a set using dynamic programming in
Java. We will use a 2D array. The idea is to create a table where
<code>dp[i][j]</code> shows the number of ways to break a set of size
<code>i</code> into <code>j</code> non-empty parts.</p>
<p>Here is the code:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SetPartition <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countPartitions</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base cases</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Only one way to partition i items into 1 subset</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// No way to partition 0 items</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// One way to partition 0 items into 0 subsets</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP table</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> j <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>k<span class="op">];</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// size of the set</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// number of subsets</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to partition the set: &quot;</span> <span class="op">+</span> <span class="fu">countPartitions</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Initialization</strong>: We start by setting up our
<code>dp</code> array. The first row (no items) and the first column
(only one subset) are filled from the base cases.</li>
<li><strong>DP Formula</strong>: For each item, we can either make a new
subset or put it into the existing <code>j</code> subsets. So, the
formula <code>dp[i][j] = dp[i - 1][j - 1] + j * dp[i - 1][j]</code>
shows these two choices.</li>
<li><strong>Complexity</strong>: The time complexity is (O(n k)), and
space complexity is also (O(n k)).</li>
</ul>
<p>This Java code counts the ways to partition a set into given subsets
using dynamic programming. For more about dynamic programming, we can
read <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">this
article on counting ways to climb stairs</a>.</p>
<h2
id="dynamic-programming-approach-for-counting-set-partitions-in-python">Dynamic
Programming Approach for Counting Set Partitions in Python</h2>
<p>To count the ways to split a set using dynamic programming in Python,
we can use a combinatorial method. The problem is to find how many ways
we can divide a set of size <code>n</code> into <code>k</code> non-empty
groups.</p>
<p>Here is how we can do this:</p>
<ol type="1">
<li><p><strong>Define the DP table</strong>: We create a DP table
<code>dp</code>. In this table, <code>dp[i][j]</code> shows the number
of ways to split <code>i</code> elements into <code>j</code>
groups.</p></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li>For all <code>i &gt;= 1</code>, <code>dp[i][1] = 1</code> (there is
only one way to put all elements in one group).</li>
<li><code>dp[0][0] = 1</code> (there is one way to split an empty
set).</li>
</ul></li>
<li><p><strong>Recurrence Relation</strong>: For <code>i &gt; 0</code>
and <code>j &gt; 0</code>, we calculate the value like this: [ dp[i][j]
= j dp[i-1][j] + dp[i-1][j-1] ]</p>
<ul>
<li>The first part <code>j * dp[i-1][j]</code> means we add the
<code>i</code>-th element to one of the existing <code>j</code>
groups.</li>
<li>The second part <code>dp[i-1][j-1]</code> means we create a new
group with the <code>i</code>-th element.</li>
</ul></li>
</ol>
<p>Here is the Python code to do this:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions(n, k):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a DP table with (n+1) x (k+1)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case initialization</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># only one way to partition i elements into 1 subset</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> j <span class="op">*</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][k]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Total number of elements</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of subsets</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to partition </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> elements into </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> subsets: </span><span class="sc">{</span>count_partitions(n, k)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This code calculates the number of ways to split a set of size
<code>n</code> into <code>k</code> groups using dynamic programming. The
time it takes is (O(n k)) and the space used is also (O(n k)).</p>
<p>If we want to learn more about dynamic programming, we can look at
related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Dynamic
Programming: Subset Sum Problem</a>.</p>
<h2
id="dynamic-programming-approach-for-counting-set-partitions-in-c">Dynamic
Programming Approach for Counting Set Partitions in C++</h2>
<p>In C++, we can count the ways to divide a set using dynamic
programming. We use a 2D array called <code>dp</code>. Here,
<code>dp[i][j]</code> shows the number of ways to divide a set of size
<code>i</code> into <code>j</code> parts.</p>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>We set <code>dp[0][0] = 1</code>. This means we have one way to
divide an empty set into zero parts.</li>
<li>For other values, we set <code>dp[0][j] = 0</code> when
<code>j &gt; 0</code>. We can’t divide an empty set into non-zero
parts.</li>
<li>We also set <code>dp[i][0] = 0</code> for all <code>i &gt; 0</code>.
We can’t divide a non-empty set into zero parts.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>We use this relation: [ dp[i][j] = dp[i-1][j-1] + j dp[i-1][j]
]</li>
<li>The first term <code>dp[i-1][j-1]</code> is when the element is in
its own part. The second term <code>j \cdot dp[i-1][j]</code> is for
including the element in any of the existing <code>j</code> parts.</li>
</ul></li>
</ol>
<h3 id="c-code-example">C++ Code Example</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPartitions<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a 2D DP table</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base case</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// One way to partition an empty set</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the DP table</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> j <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sum all ways to partition n elements into any number of subsets</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> totalWays <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        totalWays <span class="op">+=</span> dp<span class="op">[</span>n<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> totalWays<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: partitioning a set of size 5</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to partition a set of size &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; is &quot;</span> <span class="op">&lt;&lt;</span> countPartitions<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The function <code>countPartitions(int n)</code> starts by creating
a DP table. It fills the table using the rule we wrote before.</li>
<li>It finds the total number of ways to divide a set of size
<code>n</code> by adding the last row of the DP table.</li>
<li>In the <code>main()</code> function, we call
<code>countPartitions</code> for a set of size 5.</li>
</ul>
<p>This dynamic programming way gives us a smart solution to count the
ways to divide a set. It uses results we already found, which helps us
save time. The overall time needed is (O(n^2)). If you want to learn
more about dynamic programming, see <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change Problem</a>.</p>
<h2
id="optimized-space-complexity-solutions-for-set-partitioning">Optimized
Space Complexity Solutions for Set Partitioning</h2>
<p>We can make space complexity better when we count ways to partition a
set. We can use different methods like reducing the size of the DP table
or using a rolling array. Our goal is to use less space while keeping
the algorithm fast.</p>
<h3 id="space-optimization-techniques">Space Optimization
Techniques</h3>
<ol type="1">
<li><p><strong>Reducing Dimensions</strong>: Instead of using a full 2D
DP array, we can use a 1D array. This array gets updated step by step
and only saves the needed previous states.</p></li>
<li><p><strong>Rolling Array Technique</strong>: This method helps us to
track only the last calculated values. It lowers the space complexity
from (O(n^2)) to (O(n)).</p></li>
</ol>
<h3 id="java-implementation-example">Java Implementation Example</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SetPartition <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countPartitions</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example set size</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Ways to partition: &quot;</span> <span class="op">+</span> <span class="fu">countPartitions</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-example">Python Implementation
Example</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions(n):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n, i <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> i]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Example set size</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Ways to partition:&quot;</span>, count_partitions(n))</span></code></pre></div>
<h3 id="c-implementation-example">C++ Implementation Example</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPartitions<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> i<span class="op">];</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example set size</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Ways to partition: &quot;</span> <span class="op">&lt;&lt;</span> countPartitions<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="benefits-of-optimized-space-complexity">Benefits of Optimized
Space Complexity</h3>
<ul>
<li><strong>Efficiency</strong>: By reducing space complexity from
(O(n^2)) to (O(n)), we can handle bigger inputs without using too much
memory.</li>
<li><strong>Performance</strong>: Better use of cache makes the
execution faster, especially for larger data.</li>
</ul>
<p>For more information on dynamic programming methods used in set
partitioning, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change Problem</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Dynamic
Programming - Subset Sum Problem</a>.</p>
<h2
id="iterative-dynamic-programming-solutions-for-counting-set-partitions">Iterative
Dynamic Programming Solutions for Counting Set Partitions</h2>
<p>We can use iterative dynamic programming to find how many ways we can
partition a set into subsets. The main idea is to use a 2D table (or
array) to keep track of results. This helps us avoid doing the same
calculations again.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We start with a set of <code>n</code> elements. Our goal is to find
how many ways we can divide this set into <code>k</code> non-empty
subsets.</p>
<h3 id="dynamic-programming-table-initialization">Dynamic Programming
Table Initialization</h3>
<ol type="1">
<li>We create a 2D array <code>dp[n + 1][k + 1]</code>. Here,
<code>dp[i][j]</code> shows the number of ways to divide <code>i</code>
elements into <code>j</code> subsets.</li>
<li>We set up the base cases:
<ul>
<li><code>dp[0][0] = 1</code>: There is one way to divide zero elements
into zero subsets.</li>
<li><code>dp[i][0] = 0</code> for all <code>i &gt; 0</code>: We cannot
divide positive elements into zero subsets.</li>
<li><code>dp[0][j] = 0</code> for all <code>j &gt; 0</code>: We cannot
divide zero elements into positive subsets.</li>
</ul></li>
</ol>
<h3 id="iterative-filling-of-the-dp-table">Iterative Filling of the DP
Table</h3>
<p>We define the recurrence relation like this: [ dp[i][j] = j
dp[i-1][j] + dp[i-1][j-1] ]</p>
<ul>
<li><code>j * dp[i-1][j]</code>: This counts partitions where the
<code>i-th</code> element is in one of the existing <code>j</code>
subsets.</li>
<li><code>dp[i-1][j-1]</code>: This counts partitions where the
<code>i-th</code> element makes a new subset.</li>
</ul>
<h3 id="implementation-example-in-python">Implementation Example in
Python</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions(n, k):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> j <span class="op">*</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][k]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Number of elements</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Number of subsets</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_partitions(n, k))  <span class="co"># Output: Number of ways to partition</span></span></code></pre></div>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time needed for this method is (O(n k)). Here, (n) is the number
of elements and (k) is the number of subsets. The space needed can also
be (O(n k)) because of the DP table.</p>
<p>We see that iterative dynamic programming is a strong method for
counting set partitions. It gives us a clear way to solve problems that
we can break into easier parts. For more learning on dynamic
programming, we can look at topics like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-partition-equal-subset-sum-medium.html">Dynamic
Programming Approach for Counting Set Partitions in Java</a>.</p>
<h2
id="recursive-dynamic-programming-solutions-for-counting-set-partitions">Recursive
Dynamic Programming Solutions for Counting Set Partitions</h2>
<p>We can use recursive dynamic programming to count set partitions by
breaking the problem into smaller parts. The main idea is to define a
function that counts how many ways we can divide a set of size
<code>n</code> into <code>k</code> groups. We can use Bell numbers to
set up a formula. Bell numbers help us count how many ways we can
partition a set.</p>
<h3 id="recursive-formula">Recursive Formula</h3>
<p>We can find the number of ways to partition a set of size
<code>n</code> into <code>k</code> groups with this formula:</p>
<p>[ P(n, k) = k P(n-1, k) + P(n-1, k-1) ]</p>
<p>Where: - ( P(n, k) ) is how many ways we can partition <code>n</code>
items into <code>k</code> non-empty groups. - The first part counts how
we can add the <code>n-th</code> item to one of the <code>k</code>
groups. - The second part counts how we can create a new group with the
<code>n-th</code> item.</p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li>( P(n, 1) = 1 ) for any <code>n</code> (there is only one way to
make one group).</li>
<li>( P(n, n) = 1 ) (there is one way to make <code>n</code> groups with
<code>n</code> items).</li>
<li>( P(n, 0) = 0 ) for <code>n &gt; 0</code> (we can’t make groups with
zero subsets).</li>
</ul>
<h3 id="implementation">Implementation</h3>
<p>Here is a simple Python code for the recursive dynamic programming
solution to count set partitions:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions(n, k, memo<span class="op">=</span>{}):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base cases</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> k <span class="op">&gt;</span> n:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> k <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> k <span class="op">==</span> n:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (n, k) <span class="kw">in</span> memo:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(n, k)]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursive case</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    memo[(n, k)] <span class="op">=</span> k <span class="op">*</span> count_partitions(n <span class="op">-</span> <span class="dv">1</span>, k, memo) <span class="op">+</span> count_partitions(n <span class="op">-</span> <span class="dv">1</span>, k <span class="op">-</span> <span class="dv">1</span>, memo)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[(n, k)]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span>  <span class="co"># Number of elements</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of groups</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_partitions(n, k))  <span class="co"># Output: number of ways to partition</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity:</strong> The time complexity is ( O(n^2) )
because we store overlapping problems in the memoization
dictionary.</li>
<li><strong>Space Complexity:</strong> The space complexity is ( O(n) )
for saving the memoization results.</li>
</ul>
<p>This recursive method works well for moderate sizes of <code>n</code>
and <code>k</code>. If we have larger numbers, we might want to use
other methods or solutions that save space better. Recursive dynamic
programming is a nice way to count how to partition a set, using
recursion and memoization.</p>
<p>For more reading about dynamic programming, we can check articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>
<h2 id="comparative-analysis-of-set-partitioning-algorithms">Comparative
Analysis of Set Partitioning Algorithms</h2>
<p>When we look at set partitioning algorithms, we can use different
methods. These methods include recursive, iterative, and dynamic
programming. Below, we give a simple comparison of these algorithms
based on how well they perform, how much space they need, and how easy
they are to implement.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<p>Dynamic programming is the best method for counting set partitions.
It uses a table to keep track of results. This way, we do not have to
calculate the same thing over and over.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n^2) where n is the size of the
set.</li>
<li><strong>Space Complexity:</strong> O(n) for keeping results in a
table.</li>
</ul>
<p><strong>Example Code in Python:</strong></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions(n):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span> <span class="co"># Base case: one way to partition zero elements</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> i]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_partitions(<span class="dv">5</span>))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="recursive-approach">2. Recursive Approach</h3>
<p>The recursive approach is when a function calls itself to solve
smaller problems. This method is easy to understand. But it is not very
efficient because it does many repeated calculations.</p>
<ul>
<li><strong>Time Complexity:</strong> O(2^n) because of the fast growth
in recursive calls.</li>
<li><strong>Space Complexity:</strong> O(n) for the call stack.</li>
</ul>
<p><strong>Example Code in Python:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions_recursive(n, m):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> m <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_partitions_recursive(n, m <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> count_partitions_recursive(n <span class="op">-</span> m, m)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_partitions_recursive(<span class="dv">5</span>, <span class="dv">5</span>))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="iterative-approach">3. Iterative Approach</h3>
<p>The iterative approach goes through possible partitions without using
recursive calls. This can make it faster, but it still might not be as
good as dynamic programming.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n^2).</li>
<li><strong>Space Complexity:</strong> O(1) if we do it in-place.</li>
</ul>
<p><strong>Example Code in Python:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_partitions_iterative(n):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    ways <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    ways[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            ways[j] <span class="op">+=</span> ways[j <span class="op">-</span> i]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ways[n]</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_partitions_iterative(<span class="dv">5</span>))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="comparative-summary">4. Comparative Summary</h3>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr class="header">
<th>Algorithm Type</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Implementation Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Dynamic Programming</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>Moderate</td>
</tr>
<tr class="even">
<td>Recursive</td>
<td>O(2^n)</td>
<td>O(n)</td>
<td>Simple</td>
</tr>
<tr class="odd">
<td>Iterative</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>Moderate</td>
</tr>
</tbody>
</table>
<p>We find that dynamic programming is usually the best choice. It works
well and can handle larger sets. For real-world examples, we can check
out articles on similar dynamic programming problems, like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-formula-to-count-the-ways-to-partition-a-set">1.
What is the formula to count the ways to partition a set?</h3>
<p>To count the ways to partition a set, we use Bell numbers. We can
compute these numbers with dynamic programming. The Bell number ( B(n) )
shows how many ways we can partition a set of size ( n ). The formula
is:<br />
[ B(n+1) = _{k=0}^{n} B(k) ]<br />
For more details on how to do this in Java, Python, and C++, look at our
sections on dynamic programming.</p>
<h3
id="how-can-i-implement-the-set-partition-counting-algorithm-in-python">2.
How can I implement the set partition counting algorithm in Python?</h3>
<p>To implement the set partition counting algorithm in Python, we can
use dynamic programming. We will build a table to keep intermediate
results. We start with one way to partition an empty set. Then we
calculate the number of partitions step by step using the formula. Check
our section on dynamic programming for a full Python example.</p>
<h3
id="what-are-the-time-and-space-complexities-for-counting-set-partitions-using-dynamic-programming">3.
What are the time and space complexities for counting set partitions
using dynamic programming?</h3>
<p>The time complexity for counting set partitions with dynamic
programming is ( O(n^2) ). Here, ( n ) is the size of the set. This
happens because we need nested loops to fill the dynamic programming
table. The space complexity is also ( O(n) ) if we use previous results,
but it can go up to ( O(n^2) ) if we keep a full table. For more on how
to save space, see our special section.</p>
<h3 id="can-i-use-recursion-to-count-the-ways-to-partition-a-set">4. Can
I use recursion to count the ways to partition a set?</h3>
<p>Yes, we can use recursion to count the ways to partition a set. But
it can cause overlapping problems and be slow. To make it faster, we can
use memoization to save results we already found. Look at our section on
recursive dynamic programming for a clear example and how to implement
it in different programming languages.</p>
<h3 id="how-does-the-bell-number-relate-to-set-partitioning">5. How does
the Bell number relate to set partitioning?</h3>
<p>The Bell number is closely linked to counting the ways to partition a
set. The ( n )-th Bell number counts how many ways we can partition a
set with ( n ) elements. Knowing this link can make it easier to create
algorithms for counting set partitions. For more information on Bell
numbers and how they are used, check our detailed dynamic programming
articles.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            