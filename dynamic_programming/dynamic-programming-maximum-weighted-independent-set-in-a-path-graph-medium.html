
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Weighted Independent Set in a Path Graph - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content=""Explore dynamic programming techniques to solve the Maximum Weighted Independent Set problem in path graphs. Learn more!"">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Weighted Independent Set in a Path Graph - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Weighted Independent Set (MWIS) in a path graph is a
well-known problem in dynamic programming. We need to pick a group of
vertices. The rule is that no two picked vertices can be next to each
other. We want to make the total weight as high as possible. We can
solve this problem well with dynamic programming. This method breaks the
problem into smaller parts. Then we can build the best solution step by
step.</p>
<p>In this article, we will look at how to use dynamic programming to
solve the Maximum Weighted Independent Set problem in a path graph. We
will explain the problem, go over the recursive way to solve it, and
talk about memoization in Java. We will also show how to do this in
Python and C++. We will check the time and space usage, and we will go
through the code to help understand it better. At the end, we will
answer some common questions about this topic.</p>
<ul>
<li>Dynamic Programming Approach for Maximum Weighted Independent Set in
a Path Graph - Medium</li>
<li>Understanding the Problem Statement for Maximum Weighted Independent
Set</li>
<li>Dynamic Programming Recursion for Maximum Weighted Independent
Set</li>
<li>Memoization Technique for Maximum Weighted Independent Set in
Java</li>
<li>Dynamic Programming Implementation in Python for Maximum Weighted
Independent Set</li>
<li>C++ Solution for Maximum Weighted Independent Set Using Dynamic
Programming</li>
<li>Comparing Time Complexity of Different Approaches</li>
<li>Optimizing Space Complexity for Maximum Weighted Independent
Set</li>
<li>Code Walkthrough of Maximum Weighted Independent Set Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-maximum-weighted-independent-set">Understanding
the Problem Statement for Maximum Weighted Independent Set</h2>
<p>The <strong>Maximum Weighted Independent Set (MWIS)</strong> problem
in a path graph asks us to pick some vertices. We need to make sure that
no two chosen vertices are next to each other. At the same time, we want
to get the highest total weight from the chosen vertices.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have: - A path graph. This is a line of vertices connected one
after another. - Each vertex ( v_i ) has a weight ( w_i ).</p>
<p>Our goal is to find a group of vertices that are not adjacent. We
want the total weight of these vertices to be as high as possible.</p>
<h3 id="example">Example</h3>
<p>Letâ€™s look at a path graph with weights like this:</p>
<ul>
<li>Vertex 0: weight 1</li>
<li>Vertex 1: weight 2</li>
<li>Vertex 2: weight 3</li>
<li>Vertex 3: weight 4</li>
</ul>
<p>Here are the possible independent sets and their weights:</p>
<ul>
<li>{}: weight 0</li>
<li>{0}: weight 1</li>
<li>{1}: weight 2</li>
<li>{2}: weight 3</li>
<li>{3}: weight 4</li>
<li>{0, 2}: weight 4</li>
<li>{0, 3}: weight 5</li>
<li>{1, 3}: weight 6</li>
</ul>
<p>The best choice is to take vertices {1, 3}. This gives us a total
weight of 6.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The graph is a straight line (a path).</li>
<li>We can either include or leave out each vertex from the independent
set.</li>
</ul>
<p>This problem is a good example of dynamic programming. We can use
optimal substructure and overlap of subproblems to find the maximum
weight quickly.</p>
<p>We want to create an algorithm that finds the MWIS using dynamic
programming. We will use the special features of the path graph to help
us.</p>
<h2
id="dynamic-programming-recursion-for-maximum-weighted-independent-set">Dynamic
Programming Recursion for Maximum Weighted Independent Set</h2>
<p>We can solve the Maximum Weighted Independent Set (MWIS) problem on a
path graph very well using dynamic programming recursion. The main idea
is to use a recursive way to break the problem into smaller parts.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a path graph with <code>n</code> vertices. Each vertex
<code>i</code> has a weight <code>w[i]</code>. Our goal is to find a
group of vertices. In this group, no two vertices can be next to each
other. We want to make the sum of their weights as big as possible.</p>
<h3 id="recursive-relation">Recursive Relation</h3>
<p>To make our recursive relation, we let <code>dp[i]</code> show the
biggest weight of an independent set we can make with the first
<code>i</code> vertices. The recursive relation looks like this:</p>
<ul>
<li>If we take vertex <code>i</code>, we cannot take vertex
<code>i-1</code>. So, the weight becomes
<code>w[i] + dp[i-2]</code>.</li>
<li>If we do not take vertex <code>i</code>, the biggest weight is
<code>dp[i-1]</code>.</li>
</ul>
<p>So, we can write the recursion like this:</p>
<pre><code>dp[i] = max(dp[i-1], w[i] + dp[i-2])</code></pre>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>dp[0] = w[0]</code> (just the first vertex)</li>
<li><code>dp[1] = max(w[0], w[1])</code> (biggest of the first two
vertices)</li>
</ul>
<h3 id="recursive-function-in-python">Recursive Function in Python</h3>
<p>Here is how we can write the recursive solution in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(w):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(w)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> w[<span class="dv">0</span>]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(w[<span class="dv">0</span>], w[<span class="dv">1</span>])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> w[<span class="dv">0</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(w[<span class="dv">0</span>], w[<span class="dv">1</span>])</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>], w[i] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_weighted_independent_set(weights))  <span class="co"># Output: 15</span></span></code></pre></div>
<p>This code helps us find the maximum weighted independent set for a
path graph. We use dynamic programming recursion by building the
solution step by step with results we already found.</p>
<p>If you want to learn more about dynamic programming methods and how
we can use them, you can check out other articles about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming House Robber</a>.</p>
<h2
id="memoization-technique-for-maximum-weighted-independent-set-in-java">Memoization
Technique for Maximum Weighted Independent Set in Java</h2>
<p>We can solve the Maximum Weighted Independent Set (MWIS) problem in a
path graph easily using a memoization technique. Memoization helps us
avoid doing the same calculations again by saving the results of
problems we already solved.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>In a path graph, each node has a weight. Our goal is to find the
highest sum of weights of non-adjacent nodes.</p>
<h3 id="recursive-function-with-memoization">Recursive Function with
Memoization</h3>
<p>In Java, we can use a recursive function to apply the memoization
technique. This function will store results in an array.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumWeightedIndependentSet <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxWeightIndependentSet</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> weights<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> weights<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Integer</span><span class="op">[]</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">Integer</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">findMaxWeight</span><span class="op">(</span>weights<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">findMaxWeight</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> weights<span class="op">,</span> <span class="dt">int</span> index<span class="op">,</span> <span class="bu">Integer</span><span class="op">[]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>index<span class="op">]</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Include the current node</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> weights<span class="op">[</span>index<span class="op">]</span> <span class="op">+</span> <span class="fu">findMaxWeight</span><span class="op">(</span>weights<span class="op">,</span> index <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Exclude the current node</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> <span class="fu">findMaxWeight</span><span class="op">(</span>weights<span class="op">,</span> index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>index<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">];</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        MaximumWeightedIndependentSet mwis <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaximumWeightedIndependentSet</span><span class="op">();</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">11</span><span class="op">};</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Weight Independent Set: &quot;</span> <span class="op">+</span> mwis<span class="op">.</span><span class="fu">maxWeightIndependentSet</span><span class="op">(</span>weights<span class="op">));</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>maxWeightIndependentSet</strong>: This function is the main
one. It starts the memoization array and calls the helper function.</li>
<li><strong>findMaxWeight</strong>: This is a recursive function. It
calculates the maximum weight by deciding to include or exclude the
current node. It also uses the memo array to keep results we already
found.</li>
<li><strong>Memoization Array</strong>: <code>Integer[] memo</code> is
used to store results. This helps to lower the time needed from
exponential to linear.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n), where n is the number of
nodes in the path graph.</li>
<li><strong>Space Complexity</strong>: O(n) because of the memoization
array.</li>
</ul>
<p>This way, we can find a good solution to the Maximum Weighted
Independent Set problem in path graphs. We use the benefits of dynamic
programming and memoization. If we want to know more about dynamic
programming, we can look at related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2
id="dynamic-programming-implementation-in-python-for-maximum-weighted-independent-set">Dynamic
Programming Implementation in Python for Maximum Weighted Independent
Set</h2>
<p>We will solve the Maximum Weighted Independent Set problem in a path
graph using dynamic programming in Python. We can use a bottom-up
method. The problem is like this: we have a path graph with weights on
each vertex. We want to find a group of vertices. In this group, no two
vertices are next to each other. We want the total weight of these
selected vertices to be the biggest.</p>
<h3 id="problem-definition-3">Problem Definition</h3>
<p>Let <code>weights</code> be an array. Here, <code>weights[i]</code>
is the weight of the vertex at index <code>i</code>. If we have
<code>n</code> vertices, our goal is to find the maximum weight
independent set using dynamic programming.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><strong>Base Cases</strong>:
<ul>
<li>If there are no vertices (<code>n == 0</code>), the maximum weight
is <code>0</code>.</li>
<li>If there is only one vertex (<code>n == 1</code>), the maximum
weight is <code>weights[0]</code>.</li>
</ul></li>
<li><strong>Recurrence Relation</strong>: For each vertex
<code>i</code>, we can either include it or not:
<ul>
<li>If we include vertex <code>i</code>, we cannot include vertex
<code>i-1</code>. So, the value will be
<code>weights[i] + dp[i-2]</code>.</li>
<li>If we do not include vertex <code>i</code>, the value will be
<code>dp[i-1]</code>.</li>
<li>So, the relation is:</li>
</ul>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>], weights[i] <span class="op">+</span> (dp[i<span class="op">-</span><span class="dv">2</span>] <span class="cf">if</span> i <span class="op">&gt;=</span> <span class="dv">2</span> <span class="cf">else</span> <span class="dv">0</span>))</span></code></pre></div></li>
</ol>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximum_weight_independent_set(weights):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> weights[<span class="dv">0</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize dp array</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> weights[<span class="dv">0</span>]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(weights[<span class="dv">0</span>], weights[<span class="dv">1</span>])</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>], weights[i] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> maximum_weight_independent_set(weights)</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;The maximum weight independent set is: </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<p>The <code>maximum_weight_independent_set</code> function starts a
dynamic programming table called <code>dp</code>. Each entry
<code>dp[i]</code> holds the maximum weight of the independent set up to
vertex <code>i</code>.</p>
<p>The loop goes from the third vertex to the last. It uses the
recurrence relation to fill the <code>dp</code> table. In the end,
<code>dp[n-1]</code> gives us the maximum weight of the independent
set.</p>
<p>This code finds the maximum weighted independent set in a path graph
using dynamic programming ideas. If you want to learn more about dynamic
programming, check these resources: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber I</a>.</p>
<h2
id="c-solution-for-maximum-weighted-independent-set-using-dynamic-programming">C++
Solution for Maximum Weighted Independent Set Using Dynamic
Programming</h2>
<p>We can solve the Maximum Weighted Independent Set problem in a path
graph using Dynamic Programming in C++. We will use a simple method. The
main idea is to set up a recursive formula. This formula helps us find
the maximum weight of independent sets by deciding to include or not
include each node.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a path graph. Each node has a weight. Our goal is to maximize
the weight of the independent set. We must make sure that no two
adjacent nodes are in the set.</p>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<ol type="1">
<li><strong>Define State</strong>: We will let <code>dp[i]</code> be the
maximum weight of an independent set using the first <code>i</code>
nodes.</li>
<li><strong>Transition</strong>:
<ul>
<li>If we include the <code>i-th</code> node, we cannot include the
<code>(i-1)-th</code> node. So we add <code>weights[i]</code> to
<code>dp[i-2]</code>.</li>
<li>If we do not include the <code>i-th</code> node, the value will be
<code>dp[i-1]</code>.</li>
<li>The relation is: [ dp[i] = (dp[i-1], weights[i] + dp[i-2]) ]</li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li><code>dp[0] = weights[0]</code> (only the first node)</li>
<li><code>dp[1] = \max(weights[0], weights[1])</code> (max of the first
two nodes)</li>
</ul></li>
</ol>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxWeightIndependentSet<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> weights<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> weights<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>weights<span class="op">[</span><span class="dv">0</span><span class="op">],</span> weights<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> weights<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Weighted Independent Set: &quot;</span> <span class="op">&lt;&lt;</span> maxWeightIndependentSet<span class="op">(</span>weights<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<p>We make a function <code>maxWeightIndependentSet</code> that takes a
vector of weights. We start the DP array with base cases. Then we loop
through the weights starting from the third element. We use the
transition formula to fill the DP array. In the end, we return the last
element of the DP array. This element has the maximum weight of the
independent set.</p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) where n is the number of
nodes in the path graph.</li>
<li><strong>Space Complexity</strong>: O(n) for the DP array. We can
make it O(1) by only keeping the last two values.</li>
</ul>
<p>This C++ solution calculates the Maximum Weighted Independent Set in
a path graph using Dynamic Programming. It is clear and performs
well.</p>
<h2 id="comparing-time-complexity-of-different-approaches">Comparing
Time Complexity of Different Approaches</h2>
<p>When we look at the time complexity of the Maximum Weighted
Independent Set problem in a path graph, we check different methods.
These methods include naive recursion, memoization, and dynamic
programming. Each method has its own time complexity.</p>
<ol type="1">
<li><strong>Naive Recursion</strong>:
<ul>
<li>The naive recursive method checks all possible groups of nodes. This
leads to a time complexity of (O(2^n)). Here, (n) is the number of nodes
in the graph.</li>
</ul></li>
<li><strong>Memoization</strong>:
<ul>
<li>When we use memoization to save results we already calculated, the
time complexity gets better. It becomes (O(n)). We only compute each
state once and keep the results in a cache for later use.</li>
</ul></li>
<li><strong>Dynamic Programming</strong>:
<ul>
<li>The dynamic programming method builds the solution step by step
using results we already have. This also has a time complexity of
(O(n)). We use a bottom-up approach and fill a DP table. Each cell shows
the maximum weight we can get up to that node.</li>
</ul></li>
</ol>
<h3 id="summary-of-time-complexities">Summary of Time Complexities</h3>
<ul>
<li><strong>Naive Recursion</strong>: (O(2^n))</li>
<li><strong>Memoization</strong>: (O(n))</li>
<li><strong>Dynamic Programming</strong>: (O(n))</li>
</ul>
<p>In real life, the memoization and dynamic programming methods are
much better for larger graphs. They help us to solve the Maximum
Weighted Independent Set problem in a path graph easily.</p>
<p>If we want to learn more about similar dynamic programming ideas, we
can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">Dynamic
Programming: 0-1 Knapsack Problem</a>.</p>
<h2
id="optimizing-space-complexity-for-maximum-weighted-independent-set">Optimizing
Space Complexity for Maximum Weighted Independent Set</h2>
<p>When we talk about the Maximum Weighted Independent Set problem on a
path graph, it is very important to make space usage better. This helps
us to handle bigger input sizes in a good way. A simple dynamic
programming method usually needs an array of size ( n ) to keep results
for all subproblems. Here, ( n ) means the number of vertices. But we
only need the last two values at any time. So, we can make space usage
much smaller.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>Instead of using an array of size ( n ), we just need two variables.
These two variables will keep track of the maximum weights we found so
far. This change brings down the space usage from ( O(n) ) to ( O(1)
).</p>
<h3 id="implementation">Implementation</h3>
<p>Here is how we can write the optimized solution in Python:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weighted_independent_set(weights):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> weights[<span class="dv">0</span>]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    prev1, prev2 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="bu">max</span>(prev1, prev2 <span class="op">+</span> weights[i])</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">7</span>, <span class="dv">10</span>]</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> max_weighted_independent_set(weights)</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;Maximum Weighted Independent Set: </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div>
<p>In this code:</p>
<ul>
<li><code>prev1</code> keeps the maximum weight with the current
vertex.</li>
<li><code>prev2</code> keeps the maximum weight without the current
vertex.</li>
<li>The loop goes through the weights and updates these two
variables.</li>
</ul>
<p>This smart method makes sure we only use a small amount of space
while still keeping the same time complexity of ( O(n) ).</p>
<h3 id="conclusion">Conclusion</h3>
<p>By using the features of the Maximum Weighted Independent Set problem
in a path graph, we can lower our space needs. This makes our solutions
better for bigger datasets. If you want to learn more about similar
dynamic programming problems, you can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and other dynamic programming
tasks.</p>
<h2
id="code-walkthrough-of-maximum-weighted-independent-set-solutions">Code
Walkthrough of Maximum Weighted Independent Set Solutions</h2>
<p>We can solve the Maximum Weighted Independent Set (MWIS) problem in a
path graph using dynamic programming. The main idea is to use recursion
with memoization or an iterative way to build the solution step by
step.</p>
<h3 id="dynamic-programming-approach-2">Dynamic Programming
Approach</h3>
<p>We define an array <code>dp</code>. Here, <code>dp[i]</code> shows
the maximum weight of an independent set we can get from the first
<code>i</code> nodes of the path.</p>
<p>The recursive formula looks like this:</p>
<ul>
<li>If we include the current node <code>i</code>, we cannot include
node <code>i-1</code>. So, we add the weight of node <code>i</code> to
<code>dp[i-2]</code>.</li>
<li>If we do not include the current node <code>i</code>, the result
will be <code>dp[i-1]</code>.</li>
</ul>
<p>So, the formula is:</p>
<pre><code>dp[i] = max(dp[i-1], weights[i] + (dp[i-2] if i &gt; 1 else 0))</code></pre>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumWeightedIndependentSet <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxWeightIS</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> weights<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>weights<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>weights<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> weights<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>weights<span class="op">[</span><span class="dv">0</span><span class="op">],</span> weights<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> weights<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Weight of Independent Set: &quot;</span> <span class="op">+</span> <span class="fu">maxWeightIS</span><span class="op">(</span>weights<span class="op">));</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-1">Python Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_weight_is(weights):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> weights:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(weights) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> weights[<span class="dv">0</span>]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(weights)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> weights[<span class="dv">0</span>]</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(weights[<span class="dv">0</span>], weights[<span class="dv">1</span>])</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>], weights[i] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum Weight of Independent Set:&quot;</span>, max_weight_is(weights))</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxWeightIS<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> weights<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>weights<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>weights<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> weights<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> weights<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>weights<span class="op">[</span><span class="dv">0</span><span class="op">],</span> weights<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> weights<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Weight of Independent Set: &quot;</span> <span class="op">&lt;&lt;</span> maxWeightIS<span class="op">(</span>weights<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code shows how to implement the Maximum Weighted Independent Set
solution using dynamic programming in Java, Python, and C++. All
implementations use the same logic. They follow the established formula
to find the maximum weight of an independent set in a path graph.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-a-maximum-weighted-independent-set-in-a-path-graph">1.
What is a Maximum Weighted Independent Set in a Path Graph?</h3>
<p>A Maximum Weighted Independent Set in a Path Graph is a group of
vertices. No two vertices in this group are next to each other. The goal
is to make the sum of their weights as high as possible. We can solve
this problem well using dynamic programming. This method helps us work
faster, even with big graphs. It is important to understand this idea.
It helps us make better choices based on weights in straight lines.</p>
<h3
id="how-does-dynamic-programming-apply-to-finding-the-maximum-weighted-independent-set">2.
How does dynamic programming apply to finding the Maximum Weighted
Independent Set?</h3>
<p>Dynamic programming helps us solve the Maximum Weighted Independent
Set problem. It does this by breaking the problem into smaller parts. We
store the results of these smaller parts. This way, we do not repeat our
work. We can make good decisions at each vertex. This helps us build the
best solution by using results from parts we solved before.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-this-problem">3.
What is the time complexity of the dynamic programming solution for this
problem?</h3>
<p>The time complexity for the dynamic programming solution for the
Maximum Weighted Independent Set in a Path Graph is O(n). Here, n is the
number of vertices. We get this speed by going through the graph and
making choices based on what we found earlier. This makes our method
much faster than trying all possible combinations.</p>
<h3
id="can-you-explain-the-memoization-technique-used-in-dynamic-programming-for-this-problem">4.
Can you explain the memoization technique used in dynamic programming
for this problem?</h3>
<p>Memoization is a technique in dynamic programming. It helps us save
results of costly function calls. Then we can use these saved results
when we need the same inputs again. For the Maximum Weighted Independent
Set in a Path Graph, memoization allows us to keep values for groups of
vertices. This cuts down the time we need to calculate and makes our
work faster.</p>
<h3
id="are-there-any-space-optimization-techniques-for-solving-the-maximum-weighted-independent-set">5.
Are there any space optimization techniques for solving the Maximum
Weighted Independent Set?</h3>
<p>Yes, we can use space optimization techniques for the Maximum
Weighted Independent Set problem. Instead of keeping a full array for
all results, we can just use two variables. These two variables will
track the last two states we need. This way, we lower the space needed
from O(n) to O(1). This makes our solution even better.</p>
<p>For more insights into dynamic programming techniques, check out
related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadaneâ€™s Algorithm)</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            