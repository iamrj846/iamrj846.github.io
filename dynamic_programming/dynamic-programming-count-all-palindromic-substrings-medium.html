
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count All Palindromic Substrings - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to count all palindromic substrings using dynamic programming. Enhance your coding skills with this easy-to-follow guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count All Palindromic Substrings - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong method we use to solve tough
problems. We can do this by breaking them into easier smaller problems.
When we count all palindromic substrings, we build a solution step by
step. We store results from earlier calculations. This way, we do not
repeat work. In this article, we will look at different ways to count
all palindromic substrings in a string. We will show examples in Java,
Python, and C++.</p>
<p>In this article, we will talk about different ways to count
palindromic substrings. We will cover dynamic programming, iterative
methods, and the expand-around-center technique. We will give clear
examples in several programming languages. We will also check the space
complexity of each method. Plus, we will discuss common mistakes and
good practices in dynamic programming. At the end, we will answer some
frequently asked questions about palindromic substrings.</p>
<ul>
<li>Dynamically Counting All Palindromic Substrings Using Dynamic
Programming in Java</li>
<li>Implementing Palindromic Substring Count with Dynamic Programming in
Python</li>
<li>C++ Solution for Counting All Palindromic Substrings Using Dynamic
Programming</li>
<li>Optimized Space Complexity for Palindromic Substrings in Java</li>
<li>Iterative Approach to Count Palindromic Substrings in Python</li>
<li>Expand Around Center Technique for Palindromic Substrings in
C++</li>
<li>Comparative Analysis of Different Approaches to Count Palindromic
Substrings</li>
<li>Common Pitfalls and Best Practices in Dynamic Programming for
Palindromic Substrings</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information on dynamic programming ideas, we think you may
like these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Count
Ways to Climb Stairs</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Longest
Palindromic Subsequence</a>.</p>
<h2
id="implementing-palindromic-substring-count-with-dynamic-programming-in-python">Implementing
Palindromic Substring Count with Dynamic Programming in Python</h2>
<p>We can count all palindromic substrings in a string using dynamic
programming in Python. We will use a 2D table to track these substrings.
Here is how we can do it:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countPalindromicSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a 2D array to store if substring is palindrome</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Single letter palindromes</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for two-letter palindromes</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            dp[i][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for palindromes longer than two letters</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of the substring</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># A substring s[i:j+1] is a palindrome if the ends match and s[i+1:j] is also a palindrome</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j] <span class="kw">and</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>string <span class="op">=</span> <span class="st">&quot;abc&quot;</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countPalindromicSubstrings(string))  <span class="co"># Output: 3 (substrings: &#39;a&#39;, &#39;b&#39;, &#39;c&#39;)</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Initialization</strong>: We start with a 2D list
<code>dp</code> to store if substrings are palindromic.</li>
<li><strong>Single Characters</strong>: Every character is a palindrome
by itself.</li>
<li><strong>Two Characters</strong>: We check if two adjacent characters
are the same.</li>
<li><strong>Longer Substrings</strong>: For substrings longer than two,
we check if the first and last characters are the same. Also we check if
the substring between them is a palindrome.</li>
</ul>
<p>This dynamic programming method runs in O(n^2) time and uses O(n^2)
space. It is good for counting all palindromic substrings in a
string.</p>
<p>For more examples and uses of dynamic programming, we can refer to <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-palindromic-substrings-count-medium.html">Dynamic
Programming: Count All Palindromic Substrings</a>.</p>
<h2
id="c-solution-for-counting-all-palindromic-substrings-using-dynamic-programming">C++
Solution for Counting All Palindromic Substrings Using Dynamic
Programming</h2>
<p>We will count all palindromic substrings in a string using dynamic
programming in C++. We can use a 2D array to track if substrings are
palindromic. The main idea is to fill this table based on what we know
about palindromes:</p>
<ol type="1">
<li>A single character is always a palindrome.</li>
<li>Two same characters next to each other are palindromes.</li>
<li>For substrings longer than two characters, a substring
<code>s[i...j]</code> is a palindrome if the characters at both ends are
the same and the substring <code>s[i+1...j-1]</code> is also a
palindrome.</li>
</ol>
<p>Here is how we can do this in C++:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPalindromicSubstrings<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// All substrings of length 1 are palindromic</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        count<span class="op">++;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check for substrings of length 2</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check for substrings of length 3 or more</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-42"><a href="#cb2-42" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb2-43"><a href="#cb2-43" aria-hidden="true" tabindex="-1"></a>    string str <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb2-44"><a href="#cb2-44" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Total palindromic substrings: &quot;</span> <span class="op">&lt;&lt;</span> countPalindromicSubstrings<span class="op">(</span>str<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb2-45"><a href="#cb2-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-46"><a href="#cb2-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<p>We have a function called <code>countPalindromicSubstrings</code>. It
starts by making a 2D vector <code>dp</code> to track palindromic
substrings.</p>
<p>First, we count all single-character palindromes and update the
count.</p>
<p>Next, we look for two-character palindromes.</p>
<p>Finally, we check substrings of length 3 and more. We update the
<code>dp</code> table and the count of palindromic substrings based on
our rules.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for this algorithm is (O(n^2)). This happens
because we have nested loops to fill the DP table.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity is also (O(n^2)`. We need the 2D array to store
the palindrome status of substrings.</p>
<p>This C++ solution counts all palindromic substrings using dynamic
programming. It is efficient for this problem.</p>
<h2
id="optimized-space-complexity-for-palindromic-substrings-in-java">Optimized
Space Complexity for Palindromic Substrings in Java</h2>
<p>We want to make space use better when we count palindromic substrings
in Java. We can do this by making the size of the dynamic programming
table smaller. Instead of using a big 2D array, we can use a 1D array to
remember the palindromes we find. This works because the state only
needs the previous states.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><strong>Use a 1D Array</strong>: We use one array to track
palindromic substrings instead of a 2D boolean array.</li>
<li><strong>Count Palindromic Substrings</strong>: We start counting
single characters and pairs.</li>
<li><strong>Update Counts</strong>: We use two loops to update counts
based on the values we calculated before.</li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PalindromicSubstrings <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// 1D array to keep track of palindromic substrings</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for substrings of length 1</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Every single character is a palindrome</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for substrings of length 2 and more</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="dt">boolean</span><span class="op">[]</span> newDp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> start <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> start <span class="op">&lt;=</span> n <span class="op">-</span> len<span class="op">;</span> start<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> end <span class="op">=</span> start <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>start<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>end<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>len <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                        newDp<span class="op">[</span>start<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>                        newDp<span class="op">[</span>start<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>start <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>newDp<span class="op">[</span>start<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>                        count<span class="op">++;</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>            dp <span class="op">=</span> newDp<span class="op">;</span> <span class="co">// Move to the next length</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        PalindromicSubstrings solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">PalindromicSubstrings</span><span class="op">();</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> input <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Count of palindromic substrings: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">countSubstrings</span><span class="op">(</span>input<span class="op">));</span> <span class="co">// Output: 3</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li>We use a 1D boolean array <code>dp</code> to keep track if
substrings are palindromic.</li>
<li>The outer loop goes over different lengths of substrings.</li>
<li>The inner loop checks if the first and last characters of the
substring are the same.</li>
<li>If they are the same and the length is 2 or the inner substring
(from <code>start + 1</code> to <code>end - 1</code>) is palindromic, we
count it as a palindromic substring.</li>
</ul>
<p>This way, we make space use go from (O(n^2)) to (O(n)). It is more
efficient and still counts all palindromic substrings. For more learning
about dynamic programming, we can check out related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-palindromic-substrings-count-medium.html">Dynamic
Programming - Palindromic Substrings Count</a>.</p>
<h2
id="iterative-approach-to-count-palindromic-substrings-in-python">Iterative
Approach to Count Palindromic Substrings in Python</h2>
<p>We can use an iterative way to count all palindromic substrings in a
string. This method uses some ideas from dynamic programming. We will
keep a 2D table to see which substrings are palindromic. The steps
are:</p>
<ol type="1">
<li>Create a 2D list <code>dp</code>. Here, <code>dp[i][j]</code> is
<code>True</code> if the substring <code>s[i:j+1]</code> is a
palindrome.</li>
<li>Start by marking all substrings of length 1 as palindromes.</li>
<li>For substrings of length 2, set <code>dp[i][i+1]</code> to
<code>True</code> if both characters are equal.</li>
<li>For longer substrings, we use this rule:
<code>dp[i][j] = (s[i] == s[j]) and dp[i+1][j-1]</code>.</li>
<li>We will count all palindromic substrings while we fill the
<code>dp</code> table.</li>
</ol>
<p>Here is the code in Python:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countPalindromicSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a 2D DP list initialized to False</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Single character substrings are palindromes</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for substrings of length 2</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            dp[i][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for substrings of length 3 and more</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of substring</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j] <span class="kw">and</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;abcba&quot;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> countPalindromicSubstrings(s)</span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Total palindromic substrings in &#39;</span><span class="sc">{</span>s<span class="sc">}</span><span class="ss">&#39; is: </span><span class="sc">{</span>result<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>This code counts all palindromic substrings in the string
<code>s</code>. The time it takes is (O(n^2)) because of the nested
loops. The space needed is also (O(n^2)) for the DP table. This method
works well for strings that are not too long and counts all unique
palindromic substrings.</p>
<h2
id="expand-around-center-technique-for-palindromic-substrings-in-c">Expand
Around Center Technique for Palindromic Substrings in C++</h2>
<p>The Expand Around Center technique is a good way to count all
palindromic substrings in a string. This method uses each character and
each pair of characters as a center of a palindrome. Then, it expands
outwards to check if it is a palindrome.</p>
<h3 id="key-properties">Key Properties:</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2), where n is the length of
the string.</li>
<li><strong>Space Complexity</strong>: O(1) because we use only a few
variables to count.</li>
</ul>
<h3 id="implementation-steps">Implementation Steps:</h3>
<ol type="1">
<li>We loop through each character in the string.</li>
<li>For each character, we expand around it to find odd-length
palindromes.</li>
<li>For each pair of characters, we expand around them to find
even-length palindromes.</li>
<li>We count the total number of palindromic substrings that we find
during expansion.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countSubstrings<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> center <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> center <span class="op">&lt;</span> n<span class="op">;</span> center<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Count odd-length palindromes</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> expandAroundCenter<span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center<span class="op">);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Count even-length palindromes</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> expandAroundCenter<span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expandAroundCenter<span class="op">(</span>string<span class="op">&amp;</span> s<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> right <span class="op">&lt;</span> s<span class="op">.</span>length<span class="op">()</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>left<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>right<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            left<span class="op">--;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>            right<span class="op">++;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    Solution sol<span class="op">;</span></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    string s <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Total palindromic substrings: &quot;</span> <span class="op">&lt;&lt;</span> sol<span class="op">.</span>countSubstrings<span class="op">(</span>s<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// Output: 3</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The <code>countSubstrings</code> function looks at each character in
the string and treats it as a center.</li>
<li>The <code>expandAroundCenter</code> function checks for palindromes
by expanding out from the center. It goes until the characters on the
left and right do not match anymore.</li>
<li>The total count of palindromic substrings is returned.</li>
</ul>
<p>This technique works well for counting palindromic substrings without
needing extra data structures. It is also a space-efficient solution. If
we want to learn more advanced ways, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-palindromic-substrings-count-medium.html">Dynamic
Programming Count Palindromic Substrings</a>.</p>
<h2
id="comparative-analysis-of-different-approaches-to-count-palindromic-substrings">Comparative
Analysis of Different Approaches to Count Palindromic Substrings</h2>
<p>We can count palindromic substrings in different ways. Each way has
its own pros and cons. These include time complexity, space complexity,
and how easy it is to implement. Here, we will look at three main
methods: Dynamic Programming, Expand Around Center, and Iterative
methods.</p>
<h3 id="dynamic-programming">1. Dynamic Programming</h3>
<p><strong>Time Complexity:</strong> O(n^2)<br />
<strong>Space Complexity:</strong> O(n^2)</p>
<p>In this method, we create a 2D table. We say <code>dp[i][j]</code> is
true if the substring from index <code>i</code> to <code>j</code> is a
palindrome. We fill this table in a bottom-up way.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">-</span> i <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="expand-around-center">2. Expand Around Center</h3>
<p><strong>Time Complexity:</strong> O(n^2)<br />
<strong>Space Complexity:</strong> O(1)</p>
<p>This method checks each possible center for a palindrome and expands
out. Each character and each pair of characters can be a center.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> center <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> center <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> left <span class="op">+</span> center <span class="op">%</span> <span class="dv">2</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> right <span class="op">&lt;</span> n <span class="kw">and</span> s[left] <span class="op">==</span> s[right]:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h3 id="iterative-approach">3. Iterative Approach</h3>
<p><strong>Time Complexity:</strong> O(n^2)<br />
<strong>Space Complexity:</strong> O(1)</p>
<p>This approach uses one loop to check for palindromic substrings. It
finds the start and end points while checking if they are equal.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countSubstrings<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Odd length palindromes</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">+</span> j <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> s<span class="op">[</span>i <span class="op">-</span> j<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>i <span class="op">+</span> j<span class="op">];</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Even length palindromes</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">-</span> j <span class="op">+</span> <span class="dv">1</span> <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">+</span> j <span class="op">&lt;</span> n <span class="op">&amp;&amp;</span> s<span class="op">[</span>i <span class="op">-</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>i <span class="op">+</span> j<span class="op">];</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<ul>
<li><strong>Dynamic Programming</strong> helps us understand the links
between substrings but it needs more space.</li>
<li><strong>Expand Around Center</strong> is best for space and is easy
to use with low space needs.</li>
<li><strong>Iterative Approach</strong> is simple and clear. It counts
palindromic substrings without needing more space.</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check out
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a>.</p>
<h2
id="common-pitfalls-and-best-practices-in-dynamic-programming-for-palindromic-substrings">Common
Pitfalls and Best Practices in Dynamic Programming for Palindromic
Substrings</h2>
<p>When we try to use dynamic programming for counting palindromic
substrings, we can run into some common mistakes. If we understand these
mistakes and follow some good practices, we can write code that works
better and has fewer errors.</p>
<h3 id="common-pitfalls">Common Pitfalls</h3>
<ol type="1">
<li><strong>Improper Initialization</strong>:
<ul>
<li>We need to make sure that the DP table starts correctly. For
counting palindromic substrings, single-character substrings are always
palindromes.</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// single character</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Not Considering Edge Cases</strong>:
<ul>
<li>We should handle cases with strings of length 0 or 1. These cases
are easy because they are always palindromic.</li>
</ul></li>
<li><strong>Incorrect State Transition</strong>:
<ul>
<li>We must define the state transition correctly. For palindromes, if
<code>s[i] == s[j]</code>, then <code>dp[i][j] = dp[i + 1][j - 1]</code>
if <code>j - i &gt; 1</code>.</li>
</ul></li>
<li><strong>Forgetting to Count Substrings</strong>:
<ul>
<li>Sometimes, we forget to count palindromic substrings. We need to
remember to add to our count every time we find a palindrome.</li>
</ul></li>
<li><strong>Space Complexity Issues</strong>:
<ul>
<li>We need to pay attention to space complexity when using a DP table.
If we dont handle it well, it can use too much memory.</li>
</ul></li>
</ol>
<h3 id="best-practices">Best Practices</h3>
<ol type="1">
<li><strong>Use Memoization</strong>:
<ul>
<li>If our approach creates overlapping subproblems, we should use
memoization to save results of states we already calculated.</li>
</ul></li>
<li><strong>Iterative vs Recursive</strong>:
<ul>
<li>We should prefer iterative methods because they help us avoid stack
overflow problems that can happen with deep recursion in longer
strings.</li>
</ul></li>
<li><strong>Expand Around Center</strong>:
<ul>
<li>We can use the expand around center method for a solution that uses
less space. This method counts palindromes by expanding around each
character and each pair of characters.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countPalindromicSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> expandAroundCenter(s, i, i)   <span class="co"># Odd length</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> expandAroundCenter(s, i, i<span class="op">+</span><span class="dv">1</span>) <span class="co"># Even length</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expandAroundCenter(s: <span class="bu">str</span>, left: <span class="bu">int</span>, right: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> right <span class="op">&lt;</span> <span class="bu">len</span>(s) <span class="kw">and</span> s[left] <span class="op">==</span> s[right]:</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div></li>
<li><strong>Use a 1D Array for Space Optimization</strong>:
<ul>
<li>If we only need results from the last row of the DP table, we can
use a 1D array instead of a 2D array to save space.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">];</span> <span class="co">// for storing palindromic state for each character</span></span></code></pre></div></li>
<li><strong>Profile and Optimize</strong>:
<ul>
<li>We should profile our solution to find slow parts. We can optimize
the time complexity by cutting down on unnecessary calculations or
loops.</li>
</ul></li>
<li><strong>Testing on Edge Cases</strong>:
<ul>
<li>We must test our code with different string lengths. This includes
edge cases like empty strings, strings with all the same characters, and
strings with no palindromes.</li>
</ul></li>
</ol>
<p>By following these best practices and avoiding common mistakes, we
can build a strong and efficient dynamic programming solution for
counting palindromic substrings. If we want to learn more about dynamic
programming techniques, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a> for more understanding and
examples.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-for-counting-palindromic-substrings">1.
What is the Dynamic Programming approach for counting palindromic
substrings?</h3>
<p>We use the Dynamic Programming approach to count palindromic
substrings by making a 2D table. Each entry <code>dp[i][j]</code> shows
if the substring from index <code>i</code> to <code>j</code> is a
palindrome. First, we treat all single-character substrings as
palindromes. Then, we check larger substrings using results we already
have to see if they are palindromes.</p>
<h3
id="how-does-the-expand-around-center-technique-work-for-palindromic-substrings">2.
How does the Expand Around Center technique work for palindromic
substrings?</h3>
<p>The Expand Around Center technique finds palindromic substrings by
looking at each character and each pair of neighboring characters as
possible centers. For each center, we expand outwards while the
characters on both sides are the same. We count all valid palindromic
substrings while doing this. This method is fast, working in O(n^2) time
and using O(1) space.</p>
<h3
id="why-is-space-optimization-important-in-counting-palindromic-substrings">3.
Why is space optimization important in counting palindromic
substrings?</h3>
<p>Space optimization is very important when counting palindromic
substrings. It helps to lower memory use, especially for big strings. By
using a rolling array or changing the space from O(n^2) to O(n), we can
make our program run better without losing accuracy. Such optimizations
matter a lot for real-world applications where we have limited
resources.</p>
<h3
id="can-dynamic-programming-be-applied-to-find-the-longest-palindromic-substring">4.
Can Dynamic Programming be applied to find the longest palindromic
substring?</h3>
<p>Yes, we can use Dynamic Programming to find the longest palindromic
substring. We keep a table to check if substrings are palindromes. This
helps us track the longest palindrome we find. This method is similar to
counting palindromic substrings but focuses on finding the maximum
length.</p>
<h3
id="what-are-common-pitfalls-when-implementing-dynamic-programming-for-palindromic-substrings">5.
What are common pitfalls when implementing Dynamic Programming for
palindromic substrings?</h3>
<p>Common mistakes in using Dynamic Programming for palindromic
substrings include not setting up the DP table correctly, missing edge
cases like empty strings, and not handling overlapping subproblems well.
It is very important to set accurate base cases and know how the
subproblems relate to each other to count palindromic substrings
successfully.</p>
<p>For more reading on related dynamic programming ideas, we can check
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Numbers</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>. These topics will help us
understand dynamic programming techniques that we can use in similar
situations.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            