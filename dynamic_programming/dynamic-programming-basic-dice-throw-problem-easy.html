
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Basic Dice Throw Problem - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Explore the Basic Dice Throw Problem using dynamic programming. Learn easy techniques to solve this classic challenge!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Basic Dice Throw Problem - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Basic Dice Throw Problem is a famous challenge in dynamic
programming. We want to find out how many ways we can reach a certain
score using a normal six-sided die. To solve this, we need to count all
the combinations of die rolls that can give us the target score. This
problem shows us how dynamic programming can make hard problems easier.
We can do this by saving results of calculations so we do not have to do
them again.</p>
<p>In this article, we will look at different parts of the Basic Dice
Throw Problem using dynamic programming. We will start by explaining the
problem clearly. Then, we will show a recursive solution. After that, we
will give dynamic programming examples in Java, Python, and C++. We will
also talk about how to make space usage better, an iterative method, and
compare different ways to solve the problem. At the end, we will answer
some common questions to help you understand better.</p>
<ul>
<li>Dynamic Programming Approaches to Basic Dice Throw Problem -
Easy</li>
<li>Understanding the Problem Statement</li>
<li>Recursive Solution for Basic Dice Throw Problem</li>
<li>Dynamic Programming Solution in Java</li>
<li>Dynamic Programming Solution in Python</li>
<li>Dynamic Programming Solution in C++</li>
<li>Optimizing Space Complexity in Dice Throw Problem</li>
<li>Iterative Approach to Basic Dice Throw Problem</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, you can check
out other articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>. These articles have more examples that
can help you understand dynamic programming better.</p>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>The Basic Dice Throw Problem is about finding how many ways we can
reach a target sum ( N ) using a six-sided dice. Each dice can show a
number from 1 to 6. Our goal is to find out how many unique combinations
of dice throws can give us the target sum.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have: - A target sum ( N ) - A dice with numbers from 1 to 6</p>
<p>We need to find the total number of different ways to throw the dice
so that the results add up to ( N ).</p>
<h3 id="example">Example</h3>
<ol type="1">
<li>If ( N = 3 ):
<ul>
<li>Possible combinations:
<ul>
<li>(1, 1, 1)</li>
<li>(1, 2)</li>
<li>(2, 1)</li>
<li><ol start="3" type="1">
<li></li>
</ol></li>
</ul></li>
<li>Output: 4</li>
</ul></li>
<li>If ( N = 4 ):
<ul>
<li>Possible combinations:
<ul>
<li>(1, 1, 1, 1)</li>
<li>(1, 1, 2)</li>
<li>(1, 2, 1)</li>
<li>(2, 1, 1)</li>
<li>(1, 3)</li>
<li>(3, 1)</li>
<li>(2, 2)</li>
<li><ol start="4" type="1">
<li></li>
</ol></li>
</ul></li>
<li>Output: 8</li>
</ul></li>
</ol>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The value of ( N ) must be a non-negative integer.</li>
<li>The number of ways can be very big. So we usually return the result
modulo ( 10^9 + 7 ).</li>
</ul>
<p>We can solve this problem using many methods. We can use recursion,
dynamic programming, or iterative techniques. We will talk about these
methods in the next sections.</p>
<h2 id="recursive-solution-for-basic-dice-throw-problem">Recursive
Solution for Basic Dice Throw Problem</h2>
<p>We can solve the Basic Dice Throw Problem with a recursive method.
The goal is to find out how many ways we can reach a target score
<code>n</code> by rolling a dice that shows numbers from 1 to 6. Each
time we call the function, we decide to roll the dice and add its number
to our current score.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a target score <code>n</code>. We need to find the total ways
to reach that score using a regular six-faced die.</p>
<h3 id="recursive-formula">Recursive Formula</h3>
<p>We can define the recursive function like this: - If
<code>n == 0</code>, we return <code>1</code>. This is one way to reach
score 0, by not rolling the dice. - If <code>n &lt; 0</code>, we return
<code>0</code>. There is no way to get a negative score. - For
<code>n &gt; 0</code>, we add up the results of the calls for
<code>n-1</code>, <code>n-2</code>, <code>n-3</code>, <code>n-4</code>,
<code>n-5</code>, and <code>n-6</code>.</p>
<h3 id="recursive-function-implementation">Recursive Function
Implementation</h3>
<p>We can write this in Python like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base cases</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursive calls</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    total_ways <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):  <span class="co"># Dice values from 1 to 6</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        total_ways <span class="op">+=</span> countWays(n <span class="op">-</span> i)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_ways</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Target score</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to reach score&quot;</span>, n, <span class="st">&quot;is&quot;</span>, countWays(n))</span></code></pre></div>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity of this recursive method is exponential. It is
(O(6^n)) because each call can create up to 6 more calls.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity is (O(n)) because we use a stack for the
recursion.</p>
<p>This recursive method helps us understand the problem. Later, we can
make it better using things like memoization or dynamic programming. If
we want to find more advanced solutions, we can look at dynamic
programming in Java or C++.</p>
<h2 id="dynamic-programming-solution-in-java">Dynamic Programming
Solution in Java</h2>
<p>We can solve the Basic Dice Throw Problem using a dynamic programming
method in Java. The problem is about finding how many ways we can reach
a target sum (N) by throwing dice. Each die can show a number from 1 to
6.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is the Java code for the dynamic programming solution for the
Basic Dice Throw Problem:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DiceThrow <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: one way to reach sum 0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">6</span> <span class="op">&amp;&amp;</span> j <span class="op">&lt;=</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> j<span class="op">];</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> N <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Example target sum</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to reach sum &quot;</span> <span class="op">+</span> N <span class="op">+</span> <span class="st">&quot;: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>N<span class="op">));</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Dynamic Array</strong>: We use an array called
<code>dp</code> to save the number of ways to reach each sum from
<code>0</code> to <code>N</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to
<code>1</code>. This means there is one way to get a sum of
<code>0</code> (by not rolling any dice).</li>
<li><strong>Nested Loops</strong>: The first loop goes through sums from
<code>1</code> to <code>N</code>. The second loop checks possible dice
values from <code>1</code> to <code>6</code>.</li>
<li><strong>State Transition</strong>: We update the number of ways to
reach the current sum <code>i</code>. We add the ways to reach the sums
<code>i-1</code>, <code>i-2</code>, <code>i-3</code>, <code>i-4</code>,
<code>i-5</code>, and <code>i-6</code>.</li>
</ul>
<p>This way is quick. It has a time complexity of O(N) and space
complexity of O(N). This makes it good for solving the Basic Dice Throw
Problem.</p>
<h2 id="dynamic-programming-solution-in-python">Dynamic Programming
Solution in Python</h2>
<p>To solve the Basic Dice Throw Problem using dynamic programming in
Python, we want to count how many ways we can reach a certain total by
rolling a dice. The problem asks us to find how many ways we can get a
sum <code>n</code> using dice rolls from <code>1</code> to
<code>6</code>.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is a simple Python code that uses dynamic programming:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(n, m<span class="op">=</span><span class="dv">6</span>):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a table to store results of subproblems</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: There is one way to achieve a total of 0 (no dice thrown)</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp array</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> j]</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span>  <span class="co"># Total sum to achieve</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to roll a total of&quot;</span>, n, <span class="st">&quot;is&quot;</span>, countWays(n))</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We make a list <code>dp</code> that
is the size of <code>n + 1</code>. This list will keep track of how many
ways we can reach each sum from <code>0</code> to <code>n</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to
<code>1</code>. This is because there is one way to have a sum of
<code>0</code> by not rolling any dice.</li>
<li><strong>Dynamic Programming Filling</strong>: For each total from
<code>1</code> to <code>n</code>, we look at all possible dice values
from <code>1</code> to <code>6</code>. If the current total minus the
dice value is not negative, we add the number of ways to reach that
previous total to our current total.</li>
<li><strong>Result</strong>: We store the final result in
<code>dp[n]</code>. This tells us the total number of ways to get the
sum <code>n</code>.</li>
</ul>
<p>This dynamic programming method helps us find the number of ways to
reach the desired total. It is more efficient than using a recursive
method because it does not repeat calculations.</p>
<p>For more dynamic programming problems, we can check out articles on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="dynamic-programming-solution-in-c">Dynamic Programming Solution
in C++</h2>
<p>We can solve the Basic Dice Throw Problem using dynamic programming
in C++. This problem is about finding how many ways we can reach a
target score using dice rolls. Each die can show a number from 1 to 6.
Our goal is to find out how many different ways we can get a score of
<code>n</code> by throwing the dice.</p>
<p>Here is the C++ code for the dynamic programming solution:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a DP array to store the number of ways to reach each score</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span>  <span class="co">// Base case: One way to reach score 0</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Build the DP table</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">6</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> j<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter the score to reach: &quot;</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; is: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We make a DP array <code>dp</code>
of size <code>n + 1</code>. Each <code>dp[i]</code> will have the number
of ways to get the score <code>i</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to 1. This
show there is one way to reach score 0. This means no dice thrown.</li>
<li><strong>Filling the DP Table</strong>: We use two loops. The first
loop goes through each target score. The second loop goes through the
dice values from 1 to 6. If the score after throwing a dice value is not
negative, we add the number of ways to reach that score to the current
scoreâ€™s total.</li>
<li><strong>Output</strong>: The function gives back the number of ways
to reach the target score <code>n</code>.</li>
</ul>
<p>This dynamic programming method works in O(n) time. It is good for
larger values of <code>n</code>. If we want to learn more about similar
problems and dynamic programming methods, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="optimizing-space-complexity-in-dice-throw-problem">Optimizing
Space Complexity in Dice Throw Problem</h2>
<p>In the Basic Dice Throw Problem, we use dynamic programming to find
how many ways we can reach a target score with dice throws. The usual
method uses a 2D array to store results. But we can make it use less
space. Let us see how to do this.</p>
<p>Instead of using a full 2D array, we see that to find the number of
ways to reach a score ( n ) with ( k ) dice throws, we only need results
from the last throw. This lets us cut down the space needed from ( O(n
k) ) to ( O(n) ).</p>
<h3 id="optimized-code-in-java">Optimized Code in Java</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DiceThrow <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: One way to make a score of 0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span> <span class="co">// Number of dice throws</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span> <span class="co">// Update dp array</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;=</span> <span class="dv">6</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span> <span class="co">// Faces of the dice</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>j <span class="op">-</span> k <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> k<span class="op">];</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of dice</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// Target score</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; with &quot;</span> <span class="op">+</span> m <span class="op">+</span> <span class="st">&quot; dice: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>m<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="optimized-code-in-python">Optimized Code in Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(m, n):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case: One way to make a score of 0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># Number of dice throws</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n, i <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):  <span class="co"># Update dp array</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):  <span class="co"># Faces of the dice</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">-</span> k <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>                    dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> k]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of dice</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">8</span>  <span class="co"># Target score</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Number of ways to reach score </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> with </span><span class="sc">{</span>m<span class="sc">}</span><span class="ss"> dice: </span><span class="sc">{</span>count_ways(m, n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="optimized-code-in-c">Optimized Code in C++</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: One way to make a score of 0</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> k <span class="op">&lt;=</span> <span class="dv">6</span><span class="op">;</span> k<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">-</span> k <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> k<span class="op">];</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of dice</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">8</span><span class="op">;</span> <span class="co">// Target score</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; with &quot;</span> <span class="op">&lt;&lt;</span> m <span class="op">&lt;&lt;</span> <span class="st">&quot; dice: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>m<span class="op">,</span> n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This way to save space works good and still keeps the speed. We show
how to do this in Java, Python, and C++. If you want to learn more about
dynamic programming, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="iterative-approach-to-basic-dice-throw-problem">Iterative
Approach to Basic Dice Throw Problem</h2>
<p>The iterative approach helps us solve the Basic Dice Throw Problem.
It uses dynamic programming ideas to find the number of ways to reach a
target sum with dice rolls. This method does not use recursion or
memoization. Instead, it fills a table based on values we already
know.</p>
<h3 id="problem-statement-recap">Problem Statement Recap</h3>
<p>We have some dice ( m ) and a target sum ( n ). Our goal is to find
how many different ways we can roll the dice so that the total equals (
n ). Each die shows a number from ( 1 ) to ( 6 ).</p>
<h3 id="iterative-dynamic-programming-solution">Iterative Dynamic
Programming Solution</h3>
<ol type="1">
<li>We create an array <code>dp</code> with size ( n + 1 ). The value
<code>dp[i]</code> shows how many ways we can reach the sum ( i ).</li>
<li>We set <code>dp[0] = 1</code>. There is one way to get a total of
zero (by not rolling any dice).</li>
<li>We loop through each die and update the <code>dp</code> array for
each possible sum.</li>
</ol>
<h3 id="code-implementation-1">Code Implementation</h3>
<p>Here is how we can write the iterative solution in Python:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(m, n):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a dp array initialized to 0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Loop for all dice</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Temporary array to hold the new counts</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        new_dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> sum_value <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate ways to achieve the current sum_value</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> face <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> sum_value <span class="op">-</span> face <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                    new_dp[sum_value] <span class="op">+=</span> dp[sum_value <span class="op">-</span> face]</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update dp for the next die</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> new_dp</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<p>If we want to find the number of ways to get a sum of ( 7 ) with ( 3
) dice:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>m <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of dice</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">7</span>  <span class="co"># Target sum</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to achieve sum&quot;</span>, n, <span class="st">&quot;with&quot;</span>, m, <span class="st">&quot;dice is:&quot;</span>, countWays(m, n))</span></code></pre></div>
<h3 id="time-complexity-1">Time Complexity</h3>
<p>The time complexity is ( O(m n) ). Here, ( m ) is the number of dice
and ( n ) is the target sum.</p>
<h3 id="space-complexity-1">Space Complexity</h3>
<p>The space complexity is ( O(n) ). This is due to the space used by
the <code>dp</code> array.</p>
<p>This iterative way is clear and works well. It is a good method to
solve the Basic Dice Throw Problem with dynamic programming. If you want
to learn more related topics, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a> article.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we solve the Basic Dice Throw Problem using dynamic programming,
we can use different methods. Each method has its own pros and cons.
Here is a simple comparison of recursive, dynamic programming, and
iterative methods.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: Exponential (O(6^n)) because it
does the same calculations many times.</li>
<li><strong>Space Complexity</strong>: (O(n)) because of the recursion
stack.</li>
<li><strong>Pros</strong>: It is easy to understand and use.</li>
<li><strong>Cons</strong>: It is not good for larger numbers because it
has overlapping problems.</li>
</ul>
<h3 id="dynamic-programming-memoization">Dynamic Programming
(Memoization)</h3>
<ul>
<li><strong>Time Complexity</strong>: Linear (O(n )) since we compute
each state only once.</li>
<li><strong>Space Complexity</strong>: (O(n)) because we need space for
a memoization table.</li>
<li><strong>Pros</strong>: It saves time by keeping track of results we
already found.</li>
<li><strong>Cons</strong>: It needs extra space for the memoization
table.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dice_throw_memoization(n, memo):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> memo[n] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    total_ways <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">7</span>):</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">-</span> i <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            total_ways <span class="op">+=</span> dice_throw_memoization(n <span class="op">-</span> i, memo)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> total_ways</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_ways</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>memo <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(dice_throw_memoization(n, memo))</span></code></pre></div>
<h3 id="dynamic-programming-tabulation">Dynamic Programming
(Tabulation)</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(n )), like memoization but we
fill the table in a loop.</li>
<li><strong>Space Complexity</strong>: (O(n)) for the DP array.</li>
<li><strong>Pros</strong>: It avoids the overhead of recursion. It can
handle larger <code>n</code> better.</li>
<li><strong>Cons</strong>: It still needs linear space.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">diceThrowDP</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">6</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> j<span class="op">];</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="iterative-approach">Iterative Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(n)) because it uses only the
last 6 results.</li>
<li><strong>Space Complexity</strong>: (O(1)) since it keeps only the
last 6 results.</li>
<li><strong>Pros</strong>: It is the best in space and time.</li>
<li><strong>Cons</strong>: It is a bit harder to implement.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> diceThrowIterative<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span><span class="dv">7</span><span class="op">]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">0</span><span class="op">};</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total_ways <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">6</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>                total_ways <span class="op">+=</span> dp<span class="op">[(</span>i <span class="op">-</span> j<span class="op">)</span> <span class="op">%</span> <span class="dv">7</span><span class="op">];</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i <span class="op">%</span> <span class="dv">7</span><span class="op">]</span> <span class="op">=</span> total_ways<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">%</span> <span class="dv">7</span><span class="op">];</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-comparisons">Summary of Comparisons</h3>
<ul>
<li><strong>Efficiency</strong>: The iterative approach is best in both
time and space.</li>
<li><strong>Simplicity</strong>: The recursive approach is the easiest
to understand but not good for big inputs.</li>
<li><strong>Optimal Use</strong>: For medium inputs, the dynamic
programming approach (memoization or tabulation) is a good mix of
efficiency and ease.</li>
</ul>
<p>This comparison shows different ways to solve the Basic Dice Throw
Problem. We can make choices based on our needs. For more on dynamic
programming, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-basic-dice-throw-problem-in-dynamic-programming">What is
the Basic Dice Throw Problem in Dynamic Programming?</h3>
<p>The Basic Dice Throw Problem is a well-known problem in dynamic
programming. Here, we want to find how many ways we can reach a target
score using a dice that has a certain number of faces. The main
challenge is to calculate these ways without repeating calculations.
Dynamic programming helps us do this well. For more examples, you can
read our article on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h3
id="how-can-i-solve-the-basic-dice-throw-problem-using-recursion">How
can I solve the Basic Dice Throw Problem using recursion?</h3>
<p>To solve the Basic Dice Throw Problem with recursion, we need to
create a recursive function. This function will explore all possible
outcomes by simulating dice rolls. It will call itself for each face of
the dice and add the results until we reach the target score. This
simple way can take a lot of time though. To make recursive solutions
faster, we can use memoization. You can read more about this in our
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming Fibonacci with Memoization</a>.</p>
<h3
id="what-is-the-dynamic-programming-solution-for-the-basic-dice-throw-problem-in-java">What
is the dynamic programming solution for the Basic Dice Throw Problem in
Java?</h3>
<p>The dynamic programming solution for the Basic Dice Throw Problem in
Java uses a DP array. Each index in this array shows the number of ways
to reach that score. We fill this array by adding ways from previous
scores based on current dice rolls. This method makes the performance
much better. It cuts the time complexity to O(n * m). Here, n is the
target score and m is the number of dice faces. For more about dynamic
programming in Java, check our article on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h3
id="how-can-i-optimize-space-complexity-in-the-basic-dice-throw-problem">How
can I optimize space complexity in the Basic Dice Throw Problem?</h3>
<p>To make space usage better in the Basic Dice Throw Problem, we can
use a rolling array technique. This means we only keep track of the last
m scores instead of the whole DP array. This way, we reduce space from
O(n) to O(m). It makes our solution better without losing performance.
For more tips on space optimization, look at our article on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Minimum Cost Climbing Stairs</a>.</p>
<h3
id="what-iterative-approach-can-i-take-for-the-basic-dice-throw-problem">What
iterative approach can I take for the Basic Dice Throw Problem?</h3>
<p>The iterative approach for the Basic Dice Throw Problem fills a DP
array from the bottom up. We start with the base case and then compute
how many ways we can reach each score by considering all valid dice
rolls. This method is efficient and easy to use. It works much better
than the recursive method. For a similar approach, check our article on
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming Unique Paths in a Grid</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            