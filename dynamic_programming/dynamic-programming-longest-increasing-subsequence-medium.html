
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Increasing Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Longest Increasing Subsequence problem using Dynamic Programming. Boost your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Increasing Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Increasing Subsequence (LIS) problem is a well-known
challenge in dynamic programming. It looks for the longest subsequence
in a list of numbers where each number is bigger than the one before it.
To find the best solution, we build a dynamic programming array. This
array keeps track of the longest increasing subsequence at every
position. This way, we can find the answer in O(n^2) time or even O(n
log n) with better methods.</p>
<p>In this article, we will look closely at the Longest Increasing
Subsequence problem. We will explore different ways to solve it, like
dynamic programming and binary search methods. We will show code
examples in Java, Python, and C++. We will also talk about how to make
space usage better. Plus, we will point out common mistakes to avoid and
answer questions we often hear about LIS.</p>
<ul>
<li>[Dynamic Programming] Longest Increasing Subsequence Problem
Explained</li>
<li>Understanding the Dynamic Programming Approach</li>
<li>Implementing Longest Increasing Subsequence in Java</li>
<li>Implementing Longest Increasing Subsequence in Python</li>
<li>Implementing Longest Increasing Subsequence in C++</li>
<li>Optimizing Space Complexity for Longest Increasing Subsequence</li>
<li>Binary Search Approach to Longest Increasing Subsequence</li>
<li>Comparison of Different Approaches for Longest Increasing
Subsequence</li>
<li>Common Mistakes to Avoid in Longest Increasing Subsequence</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming techniques, we can
check out related articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="understanding-the-dynamic-programming-approach">Understanding
the Dynamic Programming Approach</h2>
<p>Dynamic programming is a strong method we can use to solve
optimization problems. It helps us break problems into simpler parts.
This approach works well for problems that have overlapping subproblems
and optimal substructure.</p>
<h3 id="key-concepts">Key Concepts</h3>
<ol type="1">
<li><p><strong>Overlapping Subproblems</strong>: We can divide the
problem into smaller subproblems that we can use again. For example, in
the Longest Increasing Subsequence (LIS) problem, we can reuse solutions
for smaller subsequences.</p></li>
<li><p><strong>Optimal Substructure</strong>: The best solution for the
problem comes from the best solutions of its smaller parts. In LIS, we
can create the longest subsequence by looking at the longest
subsequences of elements before it.</p></li>
</ol>
<h3 id="steps-in-dynamic-programming">Steps in Dynamic Programming</h3>
<ol type="1">
<li><p><strong>Define the State</strong>: We need to know what defines
the solution. For LIS, we can use an array <code>dp</code> where
<code>dp[i]</code> shows the length of the longest increasing
subsequence that ends with the element at index <code>i</code>.</p></li>
<li><p><strong>State Transition</strong>: We need a formula to calculate
the state. For LIS:</p>
<p>[ dp[i] = (dp[j] + 1) j &lt; i arr[j] &lt; arr[i] ]</p></li>
<li><p><strong>Base Case</strong>: We start with base cases. For LIS,
every element is a subsequence of length 1:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Compute the Result</strong>: We go through the states to
fill the <code>dp</code> array and find the answer. The result is the
biggest value in the <code>dp</code> array.</p></li>
</ol>
<h3 id="example">Example</h3>
<p>Letâ€™s look at the array
<code>arr = [10, 22, 9, 33, 21, 50, 41, 60, 80]</code>. We compute the
<code>dp</code> array like this:</p>
<ul>
<li>Start with <code>dp</code> as
<code>[1, 1, 1, 1, 1, 1, 1, 1, 1]</code>.</li>
<li>Then we update <code>dp</code> by using the state transition
rule.</li>
</ul>
<p>The final <code>dp</code> array can be
<code>[1, 2, 1, 3, 2, 4, 3, 5, 6]</code>. This means the longest
increasing subsequence has a length of 6.</p>
<p>Dynamic programming helps us lower the time complexity from
exponential to polynomial. This makes it easier for bigger inputs. For
more about dynamic programming, we can check out topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>
<h2
id="implementing-longest-increasing-subsequence-in-java">Implementing
Longest Increasing Subsequence in Java</h2>
<p>We can solve the Longest Increasing Subsequence (LIS) problem in Java
using a simple method called dynamic programming. We keep an array
<code>dp</code>. The element <code>dp[i]</code> shows the length of the
longest increasing subsequence that ends with the item at index
<code>i</code>.</p>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestIncreasingSubsequence <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lengthOfLIS</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// Each item is an increasing subsequence of length 1</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// The longest increasing subsequence length is the max value in dp</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">:</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> length<span class="op">);</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">101</span><span class="op">,</span> <span class="dv">18</span><span class="op">};</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Increasing Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">lengthOfLIS</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Initialization</strong>: We start by setting each item in
<code>dp</code> to 1.</li>
<li><strong>Nested Loop</strong>:
<ul>
<li>The first loop goes through each item.</li>
<li>The second loop looks at all the previous items to check if they can
be part of an increasing subsequence.</li>
</ul></li>
<li><strong>Update</strong>: If <code>nums[i] &gt; nums[j]</code>, we
change <code>dp[i]</code> to be the highest of its current value or
<code>dp[j] + 1</code>.</li>
<li><strong>Result</strong>: In the end, the biggest value in
<code>dp</code> shows the length of the longest increasing
subsequence.</li>
</ul>
<p>This method takes O(n^2) time. It works well for input arrays that
are not too big. If we have larger datasets, we can think about using
binary search to make it faster.</p>
<h2
id="implementing-longest-increasing-subsequence-in-python">Implementing
Longest Increasing Subsequence in Python</h2>
<p>We want to solve the Longest Increasing Subsequence (LIS) problem in
Python. We can use a dynamic programming method. The main idea is to
keep an array <code>dp</code>. Here, <code>dp[i]</code> will store the
length of the longest increasing subsequence that ends with the number
at index <code>i</code>.</p>
<p>Here is how we can do it:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_increasing_subsequence(nums):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n  <span class="co"># Each number is an increasing subsequence of length 1 by itself</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[j]:  <span class="co"># Check if the current number can extend the subsequence</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)  <span class="co"># The length of the longest increasing subsequence</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">101</span>, <span class="dv">18</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_increasing_subsequence(nums))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We create a <code>dp</code> array.
We set it to 1 because each number is an increasing subsequence of at
least length 1.</li>
<li><strong>Nested Loops</strong>: The outer loop goes through each
number. The inner loop checks all previous numbers to update the
<code>dp</code> value.</li>
<li><strong>Condition Check</strong>: If <code>nums[i]</code> is bigger
than <code>nums[j]</code>, it means we can add the number at
<code>i</code> to the increasing subsequence ending at
<code>j</code>.</li>
<li><strong>Final Result</strong>: The biggest value in the
<code>dp</code> array tells us the length of the longest increasing
subsequence.</li>
</ul>
<p>For a faster way, we can make it work in (O(n n)) using binary
search. But the method we showed here is good for understanding dynamic
programming. If you want to learn more about dynamic programming, you
can check out this topic: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>.</p>
<h2 id="implementing-longest-increasing-subsequence-in-c">Implementing
Longest Increasing Subsequence in C++</h2>
<p>To solve the Longest Increasing Subsequence (LIS) problem in C++, we
can use dynamic programming. We keep an array called <code>dp</code>. In
this array, <code>dp[i]</code> tells us the length of the longest
increasing subsequence that ends at the index <code>i</code>. The answer
we want is the biggest number in the <code>dp</code> array.</p>
<p>Here is a simple way to implement the Longest Increasing Subsequence
in C++:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestIncreasingSubsequence<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>nums<span class="op">.</span>size<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// We start the dp array with 1</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>max_element<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">());</span> <span class="co">// We return the biggest length</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">101</span><span class="op">,</span> <span class="dv">18</span><span class="op">};</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Increasing Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> longestIncreasingSubsequence<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-1">Explanation:</h3>
<ul>
<li><strong>Initialization</strong>: We make a <code>dp</code> array
that is the same size as the input array <code>nums</code>. We set all
values to 1. This is because the smallest increasing subsequence for
each element is at least 1, which is the element itself.</li>
<li><strong>Nested Loops</strong>: The first loop goes through each
element. The second loop checks all the previous elements to see if they
can make the increasing subsequence longer.</li>
<li><strong>Condition Check</strong>: If <code>nums[i]</code> is bigger
than <code>nums[j]</code>, we update <code>dp[i]</code>. We set it to
the bigger of its current value or <code>dp[j] + 1</code>.</li>
<li><strong>Result</strong>: The length of the longest increasing
subsequence is the biggest number in the <code>dp</code> array.</li>
</ul>
<p>This method has a time complexity of O(n^2). This is good for
medium-sized inputs. For bigger inputs, we can think about using a
better way that uses binary search. This can lower the time complexity
to O(n log n).</p>
<p>If you want to learn more about dynamic programming, you might like
this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">article
on the Coin Change problem</a>.</p>
<h2
id="optimizing-space-complexity-for-longest-increasing-subsequence">Optimizing
Space Complexity for Longest Increasing Subsequence</h2>
<p>When we use the Longest Increasing Subsequence (LIS) algorithm, the
usual dynamic programming method needs O(n^2) time and O(n) space. But
we can make the space use better and get it down to O(n) with a smarter
way.</p>
<h3 id="space-optimization-techniques">Space Optimization
Techniques</h3>
<ol type="1">
<li><p><strong>Using a Single Array</strong>: We do not need a 2D array
to save the lengths of increasing subsequences. We can just use one
array to track the longest subsequence lengths for each index.</p></li>
<li><p><strong>Binary Search with a Tail Array</strong>: We can cut down
space even more by using a tail array. This array will keep the last
numbers of possible subsequences. It helps us keep the smallest tail
value for each length of increasing subsequence.</p></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>We can use the optimized way with a tail array like this:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LIS <span class="op">{</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lengthOfLIS</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> tail <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> length <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> length<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">while</span> <span class="op">(</span>i <span class="op">&lt;</span> j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> mid <span class="op">=</span> i <span class="op">+</span> <span class="op">(</span>j <span class="op">-</span> i<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>tail<span class="op">[</span>mid<span class="op">]</span> <span class="op">&lt;</span> num<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                    i <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                    j <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>            tail<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> num<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> length<span class="op">)</span> length<span class="op">++;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> length<span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">101</span><span class="op">,</span> <span class="dv">18</span><span class="op">};</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Increasing Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">lengthOfLIS</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>We have a <code>tail</code> array. Here, <code>tail[i]</code> holds
the smallest tail value for all increasing subsequences of length
<code>i + 1</code>.</li>
<li>For every number in the input array, we do a binary search on the
<code>tail</code> array to find its place.</li>
<li>If the number makes the largest subsequence longer, we add it to the
<code>tail</code> array. If it can replace a value, it will keep the
smallest tail for that length.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n log n) because of binary
search.</li>
<li><strong>Space Complexity</strong>: O(n) for the <code>tail</code>
array.</li>
</ul>
<p>By making space use better this way, we can handle bigger inputs
easily while keeping the performance of the Longest Increasing
Subsequence algorithm.</p>
<p>For more about dynamic programming, we can look at other problems
like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2 id="binary-search-approach-to-longest-increasing-subsequence">Binary
Search Approach to Longest Increasing Subsequence</h2>
<p>We can use the Binary Search method to solve the Longest Increasing
Subsequence (LIS) problem. This way, we make it faster. The time needed
is O(n log n). This method uses a dynamic array to remember the smallest
tail for all increasing subsequences we find so far.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><strong>Maintain a List</strong>: We use a list called
<code>tails</code>. Here, <code>tails[i]</code> keeps the smallest tail
of all increasing subsequences with length <code>i + 1</code>.</li>
<li><strong>Binary Search</strong>: For each number in the input array,
we use binary search. This finds the spot in <code>tails</code> where
the current number can either replace a value or add to the list.</li>
<li><strong>Update Tails</strong>: If the number is bigger than all
values in <code>tails</code>, we add it to the end. If it is smaller, we
replace the first number in <code>tails</code> that is bigger or equal
to this number.</li>
</ol>
<h3 id="implementation-1">Implementation</h3>
<p>Here is a simple code example of the Binary Search method for LIS in
Python:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> length_of_lis(nums):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> bisect <span class="im">import</span> bisect_left</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    tails <span class="op">=</span> []</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect_left(tails, num)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(tails):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            tails.append(num)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            tails[pos] <span class="op">=</span> num</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(tails)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">3</span>, <span class="dv">7</span>, <span class="dv">101</span>, <span class="dv">18</span>]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(length_of_lis(nums))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The function <code>length_of_lis</code> takes a list of numbers
<code>nums</code>.</li>
<li>It uses the <code>bisect_left</code> function from the
<code>bisect</code> module to do binary search on the <code>tails</code>
list.</li>
<li>The size of the <code>tails</code> list at the end shows the length
of the Longest Increasing Subsequence.</li>
</ul>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n log n), where n is the size of
the input array.</li>
<li><strong>Space Complexity</strong>: O(n) for the <code>tails</code>
list.</li>
</ul>
<p>This binary search method is very useful for big datasets. It is a
good choice for solving the Longest Increasing Subsequence problem
quickly. For more information on dynamic programming methods, we can
look at other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>
<h2
id="comparison-of-different-approaches-for-longest-increasing-subsequence">Comparison
of Different Approaches for Longest Increasing Subsequence</h2>
<p>We can solve the Longest Increasing Subsequence (LIS) problem in
different ways. Each way has its own time and space costs. Here, we will
look at three common methods: the Naive Approach, Dynamic Programming,
and Binary Search with Dynamic Programming.</p>
<h3 id="naive-approach">1. Naive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
<li><strong>Description</strong>: This way makes all subsequences and
checks which ones are increasing. It is not good for big input
sizes.</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_increasing_subsequence(arr):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lis_ending_at(i):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        max_length <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i]:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>                max_length <span class="op">=</span> <span class="bu">max</span>(max_length, lis_ending_at(j) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_length</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    max_lis <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        max_lis <span class="op">=</span> <span class="bu">max</span>(max_lis, lis_ending_at(i))</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_lis</span></code></pre></div>
<h3 id="dynamic-programming-approach">2. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
<li><strong>Description</strong>: This way uses a DP array. Here,
<code>dp[i]</code> shows the length of the longest increasing
subsequence that ends with <code>arr[i]</code>.</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">longestIncreasingSubsequence</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>dp<span class="op">).</span><span class="fu">max</span><span class="op">().</span><span class="fu">getAsInt</span><span class="op">();</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="binary-search-with-dynamic-programming">3. Binary Search with
Dynamic Programming</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n log n)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
<li><strong>Description</strong>: This better way keeps a temporary
array. This array holds the smallest tail of all increasing subsequences
we found. We use binary search to find where each element goes.</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestIncreasingSubsequence<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> tails<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> <span class="bu">std::</span>lower_bound<span class="op">(</span>tails<span class="op">.</span>begin<span class="op">(),</span> tails<span class="op">.</span>end<span class="op">(),</span> num<span class="op">);</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> tails<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            tails<span class="op">.</span>push_back<span class="op">(</span>num<span class="op">);</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>it <span class="op">=</span> num<span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tails<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<ul>
<li>The <strong>Naive approach</strong> does not work well for larger
datasets because it takes too much time.</li>
<li>The <strong>Dynamic Programming approach</strong> is much better but
still takes a lot of time.</li>
<li>The <strong>Binary Search approach</strong> is the best. It cuts
down the time to O(n log n), so it works good for larger input
sizes.</li>
</ul>
<p>For more on dynamic programming, we can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a>.</p>
<h2
id="common-mistakes-to-avoid-in-longest-increasing-subsequence">Common
Mistakes to Avoid in Longest Increasing Subsequence</h2>
<p>When we work on the Longest Increasing Subsequence (LIS) algorithm,
we can face some common mistakes. These can give us wrong results or
slow solutions. Here are some mistakes we should be careful about:</p>
<ol type="1">
<li><strong>Incorrect Base Case Initialization</strong>:
<ul>
<li>If we do not set the base case for dynamic programming correctly, we
can get wrong lengths for subsequences. We need to make sure that the
first element of the LIS array starts at 1. Every single element is an
increasing subsequence of length 1.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> lis <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>lis<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span></code></pre></div></li>
<li><strong>Neglecting Edge Cases</strong>:
<ul>
<li>We must think about edge cases. These include an empty array or an
array with just one element. Not checking these can cause runtime
errors. So, we should always check the input size before we start.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span></code></pre></div></li>
<li><strong>Improper Nested Loops</strong>:
<ul>
<li>When we use a nested loop to compare elements, we need to compare
the right indices. The outer loop should go through each element. The
inner loop should check all previous elements.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>            lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>lis<span class="op">[</span>i<span class="op">],</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Forgetting to Update the Maximum Length</strong>:
<ul>
<li>After we build the LIS array, we must find the maximum value in the
array. This maximum value shows the length of the longest increasing
subsequence.</li>
</ul>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">:</span> lis<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> length<span class="op">);</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Ignoring Space Complexity</strong>:
<ul>
<li>If space complexity is important, we should not use a full DP array.
We can think about using a temporary array or binary search with a list.
This can help us get O(n log n) complexity.</li>
</ul></li>
<li><strong>Not Utilizing Binary Search</strong>:
<ul>
<li>If we do not use binary search, our solution can be less efficient.
We might end up with O(n^2) instead of O(n log n). We can use libraries
like <code>java.util.Arrays</code> or <code>bisect</code> in Python for
faster searching.</li>
</ul></li>
<li><strong>Improperly Handling Duplicates</strong>:
<ul>
<li>Duplicates can make the LIS logic tricky. We need to handle them
right. The definition of an increasing subsequence does not allow equal
elements.</li>
</ul></li>
<li><strong>Lack of Testing</strong>:
<ul>
<li>If we do not test the algorithm with different input cases, we might
miss errors. We should always run tests with various scenarios to check
our solution.</li>
</ul></li>
</ol>
<p>By avoiding these mistakes in the Longest Increasing Subsequence
problem, we can make our implementation stronger and faster. If we want
to read more on dynamic programming and related algorithms, we can check
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-time-complexity-of-the-longest-increasing-subsequence-algorithm">1.
What is the time complexity of the Longest Increasing Subsequence
algorithm?</h3>
<p>The time complexity of the Longest Increasing Subsequence (LIS)
algorithm can change based on the method we use. The dynamic programming
method usually has a time complexity of O(nÂ²). Here, n is the length of
the input array. But if we use a mix of dynamic programming and binary
search, we can lower the time complexity to O(n log n). This makes it
better for bigger datasets.</p>
<h3
id="how-does-the-dynamic-programming-method-find-the-longest-increasing-subsequence">2.
How does the dynamic programming method find the Longest Increasing
Subsequence?</h3>
<p>The dynamic programming method finds the Longest Increasing
Subsequence by making an array that keeps the length of the LIS at each
index. For every element in the array, it looks at all the elements
before it. Then it updates the LIS length based on the values we
computed before. This way, we consider all possible increasing
subsequences. In the end, we get the maximum length.</p>
<h3
id="can-the-longest-increasing-subsequence-algorithm-handle-duplicates">3.
Can the Longest Increasing Subsequence algorithm handle duplicates?</h3>
<p>Yes, the Longest Increasing Subsequence algorithm can deal with
duplicates. When we find the LIS, we can include duplicate values in the
subsequence as long as they keep the increasing order. But we need to
make sure that we treat each occurrence right. This is especially
important in dynamic programming methods where we compare indices.</p>
<h3
id="what-are-some-common-mistakes-when-implementing-the-longest-increasing-subsequence">4.
What are some common mistakes when implementing the Longest Increasing
Subsequence?</h3>
<p>We can make some common mistakes when we implement the Longest
Increasing Subsequence. One mistake is not starting the dynamic
programming array right. Another mistake is messing up index
comparisons. Also, we should not forget about edge cases like arrays
that have all the same elements or arrays that just have one element.
These can give us wrong results. It is very important to test with
different input cases to avoid these problems.</p>
<h3
id="how-can-i-optimize-space-complexity-in-the-longest-increasing-subsequence-problem">5.
How can I optimize space complexity in the Longest Increasing
Subsequence problem?</h3>
<p>To make space complexity better in the Longest Increasing Subsequence
problem, we can lower the extra space used by the dynamic programming
array from O(n) to O(1). We do this by only keeping the current and
previous states of the LIS lengths instead of keeping a full array.
Also, using binary search to update the LIS length can help us be more
efficient and use less space.</p>
<p>For more insights on dynamic programming techniques, check our
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            