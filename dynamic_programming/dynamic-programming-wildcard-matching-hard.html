
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Wildcard Matching - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover advanced dynamic programming techniques for wildcard matching in our in-depth blog. Master the hard challenges today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Wildcard Matching - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Wildcard matching is a tricky problem in computer science. It helps
us see if a string fits a certain pattern with wildcard characters. The
pattern can have the wildcard character <code>'*'</code>. This character
matches any number of characters, even no characters at all. The
<code>'?'</code> character matches just one character. We can solve the
wildcard matching problem quickly using dynamic programming. This way,
we do not get the slow performance that comes with a simple recursive
method.</p>
<p>In this article, we will look into the details of the wildcard
matching problem with dynamic programming methods. We will give a clear
overview of the problem. We will explain the dynamic programming
approach step by step. We will also show how to implement it in Java,
Python, and C++. We will talk about how to make space usage better. We
will compare different methods. We will look at common edge cases and
answer questions that people often ask about wildcard matching.</p>
<ul>
<li>Dynamic Programming Wildcard Matching Problem Overview</li>
<li>Understanding the Problem Statement</li>
<li>Dynamic Programming Approach Explained</li>
<li>Java Implementation of Wildcard Matching</li>
<li>Python Implementation of Wildcard Matching</li>
<li>C++ Implementation of Wildcard Matching</li>
<li>Optimizing Space Complexity in Wildcard Matching</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Common Edge Cases in Wildcard Matching</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>The Wildcard Matching problem is about checking if a string
<code>s</code> matches a pattern <code>p</code>. The pattern can have
some special characters called wildcards.</p>
<ul>
<li><code>?</code> can match any single character.</li>
<li><code>*</code> can match any group of characters. This includes an
empty group.</li>
</ul>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have two strings: - <code>s</code>: This is the string we want to
match. - <code>p</code>: This is the pattern string that may have
wildcards.</p>
<p>Our task is to create a function that checks if <code>s</code>
matches <code>p</code> based on the wildcard rules.</p>
<h3 id="example-cases">Example Cases</h3>
<ol type="1">
<li><strong>Example 1</strong>:
<ul>
<li>Input: <code>s = "aa"</code>, <code>p = "a"</code></li>
<li>Output: <code>false</code></li>
<li>Explanation: The pattern <code>a</code> does not match the string
<code>aa</code>.</li>
</ul></li>
<li><strong>Example 2</strong>:
<ul>
<li>Input: <code>s = "aa"</code>, <code>p = "*"</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: The pattern <code>*</code> matches any string.</li>
</ul></li>
<li><strong>Example 3</strong>:
<ul>
<li>Input: <code>s = "cb"</code>, <code>p = "?a"</code></li>
<li>Output: <code>false</code></li>
<li>Explanation: The pattern <code>?a</code> needs a character before
<code>a</code>, but <code>cb</code> does not fit.</li>
</ul></li>
<li><strong>Example 4</strong>:
<ul>
<li>Input: <code>s = "adceb"</code>, <code>p = "*a*b"</code></li>
<li>Output: <code>true</code></li>
<li>Explanation: The pattern <code>*a*b</code> can match
<code>adceb</code> by matching <code>dce</code>.</li>
</ul></li>
<li><strong>Example 5</strong>:
<ul>
<li>Input: <code>s = "acdcb"</code>, <code>p = "a*c?b"</code></li>
<li>Output: <code>false</code></li>
<li>Explanation: The pattern <code>a*c?b</code> does not match the input
string <code>acdcb</code>.</li>
</ul></li>
</ol>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The length of <code>s</code> and <code>p</code> can be up to
<code>100</code>.</li>
<li>The allowed characters in <code>s</code> and <code>p</code> are
lowercase English letters.</li>
</ul>
<p>We can solve this problem fast using dynamic programming methods. We
will talk about that in the next sections.</p>
<h2 id="dynamic-programming-approach-explained">Dynamic Programming
Approach Explained</h2>
<p>The Wildcard Matching problem is about checking if a string matches a
pattern with wildcard characters. The wildcards are <code>*</code>,
which can match any group of characters, and <code>?</code>, which can
match just one character. We can solve this problem well using dynamic
programming.</p>
<h3 id="dynamic-programming-table">Dynamic Programming Table</h3>
<ol type="1">
<li><strong>Define the DP Table</strong>:
<ul>
<li>We use <code>dp[i][j]</code>. It is <code>True</code> if the first
<code>i</code> characters of the string match the first <code>j</code>
characters of the pattern. If not, it is <code>False</code>.</li>
</ul></li>
<li><strong>Initialization</strong>:
<ul>
<li>We set <code>dp[0][0] = True</code>. This means an empty string
matches an empty pattern.</li>
<li>If the pattern starts with <code>*</code>, we set
<code>dp[0][j] = dp[0][j-1]</code> if the <code>j-th</code> character is
<code>*</code>. This means <code>*</code> can match an empty
string.</li>
</ul></li>
<li><strong>Filling the Table</strong>:
<ul>
<li>We go through each character of the string and pattern:
<ul>
<li>If characters match or the pattern has a <code>?</code>, we take the
match from <code>dp[i-1][j-1]</code>.</li>
<li>If the pattern has a <code>*</code>, we look at two cases:
<ul>
<li>Treat <code>*</code> as matching no characters:
<code>dp[i][j] = dp[i][j-1]</code>.</li>
<li>Treat <code>*</code> as matching one or more characters:
<code>dp[i][j] = dp[i-1][j]</code>.</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h3 id="transition-formula">Transition Formula</h3>
<ul>
<li><p>If <code>s[i-1] == p[j-1]</code> or
<code>p[j-1] == '?'</code>:</p>
<pre class="plaintext"><code>dp[i][j] = dp[i-1][j-1]</code></pre></li>
<li><p>If <code>p[j-1] == '*'</code>:</p>
<pre class="plaintext"><code>dp[i][j] = dp[i][j-1] || dp[i-1][j]</code></pre></li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). Here, <code>m</code> is
the string length and <code>n</code> is the pattern length.</li>
<li><strong>Space Complexity</strong>: O(m * n) for the DP table.</li>
</ul>
<h3 id="example-code-snippet-java">Example Code Snippet (Java)</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isMatch</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">(),</span> n <span class="op">=</span> p<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">||</span> p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With this dynamic programming method, we can solve the Wildcard
Matching problem quickly. It works well for cases where we need to match
patterns, like in search algorithms or text processing tasks.</p>
<h2 id="java-implementation-of-wildcard-matching">Java Implementation of
Wildcard Matching</h2>
<p>The wildcard matching problem is about checking if a string matches a
pattern with wildcard characters. The wildcard characters are
<code>*</code> that can match any group of characters and <code>?</code>
that can match any single character.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<p>Here is a simple Java code for the wildcard matching problem using
dynamic programming:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> WildcardMatching <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isMatch</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> sLen <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">(),</span> pLen <span class="op">=</span> p<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>sLen <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>pLen <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Empty pattern matches empty string</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Handle patterns with leading &#39;*&#39;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> pLen<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> sLen<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> pLen<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span> <span class="op">||</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>sLen<span class="op">][</span>pLen<span class="op">];</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        WildcardMatching matcher <span class="op">=</span> <span class="kw">new</span> <span class="fu">WildcardMatching</span><span class="op">();</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s <span class="op">=</span> <span class="st">&quot;adceb&quot;</span><span class="op">;</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> p <span class="op">=</span> <span class="st">&quot;*a*b&quot;</span><span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> result <span class="op">=</span> matcher<span class="op">.</span><span class="fu">isMatch</span><span class="op">(</span>s<span class="op">,</span> p<span class="op">);</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Does the string match the pattern? &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>DP Table Initialization</strong>: We create a 2D boolean
array <code>dp</code>. Each <code>dp[i][j]</code> shows if the first
<code>i</code> characters of the string <code>s</code> match the first
<code>j</code> characters of the pattern <code>p</code>.</li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>We start with the base case where both string and pattern are
empty.</li>
<li>We fill the first row to handle cases where the pattern starts with
<code>*</code>.</li>
<li>The main logic checks three conditions:
<ul>
<li>If the current character in the pattern is <code>*</code>, it can
match zero characters (left) or one or more characters (up).</li>
<li>If the current character is <code>?</code> or it matches the
character in the string, we take the value from the diagonal cell.</li>
</ul></li>
</ul></li>
<li><strong>Result</strong>: The final answer is in
<code>dp[sLen][pLen]</code>.</li>
</ul>
<p>This method is efficient and runs in O(m * n) time. Here, m is the
length of the string and n is the length of the pattern. This makes it
good for large inputs. If you want to read more about dynamic
programming techniques, you can check this <a
href="https://bestonlinetutorial.com/dynamic_programming/edit-distance-hard.html">article
on the Edit Distance problem</a>.</p>
<h2 id="python-implementation-of-wildcard-matching">Python
Implementation of Wildcard Matching</h2>
<p>The wildcard matching problem is about checking if a string matches a
pattern that can have wildcards. The wildcards are <code>*</code>, which
can match any group of characters, even nothing, and <code>?</code>,
which can match one character.</p>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<p>Here is a Python code that uses dynamic programming to solve the
wildcard matching problem:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isMatch(s: <span class="bu">str</span>, p: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(p)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span>  <span class="co"># Both string and pattern are empty</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle patterns with &#39;*&#39; at the start</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">or</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;?&#39;</span> <span class="kw">or</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;adceb&quot;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="st">&quot;*a*b&quot;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(isMatch(s, p))  <span class="co"># Output: True</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Matrix Initialization</strong>: We create a 2D list
<code>dp</code>. The <code>dp[i][j]</code> shows if the first
<code>i</code> characters of <code>s</code> match the first
<code>j</code> characters of <code>p</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0][0]</code> to
<code>True</code> because two empty strings match.</li>
<li><strong>First Row Initialization</strong>: We fill the first row
based on the pattern. It allows initial <code>*</code> characters to
match an empty string.</li>
<li><strong>Filling the DP Table</strong>: We fill the table based on
two cases:
<ul>
<li>If the current character in the pattern is <code>*</code>, it can
match no characters or some characters.</li>
<li>If the current character is <code>?</code> or matches the character
in <code>s</code>, we take the value from the diagonal cell.</li>
</ul></li>
<li><strong>Final Result</strong>: The result is in
<code>dp[m][n]</code>, showing if the whole string <code>s</code>
matches the whole pattern <code>p</code>.</li>
</ul>
<p>This dynamic programming method checks for wildcard matches in
<code>O(m * n)</code> time, where <code>m</code> is the length of the
string and <code>n</code> is the length of the pattern. For more about
dynamic programming, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-regular-expression-matching-hard.html">Dynamic
Programming: Regular Expression Matching</a> article.</p>
<h2 id="c-implementation-of-wildcard-matching">C++ Implementation of
Wildcard Matching</h2>
<p>In C++, we can solve the wildcard matching problem using dynamic
programming. This problem is about matching a string <code>s</code> with
a pattern <code>p</code>. The pattern can have wildcard characters. The
<code>*</code> can match any sequence of characters. The <code>?</code>
can match any single character.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is a simple implementation of the wildcard matching algorithm in
C++:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isMatch<span class="op">(</span>string s<span class="op">,</span> string p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sLen <span class="op">=</span> s<span class="op">.</span>length<span class="op">(),</span> pLen <span class="op">=</span> p<span class="op">.</span>length<span class="op">();</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>sLen <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>pLen <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> pLen<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> sLen<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> pLen<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span> <span class="op">||</span> s<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>sLen<span class="op">][</span>pLen<span class="op">];</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    string s <span class="op">=</span> <span class="st">&quot;adceb&quot;</span><span class="op">;</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    string p <span class="op">=</span> <span class="st">&quot;*a*b&quot;</span><span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="op">(</span>isMatch<span class="op">(</span>s<span class="op">,</span> p<span class="op">)</span> <span class="op">?</span> <span class="st">&quot;Match&quot;</span> <span class="op">:</span> <span class="st">&quot;No Match&quot;</span><span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Dynamic Programming Table</strong>: We create a 2D vector
<code>dp</code> with size <code>(sLen + 1) x (pLen + 1)</code>. The
<code>dp[i][j]</code> tells us if the first <code>i</code> characters of
<code>s</code> match the first <code>j</code> characters of
<code>p</code>.</li>
<li><strong>Initialization</strong>: We set <code>dp[0][0]</code> to
true. This means an empty pattern matches an empty string. Patterns that
start with <code>*</code> can match an empty string too.</li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>For every character in <code>s</code> and <code>p</code>, we check
the conditions:
<ul>
<li>If <code>p[j-1]</code> is <code>*</code>, it can match zero
characters (so <code>dp[i][j-1]</code>) or one character (so
<code>dp[i-1][j]</code>).</li>
<li>If <code>p[j-1]</code> is <code>?</code> or matches
<code>s[i-1]</code>, then it depends on the previous characters
(<code>dp[i-1][j-1]</code>).</li>
</ul></li>
</ul></li>
<li><strong>Final Result</strong>: The value at
<code>dp[sLen][pLen]</code> gives the final match result.</li>
</ul>
<p>This C++ code gives a clear and good solution to the wildcard
matching problem using dynamic programming. For more reading on dynamic
programming, we can check topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/edit-distance-hard.html">Edit
Distance</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/regular-expression-matching-hard.html">Regular
Expression Matching</a>.</p>
<h2 id="optimizing-space-complexity-in-wildcard-matching">Optimizing
Space Complexity in Wildcard Matching</h2>
<p>In wildcard matching, we want to check if a string (<code>s</code>)
fits a pattern (<code>p</code>). This pattern can have special
characters like <code>*</code> which matches any string and
<code>?</code> which matches a single character. A common way to solve
this problem is using dynamic programming with a 2D table. But this
takes a lot of memory, especially with long strings.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>To save space, we can change the 2D table to a 1D array. We notice
that the current state only relies on the previous state. So we only
need two arrays. One is for the current row and the other is for the
previous row.</p>
<h3 id="implementation-details">Implementation Details</h3>
<ol type="1">
<li><p><strong>Use a 1D DP Array</strong>: We create a boolean array
<code>dp</code>. Here, <code>dp[j]</code> shows if <code>s</code> up to
index <code>i</code> matches <code>p</code> up to index
<code>j</code>.</p></li>
<li><p><strong>Iterate through Characters</strong>: We loop through each
character in the pattern and string. We update the <code>dp</code> array
based on current characters and wildcards.</p></li>
<li><p><strong>Initialization</strong>: Set <code>dp[0]</code> to
<code>true</code> if <code>p</code> is empty. Also, we check if
<code>p</code> starts with <code>*</code>.</p></li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isMatch</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>p<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Empty pattern matches empty string</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle patterns like &quot;*&quot;, &quot;**&quot;, etc.</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> p<span class="op">.</span><span class="fu">length</span><span class="op">();</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> prev <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Store dp[i-1][j-1]</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// Empty pattern can&#39;t match non-empty string</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> p<span class="op">.</span><span class="fu">length</span><span class="op">();</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">boolean</span> temp <span class="op">=</span> dp<span class="op">[</span>j<span class="op">];</span> <span class="co">// Store dp[i-1][j]</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span> <span class="op">||</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> p<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> prev<span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> temp<span class="op">;</span> <span class="co">// Update prev for next iteration</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>p<span class="op">.</span><span class="fu">length</span><span class="op">()];</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isMatch(s: <span class="bu">str</span>, p: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (<span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span>  <span class="co"># Empty pattern matches empty string</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Handle patterns like &quot;*&quot;, &quot;**&quot;, etc.</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">=</span> dp[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        prev <span class="op">=</span> dp[<span class="dv">0</span>]  <span class="co"># Store dp[i-1][j-1]</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">False</span>  <span class="co"># Empty pattern can&#39;t match non-empty string</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            temp <span class="op">=</span> dp[j]  <span class="co"># Store dp[i-1][j]</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">=</span> dp[j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">or</span> dp[j]</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;?&#39;</span> <span class="kw">or</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> p[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">=</span> prev</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">=</span> <span class="va">False</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> temp  <span class="co"># Update prev for next iteration</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="bu">len</span>(p)]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isMatch<span class="op">(</span>string s<span class="op">,</span> string p<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> dp<span class="op">(</span>p<span class="op">.</span>size<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Empty pattern matches empty string</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Handle patterns like &quot;*&quot;, &quot;**&quot;, etc.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> p<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> s<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> prev <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Store dp[i-1][j-1]</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// Empty pattern can&#39;t match non-empty string</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> p<span class="op">.</span>size<span class="op">();</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">bool</span> temp <span class="op">=</span> dp<span class="op">[</span>j<span class="op">];</span> <span class="co">// Store dp[i-1][j]</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span> <span class="op">||</span> s<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> p<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> prev<span class="op">;</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> temp<span class="op">;</span> <span class="co">// Update prev for next iteration</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>p<span class="op">.</span>size<span class="op">()];</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). Here, m is the length of
the string and n is the length of the pattern.</li>
<li><strong>Space Complexity</strong>: O(n). We reduce the space from
O(m*n) to O(n) using the 1D array.</li>
</ul>
<p>This method helps us save memory while still matching well in the
wildcard matching problem. For more on dynamic programming, we can check
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-regular-expression-matching-hard.html">Dynamic
Programming Regular Expression Matching - Hard</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we look at the wildcard matching problem, we can use different
methods. Each method has its good and bad sides. We will look at three
main methods: brute force, dynamic programming, and regular
expressions.</p>
<h3 id="brute-force-approach">1. Brute Force Approach</h3>
<ul>
<li><strong>Description</strong>: The brute force method tries to create
all possible strings that fit the pattern. Then, it checks each one
against the input string.</li>
<li><strong>Time Complexity</strong>: O(2^(m + n)), where m is the
pattern length and n is the input string length.</li>
<li><strong>Space Complexity</strong>: O(m + n) for the recursion
stack.</li>
<li><strong>Pros</strong>: It is simple to use for small inputs.</li>
<li><strong>Cons</strong>: It does not work well for larger strings
because of its slow speed.</li>
</ul>
<h3 id="dynamic-programming-approach">2. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Description</strong>: This method uses a 2D table to keep
results of smaller problems. This helps to calculate things
quicker.</li>
<li><strong>Time Complexity</strong>: O(m * n), where m is the pattern
length and n is the input string length.</li>
<li><strong>Space Complexity</strong>: O(m * n) for the DP table. We can
also make it O(n) by using only two rows.</li>
<li><strong>Pros</strong>: It works well for larger inputs. It also
gives a clear way to solve the problem.</li>
<li><strong>Cons</strong>: It needs more memory for the DP table.</li>
</ul>
<p><strong>Dynamic Programming Table Construction</strong>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Empty pattern matches empty string</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>pattern<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// &#39;*&#39; can match empty string</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>pattern<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;*&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>i<span class="op">];</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>pattern<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;?&#39;</span> <span class="op">||</span> pattern<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> str<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="regular-expression-approach">3. Regular Expression Approach</h3>
<ul>
<li><strong>Description</strong>: This method changes the wildcard
pattern into a regular expression. We then use regex tools to
match.</li>
<li><strong>Time Complexity</strong>: It changes based on the regex
engine but can be O(m * n) in the worst case.</li>
<li><strong>Space Complexity</strong>: O(m + n) for regex
processing.</li>
<li><strong>Pros</strong>: It is small and often works fast thanks to
the regex engine.</li>
<li><strong>Cons</strong>: Sometimes, it can be hard to read and may
have speed issues with complicated patterns.</li>
</ul>
<h3 id="summary-of-comparison">Summary of Comparison</h3>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 14%" />
<col style="width: 15%" />
<col style="width: 22%" />
<col style="width: 28%" />
</colgroup>
<thead>
<tr class="header">
<th>Approach</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brute Force</td>
<td>O(2^(m + n))</td>
<td>O(m + n)</td>
<td>Simple to use</td>
<td>Not good for large inputs</td>
</tr>
<tr class="even">
<td>Dynamic Programming</td>
<td>O(m * n)</td>
<td>O(m * n) (O(n) optimized)</td>
<td>Works well for larger inputs</td>
<td>Needs more memory</td>
</tr>
<tr class="odd">
<td>Regular Expression</td>
<td>O(m * n)</td>
<td>O(m + n)</td>
<td>Small and fast</td>
<td>Can be hard to read</td>
</tr>
</tbody>
</table>
<p>In the end, we choose a method based on the problem needs and the
input size limits. For most cases, we like the dynamic programming
approach because it is efficient and clear. If we have more complex
matching needs, we may find the regular expression method to be the best
choice.</p>
<h2 id="common-edge-cases-in-wildcard-matching">Common Edge Cases in
Wildcard Matching</h2>
<p>When we make a wildcard matching algorithm with dynamic programming,
we can face some edge cases. These cases can change how our solution
works and what it gives us as an output. It is important to look at
these situations to make sure our matching is strong and correct. Here
are some common edge cases we should think about:</p>
<ul>
<li><strong>Empty String and Pattern</strong>:
<ul>
<li>Input: <code>s = ""</code>, <code>p = ""</code></li>
<li>Output: <code>True</code> (both string and pattern are empty).</li>
</ul></li>
<li><strong>Empty String with Non-empty Pattern</strong>:
<ul>
<li>Input: <code>s = ""</code>, <code>p = "a*"</code></li>
<li>Output: <code>True</code> (the pattern can match an empty
string).</li>
</ul></li>
<li><strong>Non-empty String with Empty Pattern</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = ""</code></li>
<li>Output: <code>False</code> (a non-empty string cannot match an empty
pattern).</li>
</ul></li>
<li><strong>Leading Wildcards</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = "*"</code></li>
<li>Output: <code>True</code> (a wildcard can match any string).</li>
</ul></li>
<li><strong>Multiple Consecutive Wildcards</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = "a**b*"</code></li>
<li>Output: <code>True</code> (consecutive wildcards are like one
wildcard).</li>
</ul></li>
<li><strong>Wildcard at the End of the Pattern</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = "abc*"</code></li>
<li>Output: <code>True</code> (the pattern matches the string).</li>
</ul></li>
<li><strong>Wildcard in Middle of the Pattern</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = "a*c"</code></li>
<li>Output: <code>True</code> (the wildcard can match characters in
between).</li>
</ul></li>
<li><strong>No Matching Characters</strong>:
<ul>
<li>Input: <code>s = "abc"</code>, <code>p = "a*d"</code></li>
<li>Output: <code>False</code> (no way to match the characters).</li>
</ul></li>
<li><strong>Multiple Wildcards Interspersed</strong>:
<ul>
<li>Input: <code>s = "abcde"</code>, <code>p = "*a*b*c*e*"</code></li>
<li>Output: <code>True</code> (wildcards can match characters in
between).</li>
</ul></li>
<li><strong>Complex Patterns</strong>:
<ul>
<li>Input: <code>s = "ab"</code>, <code>p = "a?b"</code></li>
<li>Output: <code>True</code> (the ‘?’ can match any single
character).</li>
</ul></li>
</ul>
<p>Testing these edge cases help us to make sure that our wildcard
matching works in all cases. The code below shows how to do wildcard
matching using dynamic programming in Python, while considering these
edge cases:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isMatch(s: <span class="bu">str</span>, p: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> (<span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(p) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">or</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> p[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;?&#39;</span> <span class="kw">or</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> p[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="bu">len</span>(s)][<span class="bu">len</span>(p)]</span></code></pre></div>
<p>This code looks at the different edge cases we talked about. It gives
us a strong base for wildcard matching.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-approach-to-wildcard-matching">1.
What is the time complexity of the dynamic programming approach to
wildcard matching?</h3>
<p>The time complexity for the dynamic programming method in wildcard
matching is O(m * n). Here, m means the length of the input string and n
means the length of the pattern. We fill a 2D table to show the states
of the matching process. If you want to learn more about dynamic
programming problems, check this article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>.</p>
<h3 id="how-do-wildcards-work-in-string-matching">2. How do wildcards
work in string matching?</h3>
<p>Wildcards are special symbols in string matching. They can stand for
one or more characters in a string. The most used wildcards are the
asterisk (*) that matches zero or more characters and the question mark
(?) that matches exactly one character. This makes pattern matching more
flexible. For a better understanding of this, look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-regular-expression-matching-hard.html">Dynamic
Programming: Regular Expression Matching</a>.</p>
<h3 id="can-wildcard-matching-be-solved-using-recursion">3. Can wildcard
matching be solved using recursion?</h3>
<p>Yes, we can solve wildcard matching with recursion. But this method
is not the best because it has exponential time complexity. We can
improve the recursive solution by using memoization. Memoization helps
to store results and change it into a dynamic programming solution. For
more on recursion in dynamic programming, see <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-edit-distance-hard.html">Dynamic
Programming: Edit Distance</a>.</p>
<h3
id="how-can-space-complexity-be-optimized-in-the-wildcard-matching-problem">4.
How can space complexity be optimized in the wildcard matching
problem?</h3>
<p>We can optimize space complexity in the wildcard matching problem
from O(m * n) to O(n) by using a rolling array. Instead of keeping a
full 2D table, we only need two rows. Each calculation only depends on
the current row and the previous one. This method helps to save memory
but keeps the same time complexity. For more tips on optimizing space
complexity, check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming: Minimum Cost Climbing Stairs</a>.</p>
<h3 id="what-are-common-edge-cases-in-wildcard-matching">5. What are
common edge cases in wildcard matching?</h3>
<p>Common edge cases in wildcard matching are when the pattern or string
is empty. It also includes when the pattern has two or more asterisks
together or when both the string and pattern do not match at all. We
need to handle these cases well to make sure the algorithm works
correctly. For more examples of edge cases in dynamic programming, you
might find this article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a> useful.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            