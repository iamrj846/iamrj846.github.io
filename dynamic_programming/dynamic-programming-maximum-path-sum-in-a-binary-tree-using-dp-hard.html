
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Path Sum in a Binary Tree using DP - Hard</title>
            <meta name="description" content="Discover the maximum path sum in a binary tree using dynamic programming. Master this hard problem with our expert guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Path Sum in a Binary Tree using DP - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Path Sum in a Binary Tree is a problem where we want to
find the highest sum of values along a path from one leaf node to
another leaf node in the tree. This path can go up and down through the
tree. This way, we can include the value of any node along the path. We
can solve this problem well by using dynamic programming techniques.
These techniques help us to not do the same calculations again and
again. They also help to make the process faster.</p>
<p>In this article, we will look at how to use the dynamic programming
method to solve the Maximum Path Sum in a Binary Tree. First, we will
understand what the problem is and what rules we have. Then, we will
explain the dynamic programming method in detail. We will also give
examples in Java, Python, and C++. We will talk about how to make space
usage better. We will compare different methods and point out common
mistakes. Lastly, we will answer some questions that people often
ask.</p>
<ul>
<li>[Dynamic Programming] Maximum Path Sum in a Binary Tree using
Dynamic Programming Techniques</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach to Maximum Path Sum in a Binary
Tree</li>
<li>Java Implementation of Maximum Path Sum in a Binary Tree</li>
<li>Python Implementation of Maximum Path Sum in a Binary Tree</li>
<li>C++ Implementation of Maximum Path Sum in a Binary Tree</li>
<li>Optimizing Space Complexity in Dynamic Programming Solutions</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Common Mistakes to Avoid in Dynamic Programming Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about dynamic programming, we suggest these
articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>The problem of finding the maximum path sum in a binary tree is a
common dynamic programming challenge. Our main goal is to find the
maximum sum of values along any path in the tree. A path is a series of
nodes where each pair of nodes is connected by an edge. The path can
start and end at any node in the tree.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a binary tree, we need to find the maximum path sum. The path
can start and end at any node and can go up or down in the tree.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The binary tree can be empty. If it is empty, the maximum path sum
is usually zero.</li>
<li>Node values can be positive or negative. This means negative values
can lower the sum.</li>
<li>The depth of the tree can affect how well the solution works. Deep
trees may cause stack overflow in recursive solutions.</li>
<li>The number of nodes in the tree should be reasonable. Typically, it
should not go beyond 100,000 nodes in competitive programming.</li>
</ul>
<h3 id="example">Example</h3>
<p>Look at this binary tree:</p>
<pre><code>       1
      / \
     2   3
    / \
   4   5</code></pre>
<p>We can find the maximum path sum for this tree like this: - The path
4 → 2 → 1 → 3 has a sum of 10. - So, the expected output for this tree
is 10.</p>
<p>For implementation, we use depth-first search (DFS). We will
calculate how much each node adds to the path sum and keep track of the
highest total for the whole tree.</p>
<p>This problem can be solved well using dynamic programming ideas. Each
node’s contribution is counted only once. This makes the runtime
complexity O(n), where n is the number of nodes in the tree.</p>
<h2
id="dynamic-programming-approach-to-maximum-path-sum-in-a-binary-tree">Dynamic
Programming Approach to Maximum Path Sum in a Binary Tree</h2>
<p>The maximum path sum in a binary tree means the highest sum of values
along any path from a node to its descendants. We can solve this problem
well by using a dynamic programming method. This method mixes recursive
tree traversal with memoization.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Recursive Function</strong>: We create a recursive
function. This function calculates the maximum path sum starting from
any node. It returns the highest sum from the current node to any leaf
node below it.</p></li>
<li><p><strong>Base Case</strong>: If the node is <code>null</code>, we
return <code>0</code>. There is no contribution to the path
sum.</p></li>
<li><p><strong>Recursive Calculation</strong>:</p>
<ul>
<li><p>For each node, we find the maximum path sum from its left and
right children.</p></li>
<li><p>We can calculate the possible maximum path sum at that node like
this:</p>
<pre class="plaintext"><code>max_path_sum = node.val + max(0, left_sum, right_sum)</code></pre></li>
<li><p>We update a global variable to keep track of the highest path sum
we found so far. This includes the path that goes through the current
node and both left and right child sums:</p>
<pre class="plaintext"><code>current_max = node.val + left_sum + right_sum</code></pre></li>
<li><p>If <code>current_max</code> is more than the global maximum, we
update it.</p></li>
</ul></li>
<li><p><strong>Return Value</strong>: The recursive function should
return the highest value that can be added to its parent node.</p></li>
</ol>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> left<span class="op">,</span> right<span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span><span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span> val <span class="op">=</span> x<span class="op">;</span> <span class="op">}</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumPathSum <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> maxSum <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxPathSum</span><span class="op">(</span><span class="bu">TreeNode</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="fu">calculateMaxPath</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">calculateMaxPath</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fu">calculateMaxPath</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">));</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="fu">calculateMaxPath</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">));</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the maximum path sum</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> node<span class="op">.</span><span class="fu">val</span> <span class="op">+</span> leftSum <span class="op">+</span> rightSum<span class="op">);</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the maximum sum of the path extending to the parent</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node<span class="op">.</span><span class="fu">val</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>leftSum<span class="op">,</span> rightSum<span class="op">);</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, x):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.val <span class="op">=</span> x</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> <span class="va">None</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> MaximumPathSum:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_sum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> maxPathSum(<span class="va">self</span>, root: TreeNode) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.calculateMaxPath(root)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.max_sum</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> calculateMaxPath(<span class="va">self</span>, node: TreeNode) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        left_sum <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, <span class="va">self</span>.calculateMaxPath(node.left))</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        right_sum <span class="op">=</span> <span class="bu">max</span>(<span class="dv">0</span>, <span class="va">self</span>.calculateMaxPath(node.right))</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update the maximum path sum</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_sum <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.max_sum, node.val <span class="op">+</span> left_sum <span class="op">+</span> right_sum)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Return the maximum sum of the path extending to the parent</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node.val <span class="op">+</span> <span class="bu">max</span>(left_sum, right_sum)</span></code></pre></div>
<h3 id="implementation-in-c">Implementation in C++</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    TreeNode <span class="op">*</span>left<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    TreeNode <span class="op">*</span>right<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> left<span class="op">(</span>NULL<span class="op">),</span> right<span class="op">(</span>NULL<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSum <span class="op">=</span> INT_MIN<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxPathSum<span class="op">(</span>TreeNode<span class="op">*</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        calculateMaxPath<span class="op">(</span>root<span class="op">);</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> calculateMaxPath<span class="op">(</span>TreeNode<span class="op">*</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftSum <span class="op">=</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> calculateMaxPath<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">));</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightSum <span class="op">=</span> max<span class="op">(</span><span class="dv">0</span><span class="op">,</span> calculateMaxPath<span class="op">(</span>node<span class="op">-&gt;</span>right<span class="op">));</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> max<span class="op">(</span>maxSum<span class="op">,</span> node<span class="op">-&gt;</span>val <span class="op">+</span> leftSum <span class="op">+</span> rightSum<span class="op">);</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node<span class="op">-&gt;</span>val <span class="op">+</span> max<span class="op">(</span>leftSum<span class="op">,</span> rightSum<span class="op">);</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>The dynamic programming way helps us find the maximum path sum in a
binary tree. We use recursion and keep a global maximum. This way, our
solution is both clear and effective. For more about dynamic
programming, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming Approaches</a>.</p>
<h2 id="java-implementation-of-maximum-path-sum-in-a-binary-tree">Java
Implementation of Maximum Path Sum in a Binary Tree</h2>
<p>We can implement the Maximum Path Sum in a Binary Tree using Java. We
will use a simple recursive approach with some ideas from dynamic
programming. The plan is to go through the tree and find the maximum
path sum at each node. Meanwhile, we will keep track of the highest path
sum we find.</p>
<p>Here is the Java code for this implementation:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="bu">TreeNode</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> left<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span> right<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">TreeNode</span><span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> x<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumPathSum <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> maxSum <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxPathSum</span><span class="op">(</span><span class="bu">TreeNode</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="fu">calculateMaxPath</span><span class="op">(</span>root<span class="op">);</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">calculateMaxPath</span><span class="op">(</span><span class="bu">TreeNode</span> node<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>node <span class="op">==</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate maximum path sum of left and right child</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftMax <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">calculateMaxPath</span><span class="op">(</span>node<span class="op">.</span><span class="fu">left</span><span class="op">),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightMax <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">calculateMaxPath</span><span class="op">(</span>node<span class="op">.</span><span class="fu">right</span><span class="op">),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the maximum path sum with current node</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> leftMax <span class="op">+</span> rightMax <span class="op">+</span> node<span class="op">.</span><span class="fu">val</span><span class="op">);</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the maximum sum to parent node</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>leftMax<span class="op">,</span> rightMax<span class="op">)</span> <span class="op">+</span> node<span class="op">.</span><span class="fu">val</span><span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>TreeNode Class</strong>: This class is for each node in the
binary tree.</li>
<li><strong>maxPathSum Method</strong>: This method starts the maximum
path sum and calls the recursive function.</li>
<li><strong>calculateMaxPath Method</strong>:
<ul>
<li>This method calculates the maximum path sum from the left and right
subtrees.</li>
<li>It updates the overall maximum path sum (<code>maxSum</code>) at
each node.</li>
<li>It returns the maximum sum that can go to its parent node.</li>
</ul></li>
</ul>
<p>This code works well to find the maximum path sum in a binary tree.
It has a time complexity of O(N), where N is the total number of nodes.
The space complexity is O(H), where H is the height of the tree because
of the recursion stack.</p>
<p>For more reading on similar dynamic programming problems, we can
check articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>
<h2
id="python-implementation-of-maximum-path-sum-in-a-binary-tree">Python
Implementation of Maximum Path Sum in a Binary Tree</h2>
<p>To find the maximum path sum in a binary tree using Python, we can
use a depth-first search (DFS) method. We combine this with some ideas
from dynamic programming. The main idea is to calculate the maximum path
sum for each node. We look at both its left and right children. The
maximum path sum is the node’s value plus the maximum path sum from
either its left or right child.</p>
<p>Here’s the Python code:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TreeNode:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, val<span class="op">=</span><span class="dv">0</span>, left<span class="op">=</span><span class="va">None</span>, right<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.val <span class="op">=</span> val</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left <span class="op">=</span> left</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right <span class="op">=</span> right</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> maxPathSum(<span class="va">self</span>, root: TreeNode) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.max_sum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="kw">def</span> max_gain(node):</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate maximum path sum for left and right children</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            left_gain <span class="op">=</span> <span class="bu">max</span>(max_gain(node.left), <span class="dv">0</span>)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            right_gain <span class="op">=</span> <span class="bu">max</span>(max_gain(node.right), <span class="dv">0</span>)</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Calculate current path sum including the current node</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            current_path_sum <span class="op">=</span> node.val <span class="op">+</span> left_gain <span class="op">+</span> right_gain</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Update the maximum path sum found so far</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.max_sum <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.max_sum, current_path_sum)</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Return the maximum gain from the current node</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> node.val <span class="op">+</span> <span class="bu">max</span>(left_gain, right_gain)</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>        max_gain(root)</span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.max_sum</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><p><strong>TreeNode Class</strong>: This class shows the structure
of a binary tree node. It has a value, a left child, and a right
child.</p></li>
<li><p><strong>Solution Class</strong>: This class has the method
<code>maxPathSum</code>. It starts by setting <code>self.max_sum</code>
to a very low number. This keeps track of the maximum path sum.</p></li>
<li><p><strong>max_gain Function</strong>: This is a helper function. It
finds the maximum gain from any node:</p>
<ul>
<li>It gives back 0 if the node is <code>None</code>. This makes sure we
don’t count null paths.</li>
<li>It finds the gains from the left and right children. We make sure
they are not negative by using <code>max(..., 0)</code>.</li>
<li>We calculate the current path sum by adding the node’s value to the
maximum gains from its children.</li>
<li>If the current path sum is higher than what we have found before, we
update <code>self.max_sum</code>.</li>
<li>Finally, we return the maximum gain that can be sent to the parent.
This is the node’s value plus the bigger of the left or right
gains.</li>
</ul></li>
</ul>
<p>This code uses dynamic programming to keep the best properties. It
checks all possible paths in the binary tree while avoiding extra
calculations.</p>
<p>For more about dynamic programming and tree paths, you can read about
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming - Minimum Path Sum in a Grid</a>.</p>
<h2 id="c-implementation-of-maximum-path-sum-in-a-binary-tree">C++
Implementation of Maximum Path Sum in a Binary Tree</h2>
<p>We can find the maximum path sum in a binary tree using dynamic
programming in C++. We will use a function that works by calling itself.
This function will look at each node and find the maximum path sum. It
will check both the left and right subtrees. The maximum path is the
highest sum of values along any path from one node to another in the
tree.</p>
<p>Here’s the C++ code to solve the Maximum Path Sum problem:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="co">// Definition for a binary tree node.</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> TreeNode <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    TreeNode <span class="op">*</span>left<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    TreeNode <span class="op">*</span>right<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">(</span><span class="dt">int</span> x<span class="op">)</span> <span class="op">:</span> val<span class="op">(</span>x<span class="op">),</span> left<span class="op">(</span>NULL<span class="op">),</span> right<span class="op">(</span>NULL<span class="op">)</span> <span class="op">{}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxPathSum<span class="op">(</span>TreeNode<span class="op">*</span> root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max_sum <span class="op">=</span> INT_MIN<span class="op">;</span> <span class="co">// Start with the lowest possible value</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        maxGain<span class="op">(</span>root<span class="op">,</span> max_sum<span class="op">);</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_sum<span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxGain<span class="op">(</span>TreeNode<span class="op">*</span> node<span class="op">,</span> <span class="dt">int</span><span class="op">&amp;</span> max_sum<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(!</span>node<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// If the node is null, return 0</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Call for left and right children</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> left_gain <span class="op">=</span> max<span class="op">(</span>maxGain<span class="op">(</span>node<span class="op">-&gt;</span>left<span class="op">,</span> max_sum<span class="op">),</span> <span class="dv">0</span><span class="op">);</span> <span class="co">// Only take positive gains</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> right_gain <span class="op">=</span> max<span class="op">(</span>maxGain<span class="op">(</span>node<span class="op">-&gt;</span>right<span class="op">,</span> max_sum<span class="op">),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find the maximum path sum at this node</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> price_newpath <span class="op">=</span> node<span class="op">-&gt;</span>val <span class="op">+</span> left_gain <span class="op">+</span> right_gain<span class="op">;</span></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the maximum sum</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> max<span class="op">(</span>max_sum<span class="op">,</span> price_newpath<span class="op">);</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the maximum gain for the parent node to use</span></span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node<span class="op">-&gt;</span>val <span class="op">+</span> max<span class="op">(</span>left_gain<span class="op">,</span> right_gain<span class="op">);</span></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Example usage:</span></span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a>    TreeNode<span class="op">*</span> root <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>    root<span class="op">-&gt;</span>left <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">2</span><span class="op">);</span></span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a>    root<span class="op">-&gt;</span>right <span class="op">=</span> <span class="kw">new</span> TreeNode<span class="op">(</span><span class="dv">3</span><span class="op">);</span></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a>    Solution solution<span class="op">;</span></span>
<span id="cb9-46"><a href="#cb9-46" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Path Sum: &quot;</span> <span class="op">&lt;&lt;</span> solution<span class="op">.</span>maxPathSum<span class="op">(</span>root<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// Output: 6 (2 + 1 + 3)</span></span>
<span id="cb9-47"><a href="#cb9-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-48"><a href="#cb9-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-49"><a href="#cb9-49" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The <code>TreeNode</code> struct tells us how a tree node
looks.</li>
<li>The <code>Solution</code> class has the method
<code>maxPathSum</code>. This method starts the maximum sum and calls
the helper function <code>maxGain</code>.</li>
<li>The <code>maxGain</code> function finds how much each node can add
to the path sum. It looks at the left and right gains and updates the
maximum path sum we have found.</li>
<li>We only use positive gains when we find the maximum path sum. This
way, we avoid negative values.</li>
</ul>
<p>This code runs in O(n) time. Here, n is the number of nodes in the
binary tree. The space complexity is O(h), where h is the height of the
tree because of the recursion stack.</p>
<p>For more helpful information and examples of dynamic programming, we
can check resources on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">dynamic
programming approaches</a>.</p>
<h2
id="optimizing-space-complexity-in-dynamic-programming-solutions">Optimizing
Space Complexity in Dynamic Programming Solutions</h2>
<p>In dynamic programming (DP), we need to optimize space complexity.
This is important for improving performance. It is especially true when
we deal with large datasets or strict limits. Here are some easy ways to
reduce space in dynamic programming solutions:</p>
<ol type="1">
<li><p><strong>In-Place Updates</strong>: Instead of creating a new data
structure for results, we can update the input array or matrix directly
when we can. This saves space but we must be careful with the original
data.</p></li>
<li><p><strong>State Compression</strong>: When we have overlapping
subproblems, we can use fewer states to keep only what we need. For
example, if we only need the last two results for the next state, we
keep just those two.</p></li>
<li><p><strong>Iterative Solutions</strong>: Recursive solutions can
take up a lot of stack space. We can change recursive DP solutions to
iterative ones. This helps remove the extra cost from recursive
calls.</p></li>
<li><p><strong>Memoization with Limited Storage</strong>: We can use
memoization but limit how much we store. For instance, if we solve a
problem that needs only the last few states, we can use a small
fixed-size array instead of a big table.</p></li>
<li><p><strong>Bit Manipulation</strong>: For problems with integers, we
can use bit manipulation. This lets us store multiple states in one
integer, which helps reduce space.</p></li>
</ol>
<h3 id="example-fibonacci-sequence-with-space-optimization">Example:
Fibonacci Sequence with Space Optimization</h3>
<p>Here is a simple example of optimizing space when calculating
Fibonacci numbers using an iterative method:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">fibonacci</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> current <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>            current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span> <span class="co">// Calculate current Fibonacci number</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> prev1<span class="op">;</span> <span class="co">// Update previous values</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> current<span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-1d-dp-array-for-minimum-path-sum">Example: 1D DP Array
for Minimum Path Sum</h3>
<p>In problems like Minimum Path Sum in a grid, we can use a
one-dimensional array instead of a two-dimensional array:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> cols</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">+=</span> grid[i][j]</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">=</span> <span class="bu">min</span>(dp[j], dp[j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> grid[i][j]    </span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="example-space-optimization-in-c">Example: Space Optimization in
C++</h3>
<p>In C++, we can also save space using a similar method with a
vector:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rows <span class="op">=</span> grid<span class="op">.</span>size<span class="op">(),</span> cols <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>cols<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>cols <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By using these methods, we can reduce the space complexity of dynamic
programming solutions. This makes them more efficient and better for
larger inputs. For more reading on similar topics, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we solve the problem of finding the maximum path sum in a binary
tree using dynamic programming, we can use different methods. Each
method has its own pros and cons. These include time complexity, space
complexity, and how hard they are to implement. Here, we look at three
main methods: <strong>Brute Force</strong>, <strong>Recursive with
Memoization</strong>, and <strong>Dynamic Programming with Bottom-Up
Approach</strong>.</p>
<h3 id="brute-force-approach">1. Brute Force Approach</h3>
<ul>
<li><strong>Description</strong>: This method calculates the sum of all
paths from the root to each leaf node. It finds the maximum sum without
using any tricks to make it faster.</li>
<li><strong>Time Complexity</strong>: O(N^2), where N is the number of
nodes. Each path calculation takes O(N) time.</li>
<li><strong>Space Complexity</strong>: O(N) because of the recursion
stack.</li>
</ul>
<h3 id="recursive-with-memoization">2. Recursive with Memoization</h3>
<ul>
<li><p><strong>Description</strong>: This method makes brute force
better by saving path sums we already calculated in a cache. This helps
us not to do the same work again.</p></li>
<li><p><strong>Implementation</strong>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxPathSum(node, memo):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> node <span class="kw">in</span> memo:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[node]</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    left_sum <span class="op">=</span> maxPathSum(node.left, memo)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    right_sum <span class="op">=</span> maxPathSum(node.right, memo)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    memo[node] <span class="op">=</span> node.val <span class="op">+</span> <span class="bu">max</span>(left_sum, right_sum)</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[node]</span></code></pre></div></li>
<li><p><strong>Time Complexity</strong>: O(N) because we process each
node just once.</p></li>
<li><p><strong>Space Complexity</strong>: O(N) for the cache
storage.</p></li>
</ul>
<h3 id="dynamic-programming-with-bottom-up-approach">3. Dynamic
Programming with Bottom-Up Approach</h3>
<ul>
<li><p><strong>Description</strong>: This method is more efficient. It
goes through the tree once and calculates the maximum path sum by
passing values from the leaves to the root. At each node, it finds the
best value from its children.</p></li>
<li><p><strong>Implementation</strong>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxPathSum(root):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node):</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> node:</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        left <span class="op">=</span> <span class="bu">max</span>(dfs(node.left), <span class="dv">0</span>)</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> <span class="bu">max</span>(dfs(node.right), <span class="dv">0</span>)</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> max_sum</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, node.val <span class="op">+</span> left <span class="op">+</span> right)</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> node.val <span class="op">+</span> <span class="bu">max</span>(left, right)</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    dfs(root)</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div></li>
<li><p><strong>Time Complexity</strong>: O(N), where N is the number of
nodes.</p></li>
<li><p><strong>Space Complexity</strong>: O(H), where H is the height of
the tree because of the recursion stack.</p></li>
</ul>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<table>
<thead>
<tr class="header">
<th>Approach</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Brute Force</td>
<td>O(N^2)</td>
<td>O(N)</td>
</tr>
<tr class="even">
<td>Recursive with Memoization</td>
<td>O(N)</td>
<td>O(N)</td>
</tr>
<tr class="odd">
<td>Dynamic Programming (Bottom-Up)</td>
<td>O(N)</td>
<td>O(H)</td>
</tr>
</tbody>
</table>
<p>In real life, we often like the bottom-up dynamic programming
approach because it is fast and easy to use. This method works well for
big trees. It balances time and space needs while giving good
performance. For more information on dynamic programming problems, we
can check topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming - Minimum Path Sum in a Grid</a>.</p>
<h2
id="common-mistakes-to-avoid-in-dynamic-programming-solutions">Common
Mistakes to Avoid in Dynamic Programming Solutions</h2>
<p>When we work on dynamic programming (DP) problems, we can run into
common mistakes. These mistakes can give us wrong answers or slow
solutions. Here are some mistakes we should try to avoid:</p>
<ol type="1">
<li><p><strong>Not Defining the State Clearly</strong>:<br />
We need to make sure the state is clear. If we do not understand the
state well, we might create a wrong or incomplete DP solution.</p></li>
<li><p><strong>Ignoring the Base Cases</strong>:<br />
Base cases are very important in dynamic programming. If we do not
define them or if we define them wrongly, we can get wrong results or
end up in an infinite loop.</p></li>
<li><p><strong>Overlapping Subproblems</strong>:<br />
DP works best when we can break the problem into overlapping
subproblems. If we do not see this, we might use simple recursive
solutions that do extra calculations.</p></li>
<li><p><strong>Incorrect Transition Functions</strong>:<br />
We must make sure that the move from one state to another matches the
problem’s needs. Wrong transitions can give us wrong answers.</p></li>
<li><p><strong>Forgetting to Optimize Space</strong>:<br />
Many DP problems can be solved with less memory. If we do not use this,
we waste memory.</p></li>
<li><p><strong>Not Reusing Results</strong>:<br />
If we do not save our intermediate results (memoization), we can end up
doing the same calculations over and over, which makes it
slower.</p></li>
<li><p><strong>Misunderstanding Problem Constraints</strong>:<br />
We should look closely at the constraints before we make a DP solution.
If we misunderstand them, we can make wrong guesses and wrong
solutions.</p></li>
<li><p><strong>Being Too Rigid with the Approach</strong>:<br />
Some problems can be solved in different ways using DP (like top-down or
bottom-up). If we are too strict, we might miss finding a good
solution.</p></li>
<li><p><strong>Neglecting Edge Cases</strong>:<br />
We must always think about edge cases in the problem. They might not be
obvious, but they can cause our DP solution to fail.</p></li>
<li><p><strong>Not Testing the Solution Thoroughly</strong>:<br />
We should test our solution with different inputs, especially edge
cases. This helps us make sure our dynamic programming implementation
works well.</p></li>
</ol>
<p>By remembering these common mistakes, we can get better at dynamic
programming and create smarter algorithms. If we want to learn more
about dynamic programming techniques, we can check out this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming on Fibonacci Numbers</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-maximum-path-sum-in-a-binary-tree-problem">1. What
is the Maximum Path Sum in a Binary Tree problem?</h3>
<p>The Maximum Path Sum in a Binary Tree problem is about finding the
highest sum of values along any path from one node to another node in
the tree. This path can go through parent-child links and does not have
to go through the root. Knowing this problem is important when we want
to use dynamic programming techniques well.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-the-maximum-path-sum-problem">2.
How can Dynamic Programming be applied to solve the Maximum Path Sum
problem?</h3>
<p>We can use Dynamic Programming for the Maximum Path Sum problem by
breaking it into smaller parts. We calculate the maximum path sum for
each node one by one and keep the results. This way, we can find the
overall maximum path sum for the whole binary tree fast. It helps us
avoid doing the same calculations again and again, which makes it a good
way to solve this problem.</p>
<h3
id="what-are-the-common-mistakes-to-avoid-when-implementing-the-maximum-path-sum-algorithm">3.
What are the common mistakes to avoid when implementing the Maximum Path
Sum algorithm?</h3>
<p>When we implement the Maximum Path Sum algorithm, we should avoid
some common mistakes. We should not forget to consider paths that do not
include the root. Sometimes we miscalculate the sum by wrongly including
negative values. Also, we need to handle null nodes properly. If we take
care of these things, we can make our solution stronger and more correct
using dynamic programming.</p>
<h3
id="what-is-the-time-complexity-of-the-maximum-path-sum-problem-using-dynamic-programming">4.
What is the time complexity of the Maximum Path Sum problem using
Dynamic Programming?</h3>
<p>The time complexity of the Maximum Path Sum in a Binary Tree using
dynamic programming techniques is O(N). Here, N is the number of nodes
in the tree. This complexity happens because we visit each node once to
find its maximum path sum. So, the dynamic programming way is good for
big binary trees.</p>
<h3
id="how-does-the-maximum-path-sum-differ-from-related-problems-like-the-maximum-subarray-problem">5.
How does the Maximum Path Sum differ from related problems like the
Maximum Subarray problem?</h3>
<p>The Maximum Path Sum in a Binary Tree is about the sum of values
along a path in a tree. The Maximum Subarray problem is about the sum of
contiguous elements in an array. Both problems can use dynamic
programming, but they are different in structure and rules. This means
we need different ways to solve them well. For more information, check
out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray (Kadane’s Algorithm)</a> article.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            