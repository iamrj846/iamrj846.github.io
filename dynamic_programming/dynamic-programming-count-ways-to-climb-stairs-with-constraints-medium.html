
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Climb Stairs with Constraints - Medium</title>
            <meta name="description" content="Discover how to solve the "Count Ways to Climb Stairs" problem using dynamic programming with constraints. Learn effective strategies!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Climb Stairs with Constraints - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <h1 id="count-ways-to-climb-stairs-with-constraints">Count Ways to Climb
Stairs with Constraints</h1>
<p>In this article, we will look at the dynamic programming way to count
how many ways we can climb stairs with some rules. The problem is about
finding out how many different ways someone can go up a staircase with a
certain number of steps. A person can take one or more steps at a time,
but there might be some rules to think about. By using dynamic
programming, we can quickly find the number of valid ways to reach the
top while following these rules.</p>
<p>We will talk about many parts of solving the climbing stairs problem
with dynamic programming. This includes a simple overview of the
solution, what the problem is and what the rules are, how to implement
it in Java, Python, and C++, how to make space usage better, and
comparing different methods. We will also mention real-life uses of this
problem and answer some common questions. Here are the main topics we
will cover:</p>
<ul>
<li>[Dynamic Programming] Count Ways to Climb Stairs with Constraints
Solution Overview</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach to Count Ways to Climb Stairs</li>
<li>Java Implementation for Counting Ways to Climb Stairs</li>
<li>Python Code Example for Climbing Stairs with Constraints</li>
<li>C++ Solution for Counting Climbing Ways</li>
<li>Optimizing Space Complexity in Dynamic Programming</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Real World Applications of Climbing Stairs Problem</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>We want to count how many ways we can climb stairs with some rules.
We need to find the number of different ways to reach the top when we
have certain conditions.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a staircase with <code>n</code> steps. We can climb either 1
or 2 steps at a time. But there are some rules that can change how we
climb:</p>
<ul>
<li><strong>Maximum Steps Allowed at Once</strong>: We might have a
limit on how many steps we can take at once, which is
<code>k</code>.</li>
<li><strong>Restricted Steps</strong>: Some steps might be blocked, so
we cannot land on them.</li>
<li><strong>Initial Conditions</strong>: We can start from step 0 or
step 1, based on what the problem says.</li>
</ul>
<h3 id="input">Input</h3>
<ul>
<li>An integer <code>n</code>, which is the total number of steps.</li>
<li>An integer <code>k</code>, which is the maximum steps we can take at
once (if there is one).</li>
<li>A list of restricted steps (if there are any).</li>
</ul>
<h3 id="output">Output</h3>
<ul>
<li>The total number of different ways to reach the <code>n</code>-th
step with the given rules.</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li><code>1 ≤ n ≤ 50</code></li>
<li><code>1 ≤ k ≤ 2</code> (or more depending on the problem)</li>
<li>The list of restricted steps can be different sizes and may include
steps from <code>0</code> to <code>n</code>.</li>
</ul>
<h3 id="example">Example</h3>
<p>For example, if <code>n = 5</code> and we can take a maximum of
<code>k = 2</code> steps at a time, the valid ways to climb are: - 1
step + 1 step + 1 step + 1 step + 1 step - 1 step + 1 step + 1 step + 2
steps - 1 step + 2 steps + 1 step + 1 step - 2 steps + 1 step + 1 step +
1 step - 2 steps + 2 steps + 1 step</p>
<p>If step 3 is blocked, we must not include any paths that land on step
3.</p>
<p>We can solve this problem using dynamic programming. It helps us
break the problem into smaller parts while keeping the rules in
mind.</p>
<h2
id="dynamic-programming-approach-to-count-ways-to-climb-stairs">Dynamic
Programming Approach to Count Ways to Climb Stairs</h2>
<p>We can solve the problem of counting ways to climb stairs with some
limits using dynamic programming. This method breaks the problem into
smaller parts. We store the results of these parts to avoid repeating
calculations.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have <code>n</code> stairs. We can climb either 1 or 2 stairs at a
time. Our goal is to find the number of different ways to get to the top
of the stairs. If we have extra rules like forbidden steps, we can
change our approach a bit.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We define <code>dp[i]</code>
as the number of ways to reach the <code>i-th</code> stair.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>To get to the <code>i-th</code> stair, we can come from the
<code>(i-1)-th</code> stair or the <code>(i-2)-th</code> stair.</li>
<li>So, we have: [ dp[i] = dp[i-1] + dp[i-2] ]</li>
</ul></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li><code>dp[0] = 1</code>: There is one way to stay on the ground (do
nothing).</li>
<li><code>dp[1] = 1</code>: There is one way to reach the first stair
(one step).</li>
</ul></li>
<li><p><strong>Implementation</strong>: Here is a sample implementation
in Java, Python, and C++.</p></li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ClimbStairs <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-code-example">Python Code Example</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(n):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="c-solution">C++ Solution</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> climbStairs<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This dynamic programming method helps us find the solution in O(n)
time with O(n) space. We can make it even better by using O(1) space. We
just need to keep track of the last two values we computed.</p>
<p>For more helpful information on dynamic programming techniques, check
out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> article.</p>
<h2 id="java-implementation-for-counting-ways-to-climb-stairs">Java
Implementation for Counting Ways to Climb Stairs</h2>
<p>We can solve the problem of counting the ways to climb stairs with
some rules using dynamic programming (DP). Here is a Java code that
shows the dynamic programming method.</p>
<h3 id="java-code">Java Code</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ClimbStairs <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> constraints<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: 1 way to stay at the ground (do nothing)</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> constraints<span class="op">.</span><span class="fu">length</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> constraints<span class="op">[</span>j<span class="op">]</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> constraints<span class="op">[</span>j<span class="op">]];</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        ClimbStairs cs <span class="op">=</span> <span class="kw">new</span> <span class="fu">ClimbStairs</span><span class="op">();</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// total steps</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> constraints <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span> <span class="co">// allowed steps (1 or 2)</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; stairs: &quot;</span> <span class="op">+</span> cs<span class="op">.</span><span class="fu">countWays</span><span class="op">(</span>n<span class="op">,</span> constraints<span class="op">));</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li>The <code>countWays</code> method gets the total number of stairs
<code>n</code> and an array <code>constraints</code> for the allowed
steps.</li>
<li>The <code>dp</code> array keeps the number of ways to reach each
step from 0 to <code>n</code>.</li>
<li>The outer loop goes through each step. The inner loop checks each
constraint to see if we can use it to reach the current step.</li>
<li>We store the result in <code>dp[n]</code> and return it at the
end.</li>
</ul>
<p>This code calculates how many ways we can climb stairs with the given
constraints. It shows how dynamic programming can help us solve counting
problems. For more info on dynamic programming, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a>.</p>
<h2 id="python-code-example-for-climbing-stairs-with-constraints">Python
Code Example for Climbing Stairs with Constraints</h2>
<p>In this section, we will show a Python way to solve the problem. We
want to count how many ways we can climb stairs with some rules using
dynamic programming.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have <code>n</code> steps. We can climb either 1 or 2 steps at a
time. But some steps have rules, and we cannot step on them. Our goal is
to count how many different ways we can reach the top.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>We will use a dynamic programming array called <code>dp</code>. Here
<code>dp[i]</code> means the number of different ways to reach step
<code>i</code>. The rules can be written like this:</p>
<ul>
<li>If a step is not restricted:
<ul>
<li><code>dp[i] = dp[i-1] + dp[i-2]</code></li>
</ul></li>
<li>If a step is restricted:
<ul>
<li><code>dp[i] = 0</code></li>
</ul></li>
</ul>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWays(n, restricted_steps):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP array</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case: 1 way to stay at the ground (do nothing)</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case: 1 way to climb 1 step</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    restricted <span class="op">=</span> <span class="bu">set</span>(restricted_steps)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> restricted:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">2</span>]</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># No ways to climb to a restricted step</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>restricted_steps <span class="op">=</span> [<span class="dv">2</span>]</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to climb </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> stairs with constraints: </span><span class="sc">{</span>countWays(n, restricted_steps)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Input</strong>: The function <code>countWays</code> gets
total steps <code>n</code> and a list of
<code>restricted_steps</code>.</li>
<li><strong>Base Cases</strong>: We set <code>dp[0]</code> and
<code>dp[1]</code> to handle the first two steps.</li>
<li><strong>Dynamic Programming Loop</strong>: We go from step 2 to
<code>n</code>. We check if each step is restricted. If not, we add the
ways from the last two steps. If it is restricted, we set the ways to
zero.</li>
<li><strong>Output</strong>: The function gives back the number of ways
to reach the top step with the rules.</li>
</ul>
<p>This method helps us quickly find how many ways we can climb stairs
while following the rules. For more reading about dynamic programming,
we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">this
article on climbing stairs</a>.</p>
<h2 id="c-solution-for-counting-climbing-ways">C++ Solution for Counting
Climbing Ways</h2>
<p>To solve the “Count Ways to Climb Stairs with Constraints” problem
using C++, we use dynamic programming. We create a <code>dp</code>
array. Each index in the array shows the number of ways to reach that
step. The way we move from one step to another depends on the limits we
have, like how many steps we can take at one time.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> maxSteps<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span> <span class="co">// Base case: 1 way to stay at the ground</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span>  <span class="co">// No way to climb negative stairs</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span> <span class="co">// 1 way to stay at the ground</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the dp array</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> maxSteps<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> j<span class="op">]</span> <span class="co">// Add the ways from the previous steps</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">]</span> <span class="co">// Total ways to reach the nth step</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span> <span class="co">// Number of stairs</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSteps <span class="op">=</span> <span class="dv">2</span> <span class="co">// Maximum steps that can be taken at once</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to climb &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; stairs: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>n<span class="op">,</span> maxSteps<span class="op">)</span> <span class="op">&lt;&lt;</span> endl</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Input Parameters</strong>: The function
<code>countWays</code> takes total stairs <code>n</code> and maximum
steps <code>maxSteps</code>.</li>
<li><strong>Base Cases</strong>: If <code>n</code> is 0, there is one
way to stay at the ground. If <code>n</code> is negative, there are no
ways to climb.</li>
<li><strong>Dynamic Programming Array</strong>: We make a vector called
<code>dp</code> to keep the number of ways to reach each step.</li>
<li><strong>Filling the DP Array</strong>: For each step <code>i</code>,
we add the ways from previous steps based on the allowed maximum
steps.</li>
<li><strong>Output</strong>: We return the total number of ways to reach
the nth step.</li>
</ul>
<p>This C++ solution counts the ways to climb stairs with limits. It
shows a simple dynamic programming method. For more about dynamic
programming techniques, we can look at related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="optimizing-space-complexity-in-dynamic-programming">Optimizing
Space Complexity in Dynamic Programming</h2>
<p>In dynamic programming (DP), we need to optimize space complexity.
This helps us improve performance, especially when we work with large
inputs. Many DP problems can get solved with an iterative method that
uses less space. We do this by using the relationships between
states.</p>
<h3 id="key-techniques-for-space-optimization">Key Techniques for Space
Optimization</h3>
<ul>
<li><p><strong>State Reduction</strong>: Instead of keeping a full DP
table, we keep only the states we need. For example, in the climbing
stairs problem, we see that the ways to reach the current step depend
only on the last two steps. So, we can store only the last two values
instead of the whole array.</p></li>
<li><p><strong>In-Place Updates</strong>: If the problem allows, we can
change the input array directly. This way, we save space for another DP
array.</p></li>
<li><p><strong>Iterative Approach</strong>: We should use loops instead
of recursion. This helps us avoid the extra cost of recursive calls and
using stack memory.</p></li>
</ul>
<h3 id="example-climbing-stairs-problem">Example: Climbing Stairs
Problem</h3>
<p>In the climbing stairs problem, where we can take 1 or 2 steps at a
time, we can optimize space like this:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is how we can do the optimized space complexity approach in
Python:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(n):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    first, second <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> first <span class="op">+</span> second</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<p>In C++, we can write the space-optimized version like this:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> first <span class="op">+</span> second<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-benefits">Summary of Benefits</h3>
<ul>
<li><strong>Reduced Memory Usage</strong>: When we use constant space,
the algorithm works better with memory.</li>
<li><strong>Improved Performance</strong>: Less memory allocation and
garbage collection make the execution times faster.</li>
<li><strong>Scalability</strong>: The algorithm can manage bigger inputs
without hitting memory limits.</li>
</ul>
<p>For more insights about dynamic programming and space optimization
strategies, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we try to count the ways to climb stairs with limits, we can use
different methods. Each method has its own pros and cons in terms of how
hard it is and how well it works. Here is a simple comparison of the
most common methods.</p>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li><strong>Description</strong>: This is a simple way. It breaks the
problem into smaller parts. We look at all possible ways to climb the
stairs by calling the same function again.</li>
<li><strong>Complexity</strong>: It has an exponential time complexity
of (O(2^n)). This happens because of repeated calculations. It does not
work well for bigger inputs.</li>
<li><strong>Space Complexity</strong>: It uses (O(n)) for the recursion
stack.</li>
</ul></li>
<li><strong>Dynamic Programming (Top-Down with Memoization)</strong>:
<ul>
<li><strong>Description</strong>: This method saves results of previous
calculations. This way, we do not do the same work again. It builds on
the recursive method by storing results.</li>
<li><strong>Complexity</strong>: It has a linear time complexity of
(O(n)). Each state is calculated only one time.</li>
<li><strong>Space Complexity</strong>: It uses (O(n)) because of the
memoization table.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> climbStairs(n, constraints):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(i):</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> memo:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[i]</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> step <span class="kw">in</span> constraints:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            total <span class="op">+=</span> dp(i <span class="op">-</span> step)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        memo[i] <span class="op">=</span> total</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(n)</span></code></pre></div></li>
<li><strong>Dynamic Programming (Bottom-Up)</strong>:
<ul>
<li><strong>Description</strong>: This method builds the solution step
by step. It uses a table (array) to keep track of how many ways we can
reach each step until we get to the top.</li>
<li><strong>Complexity</strong>: It has a linear time complexity of
(O(n)).</li>
<li><strong>Space Complexity</strong>: It uses (O(n)) for the array, but
we can make it better.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> climbStairs(n, constraints):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> step <span class="kw">in</span> constraints:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> step <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> step]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div></li>
<li><strong>Optimized Space Complexity</strong>:
<ul>
<li><strong>Description</strong>: This method saves space by only
keeping the last few values we calculated. We do not need to store all
the values.</li>
<li><strong>Complexity</strong>: It has a linear time complexity of
(O(n)).</li>
<li><strong>Space Complexity</strong>: It uses constant space
(O(1)).</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> climbStairs(n, constraints):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    prev1, prev2 <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> step <span class="kw">in</span> constraints:</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> step <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>                total <span class="op">+=</span> prev1 <span class="cf">if</span> step <span class="op">==</span> <span class="dv">1</span> <span class="cf">else</span> prev2</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> total</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span></code></pre></div></li>
<li><strong>Mathematical Approach</strong>:
<ul>
<li><strong>Description</strong>: For some types of limits, we can use a
math formula or generating functions to get a quick answer.</li>
<li><strong>Complexity</strong>: It is often (O(1)) for direct
calculation, but it may need some prep work.</li>
<li><strong>Space Complexity</strong>: It uses very little space,
depending on how we do it.</li>
</ul></li>
</ol>
<p>In summary, picking the right method depends on the limits of the
problem, the size of (n), and how fast we need the answer. For most
cases, we prefer dynamic programming solutions. They give a good mix of
speed and simplicity. If we want to learn more, we can read about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming: Minimum Cost Climbing Stairs</a>.</p>
<h2 id="real-world-applications-of-climbing-stairs-problem">Real World
Applications of Climbing Stairs Problem</h2>
<p>The climbing stairs problem is important in dynamic programming. It
has many real-world uses in different areas. These uses take advantage
of simple optimization and solving problems step by step. Here are some
good examples:</p>
<ul>
<li><p><strong>Robotics and Path Planning:</strong> Robots that move in
a grid can use the climbing stairs algorithm. This helps them find how
many ways they can get to a place while avoiding obstacles. This method
is very important when robots must find the best path quickly.</p></li>
<li><p><strong>Game Development:</strong> In strategy games, players
have to move through levels. The climbing stairs problem can help figure
out different ways to move in the game. This can make the game more fun
and give players different strategies.</p></li>
<li><p><strong>Network Routing:</strong> In computer networks, we need
to find how many ways data can travel from one point to another. This
can be like the climbing stairs problem. It helps in making better
routing protocols.</p></li>
<li><p><strong>Resource Management:</strong> When we talk about resource
allocation, like giving tasks to workers or managing a project, the
climbing stairs problem can help. It shows different ways to give out
tasks while following rules.</p></li>
<li><p><strong>Financial Modeling:</strong> The problem can also be
useful in finance. For example, it can help predict how many ways we can
reach a certain investment goal over time. This includes limits like
budgets or time.</p></li>
<li><p><strong>Combinatorial Optimization:</strong> We can change many
optimization problems into climbing stairs problems. This way, we can
find different combinations or arrangements within certain
limits.</p></li>
</ul>
<p>Using the dynamic programming method to count ways to climb stairs
gives us a smart way to solve this problem. It also helps us understand
how to solve many real-world issues in different fields. For more
information on dynamic programming, check out this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number article</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-climbing-stairs-problem-in-dynamic-programming">1.
What is the climbing stairs problem in dynamic programming?</h3>
<p>The climbing stairs problem is a well-known challenge in dynamic
programming. We need to find out how many different ways we can reach
the top of a staircase with a certain number of steps. We can climb one
or two steps at a time. Sometimes, this problem has different rules that
make it harder.</p>
<h3
id="how-does-dynamic-programming-help-in-solving-the-climbing-stairs-problem">2.
How does dynamic programming help in solving the climbing stairs
problem?</h3>
<p>Dynamic programming helps us solve the climbing stairs problem
better. It does this by breaking the problem into smaller parts and
keeping track of the answers to these parts. This way, we do not have to
do the same calculations over and over again. This makes it faster to
find out how many ways we can climb the stairs with different rules.</p>
<h3
id="what-are-the-time-and-space-complexities-of-the-climbing-stairs-problem">3.
What are the time and space complexities of the climbing stairs
problem?</h3>
<p>When we use dynamic programming for the climbing stairs problem, the
time complexity is O(n). Here, n is the number of steps. The space
complexity can change based on how we do it. A simple recursive way uses
O(n) space because of the recursion stack. But if we use a smart
iterative way, we can lower it to O(1) by only keeping the last two
results.</p>
<h3
id="can-you-provide-an-example-of-a-climbing-stairs-problem-with-constraints">4.
Can you provide an example of a climbing stairs problem with
constraints?</h3>
<p>Sure! A common version of the climbing stairs problem has some rules.
For example, we might not be able to step on certain stairs because of
obstacles. If we have 5 stairs and step 3 is blocked, we must change how
we count the ways to climb. We should not count paths that go through
step 3. This makes it trickier to find the number of ways to climb.</p>
<h3
id="where-can-i-find-more-dynamic-programming-problems-similar-to-the-climbing-stairs-problem">5.
Where can I find more dynamic programming problems similar to the
climbing stairs problem?</h3>
<p>If we want to practice more problems like the climbing stairs
problem, we can check out some resources. For example, we can look at
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Min Cost Climbing Stairs</a>. These articles give good
examples and help us understand dynamic programming better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            