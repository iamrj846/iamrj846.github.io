
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Partition Equal Subset Sum - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Explore Dynamic Programming with our guide on Partition Equal Subset Sum. Learn strategies to solve this critical problem!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Partition Equal Subset Sum - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Partition Equal Subset Sum problem is a well-known challenge in
dynamic programming. It asks if we can split a set into two groups that
have the same total sum. To solve this, we need to check if we can find
a group in the set that adds up to half of the total sum of all
elements. We can solve this problem well using dynamic programming. This
way, we can explore possible groups without repeating our work.</p>
<p>In this article, we will look closely at the Partition Equal Subset
Sum problem. We will explain its definition and what the problem is
about. We will talk about different dynamic programming methods in Java,
Python, and C++. We will also discuss how to make our space use better.
Plus, we will look at recursive methods with memoization and ways to
solve it step by step. We will also give a full analysis of the time it
takes to run our solutions. By the end of this article, we will
understand how to solve the Partition Equal Subset Sum problem.</p>
<ul>
<li>Dynamically Solving Partition Equal Subset Sum Problem - Medium</li>
<li>Understanding the Problem Statement for Partition Equal Subset
Sum</li>
<li>Dynamic Programming Approach for Partition Equal Subset Sum in
Java</li>
<li>Dynamic Programming Approach for Partition Equal Subset Sum in
Python</li>
<li>Dynamic Programming Approach for Partition Equal Subset Sum in
C++</li>
<li>Optimizing Space Complexity for Partition Equal Subset Sum</li>
<li>Recursive Approach with Memoization for Partition Equal Subset
Sum</li>
<li>Iterative Approach for Partition Equal Subset Sum</li>
<li>Time Complexity Analysis for Partition Equal Subset Sum</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming techniques, we can
check out related articles. They can help us understand better. Some of
them are <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming on Fibonacci Numbers</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2
id="understanding-the-problem-statement-for-partition-equal-subset-sum">Understanding
the Problem Statement for Partition Equal Subset Sum</h2>
<p>The Partition Equal Subset Sum problem is a well-known issue in
computer science. It asks if we can split a set of non-negative numbers
into two groups. The sum of the numbers in both groups should be the
same.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have an array of integers called <code>nums</code>. Our job is to
check if we can split it into two groups with equal sums. We need to
follow these rules:</p>
<ol type="1">
<li>The total sum of all numbers in the array must be even. If the total
sum is odd, we cannot split it into two equal groups.</li>
<li>If the total sum is even, we call it <code>totalSum</code>. We need
to find one group that adds up to <code>totalSum / 2</code>.</li>
<li>We can use dynamic programming methods to solve the problem.</li>
</ol>
<h3 id="example">Example</h3>
<p>Let us look at the input array:</p>
<pre><code>nums = [1, 5, 11, 5]</code></pre>
<ul>
<li>The total sum is <code>1 + 5 + 11 + 5 = 22</code>, which is
even.</li>
<li>We need to find a group that adds up to
<code>22 / 2 = 11</code>.</li>
<li>One way to split it is <code>[1, 5, 5]</code> and <code>[11]</code>.
Both groups add up to <code>11</code>.</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The length of <code>nums</code> can be from <code>1</code> to
<code>200</code>.</li>
<li>Each number can be from <code>0</code> to <code>1000</code>.</li>
</ul>
<p>Our aim is to create a smart algorithm that can find out if we can
make such a split. We will use dynamic programming to make the solution
better.</p>
<h2
id="dynamic-programming-approach-for-partition-equal-subset-sum-in-java">Dynamic
Programming Approach for Partition Equal Subset Sum in Java</h2>
<p>To solve the Partition Equal Subset Sum problem using dynamic
programming in Java, we need to check if we can split a set into two
groups. These groups must have the same total. If the total sum of the
array is odd, we cannot split it. So first, we check if the total sum is
even. If it is even, we then look for a group that adds up to half of
the total sum.</p>
<h3 id="steps-to-implement">Steps to Implement:</h3>
<ol type="1">
<li>Find the total sum of the array.</li>
<li>If the total sum is odd, we return false.</li>
<li>Create a boolean DP array. In this array, <code>dp[j]</code> tells
if we can make a group with sum <code>j</code>.</li>
<li>Go through the numbers in the array and update the DP array.</li>
</ol>
<h3 id="java-code-implementation">Java Code Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PartitionEqualSubsetSum <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">canPartition</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> totalSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            totalSum <span class="op">+=</span> num<span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If total sum is odd, we cannot partition it into two equal subsets</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>totalSum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> target <span class="op">=</span> totalSum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// A sum of 0 can always be achieved</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> target<span class="op">;</span> j <span class="op">&gt;=</span> num<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> num<span class="op">];</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>target<span class="op">];</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        PartitionEqualSubsetSum solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">PartitionEqualSubsetSum</span><span class="op">();</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>solution<span class="op">.</span><span class="fu">canPartition</span><span class="op">(</span>nums<span class="op">));</span> <span class="co">// Output: true</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li>The <code>canPartition</code> method finds the total sum of the
input array.</li>
<li>It checks if the total sum is even. If it is not even, it returns
<code>false</code>.</li>
<li>The <code>dp</code> array starts to track sums we can make up to the
target sum.</li>
<li>The loops update the <code>dp</code> array based on the numbers in
the input array.</li>
<li>In the end, it checks if we can make the target sum.</li>
</ul>
<p>This way we use dynamic programming to solve the Partition Equal
Subset Sum problem. The time complexity is O(n * target) and the space
complexity is O(target).</p>
<h2
id="dynamic-programming-approach-for-partition-equal-subset-sum-in-python">Dynamic
Programming Approach for Partition Equal Subset Sum in Python</h2>
<p>We can solve the Partition Equal Subset Sum problem well using a
dynamic programming method. Our goal is to check if we can split a set
into two subsets. Both subsets should have the same sum.</p>
<h3 id="problem-formulation">Problem Formulation</h3>
<p>We start with a set of numbers. First, we need to find the total sum.
If the total sum is odd, we cannot split the set into two equal parts.
In this case, we return <code>False</code>. If the sum is even, we look
for a subset that has a sum equal to half of the total sum. We call this
half <code>target</code>.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>We will make a boolean array called <code>dp</code>. In this array,
<code>dp[i]</code> is <code>True</code> if we can form a subset with sum
<code>i</code> from the numbers we have.</p>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canPartition(nums):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    total_sum <span class="op">=</span> <span class="bu">sum</span>(nums)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If the total sum is odd, we cannot split it into two equal subsets</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total_sum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> total_sum <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (target <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span>  <span class="co"># A sum of 0 can always be formed with no elements</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Traverse backwards to ensure we do not use the same number more than once</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(target, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> dp[i] <span class="kw">or</span> dp[i <span class="op">-</span> num]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[target]</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">11</span>, <span class="dv">5</span>]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(canPartition(nums))  <span class="co"># Output: True</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ol type="1">
<li><strong>Calculate Total Sum</strong>: We find the total sum of the
input list.</li>
<li><strong>Check for Odd Total</strong>: If the total sum is odd, we
return <code>False</code>.</li>
<li><strong>Initialize DP Array</strong>: We create a DP array that is
size <code>target + 1</code>. We set <code>dp[0]</code> to
<code>True</code> because we can always get a sum of 0.</li>
<li><strong>Filling the DP array</strong>: For each number in the list,
we update the DP array from back to front. This way, we do not count the
same number more than once.</li>
<li><strong>Return Result</strong>: Finally, we return
<code>dp[target]</code>. This tells us if a subset with the target sum
exists.</li>
</ol>
<p>This method runs in O(n * target) time. Here, <code>n</code> is the
number of elements in the list. The space we use is O(target) because of
the DP array.</p>
<p>For more about dynamic programming, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a>. It is a similar use of dynamic
programming techniques.</p>
<h2
id="dynamic-programming-approach-for-partition-equal-subset-sum-in-c">Dynamic
Programming Approach for Partition Equal Subset Sum in C++</h2>
<p>The Partition Equal Subset Sum problem is about checking if we can
split a set into two groups. The sum of the numbers in both groups
should be the same. We can use the dynamic programming method to solve
this. It is based on the subset sum problem.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ol type="1">
<li><strong>Input</strong>: An array <code>nums</code> of non-negative
numbers.</li>
<li><strong>Goal</strong>: We want to see if there is a group of
<code>nums</code> that adds up to <code>total/2</code>. Here,
<code>total</code> is the sum of all numbers in <code>nums</code>.</li>
<li><strong>Condition</strong>: If <code>total</code> is odd, we cannot
split the set.</li>
</ol>
<h3 id="dynamic-programming-table">Dynamic Programming Table</h3>
<p>We use a 2D boolean array <code>dp</code>. The value
<code>dp[i][j]</code> shows if we can make a sum <code>j</code> using
the first <code>i</code> numbers from the array.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> canPartition<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> num<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>total <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> target <span class="op">=</span> total <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize the dp array</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Sum 0 is always possible</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the dp table</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> target<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]];</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>target<span class="op">];</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>canPartition<span class="op">(</span>nums<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Can partition the array into two subsets of equal sum.&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Cannot partition the array into two subsets of equal sum.&quot;</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>We first find the total sum of the input array.</li>
<li>If the total is odd, we return false right away.</li>
<li>Then, we set up a DP table to track possible sums.</li>
<li>The loops fill this table. We decide to include or exclude each
number.</li>
<li>At the end, we check if <code>dp[n][target]</code> is true. This
means we can split the set.</li>
</ul>
<p>This C++ solution uses dynamic programming well. It checks if we can
split the array into two equal sum groups. The time needed is O(n *
target) and the space used is O(n * target). For more on similar
problems, look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2
id="optimizing-space-complexity-for-partition-equal-subset-sum">Optimizing
Space Complexity for Partition Equal Subset Sum</h2>
<p>We can make the space use better for the Partition Equal Subset Sum
problem by using a 1D array instead of a 2D array. This problem asks if
we can split a set into two subsets with the same sum. We need to look
at the sums we can get instead of the actual subsets.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Define the Target Sum</strong>: We get the target sum by
taking half of the total sum of the array. If the total sum is odd, we
cannot split it into two equal subsets.</p></li>
<li><p><strong>Initialize a 1D Array</strong>: We create a boolean array
<code>dp</code> with size <code>target + 1</code>. The
<code>dp[j]</code> tells us if we can make a subset with sum
<code>j</code>.</p></li>
<li><p><strong>Iterate Through the Array</strong>: For each number in
the input array, we update the <code>dp</code> array from the back to
avoid changing results we still need.</p></li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<h4 id="java">Java</h4>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">canPartition</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> total <span class="op">+=</span> num<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>total <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> target <span class="op">=</span> total <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> target<span class="op">;</span> j <span class="op">&gt;=</span> num<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> num<span class="op">];</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>target<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python">Python</h4>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canPartition(nums):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    total <span class="op">=</span> <span class="bu">sum</span>(nums)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> total <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (target <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(target, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">=</span> dp[j] <span class="kw">or</span> dp[j <span class="op">-</span> num]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[target]</span></code></pre></div>
<h4 id="c">C++</h4>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> canPartition<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total <span class="op">=</span> accumulate<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>total <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> target <span class="op">=</span> total <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> dp<span class="op">(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> target<span class="op">;</span> j <span class="op">&gt;=</span> num<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> num<span class="op">];</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>target<span class="op">];</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li>The space complexity is O(target) now instead of O(n * target).
Here, n is how many elements are in the input array. This change helps
us deal with bigger inputs better.</li>
</ul>
<p>By using this better way, we improve how the Partition Equal Subset
Sum problem works while keeping the code clear and useful. For more
about dynamic programming, we can look at topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2
id="recursive-approach-with-memoization-for-partition-equal-subset-sum">Recursive
Approach with Memoization for Partition Equal Subset Sum</h2>
<p>We can solve the Partition Equal Subset Sum problem using a recursive
way with memoization. This method helps by saving results from our
calculations. So we do not need to do the same work again.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have a set of integers. Our goal is to see if we can split it into
two groups. The sum of numbers in both groups should be the same. The
recursive function will check if we can create a group with a specific
sum using the numbers in the array.</p>
<h3 id="recursive-function-with-memoization">Recursive Function with
Memoization</h3>
<p>The recursive function needs three things: the current position in
the array, the sum we still need, and a memoization table to keep the
results we have already found.</p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PartitionEqualSubsetSum <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">canPartition</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> totalSum <span class="op">=</span> <span class="bu">Arrays</span><span class="op">.</span><span class="fu">stream</span><span class="op">(</span>nums<span class="op">).</span><span class="fu">sum</span><span class="op">();</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>totalSum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// If total sum is odd we cannot split</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> target <span class="op">=</span> totalSum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Boolean</span><span class="op">[][]</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">Boolean</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">][</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">canPartitionRecursive</span><span class="op">(</span>nums<span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> target<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">canPartitionRecursive</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> index<span class="op">,</span> <span class="dt">int</span> sum<span class="op">,</span> <span class="bu">Boolean</span><span class="op">[][]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>sum <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// We found a group with the right sum</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> sum <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span> <span class="co">// Out of bounds or negative sum</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">]</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">];</span> <span class="co">// Return saved result</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We can include the current number or not</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> include <span class="op">=</span> <span class="fu">canPartitionRecursive</span><span class="op">(</span>nums<span class="op">,</span> index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> sum <span class="op">-</span> nums<span class="op">[</span>index<span class="op">],</span> memo<span class="op">);</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> exclude <span class="op">=</span> <span class="fu">canPartitionRecursive</span><span class="op">(</span>nums<span class="op">,</span> index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> sum<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">]</span> <span class="op">=</span> include <span class="op">||</span> exclude<span class="op">;</span> <span class="co">// Save the result</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">];</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> can_partition(nums):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    total_sum <span class="op">=</span> <span class="bu">sum</span>(nums)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total_sum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># If total sum is odd we cannot split</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> total_sum <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> can_partition_recursive(nums, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>, target, memo)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> can_partition_recursive(nums, index, sum_remaining, memo):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> sum_remaining <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># We found a group with the right sum</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> index <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> sum_remaining <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Out of bounds or negative sum</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (index, sum_remaining) <span class="kw">in</span> memo:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(index, sum_remaining)]  <span class="co"># Return saved result</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We can include the current number or not</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> can_partition_recursive(nums, index <span class="op">-</span> <span class="dv">1</span>, sum_remaining <span class="op">-</span> nums[index], memo)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> can_partition_recursive(nums, index <span class="op">-</span> <span class="dv">1</span>, sum_remaining, memo)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    memo[(index, sum_remaining)] <span class="op">=</span> include <span class="kw">or</span> exclude  <span class="co"># Save the result</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[(index, sum_remaining)]</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;numeric&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> canPartition<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> totalSum <span class="op">=</span> <span class="bu">std::</span>accumulate<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>totalSum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// If total sum is odd we cannot split</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> target <span class="op">=</span> totalSum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> memo<span class="op">(</span>nums<span class="op">.</span>size<span class="op">(),</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> canPartitionRecursive<span class="op">(</span>nums<span class="op">,</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> target<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> canPartitionRecursive<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> index<span class="op">,</span> <span class="dt">int</span> sum<span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>sum <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span>  <span class="co">// We found a group with the right sum</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>index <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> sum <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span>  <span class="co">// Out of bounds or negative sum</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">];</span>  <span class="co">// Return saved result</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We can include the current number or not</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> include <span class="op">=</span> canPartitionRecursive<span class="op">(</span>nums<span class="op">,</span> index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> sum <span class="op">-</span> nums<span class="op">[</span>index<span class="op">],</span> memo<span class="op">);</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">bool</span> exclude <span class="op">=</span> canPartitionRecursive<span class="op">(</span>nums<span class="op">,</span> index <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> sum<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">]</span> <span class="op">=</span> include <span class="op">||</span> exclude<span class="op">;</span>  <span class="co">// Save the result</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>index<span class="op">][</span>sum<span class="op">];</span></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<p>The recursive way with memoization makes the time to solve this
problem much shorter than a simple recursive way. This method uses the
idea of repeating problems and keeps results in a memoization table. It
works well for medium input sizes where the total sum is not too
big.</p>
<h2 id="iterative-approach-for-partition-equal-subset-sum">Iterative
Approach for Partition Equal Subset Sum</h2>
<p>We use the iterative approach to solve the Partition Equal Subset Sum
problem. This method uses a dynamic programming table. It helps us build
solutions based on values we already calculated. Our goal is to find out
if we can split a given set into two subsets. The sum of the elements in
both subsets should be the same.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have an array called <code>nums</code>. We need to check if it can
be divided into two subsets with equal sum. The target sum for each
subset is <code>totalSum/2</code>. Here, <code>totalSum</code> is the
total of all elements in <code>nums</code>. If <code>totalSum</code> is
odd, we can quickly say false.</p>
<h3 id="steps-to-implement-the-iterative-approach">Steps to Implement
the Iterative Approach</h3>
<ol type="1">
<li>First, we calculate the total sum of the array. If it is odd, we
return false.</li>
<li>Next, we set up a boolean DP array <code>dp</code> that is
<code>target + 1</code> in size. The <code>target</code> is
<code>totalSum / 2</code>.</li>
<li>We set <code>dp[0] = true</code> because we can always make a sum of
0 with an empty subset.</li>
<li>We go through each number in <code>nums</code> and update the DP
table from the back. This way, we do not overwrite any values.</li>
<li>The final answer will be in <code>dp[target]</code>.</li>
</ol>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">canPartition</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> totalSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> totalSum <span class="op">+=</span> num<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>totalSum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> target <span class="op">=</span> totalSum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> target<span class="op">;</span> j <span class="op">&gt;=</span> num<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> num<span class="op">];</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>target<span class="op">];</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-1">Python Implementation</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> canPartition(nums):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    total_sum <span class="op">=</span> <span class="bu">sum</span>(nums)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> total_sum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    target <span class="op">=</span> total_sum <span class="op">//</span> <span class="dv">2</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> (target <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(target, num <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">=</span> dp[j] <span class="kw">or</span> dp[j <span class="op">-</span> num]</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[target]</span></code></pre></div>
<h3 id="c-implementation-2">C++ Implementation</h3>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">bool</span> canPartition<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> totalSum <span class="op">=</span> accumulate<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">(),</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>totalSum <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> target <span class="op">=</span> totalSum <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> dp<span class="op">(</span>target <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> target<span class="op">;</span> j <span class="op">&gt;=</span> num<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> dp<span class="op">[</span>j <span class="op">-</span> num<span class="op">];</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>target<span class="op">];</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for the iterative approach is O(n * target).
Here, <code>n</code> is the number of elements in <code>nums</code> and
<code>target</code> is <code>totalSum / 2</code>. The space complexity
is O(target) because of the DP array we use.</p>
<p>This iterative dynamic programming method checks if we can divide the
given array into two subsets with equal sum. It is a basic technique for
solving similar subset-sum problems. For more reading on related topics,
you can check articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths</a>.</p>
<h2 id="time-complexity-analysis-for-partition-equal-subset-sum">Time
Complexity Analysis for Partition Equal Subset Sum</h2>
<p>We can solve the Partition Equal Subset Sum problem using dynamic
programming. The time it takes to solve this problem mainly depends on
how many items we have and the target sum from the input array.</p>
<ol type="1">
<li><strong>Dynamic Programming Table Construction</strong>:
<ul>
<li>Let ( n ) be the number of items in the array. Let ( S ) be the
total sum of the items.</li>
<li>We need to find if there is a subset that adds up to ( S/2 ).</li>
<li>The dynamic programming method uses a 2D table
<code>dp[n+1][S/2 + 1]</code>. Here:
<ul>
<li>The rows show the items (from 0 to ( n )).</li>
<li>The columns show the possible sums (from 0 to ( S/2 )).</li>
</ul></li>
<li>This gives us a time complexity of ( O(n S) ).</li>
</ul></li>
<li><strong>Space Optimization</strong>:
<ul>
<li>We can make the space needed smaller. Instead of using a 2D array,
we can use a 1D array. This gives us a space complexity of ( O(S) ):
<ul>
<li>We only need the current and previous states to find the
answer.</li>
</ul></li>
<li>The time complexity is still ( O(n S ). But now, the space needed is
less.</li>
</ul></li>
<li><strong>Example</strong>:
<ul>
<li>Let’s take the array ([1, 5, 11, 5]) which has a total sum ( S = 22
).</li>
<li>We will look for a subset sum of ( 11 ).</li>
<li>The DP table will be ( 5 ) (for 4 items and sums from 0 to 11).</li>
</ul></li>
<li><strong>Final Time Complexity</strong>:
<ul>
<li>So, the total time complexity to solve the Partition Equal Subset
Sum problem using dynamic programming is:
<ul>
<li>( O(n S) ). Here ( n ) is the number of items and ( S ) is the
target sum ( S/2 ).</li>
</ul></li>
</ul></li>
</ol>
<p>This analysis shows how we can use dynamic programming to solve the
Partition Equal Subset Sum problem efficiently in terms of time and
space.</p>
<p>For more information about dynamic programming, we can check articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-partition-equal-subset-sum-problem">What is the
Partition Equal Subset Sum problem?</h3>
<p>The Partition Equal Subset Sum problem is a well-known challenge in
algorithms. It asks if we can split a set of numbers into two groups
with the same total. This problem uses dynamic programming. We create a
solution by solving smaller problems step by step. Knowing this problem
helps us learn dynamic programming better.</p>
<h3
id="how-can-i-implement-the-dynamic-programming-approach-for-the-partition-equal-subset-sum-in-java">How
can I implement the dynamic programming approach for the Partition Equal
Subset Sum in Java?</h3>
<p>To use dynamic programming for the Partition Equal Subset Sum problem
in Java, we can make a 2D boolean array. This array shows if we can
reach certain sums with subsets. The outer loop goes through the
numbers. The inner loop checks for possible sums. For a full example,
check our <a href="#">Dynamic Programming Approach for Partition Equal
Subset Sum in Java</a>.</p>
<h3
id="what-is-the-time-complexity-of-the-partition-equal-subset-sum-algorithm">What
is the time complexity of the Partition Equal Subset Sum algorithm?</h3>
<p>The time complexity for the dynamic programming approach for the
Partition Equal Subset Sum problem is O(n * sum). Here ‘n’ is the count
of numbers in the array. ‘sum’ is half of the total sum of the numbers.
This complexity comes from the nested loops we use to fill the DP table.
Looking at time complexity helps us make solutions better for large
inputs.</p>
<h3
id="can-the-partition-equal-subset-sum-problem-be-solved-using-recursion">Can
the Partition Equal Subset Sum problem be solved using recursion?</h3>
<p>Yes, we can solve the Partition Equal Subset Sum problem with
recursion. We often add memoization to avoid doing the same work again.
This method checks all possible groups to see if we can find a valid
split. For more details, see our section on the <a href="#">Recursive
Approach with Memoization for Partition Equal Subset Sum</a>.</p>
<h3
id="how-does-space-complexity-affect-the-partition-equal-subset-sum-solution">How
does space complexity affect the Partition Equal Subset Sum
solution?</h3>
<p>Space complexity is very important in dynamic programming for the
Partition Equal Subset Sum problem. The usual DP method uses O(n * sum)
space because of the 2D array. But we can make it better to O(sum) by
using a 1D array and updating it directly. This change is important for
saving memory. For more info, check our section on <a
href="#">Optimizing Space Complexity for Partition Equal Subset
Sum</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            