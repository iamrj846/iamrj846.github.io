
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Interleaving String - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content=""Explore the Interleaving String problem using dynamic programming. Learn techniques, solutions, and examples in our detailed guide!"">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Interleaving String - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Interleaving String problem is a well-known challenge in dynamic
programming. It asks us to check if a string <code>s3</code> is made by
mixing two other strings, <code>s1</code> and <code>s2</code>. We need
to see if we can combine all letters from <code>s1</code> and
<code>s2</code> while keeping their order in <code>s3</code>. We can
solve this problem well using different dynamic programming methods.
These methods can be recursive or iterative. They help us get good
performance.</p>
<p>In this article, we will look at the Interleaving String problem
closely. We will define it and discuss different ways to solve it. We
will also show how to implement these solutions in various programming
languages. We will cover the dynamic programming method, recursive
solutions, and space-saving techniques. We will give practical examples
in Java, Python, and C++. Also, we will talk about testing methods, how
to check performance, and answer common questions. This will help us
understand the topic better.</p>
<ul>
<li>Dynamic Programming Approach to Interleaving String - Medium</li>
<li>Understanding the Interleaving String Problem</li>
<li>Recursive Solution for Interleaving String in Java</li>
<li>Dynamic Programming Solution for Interleaving String in Python</li>
<li>Bottom-Up Dynamic Programming Approach in C++</li>
<li>Space Optimized Dynamic Programming Solution in Java</li>
<li>Memoization Technique for Interleaving String in Python</li>
<li>Testing and Validating Interleaving String Solutions</li>
<li>Performance Analysis of Interleaving String Algorithms</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-interleaving-string-problem">Understanding the
Interleaving String Problem</h2>
<p>The Interleaving String problem is a well-known problem in dynamic
programming. It asks if we can make a string <code>s3</code> by mixing
two other strings, <code>s1</code> and <code>s2</code>. The letters from
<code>s1</code> and <code>s2</code> must keep their order in
<code>s3</code>.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have three strings: <code>s1</code>, <code>s2</code>, and
<code>s3</code>. Our job is to see if <code>s3</code> is made by mixing
<code>s1</code> and <code>s2</code>.</p>
<h3 id="key-conditions">Key Conditions</h3>
<ol type="1">
<li><p>The length of <code>s3</code> must be equal to the total lengths
of <code>s1</code> and <code>s2</code>: [ (s3) = (s1) + (s2) ]</p></li>
<li><p>The letters from both <code>s1</code> and <code>s2</code> must
show up in <code>s3</code> in the same order as they are in
<code>s1</code> and <code>s2</code>.</p></li>
</ol>
<h3 id="example">Example</h3>
<ul>
<li><p><strong>Input:</strong> <code>s1 = "aab"</code>,
<code>s2 = "axy"</code>, <code>s3 = "aabyx"</code></p></li>
<li><p><strong>Output:</strong> <code>True</code> (because “aab” and
“axy” can mix to make “aabyx”)</p></li>
<li><p><strong>Input:</strong> <code>s1 = "aab"</code>,
<code>s2 = "axy"</code>, <code>s3 = "aaaxy"</code></p></li>
<li><p><strong>Output:</strong> <code>False</code> (the letter ‘x’ from
<code>s2</code> can’t come after ‘a’ from <code>s1</code> in this
order)</p></li>
</ul>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>To solve this problem with dynamic programming, we can build a 2D
table called <code>dp[i][j]</code>. Here, <code>dp[i][j]</code> tells if
<code>s3[0...i+j-1]</code> can be made by mixing
<code>s1[0...i-1]</code> and <code>s2[0...j-1]</code>.</p>
<h3 id="transition-formula">Transition Formula</h3>
<ul>
<li>Base Case: <code>dp[0][0] = True</code></li>
<li>For each <code>i</code> and <code>j</code>:
<ul>
<li>If the current letter of <code>s1</code> matches with
<code>s3</code>, then: [ dp[i][j] = dp[i-1][j] s1[i-1] == s3[i+j-1]
]</li>
<li>If the current letter of <code>s2</code> matches with
<code>s3</code>, then: [ dp[i][j] = dp[i][j-1] s2[j-1] == s3[i+j-1]
]</li>
</ul></li>
</ul>
<p>This way gives us a good solution to the Interleaving String problem.
We can check interleavings in a clear way.</p>
<p>For more practice with dynamic programming, we can check out other
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2 id="recursive-solution-for-interleaving-string-in-java">Recursive
Solution for Interleaving String in Java</h2>
<p>The interleaving string problem asks if we can make a string
<code>s3</code> by mixing two other strings <code>s1</code> and
<code>s2</code>. We can solve this problem using a recursive method.
This method looks at all the ways we can mix <code>s1</code> and
<code>s2</code> to match <code>s3</code>.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a simple recursive solution in Java:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> InterleavingString <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isInterleave</span><span class="op">(</span><span class="bu">String</span> s1<span class="op">,</span> <span class="bu">String</span> s2<span class="op">,</span> <span class="bu">String</span> s3<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>s1<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">+</span> s2<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">!=</span> s3<span class="op">.</span><span class="fu">length</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">isInterleaveHelper</span><span class="op">(</span>s1<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> s2<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> s3<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">boolean</span> <span class="fu">isInterleaveHelper</span><span class="op">(</span><span class="bu">String</span> s1<span class="op">,</span> <span class="dt">int</span> i<span class="op">,</span> <span class="bu">String</span> s2<span class="op">,</span> <span class="dt">int</span> j<span class="op">,</span> <span class="bu">String</span> s3<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> s3<span class="op">.</span><span class="fu">length</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> fromS1 <span class="op">=</span> <span class="op">(</span>i <span class="op">&lt;</span> s1<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">&amp;&amp;</span> s1<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>k<span class="op">))</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">isInterleaveHelper</span><span class="op">(</span>s1<span class="op">,</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> s2<span class="op">,</span> j<span class="op">,</span> s3<span class="op">,</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> fromS2 <span class="op">=</span> <span class="op">(</span>j <span class="op">&lt;</span> s2<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">&amp;&amp;</span> s2<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>k<span class="op">))</span> <span class="op">&amp;&amp;</span> </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                         <span class="fu">isInterleaveHelper</span><span class="op">(</span>s1<span class="op">,</span> i<span class="op">,</span> s2<span class="op">,</span> j <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> s3<span class="op">,</span> k <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> fromS1 <span class="op">||</span> fromS2<span class="op">;</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        InterleavingString solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">InterleavingString</span><span class="op">();</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s1 <span class="op">=</span> <span class="st">&quot;aab&quot;</span><span class="op">;</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s2 <span class="op">=</span> <span class="st">&quot;axy&quot;</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s3 <span class="op">=</span> <span class="st">&quot;aaxaby&quot;</span><span class="op">;</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span>solution<span class="op">.</span><span class="fu">isInterleave</span><span class="op">(</span>s1<span class="op">,</span> s2<span class="op">,</span> s3<span class="op">));</span> <span class="co">// Output: true</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The <code>isInterleave</code> method checks if the total length of
<code>s1</code> and <code>s2</code> is the same as the length of
<code>s3</code>. If they do not match, it returns false.</li>
<li>The <code>isInterleaveHelper</code> method uses recursion to check
two important things:
<ul>
<li>If the current character of <code>s3</code> is the same as the
character from <code>s1</code>, it calls itself with the next character
of <code>s1</code>.</li>
<li>If the current character of <code>s3</code> is the same as the
character from <code>s2</code>, it calls itself with the next character
of <code>s2</code>.</li>
</ul></li>
<li>The recursion keeps going until we match all characters in
<code>s3</code>, which then returns true.</li>
</ul>
<p>This recursive method has a time complexity of O(2^(m+n)), where m
and n are the lengths of <code>s1</code> and <code>s2</code>. This might
not be fast for big strings. So, we can think about using dynamic
programming to make it better.</p>
<p>For more ways to improve this, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Approach to Interleaving String - Medium</a>.</p>
<h2
id="dynamic-programming-solution-for-interleaving-string-in-python">Dynamic
Programming Solution for Interleaving String in Python</h2>
<p>The interleaving string problem is about checking if we can make a
string <code>s3</code> by mixing characters from two strings
<code>s1</code> and <code>s2</code>. We can use dynamic programming to
solve this problem in a smart way.</p>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<ol type="1">
<li><p><strong>Define a 2D DP Array</strong>: We use
<code>dp[i][j]</code> to show if the first <code>i</code> characters of
<code>s1</code> and the first <code>j</code> characters of
<code>s2</code> can create the first <code>i+j</code> characters of
<code>s3</code>.</p></li>
<li><p><strong>Base Case</strong>: We set <code>dp[0][0]</code> to
<code>True</code> because two empty strings can make an empty
string.</p></li>
<li><p><strong>Fill the DP Table</strong>:</p>
<ul>
<li>If the last character of <code>s3</code> matches the last character
of <code>s1</code>, we check the previous state
<code>dp[i-1][j]</code>.</li>
<li>If the last character of <code>s3</code> matches the last character
of <code>s2</code>, we check the previous state
<code>dp[i][j-1]</code>.</li>
</ul></li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isInterleave(s1: <span class="bu">str</span>, s2: <span class="bu">str</span>, s3: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(s1) <span class="op">+</span> <span class="bu">len</span>(s2) <span class="op">!=</span> <span class="bu">len</span>(s3):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> (<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s1[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i][j] <span class="kw">or</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> s2[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i][j] <span class="kw">or</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="bu">len</span>(s1)][<span class="bu">len</span>(s2)]</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Input Validation</strong>: First, we check if the total
length of <code>s1</code> and <code>s2</code> is the same as
<code>s3</code>.</li>
<li><strong>DP Table Creation</strong>: We make a 2D list
<code>dp</code>, starting with <code>False</code>, and set
<code>dp[0][0]</code> to <code>True</code>.</li>
<li><strong>DP Table Filling</strong>: We go through each character of
<code>s1</code> and <code>s2</code> with loops. We update the DP table
based on whether characters match with <code>s3</code>.</li>
<li><strong>Result</strong>: The value at
<code>dp[len(s1)][len(s2)]</code> tells us if we can form
<code>s3</code> by mixing <code>s1</code> and <code>s2</code>.</li>
</ul>
<p>This dynamic programming solution is fast. It has a time complexity
of O(n * m) where n and m are the lengths of <code>s1</code> and
<code>s2</code>.</p>
<p>For more on dynamic programming, we can check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="bottom-up-dynamic-programming-approach-in-c">Bottom-Up Dynamic
Programming Approach in C++</h2>
<p>We use the Bottom-Up Dynamic Programming method to solve the
Interleaving String problem. This method builds a 2D table. The table
helps us store results from smaller problems. We fill the table step by
step. This way, we do not need to use recursion.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have three strings <code>s1</code>, <code>s2</code>, and
<code>s3</code>. Our job is to check if <code>s3</code> is made by
mixing <code>s1</code> and <code>s2</code>. This means <code>s3</code>
must keep the order of characters from <code>s1</code> and
<code>s2</code>.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ code that shows the Bottom-Up Dynamic
Programming approach:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> isInterleave<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>s1<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span>s2<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span>s3<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> l1 <span class="op">=</span> s1<span class="op">.</span>size<span class="op">(),</span> l2 <span class="op">=</span> s2<span class="op">.</span>size<span class="op">(),</span> l3 <span class="op">=</span> s3<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>l1 <span class="op">+</span> l2 <span class="op">!=</span> l3<span class="op">)</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>l1 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>l2 <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> l1<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>s1<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s3<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> l2<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>s2<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s3<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> l1<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> l2<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> s1<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s3<span class="op">[</span>i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">||</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                       <span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> s2<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> s3<span class="op">[</span>i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>l1<span class="op">][</span>l2<span class="op">];</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>We check if the total length of <code>s1</code> and <code>s2</code>
is the same as <code>s3</code>. If not, we return false.</li>
<li>We create a 2D vector <code>dp</code>. Here, <code>dp[i][j]</code>
tells us if we can make <code>s3</code> using <code>s1</code> and
<code>s2</code> up to length <code>i</code> and <code>j</code>.</li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li>We fill the first row and column. We do this based on if characters
from <code>s1</code> and <code>s2</code> match the ones in
<code>s3</code>.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>We go through each character in <code>s1</code> and <code>s2</code>.
We update the <code>dp</code> table depending on whether the current
characters match the character in <code>s3</code>.</li>
</ul></li>
<li><strong>Final Result</strong>:
<ul>
<li>The value <code>dp[l1][l2]</code> shows if we can make
<code>s3</code> by mixing <code>s1</code> and <code>s2</code>.</li>
</ul></li>
</ol>
<p>This method runs in O(n * m) time and uses O(n * m) space. Here, n
and m are the lengths of <code>s1</code> and <code>s2</code>.</p>
<p>For more information on dynamic programming, you can check these
articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a>.</p>
<h2 id="space-optimized-dynamic-programming-solution-in-java">Space
Optimized Dynamic Programming Solution in Java</h2>
<p>We can use a Space Optimized Dynamic Programming method to solve the
Interleaving String problem. This method uses a 1D array instead of a 2D
array. It helps us save memory. We only need to keep track of the last
state to find the current state.</p>
<p>Here is a simple Java code for this space optimized solution:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> InterleavingString <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">boolean</span> <span class="fu">isInterleave</span><span class="op">(</span><span class="bu">String</span> s1<span class="op">,</span> <span class="bu">String</span> s2<span class="op">,</span> <span class="bu">String</span> s3<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s1<span class="op">.</span><span class="fu">length</span><span class="op">(),</span> n <span class="op">=</span> s2<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>m <span class="op">+</span> n <span class="op">!=</span> s3<span class="op">.</span><span class="fu">length</span><span class="op">())</span> <span class="cf">return</span> <span class="kw">false</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> s2<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&amp;&amp;</span> s1<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> s1<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">||</span> </span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                         <span class="op">(</span>dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> s2<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> s3<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        InterleavingString solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">InterleavingString</span><span class="op">();</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s1 <span class="op">=</span> <span class="st">&quot;aab&quot;</span><span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s2 <span class="op">=</span> <span class="st">&quot;axy&quot;</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s3 <span class="op">=</span> <span class="st">&quot;aaxaby&quot;</span><span class="op">;</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span> result <span class="op">=</span> solution<span class="op">.</span><span class="fu">isInterleave</span><span class="op">(</span>s1<span class="op">,</span> s2<span class="op">,</span> s3<span class="op">);</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Is Interleaving: &quot;</span> <span class="op">+</span> result<span class="op">);</span>  <span class="co">// Output: true</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We create a boolean array
<code>dp</code> to keep results of smaller problems. The size of the
array is <code>n + 1</code>. Here <code>n</code> is the length of the
second string.</li>
<li><strong>First Pass</strong>: We fill the first row of the
<code>dp</code> array. We compare characters from <code>s2</code> with
<code>s3</code>.</li>
<li><strong>Second Pass</strong>: We go through each character of
<code>s1</code>. We update the <code>dp</code> array based on matches of
current characters from <code>s1</code> and <code>s2</code> with
<code>s3</code>.</li>
<li>The final answer is in <code>dp[n]</code>. It tells us if
<code>s3</code> can be made by mixing <code>s1</code> and
<code>s2</code>.</li>
</ul>
<p>This way of solving keeps the time complexity as (O(m n)). It also
reduces the space complexity to (O(n)). This makes it fast for bigger
inputs. We can read more about dynamic programming methods in <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="memoization-technique-for-interleaving-string-in-python">Memoization
Technique for Interleaving String in Python</h2>
<p>We can use the memoization technique to solve the interleaving string
problem. This method improves the recursive solution by saving results
we already calculated. This way, we avoid doing the same work again. It
also lowers the time complexity from exponential to polynomial.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>We have three strings <code>s1</code>, <code>s2</code>, and
<code>s3</code>. We need to check if <code>s3</code> is made by mixing
<code>s1</code> and <code>s2</code>. When we mix two strings, we keep
the order of their characters.</p>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is a simple Python code using the memoization method:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isInterleave(s1: <span class="bu">str</span>, s2: <span class="bu">str</span>, s3: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n1, n2, n3 <span class="op">=</span> <span class="bu">len</span>(s1), <span class="bu">len</span>(s2), <span class="bu">len</span>(s3)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n1 <span class="op">+</span> n2 <span class="op">!=</span> n3:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(i, j):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (i, j) <span class="kw">in</span> memo:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">==</span> n1 <span class="kw">and</span> j <span class="op">==</span> n2:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        pick_s1 <span class="op">=</span> i <span class="op">&lt;</span> n1 <span class="kw">and</span> s1[i] <span class="op">==</span> s3[i <span class="op">+</span> j] <span class="kw">and</span> dfs(i <span class="op">+</span> <span class="dv">1</span>, j)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        pick_s2 <span class="op">=</span> j <span class="op">&lt;</span> n2 <span class="kw">and</span> s2[j] <span class="op">==</span> s3[i <span class="op">+</span> j] <span class="kw">and</span> dfs(i, j <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        memo[(i, j)] <span class="op">=</span> pick_s1 <span class="kw">or</span> pick_s2</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(i, j)]</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>s1 <span class="op">=</span> <span class="st">&quot;aab&quot;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>s2 <span class="op">=</span> <span class="st">&quot;axy&quot;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>s3 <span class="op">=</span> <span class="st">&quot;aaxaby&quot;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(isInterleave(s1, s2, s3))  <span class="co"># Output: True</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Base Case</strong>: First, we check if the total length of
<code>s1</code> and <code>s2</code> is not the same as the length of
<code>s3</code>. If so, we return <code>False</code>.</li>
<li><strong>DFS Function</strong>: The <code>dfs</code> function looks
at characters from <code>s1</code> and <code>s2</code> to see if they
match <code>s3</code>. We use memoization to save results in the
<code>memo</code> dictionary.</li>
<li><strong>Character Matching</strong>: It checks if the current
character in <code>s1</code> or <code>s2</code> matches the one in
<code>s3</code>. Then it looks at the next characters.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n1 * n2). Here, <code>n1</code>
and <code>n2</code> are the lengths of <code>s1</code> and
<code>s2</code>. Each state is calculated only once.</li>
<li><strong>Space Complexity</strong>: O(n1 * n2) for the memoization
table.</li>
</ul>
<p>This memoization technique helps us reduce the amount of work we need
to do. It is good for bigger input sizes. If you want to learn more
about dynamic programming, you can check other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="testing-and-validating-interleaving-string-solutions">Testing
and Validating Interleaving String Solutions</h2>
<p>To make sure our interleaving string algorithms work well, we need to
have good testing methods. Here are some important things to think about
when we test and validate interleaving string solutions.</p>
<h3 id="test-cases">Test Cases</h3>
<ol type="1">
<li><strong>Basic Valid Cases</strong>:
<ul>
<li>Inputs: <code>s1 = "aab"</code>, <code>s2 = "axy"</code>,
<code>s3 = "aaxaby"</code>. Expected output: <code>True</code>.</li>
<li>Inputs: <code>s1 = "ab"</code>, <code>s2 = "cd"</code>,
<code>s3 = "abcd"</code>. Expected output: <code>True</code>.</li>
</ul></li>
<li><strong>Basic Invalid Cases</strong>:
<ul>
<li>Inputs: <code>s1 = "aab"</code>, <code>s2 = "axy"</code>,
<code>s3 = "aabaxy"</code>. Expected output: <code>False</code>.</li>
<li>Inputs: <code>s1 = "abc"</code>, <code>s2 = "def"</code>,
<code>s3 = "abdecf"</code>. Expected output: <code>False</code>.</li>
</ul></li>
<li><strong>Edge Cases</strong>:
<ul>
<li>Inputs: <code>s1 = ""</code>, <code>s2 = ""</code>,
<code>s3 = ""</code>. Expected output: <code>True</code>.</li>
<li>Inputs: <code>s1 = ""</code>, <code>s2 = "a"</code>,
<code>s3 = "a"</code>. Expected output: <code>True</code>.</li>
<li>Inputs: <code>s1 = "a"</code>, <code>s2 = ""</code>,
<code>s3 = "a"</code>. Expected output: <code>True</code>.</li>
<li>Inputs: <code>s1 = "a"</code>, <code>s2 = ""</code>,
<code>s3 = "b"</code>. Expected output: <code>False</code>.</li>
</ul></li>
</ol>
<h3 id="unit-testing">Unit Testing</h3>
<p>We should create unit tests to check our interleaving string
algorithm automatically. Here is an example using Python’s
<code>unittest</code> framework.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> unittest</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> isInterleave(s1, s2, s3):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(s1) <span class="op">+</span> <span class="bu">len</span>(s2) <span class="op">!=</span> <span class="bu">len</span>(s3):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> (<span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][<span class="dv">0</span>] <span class="kw">and</span> s1[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> s2[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s1) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s2) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> (dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="kw">and</span> s1[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span>]) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                        (dp[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> s2[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> s3[i <span class="op">+</span> j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="bu">len</span>(s1)][<span class="bu">len</span>(s2)]</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> TestInterleavingString(unittest.TestCase):</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> test_cases(<span class="va">self</span>):</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertTrue(isInterleave(<span class="st">&quot;aab&quot;</span>, <span class="st">&quot;axy&quot;</span>, <span class="st">&quot;aaxaby&quot;</span>))</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertTrue(isInterleave(<span class="st">&quot;ab&quot;</span>, <span class="st">&quot;cd&quot;</span>, <span class="st">&quot;abcd&quot;</span>))</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertFalse(isInterleave(<span class="st">&quot;aab&quot;</span>, <span class="st">&quot;axy&quot;</span>, <span class="st">&quot;aabaxy&quot;</span>))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertFalse(isInterleave(<span class="st">&quot;abc&quot;</span>, <span class="st">&quot;def&quot;</span>, <span class="st">&quot;abdecf&quot;</span>))</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertTrue(isInterleave(<span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;&quot;</span>))</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertTrue(isInterleave(<span class="st">&quot;&quot;</span>, <span class="st">&quot;a&quot;</span>, <span class="st">&quot;a&quot;</span>))</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertTrue(isInterleave(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;a&quot;</span>))</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.assertFalse(isInterleave(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;&quot;</span>, <span class="st">&quot;b&quot;</span>))</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    unittest.main()</span></code></pre></div>
<h3 id="performance-testing">Performance Testing</h3>
<ul>
<li>We need to measure the time it takes for big inputs.</li>
<li>We can use tools like <code>timeit</code> in Python to check
performance.</li>
<li>Test with strings that have different lengths to see how well our
algorithm scales.</li>
</ul>
<h3 id="validation-techniques">Validation Techniques</h3>
<ul>
<li><strong>Assertions</strong>: Use assertions in our code to check
that outputs are correct for the inputs we give.</li>
<li><strong>Logging</strong>: Set up logging to see what happens during
execution and find issues more easily.</li>
<li><strong>Compare with Brute Force</strong>: For smaller inputs, we
can compare our results with a brute force solution to check if they are
correct.</li>
</ul>
<h3 id="common-tools">Common Tools</h3>
<ul>
<li>We can use testing frameworks like <code>JUnit</code> for Java,
<code>unittest</code> or <code>pytest</code> for Python, and
<code>Catch2</code> for C++ to help us test our code better.</li>
</ul>
<p>By doing these things, we can test and validate our interleaving
string solutions. This will help us make sure they are correct and work
well.</p>
<h2
id="performance-analysis-of-interleaving-string-algorithms">Performance
Analysis of Interleaving String Algorithms</h2>
<p>We think the performance of interleaving string algorithms is very
important. This is especially true when we work with larger strings. The
difficulty of the problem changes based on the method we use. Common
methods include recursive, dynamic programming, and space-optimized
methods.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^(m+n)). Here, m and n are the
lengths of the two strings. This happens because of the many branching
choices we have.</li>
<li><strong>Space Complexity</strong>: O(m+n) for the recursion
stack.</li>
</ul>
<h3 id="dynamic-programming-approach-2">Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m*n). Again, m and n are the
lengths of the input strings. The algorithm fills a 2D DP table. We need
to check all combinations of the two strings.</li>
<li><strong>Space Complexity</strong>: O(m*n) because of the DP
table.</li>
</ul>
<h3 id="space-optimized-dynamic-programming">Space Optimized Dynamic
Programming</h3>
<ul>
<li><strong>Time Complexity</strong>: Still O(m*n). The main logic does
not change.</li>
<li><strong>Space Complexity</strong>: It is reduced to O(min(m, n)). We
only keep the previous row or column instead of the whole DP table.</li>
</ul>
<h3 id="performance-considerations">Performance Considerations</h3>
<ul>
<li>For short strings, the recursive approach might work fine. But it
gets slow when the string length grows. This is because of its
exponential nature.</li>
<li>We prefer the dynamic programming approach for longer strings. It
gives a good runtime but uses more space.</li>
<li>We suggest space-optimized techniques when memory use is important.
This is especially true in places with limited resources.</li>
</ul>
<h3 id="example-performance-metrics">Example Performance Metrics</h3>
<p>For two strings of length 20: - The recursive method can take several
seconds to finish. - The dynamic programming method can give results in
milliseconds. - The space-optimized dynamic programming also finishes in
milliseconds but uses much less memory.</p>
<p>By looking at these performance metrics, we can choose the best
interleaving string algorithm based on our needs.</p>
<p>For more information on dynamic programming techniques, we can check
out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-interleaving-string-problem-in-dynamic-programming">1.
What is the interleaving string problem in dynamic programming?</h3>
<p>The interleaving string problem is a well-known challenge in dynamic
programming. It asks if we can make a string by mixing two other strings
while keeping their order. We need to understand how to handle indices
and compare substrings well. This problem is a good example of using
dynamic programming techniques.</p>
<h3
id="how-can-i-solve-the-interleaving-string-problem-using-recursion">2.
How can I solve the interleaving string problem using recursion?</h3>
<p>To solve the interleaving string problem with recursion, we can make
a function. This function checks if the current characters of both
strings match the target string. If they match, we check the next
characters. If we reach the end of both strings and the target string is
correct, we return true. But this way may cause some repeated
calculations. So, we should think about using memoization to make it
better.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-the-interleaving-string">3.
What is the time complexity of the dynamic programming solution for the
interleaving string?</h3>
<p>The time complexity for the dynamic programming solution of the
interleaving string problem is O(m * n). Here, m and n are the lengths
of the two strings. We have to fill a 2D table of size m x n. Each cell
shows if we can form a substring. This way, the solution checks all
character combinations efficiently.</p>
<h3
id="can-you-explain-the-bottom-up-dynamic-programming-approach-for-the-interleaving-string">4.
Can you explain the bottom-up dynamic programming approach for the
interleaving string?</h3>
<p>The bottom-up dynamic programming approach for the interleaving
string problem uses a 2D table to keep results of smaller problems. We
start by setting the table with base cases. Then, we fill it step by
step based on the characters of the two strings. This method does not
have the extra cost of recursive calls. It is usually faster and takes
up less space.</p>
<h3 id="how-do-i-validate-my-interleaving-string-solution">5. How do I
validate my interleaving string solution?</h3>
<p>To validate our interleaving string solution, we can run several unit
tests with known inputs and outputs. We should also test edge cases like
empty strings or strings with repeated characters to make sure our
solution works well. Using assertions in our code can help us check
automatically during development.</p>
<p>For more insights on dynamic programming techniques, check out
articles on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
number</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">climbing
stairs problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            