
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Non-Adjacent Elements - Medium</title>
            <meta name="description" content="Discover how to solve the Maximum Sum of Non-Adjacent Elements problem using dynamic programming. Boost your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Non-Adjacent Elements - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Sum of Non-Adjacent Elements is a well-known dynamic
programming problem. It helps us find the biggest sum of numbers in an
array. But we can only pick numbers that are not next to each other.</p>
<p>To solve this, we use something called an optimal substructure. This
means that the best sum at any spot relies on the best sums from earlier
spots. This way, we can work fast and avoid picking adjacent
numbers.</p>
<p>In this article, we will explain the problem clearly. We will also
talk about optimal substructure and show how to implement solutions in
Java, Python, and C++. We will check the time and space complexity of
the solution. Plus, we will look at both recursive and bottom-up
approaches. This guide will help us understand and solve the Maximum Sum
of Non-Adjacent Elements problem well.</p>
<ul>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Problem
Explanation</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Optimal
Substructure</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Java
Implementation</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Python
Implementation</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements C++
Implementation</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Time
Complexity Analysis</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Space
Complexity Analysis</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Recursive
Approach</li>
<li>Dynamic Programming Maximum Sum of Non-Adjacent Elements Bottom-Up
Approach</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can read
related articles. They are <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber Problem</a>. They give us great insights.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-optimal-substructure">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Optimal
Substructure</h2>
<p>The optimal substructure is very important in dynamic programming. It
helps us solve the problem of finding the maximum sum of non-adjacent
elements in an array.</p>
<p>Given an array called <code>nums</code>, we want to maximize the sum
of the selected elements. We canâ€™t choose two elements that are next to
each other. We can define the optimal substructure using recursion.</p>
<ul>
<li>Let <code>dp[i]</code> be the maximum sum of non-adjacent elements
from the first <code>i</code> elements of the array.</li>
<li>For each index <code>i</code>, we have two choices:
<ol type="1">
<li>We can include <code>nums[i]</code> in the sum. This means we cannot
include <code>nums[i-1]</code>. So, the value will be
<code>nums[i] + dp[i-2]</code>.</li>
<li>We can exclude <code>nums[i]</code>. This gives us the value
<code>dp[i-1]</code>.</li>
</ol></li>
</ul>
<p>We can write the recursive relation like this:</p>
<pre><code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code></pre>
<p>We also have base cases: - <code>dp[0] = nums[0]</code> (only one
element to think about) - <code>dp[1] = max(nums[0], nums[1])</code>
(the maximum of the first two elements)</p>
<p>This relation helps us to build the solution from smaller problems.
So, it is efficient to find the maximum sum of non-adjacent
elements.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-java-implementation">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Java
Implementation</h2>
<p>To find the maximum sum of non-adjacent elements using Dynamic
Programming in Java, we can use a simple method. We will keep track of
two numbers. One will show the maximum sum including the current number.
The other will show the maximum sum without the current number.</p>
<p>Here is the Java code:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNonAdjacent <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Maximum sum including the previous element</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Maximum sum excluding the previous element</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Calculate new exclude; it is the max of previous include and exclude</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newExclude <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Update include to the previous exclude plus current num</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            include <span class="op">=</span> exclude <span class="op">+</span> num<span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Update exclude</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            exclude <span class="op">=</span> newExclude<span class="op">;</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the maximum of include and exclude</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of non-adjacent elements: &quot;</span> <span class="op">+</span> <span class="fu">maxSum</span><span class="op">(</span>nums<span class="op">));</span> <span class="co">// Output: 15</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Variables</strong>:
<ul>
<li><code>include</code> is for the max sum with the current
element.</li>
<li><code>exclude</code> is for the max sum without the current
element.</li>
</ul></li>
<li><strong>Loop</strong>:
<ul>
<li>For each number in the array, we find the new <code>exclude</code>
as the max of the last <code>include</code> and
<code>exclude</code>.</li>
<li>We update the <code>include</code> to be the last
<code>exclude</code> plus the current number.</li>
</ul></li>
<li><strong>Return</strong>: After we go through all numbers, we return
the biggest between <code>include</code> and <code>exclude</code>.</li>
</ul>
<p>This method runs in O(n) time and uses O(1) space. It works well for
big input sizes. For more about dynamic programming, you can check the
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming - House Robber I</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-python-implementation">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Python
Implementation</h2>
<p>We can solve the problem of finding the maximum sum of non-adjacent
elements using Python with a dynamic programming approach. The main idea
is to use two variables. One tracks the maximum sum when we include the
current element. The other tracks the maximum sum when we do not include
the current element.</p>
<p>Here is a simple implementation in Python:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_non_adjacent_sum(arr):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> arr:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">len</span>(arr) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[<span class="dv">0</span>]</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Maximum sum including the last element</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Maximum sum excluding the last element</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update include to be the last exclude plus current number</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        new_include <span class="op">=</span> exclude <span class="op">+</span> num</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update exclude to be the biggest of last include and exclude</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Update include for the next round</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> new_include</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> max_non_adjacent_sum(arr)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum sum of non-adjacent elements:&quot;</span>, result)</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We start with two variables
<code>include</code> and <code>exclude</code>. They help us track the
sums as we go through the array.</li>
<li><strong>Iteration</strong>: For each number, we calculate a new
include sum. This new sum is the current number added to the last
exclude sum. Then we update the exclude sum to be the biggest of the
last include and exclude sums.</li>
<li><strong>Final Result</strong>: At the end, we take the maximum of
<code>include</code> and <code>exclude</code>. This gives us the answer
we want.</li>
</ul>
<p>This dynamic programming solution works in O(n) time complexity and
O(1) space complexity. This makes it fast and efficient for this
problem.</p>
<p>For more problems related to dynamic programming, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming Coin Change</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-ii-medium.html">Dynamic
Programming House Robber II</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-c-implementation">Dynamic
Programming Maximum Sum of Non-Adjacent Elements C++ Implementation</h2>
<p>To solve the problem of finding the maximum sum of non-adjacent
elements using dynamic programming in C++, we can use a simple way. We
will keep track of two numbers. One number tracks the maximum sum that
includes the current element. The other number tracks the maximum sum
that does not include it.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxNonAdjacentSum<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> include <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span>  <span class="co">// Maximum sum including the first element</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>        <span class="co">// Maximum sum excluding the first element</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> newExclude <span class="op">=</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span> <span class="co">// New exclude is the max of include and exclude</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> exclude <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span>            <span class="co">// Include current element</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> newExclude<span class="op">;</span>                    <span class="co">// Update exclude</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span> <span class="co">// Return the maximum of include and exclude</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum sum of non-adjacent elements: &quot;</span> <span class="op">&lt;&lt;</span> maxNonAdjacentSum<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this code: - We start with <code>include</code> as the first
element of the array. <code>exclude</code> starts from zero. - For each
next element, we find a new <code>exclude</code>. This is the maximum of
the previous <code>include</code> and <code>exclude</code>. - We then
update <code>include</code> to be the sum of the current element and the
previous <code>exclude</code>. - At the end, we return the maximum of
<code>include</code> and <code>exclude</code>. This shows the maximum
sum of non-adjacent elements.</p>
<p>This method runs in O(n) time and O(1) space. It is very efficient
for this problem. If you want to learn more about dynamic programming,
you can also check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming House Robber I</a>. This link talks about similar ideas.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-time-complexity-analysis">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Time Complexity
Analysis</h2>
<p>We can see that the time complexity for the <strong>Maximum Sum of
Non-Adjacent Elements</strong> problem changes based on the method we
use. Here is a simple breakdown of the time complexity for different
methods.</p>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li>The basic recursive solution checks all possible combinations of
elements. This results in a lot of calls.</li>
<li><strong>Time Complexity</strong>: O(2^n). Here, n is the number of
elements in the array.</li>
</ul></li>
<li><strong>Memoization (Top-Down Dynamic Programming)</strong>:
<ul>
<li>When we store results of smaller problems, we save time on
calculations.</li>
<li>Each element gets calculated only once. This gives us a linear
number of calculations.</li>
<li><strong>Time Complexity</strong>: O(n). Again, n is the number of
elements in the array.</li>
</ul></li>
<li><strong>Bottom-Up Dynamic Programming</strong>:
<ul>
<li>This method builds a DP table step by step.</li>
<li>Each state uses results from earlier states. This also leads to a
linear number of states.</li>
<li><strong>Time Complexity</strong>: O(n). n is the number of elements
in the array.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>In the recursive approach, it is O(n) because of the call
stack.</li>
<li>For memoization, it is O(n) to store the results we calculate.</li>
<li>The bottom-up method can be made O(1) by only keeping the last two
results we calculated.</li>
</ul></li>
</ol>
<p>In conclusion, we find that the best solutions using memoization and
the bottom-up method have a time complexity of O(n). This makes them
good choices for solving the Maximum Sum of Non-Adjacent Elements
problem.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-space-complexity-analysis">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Space Complexity
Analysis</h2>
<p>The space complexity for the Dynamic Programming solution of the
Maximum Sum of Non-Adjacent Elements problem mainly depends on how we
store the results we get.</p>
<h3 id="space-complexity-breakdown">Space Complexity Breakdown</h3>
<ol type="1">
<li><strong>Dynamic Programming Array</strong>:
<ul>
<li>In a normal dynamic programming method, we use an array called
<code>dp</code>. The size of this array is <code>n</code> (where
<code>n</code> is the length of the input array). This gives us a space
complexity of <strong>O(n)</strong>.</li>
</ul></li>
<li><strong>Optimized Space Approach</strong>:
<ul>
<li>We can make the space complexity better by using just two variables.
These variables will hold the maximum sums from the last two indices.
This way, we reduce the space complexity to <strong>O(1)</strong>.</li>
</ul></li>
</ol>
<h3 id="implementation-example">Implementation Example</h3>
<p>Here is how we can write the space-efficient version in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_non_adjacent_sum(nums):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    prev1, prev2 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="bu">max</span>(prev1, prev2 <span class="op">+</span> num)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span></code></pre></div>
<p>In this code: - <code>prev1</code> is the maximum sum that includes
the current element. - <code>prev2</code> is the maximum sum that does
not include the current element.</p>
<p>So, the simple solution has space complexity of O(n). But our
optimized way gets O(1). This makes it much better for bigger
datasets.</p>
<p>If we want to learn more about dynamic programming techniques, we can
check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming - House Robber I</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadaneâ€™s Algorithm)</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-recursive-approach">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Recursive Approach</h2>
<p>We can solve the problem of finding the maximum sum of non-adjacent
elements using a recursive approach. For each element in the array, we
have two choices. We can either include the element in the sum or leave
it out. This gives us a simple recursive definition.</p>
<h3 id="recursive-function-definition">Recursive Function
Definition</h3>
<p>Let <code>arr</code> be the input array. Let <code>n</code> be its
length. We can define the recursive function like this:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_recursive(arr, n):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[<span class="dv">0</span>]</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Choose the maximum of including or excluding the current element</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    include_current <span class="op">=</span> arr[n<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> max_sum_recursive(arr, n<span class="op">-</span><span class="dv">2</span>)</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    exclude_current <span class="op">=</span> max_sum_recursive(arr, n<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(include_current, exclude_current)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Base Cases</strong>:
<ul>
<li>If the array is empty (<code>n == 0</code>), then the maximum sum is
<code>0</code>.</li>
<li>If there is only one element (<code>n == 1</code>), the maximum sum
is the value of that element.</li>
</ul></li>
<li><strong>Recursive Choices</strong>:
<ul>
<li>If we include the current element (<code>arr[n-1]</code>), we add
its value to the result of calling the function without the previous
element (<code>max_sum_recursive(arr, n-2)</code>).</li>
<li>If we do not include the current element, we just call the function
on the rest of the array
(<code>max_sum_recursive(arr, n-1)</code>).</li>
</ul></li>
</ul>
<h3 id="example">Example</h3>
<p>For an input array <code>arr = [3, 2, 5, 10, 7]</code>, the recursive
function will check many paths. It will find the correct maximum sum of
non-adjacent elements in the end.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>This recursive approach has an exponential time complexity. It is
<code>O(2^n</code> because of overlapping problems. We can make it much
better using memoization or using a dynamic programming approach.</p>
<p>For more learning on related problems, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-non-adjacent-elements-bottom-up-approach">Dynamic
Programming Maximum Sum of Non-Adjacent Elements Bottom-Up Approach</h2>
<p>We can solve the Maximum Sum of Non-Adjacent Elements problem using
the Bottom-Up Approach. This means we build the solution step by step
from the simplest cases. We will use an array to keep track of the
maximum sums for smaller problems. This way, we get an efficient
solution.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an array <code>arr</code> of integers. Our goal is to find
the maximum sum of non-adjacent elements. If we pick one element, we
cannot pick the ones right next to it.</p>
<h3 id="bottom-up-dynamic-programming-solution">Bottom-Up Dynamic
Programming Solution</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: We create a DP array
<code>dp</code>. Each <code>dp[i]</code> shows the maximum sum of
non-adjacent elements up to the first <code>i</code> elements of the
array.</p></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li>If the array is empty, the result is <code>0</code>.</li>
<li>If there is only one element, the result is
<code>arr[0]</code>.</li>
<li>If there are two elements, the result is the bigger one:
<code>max(arr[0], arr[1])</code>.</li>
</ul></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li><p>For each element from the third one (index 2), we can calculate
the maximum sum like this:</p>
<pre><code>dp[i] = max(dp[i-1], arr[i] + dp[i-2])</code></pre></li>
<li><p>Here <code>dp[i-1]</code> is when we do not take the current
element. <code>arr[i] + dp[i-2]</code> is when we take the current
element and add it to the best sum from earlier non-adjacent
elements.</p></li>
</ul></li>
<li><p><strong>Final Result</strong>: The final answer will be in
<code>dp[n-1]</code>, where <code>n</code> is the size of the
array.</p></li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNonAdjacent <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum(arr):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[<span class="dv">0</span>]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(arr[<span class="dv">0</span>], arr[<span class="dv">1</span>])</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> arr[<span class="dv">0</span>]</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(arr[<span class="dv">0</span>], arr[<span class="dv">1</span>])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>], arr[i] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSum<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> max<span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This bottom-up approach is good. It helps us use the results we
already found to build the solution. It has a time complexity of O(n)
and space complexity of O(n) because of the DP array. To save space, we
can reduce the space complexity to O(1). We can do this by only keeping
the last two values instead of the full DP array.</p>
<p>If you want to learn more, you can check these articles: - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming - House Robber I</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadaneâ€™s Algorithm)</a></p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-maximum-sum-of-non-adjacent-elements-problem">1.
What is the Maximum Sum of Non-Adjacent Elements problem?</h3>
<p>The Maximum Sum of Non-Adjacent Elements problem is a well-known
dynamic programming task. The goal is to find the highest sum of numbers
in an array. We need to make sure no two chosen numbers are next to each
other. This problem shows how important it is to have an optimal
structure. We can use dynamic programming methods to get a good
solution.</p>
<h3
id="how-do-i-implement-the-maximum-sum-of-non-adjacent-elements-in-python">2.
How do I implement the Maximum Sum of Non-Adjacent Elements in
Python?</h3>
<p>To implement the Maximum Sum of Non-Adjacent Elements in Python, we
can use a dynamic programming method. We will keep track of two values.
One is for the maximum sum including the current number. The other is
for excluding it. This method gives us an O(n) time complexity, which is
good for bigger arrays. Here is a simple code:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_non_adjacent(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        new_exclude <span class="op">=</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> exclude <span class="op">+</span> num</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> new_exclude</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(include, exclude)</span></code></pre></div>
<h3
id="what-is-the-time-complexity-of-the-maximum-sum-of-non-adjacent-elements-solution">3.
What is the time complexity of the Maximum Sum of Non-Adjacent Elements
solution?</h3>
<p>The time complexity for the best solution to the Maximum Sum of
Non-Adjacent Elements is O(n). Here, n is the length of the input array.
We go through the array just once. For each number, we do calculations
in constant time. This efficient way is very important for solving
bigger problems.</p>
<h3
id="can-you-explain-the-recursive-approach-for-solving-this-problem">4.
Can you explain the recursive approach for solving this problem?</h3>
<p>The recursive way to solve the Maximum Sum of Non-Adjacent Elements
means we define a function. This function looks at two choices for each
number. We can either include it in the sum and skip the next one, or we
can skip it completely. This creates overlapping subproblems. That is
why using memoization or dynamic programming makes it faster. For more
information on recursive solutions, check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming Fibonacci with Memoization</a>.</p>
<h3 id="how-does-the-bottom-up-approach-work-for-this-problem">5. How
does the Bottom-Up approach work for this problem?</h3>
<p>The Bottom-Up approach for the Maximum Sum of Non-Adjacent Elements
builds a solution step by step. We start by creating an array to keep
the maximum sums up to each index. We fill this array based on whether
we include or exclude the current number. This method avoids the extra
work of recursion. It also finds the maximum sum quickly in linear time.
This makes it a good choice for these types of problems. For comparison,
you might like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming House Robber I</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            