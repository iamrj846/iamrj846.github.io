
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] 0/1 Knapsack Problem - Medium</title>
            <meta name="description" content="Discover the 0/1 Knapsack Problem in our dynamic programming guide. Learn strategies, examples, and solutions for medium-level challenges!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] 0/1 Knapsack Problem - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The 0/1 Knapsack Problem is a well-known problem. It tries to get the
most value from items we can put in a knapsack without going over its
weight limit. Each item can be either put in the knapsack (1) or not put
in (0). That is why we call it the “0/1” knapsack problem.</p>
<p>To solve this problem, we usually use dynamic programming. This
method helps us find the best value by dividing the problem into
smaller, easier parts.</p>
<p>In this article, we will talk about the 0/1 Knapsack Problem in
detail. We will explain the problem statement. We will also show how to
use dynamic programming in Java, Python, and C++. We will look at
memoization methods for these programming languages. Finally, we will
analyze time and space complexity. We will also answer common questions
about the 0/1 Knapsack Problem.</p>
<ul>
<li>Dynamic Programming 0/1 Knapsack Problem Explained</li>
<li>Understanding the Problem Statement of 0/1 Knapsack</li>
<li>Dynamic Programming Approach to 0/1 Knapsack in Java</li>
<li>Dynamic Programming Approach to 0/1 Knapsack in Python</li>
<li>Dynamic Programming Approach to 0/1 Knapsack in C++</li>
<li>Memoization Technique for 0/1 Knapsack in Java</li>
<li>Memoization Technique for 0/1 Knapsack in Python</li>
<li>Memoization Technique for 0/1 Knapsack in C++</li>
<li>Time and Space Complexity Analysis of 0/1 Knapsack</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to know more about dynamic programming, you can check
these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Dynamic
Programming: Subset Sum Problem</a>.</p>
<h2
id="understanding-the-problem-statement-of-01-knapsack">Understanding
the Problem Statement of 0/1 Knapsack</h2>
<p>The 0/1 Knapsack Problem is a well-known problem in computer science.
It is important in dynamic programming. We can explain the problem like
this:</p>
<p>We have a set of items. Each item has a weight and a value. Our task
is to decide how many of each item to put in a knapsack. The total
weight must be less than or equal to a given limit. We want to make the
total value as high as possible. The “0/1” means we can either take the
whole item or leave it. We cannot take part of an item.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Inputs</strong>:
<ul>
<li><code>n</code>: Number of items.</li>
<li><code>W</code>: Maximum weight capacity of the knapsack.</li>
<li><code>weights[]</code>: List of weights for the items.</li>
<li><code>values[]</code>: List of values for the items.</li>
</ul></li>
<li><strong>Outputs</strong>:
<ul>
<li>Maximum value we can get without going over the weight limit.</li>
</ul></li>
</ul>
<h3 id="example">Example</h3>
<p>Let’s look at an example:</p>
<ul>
<li>Items:
<ul>
<li>Item 1: Weight = 2, Value = 1</li>
<li>Item 2: Weight = 3, Value = 4</li>
<li>Item 3: Weight = 4, Value = 5</li>
<li>Item 4: Weight = 5, Value = 7</li>
</ul></li>
<li>Capacity of knapsack (<code>W</code>) = 7</li>
</ul>
<h3 id="objective">Objective</h3>
<p>Our goal is to get the highest total value without going over the
weight limit. In the example above, if we pick Item 2 and Item 4, we get
a total value of 11 (4 + 7). But the total weight is 8, which is too
much.</p>
<p>Instead, we can pick Item 2 and Item 3. This gives us a total value
of 9 (4 + 5) and the total weight is exactly 7.</p>
<p>We can solve the 0/1 Knapsack Problem using different ways. One
method is dynamic programming. This method helps us find the maximum
value by keeping track of results we already found. If you want to learn
more about dynamic programming, you can read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a>.</p>
<h2 id="dynamic-programming-approach-to-01-knapsack-in-java">Dynamic
Programming Approach to 0/1 Knapsack in Java</h2>
<p>The 0/1 Knapsack Problem is a well-known dynamic programming problem.
We want to get the most value from items in a knapsack without going
over its weight limit. Each item can either go into the knapsack or not.
That is why we call it 0/1.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have: - An array of weights <code>w[]</code> with size
<code>n</code>. - An array of values <code>v[]</code> also with size
<code>n</code>. - A maximum weight limit <code>W</code> for the
knapsack.</p>
<p>Our goal is to find the highest value we can get by picking items
without going over the weight limit.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>We use a 2D array called <code>dp</code>. Here, <code>dp[i][j]</code>
shows the highest value we can get with the first <code>i</code> items
and a maximum weight <code>j</code>.</p>
<h4 id="steps">Steps:</h4>
<ol type="1">
<li>We start by setting <code>dp[0][j]</code> to 0 for all
<code>j</code> because having 0 items means we get 0 value.</li>
<li>For each item <code>i</code> from 1 to <code>n</code>, and for each
weight <code>j</code> from 1 to <code>W</code>:
<ul>
<li><p>If the weight of the current item <code>w[i-1]</code> is less
than or equal to <code>j</code>, we find the best option between
including or not including the item:</p>
<pre><code>dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i-1]] + v[i-1])</code></pre></li>
<li><p>If not, we just exclude the item and keep the previous value:</p>
<pre><code>dp[i][j] = dp[i-1][j]</code></pre></li>
</ul></li>
</ol>
<h4 id="java-code-implementation">Java Code Implementation</h4>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Knapsack <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">knapsack</span><span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> wt<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> val<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> w <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w <span class="op">-</span> wt<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]]</span> <span class="op">+</span> val<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>W<span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> val <span class="op">=</span> <span class="op">{</span><span class="dv">60</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">120</span><span class="op">};</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> wt <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> W <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> val<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">+</span> <span class="fu">knapsack</span><span class="op">(</span>W<span class="op">,</span> wt<span class="op">,</span> val<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>knapsack</code> function sets up the <code>dp</code>
array.</li>
<li>It goes through each item and weight to fill the <code>dp</code>
table based on if we include or exclude items.</li>
<li>The final answer is in <code>dp[n][W]</code>, which tells us the
maximum value we can achieve with the weight limit.</li>
</ul>
<p>This dynamic programming method solves the 0/1 Knapsack Problem in
O(n*W) time. Here, <code>n</code> is the number of items and
<code>W</code> is the maximum weight limit. For more about dynamic
programming, you can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change</a>.</p>
<h2 id="dynamic-programming-approach-to-01-knapsack-in-python">Dynamic
Programming Approach to 0/1 Knapsack in Python</h2>
<p>The 0/1 Knapsack Problem is a well-known example of dynamic
programming. In this problem, we want to get the most value from items
in a knapsack without going over its weight limit. Each item can either
go in the knapsack (1) or not (0).</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<p>We have: - <code>n</code>: Number of items - <code>weights[]</code>:
List of weights of the items - <code>values[]</code>: List of values for
each item - <code>W</code>: Maximum weight the knapsack can hold</p>
<h3 id="dynamic-programming-solution-1">Dynamic Programming
Solution</h3>
<p>We solve the 0/1 Knapsack Problem with a 2D list <code>dp</code>.
Here, <code>dp[i][w]</code> shows the maximum value we can get with a
weight limit <code>w</code> using the first <code>i</code> items.</p>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> knapsack(weights, values, W, n):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(W <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> w <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, W <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> weights[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&lt;=</span> w:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>                dp[i][w] <span class="op">=</span> <span class="bu">max</span>(values[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">1</span>][w <span class="op">-</span> weights[i <span class="op">-</span> <span class="dv">1</span>]], dp[i <span class="op">-</span> <span class="dv">1</span>][w])</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                dp[i][w] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][w]</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n][W]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>weights <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">40</span>]</span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="bu">len</span>(values)</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>max_value <span class="op">=</span> knapsack(weights, values, W, n)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum value in knapsack:&quot;</span>, max_value)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a 2D list <code>dp</code>
and set all values to 0.</li>
<li><strong>Filling the DP Table</strong>: We use two loops. One for
items and one for weight limits. If the current item’s weight is less
than or equal to <code>w</code>, we calculate the best value by either
adding the item or leaving it out.</li>
<li><strong>Result</strong>: The best value we can get with weight
<code>W</code> is in <code>dp[n][W]</code>.</li>
</ul>
<p>This dynamic programming method gives us a solution with a time
complexity of (O(n W)) and a space complexity of (O(n W)). We can make
the space better to (O(W)) using a single list. But this code is clear
for understanding the DP table.</p>
<p>For more on similar dynamic programming problems, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-simple-0-1-knapsack-small-instance-easy.html">Dynamic
Programming: Simple 0/1 Knapsack Small Instance</a>.</p>
<h2 id="dynamic-programming-approach-to-01-knapsack-in-c">Dynamic
Programming Approach to 0/1 Knapsack in C++</h2>
<p>The 0/1 Knapsack Problem is a well-known problem. We want to get the
most value from items in a knapsack with a fixed size. Each item we can
either take or leave. This is why we call it “0/1”.</p>
<p>In the dynamic programming method, we make a 2D array called
<code>dp</code>. Here, <code>dp[i][w]</code> shows the best value we can
get with a knapsack size <code>w</code> using the first <code>i</code>
items. The steps of the algorithm are:</p>
<ol type="1">
<li><strong>Initialization</strong>: Set <code>dp[0][w] = 0</code> for
all <code>w</code>. If we have no items, the value is zero.</li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>For each item <code>i</code> from 1 to <code>n</code>:
<ul>
<li>For each capacity <code>w</code> from 0 to <code>W</code>:
<ul>
<li><p>If the weight of item <code>i</code> is less than or equal to
<code>w</code>, we pick the best choice between taking the item or
not:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w <span class="op">-</span> weight<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]]</span> <span class="op">+</span> value<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span></code></pre></div></li>
<li><p>If not, we keep the value from the previous item:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span></code></pre></div></li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<p>Here is the C++ code that shows how we use dynamic programming for
the 0/1 Knapsack Problem:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> knapsack<span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> weights<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> values<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> w <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> w <span class="op">&lt;=</span> W<span class="op">;</span> w<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>weights<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> w<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w <span class="op">-</span> weights<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]]</span> <span class="op">+</span> values<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>w<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>w<span class="op">];</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">][</span>W<span class="op">];</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> W <span class="op">=</span> <span class="dv">50</span><span class="op">;</span> <span class="co">// knapsack capacity</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span> <span class="co">// weights of items</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> values <span class="op">=</span> <span class="op">{</span><span class="dv">60</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">120</span><span class="op">};</span> <span class="co">// values of items</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> values<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">&lt;&lt;</span> knapsack<span class="op">(</span>W<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code:</h3>
<ul>
<li>The <code>knapsack</code> function sets up a 2D vector
<code>dp</code> to keep the best values.</li>
<li>It goes through each item and weight, updating the <code>dp</code>
table to decide if we include each item.</li>
<li>The final answer is in <code>dp[n][W]</code>. This shows the best
value we can have with <code>n</code> items and size
<code>W</code>.</li>
</ul>
<p>This dynamic programming method solves the 0/1 Knapsack Problem well.
It has a time complexity of <code>O(n*W)</code> and a space complexity
of <code>O(n*W)</code>. If you want to learn more about dynamic
programming methods, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2 id="memoization-technique-for-01-knapsack-in-java">Memoization
Technique for 0/1 Knapsack in Java</h2>
<p>We use the memoization technique as a way to make our dynamic
programming better. This method saves the results of costly function
calls. Then it gives back the saved result when we see the same inputs
again. For the 0/1 Knapsack problem, memoization helps us skip repeated
calculations. This makes our solution much faster.</p>
<h3 id="problem-definition-3">Problem Definition</h3>
<p>We have a set of items. Each item has a weight and a value. Our goal
is to find the maximum value we can put in a knapsack with a certain
capacity. We can either include each item or leave it out. This is why
we call it the “0/1” problem.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a Java code for the 0/1 Knapsack problem using the
memoization technique:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Knapsack <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Method to find the maximum value</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">knapsack</span><span class="op">(</span><span class="dt">int</span> capacity<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> weights<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> values<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">knapsackHelper</span><span class="op">(</span>capacity<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recursive helper method with memoization</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">knapsackHelper</span><span class="op">(</span><span class="dt">int</span> capacity<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> weights<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> values<span class="op">,</span> <span class="dt">int</span> n<span class="op">,</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> capacity <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> key <span class="op">=</span> n <span class="op">+</span> <span class="st">&quot;:&quot;</span> <span class="op">+</span> capacity<span class="op">;</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>key<span class="op">))</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>key<span class="op">);</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If weight of the nth item is more than the capacity, skip it</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>weights<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> capacity<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>key<span class="op">,</span> <span class="fu">knapsackHelper</span><span class="op">(</span>capacity<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Include the item and exclude the item, take the maximum</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> includedValue <span class="op">=</span> values<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="fu">knapsackHelper</span><span class="op">(</span>capacity <span class="op">-</span> weights<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> weights<span class="op">,</span> values<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> excludedValue <span class="op">=</span> <span class="fu">knapsackHelper</span><span class="op">(</span>capacity<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>            memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>key<span class="op">,</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>includedValue<span class="op">,</span> excludedValue<span class="op">));</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>key<span class="op">);</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        Knapsack knapsack <span class="op">=</span> <span class="kw">new</span> <span class="fu">Knapsack</span><span class="op">();</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> weights <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> values <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">40</span><span class="op">};</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> capacity <span class="op">=</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> values<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxValue <span class="op">=</span> knapsack<span class="op">.</span><span class="fu">knapsack</span><span class="op">(</span>capacity<span class="op">,</span> weights<span class="op">,</span> values<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">+</span> maxValue<span class="op">);</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>HashMap for Memoization</strong>: We use a
<code>HashMap</code> to keep results we already found. The key is a mix
of the item index and the remaining capacity.</li>
<li><strong>Recursive Function</strong>: The <code>knapsackHelper</code>
method finds the maximum value by checking if we should include the
current item or not.</li>
<li><strong>Base Case</strong>: We stop when there are no items left or
the capacity is zero.</li>
<li><strong>Result Calculation</strong>: We calculate the maximum of the
included and excluded values. Then we store it in our memoization
map.</li>
</ul>
<p>This code helps us reduce the time from exponential to polynomial. It
makes sure we compute each state only one time. For more learning about
dynamic programming, you can check articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-simple-0-1-knapsack-small-instance-easy.html">Dynamic
Programming - Simple 0/1 Knapsack</a>.</p>
<h2 id="memoization-technique-for-01-knapsack-in-python">Memoization
Technique for 0/1 Knapsack in Python</h2>
<p>We use memoization to make recursive functions faster. This method
saves the results of expensive calls. Then, we can use those results
again when we get the same inputs. For the 0/1 Knapsack problem,
memoization helps us save a lot of time.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have weights and values for <code>n</code> items. Our goal is to
find the maximum value we can get. We can only select items if their
total weight does not go over the given limit <code>W</code>.</p>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is a simple Python code using memoization for the 0/1 Knapsack
problem:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> knapsack(weights, values, W, n, memo):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if result is already computed</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> memo[n][W] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n][W]</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: no items or no capacity</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> W <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># If weight of the nth item is more than W, skip it</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> weights[n<span class="op">-</span><span class="dv">1</span>] <span class="op">&gt;</span> W:</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        memo[n][W] <span class="op">=</span> knapsack(weights, values, W, n<span class="op">-</span><span class="dv">1</span>, memo)</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Maximize value by either including or excluding the nth item</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        include_item <span class="op">=</span> values[n<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> knapsack(weights, values, W <span class="op">-</span> weights[n<span class="op">-</span><span class="dv">1</span>], n<span class="op">-</span><span class="dv">1</span>, memo)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        exclude_item <span class="op">=</span> knapsack(weights, values, W, n<span class="op">-</span><span class="dv">1</span>, memo)</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        memo[n][W] <span class="op">=</span> <span class="bu">max</span>(include_item, exclude_item)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n][W]</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> main():</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    weights <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">40</span>]</span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> <span class="dv">6</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(values)</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(W <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    max_value <span class="op">=</span> knapsack(weights, values, W, n, memo)</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Maximum value in Knapsack =&quot;</span>, max_value)</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    main()</span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<ul>
<li>The <code>knapsack</code> function takes the weights and values of
the items. It also takes the current capacity <code>W</code>, the number
of items <code>n</code>, and a memoization table <code>memo</code>.</li>
<li>First, we check if we already found the answer for the current state
(<code>n</code>, <code>W</code>). If we did, we just return that
value.</li>
<li>If there are no items or the capacity is zero, we return zero. This
is the base case.</li>
<li>If the weight of the current item is more than the capacity, we skip
this item and find the maximum value for the remaining items.</li>
<li>If we can include the item, we find the maximum value by including
or excluding the item. We store the result in the memoization
table.</li>
<li>Finally, we return the maximum value we can get with the weights and
values we have.</li>
</ul>
<h3 id="advantages-of-using-memoization">Advantages of Using
Memoization</h3>
<ul>
<li><strong>Efficiency</strong>: It makes the time complexity lower from
exponential to polynomial.</li>
<li><strong>Reusability</strong>: It saves results of smaller problems.
This way, we do not calculate them again.</li>
</ul>
<p>This memoization method is very helpful for solving the 0/1 Knapsack
problem fast. If you want to learn more about dynamic programming, you
can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Dynamic
Programming: Subset Sum Problem</a>.</p>
<h2 id="memoization-technique-for-01-knapsack-in-c">Memoization
Technique for 0/1 Knapsack in C++</h2>
<p>The memoization technique helps us to make recursive algorithms
faster. It saves the results of costly function calls. When we use the
same inputs again, it gives us the saved result. For the 0/1 Knapsack
problem, this method can cut down the time we need by avoiding repeating
calculations.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple C++ code that uses the memoization technique for the
0/1 Knapsack problem:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> knapsackUtil<span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span> wt<span class="op">[],</span> <span class="dt">int</span> val<span class="op">[],</span> <span class="dt">int</span> n<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base case: no items left or no capacity</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> W <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check if we already have the result</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">][</span>W<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">][</span>W<span class="op">];</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// If the weight of the nth item is more than Knapsack capacity W, skip it</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>wt<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> W<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">][</span>W<span class="op">]</span> <span class="op">=</span> knapsackUtil<span class="op">(</span>W<span class="op">,</span> wt<span class="op">,</span> val<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Get the maximum value of two options: nth item included and not included</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">][</span>W<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>val<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> knapsackUtil<span class="op">(</span>W <span class="op">-</span> wt<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> wt<span class="op">,</span> val<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">),</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                                knapsackUtil<span class="op">(</span>W<span class="op">,</span> wt<span class="op">,</span> val<span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> knapsack<span class="op">(</span><span class="dt">int</span> W<span class="op">,</span> <span class="dt">int</span> wt<span class="op">[],</span> <span class="dt">int</span> val<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> memo<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>W <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> knapsackUtil<span class="op">(</span>W<span class="op">,</span> wt<span class="op">,</span> val<span class="op">,</span> n<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> val<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">60</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">120</span><span class="op">};</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wt<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">20</span><span class="op">,</span> <span class="dv">30</span><span class="op">};</span></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> W <span class="op">=</span> <span class="dv">50</span><span class="op">;</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="kw">sizeof</span><span class="op">(</span>val<span class="op">)</span> <span class="op">/</span> <span class="kw">sizeof</span><span class="op">(</span>val<span class="op">[</span><span class="dv">0</span><span class="op">]);</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum value in Knapsack = &quot;</span> <span class="op">&lt;&lt;</span> knapsack<span class="op">(</span>W<span class="op">,</span> wt<span class="op">,</span> val<span class="op">,</span> n<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-4">Explanation of the Code</h3>
<ul>
<li><strong>Function <code>knapsackUtil</code></strong>: This is the
recursive function that uses memoization for the knapsack problem.
<ul>
<li>It checks base cases where there are no items left or the capacity
is zero.</li>
<li>If we already calculated the value and stored it in
<code>memo</code>, it returns that value.</li>
<li>If the current item is too heavy for the capacity, it skips that
item.</li>
<li>Otherwise, it finds the maximum value by including or not including
the current item.</li>
</ul></li>
<li><strong>Function <code>knapsack</code></strong>: This sets up the
memoization table and calls the recursive function.</li>
</ul>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n * W) where n is the number of
items and W is the maximum capacity of the knapsack.</li>
<li><strong>Space Complexity</strong>: O(n * W) for the memoization
table.</li>
</ul>
<p>This code helps us solve the 0/1 Knapsack problem quickly using
memoization in C++. For more reading on similar dynamic programming
problems, we can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-simple-0-1-knapsack-small-instance-easy.html">Dynamic
Programming - Simple 0/1 Knapsack Small Instance</a>.</p>
<h2 id="time-and-space-complexity-analysis-of-01-knapsack">Time and
Space Complexity Analysis of 0/1 Knapsack</h2>
<p>We can look at the time and space complexity of the 0/1 Knapsack
problem by using the dynamic programming method.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ol type="1">
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>The time complexity for the 0/1 Knapsack problem with dynamic
programming is O(n * W). Here:
<ul>
<li>n is the number of items.</li>
<li>W is the maximum weight the knapsack can hold.</li>
</ul></li>
<li>This happens because we fill a 2D array that has size (n + 1) x (W +
1). We check each item with each weight capacity.</li>
</ul></li>
<li><strong>Memoization Technique</strong>:
<ul>
<li>With memoization, the time complexity is still O(n * W). The
recursive function solves each small problem one time and saves the
answers.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ol type="1">
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>The space complexity for the normal dynamic programming solution is
O(n * W). This is because we need to keep the 2D table for storing
results.</li>
</ul></li>
<li><strong>Optimized Space Complexity</strong>:
<ul>
<li>We can reduce the space complexity to O(W) by using a 1D array
instead of a 2D array. We can do this because we can overwrite the
values from the previous row. They are not needed after each step.</li>
</ul></li>
<li><strong>Memoization Technique</strong>:
<ul>
<li>For memoization, the space complexity is O(n) for the call stack
plus O(n * W) for the memoization table. So total space is O(n *
W).</li>
</ul></li>
</ol>
<p>In short, both the dynamic programming and memoization methods have a
time complexity of O(n * W). The space complexity can change from O(n *
W) to O(W) based on how we optimize. The choice of method and
optimization depends on the details of the problem. For more information
on similar problems, you can check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Dynamic
Programming: Subset Sum Problem</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-01-knapsack-problem-in-dynamic-programming">What is
the 0/1 Knapsack Problem in Dynamic Programming?</h3>
<p>The 0/1 Knapsack Problem is a well-known problem in dynamic
programming. It involves a group of items. Each item has a weight and a
value. We also have a knapsack. It can only hold a certain maximum
weight. The goal is to find the best combination of items that gives the
highest total value without going over the weight limit. This problem
shows how we can optimize things in dynamic programming. It is important
in computer science.</p>
<h3 id="how-do-you-implement-the-01-knapsack-algorithm-in-python">How do
you implement the 0/1 Knapsack algorithm in Python?</h3>
<p>To implement the 0/1 Knapsack algorithm in Python, we can use a
dynamic programming method. First, we create a 2D array. The rows will
represent the items. The columns will represent the weights. Then, we go
through each item. We update the array to keep the highest value for
each weight. This way, we can find the best solution by using answers
from smaller problems.</p>
<h3 id="what-is-the-time-complexity-of-the-01-knapsack-problem">What is
the time complexity of the 0/1 Knapsack Problem?</h3>
<p>The time complexity of the 0/1 Knapsack Problem using dynamic
programming is O(nW). Here, n is the number of items and W is the weight
limit of the knapsack. This complexity comes from filling a 2D table.
This table keeps track of the highest value for each item and weight. It
helps us find good solutions even when the input is not too small.</p>
<h3
id="can-you-explain-the-difference-between-memoization-and-dynamic-programming-for-01-knapsack">Can
you explain the difference between Memoization and Dynamic Programming
for 0/1 Knapsack?</h3>
<p>Memoization and dynamic programming are both ways to optimize the 0/1
Knapsack Problem. But they are different in how they work. Memoization
is a top-down method. It uses recursive functions and saves results of
small problems. This stops us from doing the same work again. On the
other hand, dynamic programming is a bottom-up method. It solves all
small problems one by one and builds the solution step by step.</p>
<h3
id="are-there-other-problems-related-to-the-01-knapsack-problem-in-dynamic-programming">Are
there other problems related to the 0/1 Knapsack Problem in dynamic
programming?</h3>
<p>Yes, there are many other problems in dynamic programming. Some
examples are the Subset Sum Problem and the Fractional Knapsack Problem.
The Subset Sum Problem checks if a group of numbers can add up to a
certain target. The Fractional Knapsack Problem lets us divide items and
take parts of them. We can solve it using a greedy method. If you want
to learn more, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-subset-sum-problem-medium.html">Subset
Sum Problem</a> to see the details.</p>
<p>These FAQs give a good view of the 0/1 Knapsack Problem and related
ideas. They help us understand dynamic programming better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            