
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Increasing Subsequence with Gap Constraint - Medium</title>
            <meta name="description" content="Discover how to solve the Maximum Sum of Increasing Subsequence with Gap Constraint using Dynamic Programming. Boost your skills!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Increasing Subsequence with Gap Constraint - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Sum of Increasing Subsequence with Gap Constraint is a
dynamic programming problem. Our goal is to find the highest sum of an
increasing subsequence from a given array. We must also make sure that
no two elements in the subsequence are next to each other in the
original array. This means if we pick an element at index i, we cannot
pick the elements at indices i-1 or i+1. To solve this problem in a
smart way, we use a dynamic programming approach. This method builds on
results we have already found to avoid doing the same work again.</p>
<p>In this article, we will talk about different parts of the Maximum
Sum of Increasing Subsequence with Gap Constraint. We will begin by
understanding the problem and what we need to do. Then, we will look at
how optimal substructure and overlapping subproblems work in dynamic
programming. After that, we will check the brute force solution. Next,
we will look at the dynamic programming solutions in Java, Python, and
C++. Finally, we will analyze the time and space complexity of these
solutions. We will also discuss common edge cases and answer some
frequently asked questions about this topic.</p>
<ul>
<li>Dynamic Programming Approach for Maximum Sum of Increasing
Subsequence with Gap Constraint</li>
<li>Understanding the Problem Statement and Requirements</li>
<li>Optimal Substructure and Overlapping Subproblems in Dynamic
Programming</li>
<li>Brute Force Solution for Maximum Sum of Increasing Subsequence</li>
<li>Dynamic Programming Solution in Java for Maximum Sum of Increasing
Subsequence</li>
<li>Dynamic Programming Solution in Python for Maximum Sum of Increasing
Subsequence</li>
<li>Dynamic Programming Solution in C++ for Maximum Sum of Increasing
Subsequence</li>
<li>Time and Space Complexity Analysis of the Solutions</li>
<li>Common Edge Cases and Considerations</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on related dynamic programming ideas, check out
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-increasing-subsequence-medium.html">Dynamic
Programming: Maximum Sum of Increasing Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2
id="understanding-the-problem-statement-and-requirements">Understanding
the Problem Statement and Requirements</h2>
<p>We need to find the <strong>Maximum Sum of Increasing Subsequence
with Gap Constraint</strong>. This means we want to get the largest sum
from a list of numbers. The numbers we pick must be in order from
smallest to biggest, and they cannot be next to each other in the
original list. If we choose a number at position <code>i</code>, we
cannot pick numbers at positions <code>i-1</code> and
<code>i-2</code>.</p>
<h3 id="problem-definition">Problem Definition:</h3>
<ul>
<li><strong>Input</strong>: A list of integers <code>arr</code> with
length <code>n</code>.</li>
<li><strong>Output</strong>: The biggest sum of a strictly increasing
subsequence where no two chosen numbers are next to each other.</li>
</ul>
<h3 id="example">Example:</h3>
<p>Let’s say our input list is <code>arr = [3, 5, 6, 7, 8, 9]</code>.
The biggest sum from an increasing subsequence is
<code>3 + 6 + 9 = 18</code>. The chosen positions are <code>0</code>,
<code>2</code>, and <code>5</code>. These numbers are in order and are
not next to each other.</p>
<h3 id="requirements">Requirements:</h3>
<ol type="1">
<li><strong>Constraints</strong>:
<ul>
<li>The subsequence must be in order from smallest to biggest.</li>
<li>The numbers we choose cannot be next to each other in the original
list.</li>
</ul></li>
<li><strong>Goal</strong>:
<ul>
<li>We want to use dynamic programming to find the biggest sum while
following the rules.</li>
</ul></li>
<li><strong>Output Format</strong>: The result should be a whole number
that shows the biggest sum we found.</li>
</ol>
<p>We can solve this problem using dynamic programming. We will talk
more about this in the next sections. We will explore how to analyze the
best parts and show code examples in Java, Python, and C++.</p>
<h2
id="optimal-substructure-and-overlapping-subproblems-in-dynamic-programming">Optimal
Substructure and Overlapping Subproblems in Dynamic Programming</h2>
<p>We can solve the problem of finding the maximum sum of an increasing
subsequence with a gap constraint using dynamic programming. We focus on
two main ideas: optimal substructure and overlapping subproblems.</p>
<h3 id="optimal-substructure">Optimal Substructure</h3>
<p>Optimal substructure means we can build a solution from smaller
parts. For our problem, we can define the optimal substructure like
this:</p>
<ul>
<li><p>Let <code>dp[i]</code> be the maximum sum of an increasing
subsequence that ends with the element at index <code>i</code>.</p></li>
<li><p>For each element <code>arr[i]</code>, we will look at all
previous elements <code>arr[j]</code> (where <code>j &lt; i</code> and
<code>arr[j] &lt; arr[i]</code>). We update <code>dp[i]</code> like
this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> arr[i])  <span class="co"># if j is allowed by gap constraints</span></span></code></pre></div></li>
</ul>
<h3 id="overlapping-subproblems">Overlapping Subproblems</h3>
<p>Overlapping subproblems happen when we solve the same smaller
problems many times. In our case:</p>
<ul>
<li>When we calculate <code>dp[i]</code>, we need the values of
<code>dp[j]</code> for all valid <code>j &lt; i</code>. This means as we
find results for larger subsequences, we often need to redo calculations
for <code>dp</code> values that we already found.</li>
<li>By saving these values in a <code>dp</code> array, we do not have to
calculate them again. We make sure each value is computed only
once.</li>
</ul>
<h3 id="example-1">Example</h3>
<p>Let’s say we have an array <code>arr = [3, 5, 6, 2, 4, 5]</code>. We
will compute the <code>dp</code> array like this:</p>
<ol type="1">
<li>Start with <code>dp[i] = arr[i]</code> for all <code>i</code>.</li>
<li>Go through each element and check the previous elements to update
the <code>dp</code> value based on the increasing order and gap
rules.</li>
</ol>
<p>This method helps us build on what we already computed. It finds the
maximum sum of the increasing subsequence while following the gap
constraints.</p>
<p>Here is a simple implementation in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_increasing_subsequence(arr):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> arr[:]  <span class="co"># Copy arr to dp</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i]:  <span class="co"># Check if it is increasing</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> arr[i])  <span class="co"># Update dp[i]</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)  <span class="co"># The max value in dp is our answer</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_increasing_subsequence(arr))  <span class="co"># Output: 12</span></span></code></pre></div>
<p>This code shows the dynamic programming approach. It uses both
optimal substructure and overlapping subproblems. This way, we get an
efficient and clear solution for the maximum sum of increasing
subsequences with gap constraints.</p>
<h2
id="brute-force-solution-for-maximum-sum-of-increasing-subsequence">Brute
Force Solution for Maximum Sum of Increasing Subsequence</h2>
<p>We can use a brute force method to solve the Maximum Sum of
Increasing Subsequence with Gap Constraint. This means we look at all
possible subsequences of the input array. Then we calculate their sums.
We also make sure the selected elements follow the gap rule. This way is
not fast for big inputs but is a simple way to start learning about the
problem.</p>
<h3 id="steps-to-implement-the-brute-force-solution">Steps to Implement
the Brute Force Solution</h3>
<ol type="1">
<li><strong>Generate Subsequences</strong>: We need to find all
increasing subsequences of the array.</li>
<li><strong>Check Gap Constraint</strong>: We check if each subsequence
follows the gap rule.</li>
<li><strong>Calculate Sums</strong>: We add up the valid
subsequences.</li>
<li><strong>Track Maximum Sum</strong>: We keep a variable to remember
the biggest sum we find.</li>
</ol>
<h3 id="example-2">Example</h3>
<p>If we have an array <code>arr = [3, 5, 6, 7, 8]</code> and a gap of
1, some increasing subsequences are: - <code>[3]</code> -
<code>[5]</code> - <code>[3, 5]</code> - <code>[3, 6]</code> -
<code>[3, 7]</code> - and more.</p>
<h3 id="brute-force-code-implementation">Brute Force Code
Implementation</h3>
<p>Here is a simple Python code for the brute force method:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_valid(subseq, gap):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(subseq) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(subseq[i] <span class="op">-</span> subseq[i <span class="op">+</span> <span class="dv">1</span>]) <span class="op">&lt;=</span> gap:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="va">False</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> generate_subsequences(arr):</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    subsequences <span class="op">=</span> []</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span> <span class="op">&lt;&lt;</span> n):  <span class="co"># 2^n combinations</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        subseq <span class="op">=</span> []</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">&amp;</span> (<span class="dv">1</span> <span class="op">&lt;&lt;</span> j):</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                subseq.append(arr[j])</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> subseq <span class="kw">and</span> <span class="bu">all</span>(subseq[k] <span class="op">&lt;</span> subseq[k <span class="op">+</span> <span class="dv">1</span>] <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(subseq) <span class="op">-</span> <span class="dv">1</span>)):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            subsequences.append(subseq)</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> subsequences</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_increasing_subsequence(arr, gap):</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    subsequences <span class="op">=</span> generate_subsequences(arr)</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> subseq <span class="kw">in</span> subsequences:</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_valid(subseq, gap):</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, <span class="bu">sum</span>(subseq))</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>]</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>gap <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_increasing_subsequence(arr, gap))  <span class="co"># Output the maximum sum</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n) because we create all
possible subsequences.</li>
<li><strong>Space Complexity</strong>: O(n) for saving the
subsequences.</li>
</ul>
<p>We see that this brute force way helps us understand the problem. But
it is not good for large data because it takes a lot of time. For a
better solution, we can use dynamic programming methods that can make
the time faster.</p>
<h2
id="dynamic-programming-solution-in-java-for-maximum-sum-of-increasing-subsequence">Dynamic
Programming Solution in Java for Maximum Sum of Increasing
Subsequence</h2>
<p>We want to find the maximum sum of an increasing subsequence with a
gap rule using dynamic programming in Java. Our aim is to make the sum
of elements in the increasing subsequence as big as possible while
making sure that no two chosen elements are next to each other.</p>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is a simple code for the dynamic programming solution:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumSumIncreasingSubsequence <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSumIS</span><span class="op">(</span><span class="dt">int</span> arr<span class="op">[],</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create an array to store maximum sum ending at each index</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> maxSum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize maxSum with the array elements</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            maxSum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Build the maxSum array</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Update maxSum[i] if arr[i] is greater than arr[j]</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">// and the gap constraint is satisfied</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> i <span class="op">-</span> j <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                    maxSum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">[</span>i<span class="op">],</span> maxSum<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find the maximum sum from the maxSum array</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            max <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>max<span class="op">,</span> maxSum<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Sum of Increasing Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">maxSumIS</span><span class="op">(</span>arr<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The <code>maxSumIS</code> method makes an array called
<code>maxSum</code> to keep the max sum subsequence ending at each
index.</li>
<li>It fills <code>maxSum</code> with the same values as the input array
at first.</li>
<li>A nested loop goes through the array to change <code>maxSum</code>
based on the increasing subsequence rule and the gap rule.</li>
<li>In the end, it finds the highest value in <code>maxSum</code>, which
shows the maximum sum of the increasing subsequence with the gap
rule.</li>
</ul>
<h3 id="example-usage">Example Usage</h3>
<p>For the input array <code>{3, 2, 5, 10, 7}</code>, the output will
be:</p>
<pre><code>Maximum Sum of Increasing Subsequence: 15</code></pre>
<p>This is because we select the subsequence <code>{5, 10}</code> which
gives the maximum sum of 15, keeping the gap rule.</p>
<p>This Java code works well to find the maximum sum of an increasing
subsequence with a gap rule using dynamic programming ideas.</p>
<h2
id="dynamic-programming-solution-in-python-for-maximum-sum-of-increasing-subsequence">Dynamic
Programming Solution in Python for Maximum Sum of Increasing
Subsequence</h2>
<p>We will solve the problem of finding the maximum sum of an increasing
subsequence with a gap constraint using dynamic programming in Python.
Our approach is simple.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have an array <code>nums</code>. We need to find the maximum sum
of increasing subsequences. We must make sure that no two elements in
the subsequence are next to each other.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create a <code>dp</code> array.
Each <code>dp[i]</code> will hold the maximum sum of the increasing
subsequence that ends at index <code>i</code>.</li>
<li><strong>Base Case</strong>: Each element can be a subsequence by
itself. So we set <code>dp[i] = nums[i]</code> for all
<code>i</code>.</li>
<li><strong>Recurrence Relation</strong>: For each element
<code>nums[i]</code>, we check all previous elements
<code>nums[j]</code> where <code>j</code> is less than <code>i</code>.
If <code>nums[j]</code> is less than <code>nums[i]</code>, we update
<code>dp[i]</code> like this: [ dp[i] = (dp[i], dp[j] + nums[i]) ]</li>
<li><strong>Result</strong>: The answer is the maximum value in the
<code>dp</code> array.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_increasing_subsequence(nums):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> nums[i]  <span class="co"># Start with the value itself</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[j] <span class="op">&lt;</span> nums[i]:  <span class="co"># Check the increasing condition</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> nums[i])</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">6</span>, <span class="dv">7</span>, <span class="dv">8</span>, <span class="dv">20</span>]</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> max_sum_increasing_subsequence(nums)</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum Sum of Increasing Subsequence:&quot;</span>, result)  <span class="co"># Output: 48</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<p>The <code>max_sum_increasing_subsequence</code> function starts by
making a <code>dp</code> list. This list stores the maximum sums. We
loop through the array to fill the <code>dp</code> list based on the
conditions we said before. Finally, we return the maximum value from the
<code>dp</code> list. This value is the maximum sum of the increasing
subsequence.</p>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). This is because we compare
each element with all previous elements.</li>
<li><strong>Space Complexity</strong>: O(n). This is for the
<code>dp</code> array.</li>
</ul>
<p>This dynamic programming solution helps us find the maximum sum of an
increasing subsequence with the gap constraint. It follows the rules of
the problem. If we want to learn more about similar problems, we can
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-increasing-subsequence-medium.html">Dynamic
Programming - Maximum Sum of Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-solution-in-c-for-maximum-sum-of-increasing-subsequence">Dynamic
Programming Solution in C++ for Maximum Sum of Increasing
Subsequence</h2>
<p>To solve the problem of finding the maximum sum of an increasing
subsequence with a gap rule using dynamic programming in C++, we create
a dynamic programming array. Each element at index <code>i</code> shows
the maximum sum of an increasing subsequence that ends with the element
at index <code>i</code>.</p>
<p>We start by looking through the array. For each element, we check all
previous elements. We want to find suitable candidates that can add to
the subsequence sum. The gap rule means we only look at previous
elements that are not next to the current one.</p>
<p>Here is a C++ code that shows this way:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumIS<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create an array to store maximum sum ending at each index</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span>i<span class="op">];</span> <span class="co">// Set max sum as the element itself</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the dp array</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span> <span class="co">// Check for gap rule</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The result is the maximum value in dp[]</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span><span class="bu">std::</span>max_element<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Maximum Sum of Increasing Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> maxSumIS<span class="op">(</span>arr<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code:</h3>
<ul>
<li><strong>Initialization</strong>: We start the <code>dp</code> array.
We set each element to the same value in the input array. The minimum
sum for each element is the element itself.</li>
<li><strong>Nested Loops</strong>: The outer loop goes through each
element of the array. The inner loop checks all previous elements (with
the gap rule). If the current element is bigger than the previous one,
we update the <code>dp</code> value for the current index.</li>
<li><strong>Result Calculation</strong>: At last, we get the result by
finding the biggest value in the <code>dp</code> array. This shows the
maximum sum of an increasing subsequence.</li>
</ul>
<p>This dynamic programming solution runs in O(n^2) time. This is good
for input arrays that are not too big. For more information on dynamic
programming techniques, we can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-increasing-subsequence-medium.html">Dynamic
Programming - Maximum Sum of Increasing Subsequence</a>.</p>
<h2 id="time-and-space-complexity-analysis-of-the-solutions">Time and
Space Complexity Analysis of the Solutions</h2>
<p>We can look at the time and space complexity of the Maximum Sum of
Increasing Subsequence with Gap Constraint. We will check both the brute
force way and the dynamic programming way.</p>
<h3 id="brute-force-approach">Brute Force Approach</h3>
<ul>
<li><strong>Time Complexity:</strong> O(2^n)
<ul>
<li>The brute force method checks all possible subsequences. This makes
the time grow very fast.</li>
</ul></li>
<li><strong>Space Complexity:</strong> O(n)
<ul>
<li>The recursion stack can go as deep as n at its worst.</li>
</ul></li>
</ul>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<p>The dynamic programming way improves the brute force way. It does
this by using memoization or tabulation.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n^2)
<ul>
<li>The algorithm goes through each element. It checks past elements
that can make an increasing subsequence. This means n comparisons for
each of the n elements.</li>
</ul></li>
<li><strong>Space Complexity:</strong> O(n)
<ul>
<li>The DP array keeps the maximum sums for each index. This uses linear
space.</li>
</ul></li>
</ul>
<h3 id="example-analysis">Example Analysis</h3>
<p>If we have an input array <code>arr[] = {3, 2, 5, 10, 7}</code>, we
can write the dynamic programming solution like this:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">maximumSumIncreasingSubsequence</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="bu">System</span><span class="op">.</span><span class="fu">arraycopy</span><span class="op">(</span>arr<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> dp<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n<span class="op">);</span> <span class="co">// Initialize dp array with arr values</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> i <span class="op">-</span> j <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span> <span class="co">// Gap constraint</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> sum <span class="op">:</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> sum<span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this solution, we see the time complexity is still O(n^2) because
of the nested loops. The space complexity is O(n) because of the
<code>dp</code> array.</p>
<h3 id="summary-of-complexity">Summary of Complexity</h3>
<ul>
<li><strong>Brute Force:</strong>
<ul>
<li>Time: O(2^n), Space: O(n)</li>
</ul></li>
<li><strong>Dynamic Programming:</strong>
<ul>
<li>Time: O(n^2), Space: O(n)</li>
</ul></li>
</ul>
<p>This analysis shows how much better the dynamic programming method is
compared to the brute force way. We can see why it is a better option
for the Maximum Sum of Increasing Subsequence with Gap Constraint
problem.</p>
<h2 id="common-edge-cases-and-considerations">Common Edge Cases and
Considerations</h2>
<p>When we use dynamic programming to find the Maximum Sum of Increasing
Subsequence with Gap Constraint, we should think about many edge cases
and things to consider:</p>
<ul>
<li><p><strong>Empty Input</strong>: If our input array is empty, the
maximum sum is 0. We need to check this case first in our code.</p></li>
<li><p><strong>Single Element</strong>: If our array has only one
element, the maximum sum is just that element. We should return it right
away without more checks.</p></li>
<li><p><strong>All Negative Numbers</strong>: If our array has only
negative numbers, the algorithm should still find the maximum value.
This will be the least negative number. We should compare sums carefully
to get the right result.</p></li>
<li><p><strong>All Increasing or Decreasing</strong>: If the array is
sorted in increasing order, the maximum sum is the total of all
elements. If it is sorted in decreasing order, the maximum sum will be
the first element because we can’t make a valid increasing
subsequence.</p></li>
<li><p><strong>Repeated Elements</strong>: If our input array has
repeated elements, we must make sure the algorithm finds increasing
subsequences correctly. For example, if we have <code>[3, 3, 3]</code>,
it should return 3.</p></li>
<li><p><strong>Gap Constraint Handling</strong>: The gap constraint
means that after we pick one element, the next one in our subsequence
must be at least two indices away. We need to pay attention to this in
our implementation.</p></li>
<li><p><strong>Performance with Large Inputs</strong>: If our input size
is big, the time complexity of O(n^2) can be a problem. We should think
about ways to make it faster or use different algorithms if we have
performance issues.</p></li>
<li><p><strong>Data Type Limits</strong>: When we calculate sums,
especially with big numbers, we need to check that our data types can
manage the possible overflow. We should use data types like
<code>long</code> in Java or <code>int</code> in Python
carefully.</p></li>
<li><p><strong>Negative Gap Values</strong>: Usually, the gap is
positive. But we need to make sure our implementation ignores any
negative gap constraints if we make a mistake.</p></li>
</ul>
<p>By thinking about these edge cases, we can make a strong
implementation of the Maximum Sum of Increasing Subsequence with Gap
Constraint. If we want to read more about dynamic programming, we can
check these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-increasing-subsequence-with-a-gap-constraint">1.
What is the maximum sum of increasing subsequence with a gap
constraint?</h3>
<p>The maximum sum of increasing subsequence with a gap constraint means
we want to find the biggest sum of increasing numbers in a sequence. We
cannot pick two numbers that are next to each other. This is a special
case of the maximum sum increasing subsequence problem. We need to use
dynamic programming to find the answer in a smart way.</p>
<h3
id="how-does-dynamic-programming-apply-to-the-maximum-sum-of-increasing-subsequence-with-gap-constraint">2.
How does dynamic programming apply to the maximum sum of increasing
subsequence with gap constraint?</h3>
<p>We use dynamic programming for this problem by breaking it into
smaller parts. We keep the results of sums we have already calculated.
This helps us not to do the same work again. So, we can solve the
problem faster than just trying all options. This method is very
important for solving this medium-level dynamic programming task.</p>
<h3
id="can-you-explain-the-brute-force-solution-for-the-maximum-sum-of-increasing-subsequence-with-gap-constraint">3.
Can you explain the brute force solution for the maximum sum of
increasing subsequence with gap constraint?</h3>
<p>The brute force way to solve this problem is to make all possible
subsequences and find their sums. We also check if they follow the gap
rule. But this way is not good. It takes too much time, especially when
the input is big. So, we better use dynamic programming because it works
better.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-the-maximum-sum-of-increasing-subsequence">4.
What is the time complexity of the dynamic programming solution for the
maximum sum of increasing subsequence?</h3>
<p>The time complexity for the dynamic programming solution is O(n^2).
Here, n is the number of elements in the input array. This happens
because we have nested loops to compare the numbers and create the
maximum sum array. The space complexity is O(n) since we need space to
keep some results.</p>
<h3
id="are-there-any-common-edge-cases-to-consider-in-the-maximum-sum-of-increasing-subsequence-problem">5.
Are there any common edge cases to consider in the maximum sum of
increasing subsequence problem?</h3>
<p>Yes, there are some common edge cases. One is an empty input array.
The result should be zero in this case. Another case is when all
elements are the same. The maximum sum would just be one of those
elements. Also, if there is only one element, that should be the maximum
sum. These cases show how important it is to make a strong
implementation in dynamic programming solutions.</p>
<p>For more insights into dynamic programming techniques, we can explore
related topics like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">maximum
subarray sum using Kadane’s algorithm</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">longest
increasing subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            