
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Increasing Subsequence in a Circular Array - Hard</title>
            <meta name="description" content=""Master Dynamic Programming with our guide on the Longest Increasing Subsequence in a Circular Array. Tackle this hard challenge!"">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Increasing Subsequence in a Circular Array - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Increasing Subsequence (LIS) in a circular array is a
hard problem in dynamic programming. It needs us to find the longest
subsequence where elements go up in order while we think about the
circular shape of the array. To solve this, we change the circular array
into a straight line. This helps us use the regular LIS methods better.
With dynamic programming methods, we can find the longest increasing
subsequence quickly and efficiently.</p>
<p>In this article, we will look at different parts of the Longest
Increasing Subsequence in a Circular Array. We will talk about advanced
methods for dynamic programming. We will also explain the problem
statement and its limits. Then, we will check the usual dynamic
programming way for LIS. After that, we will discuss how to change
circular arrays. We will give examples in Java, Python, and C++. We will
also talk about how to make it better and look at the complexity.
Finally, we will mention some real-life uses of this algorithm. We will
end with some common questions about this topic.</p>
<ul>
<li>[Dynamic Programming] Longest Increasing Subsequence in a Circular
Array - Advanced Techniques</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach for Longest Increasing Subsequence</li>
<li>Circular Array Transformation for Standard LIS</li>
<li>Java Implementation of Longest Increasing Subsequence in Circular
Array</li>
<li>Python Solution for Longest Increasing Subsequence in Circular
Array</li>
<li>C++ Code for Longest Increasing Subsequence in Circular Array</li>
<li>Optimizations and Complexity Analysis</li>
<li>Practical Applications of Longest Increasing Subsequence</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to read more about related dynamic programming topics,
you can check the articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
Numbers</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs</a>.</p>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>The <strong>Longest Increasing Subsequence (LIS)</strong> in a
circular array problem asks us to find the longest sequence of
increasing numbers from an array that wraps around. This means the last
elements can connect to the first ones.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have an array called <code>nums</code>. Our goal is to find the
length of the longest strictly increasing subsequence. This subsequence
should consider the array as circular.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The length of the array <code>nums</code> can be from <code>1</code>
to <code>10^5</code>.</li>
<li>Each number in <code>nums</code> can be from <code>-10^4</code> to
<code>10^4</code>.</li>
</ul>
<h3 id="example">Example</h3>
<p>Let’s look at this circular array:</p>
<pre><code>nums = [3, 1, 5, 2, 4]</code></pre>
<p>The longest increasing subsequence we can find is:</p>
<ul>
<li>Non-circular: <code>[1, 2, 4]</code> → Length: 3</li>
<li>Circular: <code>[4, 1, 2]</code> → Length: 3</li>
</ul>
<p>In this example, both non-circular and circular LIS give us the same
length.</p>
<h3 id="key-points">Key Points</h3>
<ul>
<li>The subsequence does not need to be next to each other.</li>
<li>The circular part makes it harder since we must think about wrapping
around the array.</li>
<li>We can use dynamic programming techniques with some transformations
for an easier solution.</li>
</ul>
<p>This problem is a variation of the normal LIS problem. Understanding
the circular part is important to make a good algorithm. In the next
sections, we will look at a dynamic programming method for this problem.
We will also see how to implement it in Java, Python, and C++.</p>
<h2
id="dynamic-programming-approach-for-longest-increasing-subsequence">Dynamic
Programming Approach for Longest Increasing Subsequence</h2>
<p>The Longest Increasing Subsequence (LIS) is a well-known problem in
dynamic programming. Our goal is to find the longest subsequence in a
given sequence. This subsequence should have all elements in increasing
order. We can use dynamic programming to solve this problem in an
efficient way.</p>
<h3 id="dynamic-programming-methodology">Dynamic Programming
Methodology</h3>
<ol type="1">
<li><p><strong>Define the DP Array</strong>: We make a DP array. Here,
<code>dp[i]</code> shows the length of the longest increasing
subsequence that ends with the element at index <code>i</code>.</p></li>
<li><p><strong>Initialization</strong>: We set each element of the
<code>dp</code> array to 1. This is because the shortest increasing
subsequence that includes each element itself is 1.</p></li>
<li><p><strong>DP Transition</strong>: For each element
<code>nums[i]</code>, we compare it with all previous elements
<code>nums[j]</code> (where <code>j &lt; i</code>). If
<code>nums[i]</code> is greater than <code>nums[j]</code>, we update the
<code>dp[i]</code> value:</p>
<pre class="plaintext"><code>dp[i] = max(dp[i], dp[j] + 1)</code></pre></li>
<li><p><strong>Result Calculation</strong>: The result is the maximum
value in the <code>dp</code> array after we process all
elements.</p></li>
</ol>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity of this method is O(n^2). Here, n is the number
of elements in the input array.</p>
<h3 id="example-code-implementation">Example Code Implementation</h3>
<p>Here is a Java code for the dynamic programming approach to find the
Longest Increasing Subsequence:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestIncreasingSubsequence <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lengthOfLIS</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">:</span> dp<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>            maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> length<span class="op">);</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is a Python code for the same approach:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> length_of_lis(nums):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[j]:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp)</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a C++ code for the Longest Increasing Subsequence using
dynamic programming:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lengthOfLIS<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>max_element<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This dynamic programming approach helps us find the longest
increasing subsequence quickly. It works well for the number of elements
we have. For more advanced techniques about the Longest Increasing
Subsequence, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2 id="circular-array-transformation-for-standard-lis">Circular Array
Transformation for Standard LIS</h2>
<p>To solve the Longest Increasing Subsequence (LIS) problem in a
circular array, we can change the circular array to a regular linear
array. The main idea is to see that any increasing subsequence in a
circular array can be found by looking at the array as two separate
linear parts.</p>
<h3 id="steps-to-transform-a-circular-array">Steps to Transform a
Circular Array</h3>
<ol type="1">
<li><p><strong>Duplicate the Array</strong>: First, we create a new
array by joining the original array to itself. This helps us to mimic
the circular shape of the array without wrapping around.</p>
<ul>
<li>For an array <code>A</code> with length <code>n</code>, we make an
array <code>B = A + A</code>.</li>
</ul></li>
<li><p><strong>Limit the Subsequence Length</strong>: When we search for
the longest increasing subsequence, we must make sure that the length of
the subsequence does not go over <code>n</code>. This is important
because even though the array <code>B</code> has a length of
<code>2n</code>, valid subsequences can only start from the first
<code>n</code> elements.</p></li>
<li><p><strong>Apply LIS Algorithm</strong>: We use the normal LIS
algorithm on the first <code>2n</code> elements of the new array. But we
should only start the LIS from the original array’s index to keep the
circular rule.</p></li>
</ol>
<h3 id="example-1">Example</h3>
<p>For a circular array <code>A = [3, 4, 5, 1, 2]</code>, our new array
will be:</p>
<pre><code>B = [3, 4, 5, 1, 2, 3, 4, 5, 1, 2]</code></pre>
<p>When we apply the LIS algorithm, we make sure that no subsequence
starts after index <code>n-1</code> in the original array.</p>
<h3 id="lis-algorithm">LIS Algorithm</h3>
<p>A common way to find the LIS is using dynamic programming with binary
search. Here is a simple version in Python:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> lengthOfLIS(nums):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> bisect <span class="im">import</span> bisect_left</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> []</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect_left(dp, num)</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(dp):</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            dp.append(num)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            dp[pos] <span class="op">=</span> num</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(dp)</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circularLIS(arr):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    transformed <span class="op">=</span> arr <span class="op">+</span> arr</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    max_lis <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        max_lis <span class="op">=</span> <span class="bu">max</span>(max_lis, lengthOfLIS(transformed[i:i<span class="op">+</span>n]))</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_lis</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Increasing Subsequence in Circular Array:&quot;</span>, circularLIS(arr))</span></code></pre></div>
<p>This code changes the circular array and finds the longest increasing
subsequence while following the rules of a circular shape.</p>
<h2
id="java-implementation-of-longest-increasing-subsequence-in-circular-array">Java
Implementation of Longest Increasing Subsequence in Circular Array</h2>
<p>We can implement the Longest Increasing Subsequence (LIS) in a
circular array using Java. We will use a simple dynamic programming
method and a little trick to deal with the circular shape of the input
array. Here are the steps:</p>
<ol type="1">
<li><p><strong>Transform the Circular Array</strong>: First, we will
duplicate the array. This helps us handle the circular shape. If our
original array is <code>nums</code>, we create a new array called
<code>numsExtended</code>. Its size will be <code>2 * n</code>, where
<code>n</code> is the length of <code>nums</code>. We copy
<code>nums</code> into <code>numsExtended</code> two times.</p></li>
<li><p><strong>Dynamic Programming for LIS</strong>: We will use dynamic
programming to find the LIS. For each element in the extended array, we
will find the longest increasing subsequence that ends at that
element.</p></li>
<li><p><strong>Restrict the Length</strong>: We will only look at
subsequences that start in the first <code>n</code> elements and end in
the second <code>n</code> elements of the extended array.</p></li>
</ol>
<p>Here is the Java code that shows this method:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestIncreasingSubsequenceCircular <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestIncreasingSubsequenceCircular</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> numsExtended <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span><span class="dv">2</span> <span class="op">*</span> n<span class="op">];</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            numsExtended<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            numsExtended<span class="op">[</span>i <span class="op">+</span> n<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> <span class="fu">lis</span><span class="op">(</span>numsExtended<span class="op">,</span> i<span class="op">,</span> n<span class="op">));</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">lis</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> length <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>length<span class="op">];</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLIS <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;</span> start <span class="op">+</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>            maxLIS <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLIS<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLIS<span class="op">;</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="fu">longestIncreasingSubsequenceCircular</span><span class="op">(</span>nums<span class="op">);</span></span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Increasing Subsequence in Circular Array: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><p><strong><code>longestIncreasingSubsequenceCircular</code>
Method</strong>: This method duplicates the original array. It
calculates the LIS by going through the first <code>n</code> elements
and calling the <code>lis</code> method.</p></li>
<li><p><strong><code>lis</code> Method</strong>: This method finds the
longest increasing subsequence starting from a certain index in the
extended array. It uses dynamic programming. Here, <code>dp[i]</code>
keeps the length of the LIS ending at index <code>i</code>.</p></li>
<li><p><strong><code>main</code> Method</strong>: This shows how to use
the function with a sample input array. It prints the length of the
longest increasing subsequence we found.</p></li>
</ul>
<p>This Java code works well to find the length of the LIS in a circular
array. It uses dynamic programming to manage the circular shape of the
problem easily.</p>
<h2
id="python-solution-for-longest-increasing-subsequence-in-circular-array">Python
Solution for Longest Increasing Subsequence in Circular Array</h2>
<p>We can solve the Longest Increasing Subsequence (LIS) problem in a
circular array using Python. We will use a method called dynamic
programming. This solution changes the circular array into a linear one
while keeping its circular properties.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Linear Transformation</strong>: To deal with the circular
nature, we can make a copy of the array. For example, if we have the
original array <code>A</code>, we create <code>A' = A + A</code>. This
helps us see the circular array as a straight line. We can look at all
possible parts of length <code>n</code>.</p></li>
<li><p><strong>Dynamic Programming for LIS</strong>: We will use a
normal LIS method on the new linear array. The important part is to only
look at increasing subsequences that start from the first element of the
original array and wrap back to the start.</p></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is a Python code for the Longest Increasing Subsequence in a
Circular Array:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_increasing_subsequence(arr):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> arr:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> arr <span class="op">+</span> arr  <span class="co"># Duplicate array to handle circular nature</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> n)  <span class="co"># dp[i] will hold the length of LIS ending at index i</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    max_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&lt;</span> arr[i]:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Only consider the max LIS for the first n elements</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> n:</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            max_length <span class="op">=</span> <span class="bu">max</span>(max_length, dp[i])</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_length</span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>circular_array <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">2</span>]</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> longest_increasing_subsequence(circular_array)</span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Increasing Subsequence in Circular Array:&quot;</span>, result)</span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Array Duplication</strong>: We make a new array by joining
the original array with itself. This shows the circular behavior.</li>
<li><strong>Dynamic Programming Table</strong>: We keep a
<code>dp</code> array where <code>dp[i]</code> shows the length of the
longest increasing subsequence that ends at index <code>i</code>.</li>
<li><strong>Nested Loops</strong>: The outer loop goes through the
duplicated array. The inner loop checks earlier parts to see if they can
add to the current increasing subsequence.</li>
<li><strong>Max Length Calculation</strong>: We only look at
subsequences that start in the first <code>n</code> elements of the
duplicated array. This keeps the circular rules.</li>
</ul>
<p>This method finds the Longest Increasing Subsequence in a Circular
Array in <code>O(n^2)</code> time. It works well for moderate input
sizes.</p>
<h2 id="c-code-for-longest-increasing-subsequence-in-circular-array">C++
Code for Longest Increasing Subsequence in Circular Array</h2>
<p>We can solve the Longest Increasing Subsequence (LIS) problem in a
circular array with C++. We will use a two-pass dynamic programming
method. First, we calculate the LIS for the normal linear array. Next,
we think about the circular aspect of the array.</p>
<h3 id="steps-to-implement">Steps to Implement:</h3>
<ol type="1">
<li><strong>Calculate LIS for the Original Array</strong>: We can use a
simple dynamic programming method to find the longest increasing
subsequence.</li>
<li><strong>Transforming the Circular Array</strong>: We will duplicate
the array and find LIS for each starting point.</li>
<li><strong>Combine Results</strong>: We will look for the biggest LIS
from both passes.</li>
</ol>
<h3 id="c-implementation-1">C++ Implementation:</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> lis<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>nums<span class="op">.</span>size<span class="op">(),</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>        maxLength <span class="op">=</span> max<span class="op">(</span>maxLength<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestIncreasingSubsequenceCircular<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_lis <span class="op">=</span> lis<span class="op">(</span>nums<span class="op">);</span> <span class="co">// LIS for the original array</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-31"><a href="#cb10-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For circular array, we check combinations</span></span>
<span id="cb10-32"><a href="#cb10-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total_max <span class="op">=</span> max_lis<span class="op">;</span></span>
<span id="cb10-33"><a href="#cb10-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-34"><a href="#cb10-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-35"><a href="#cb10-35" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> temp<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> i<span class="op">,</span> nums<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb10-36"><a href="#cb10-36" aria-hidden="true" tabindex="-1"></a>        temp<span class="op">.</span>insert<span class="op">(</span>temp<span class="op">.</span>end<span class="op">(),</span> nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> i<span class="op">);</span></span>
<span id="cb10-37"><a href="#cb10-37" aria-hidden="true" tabindex="-1"></a>        total_max <span class="op">=</span> max<span class="op">(</span>total_max<span class="op">,</span> lis<span class="op">(</span>temp<span class="op">));</span></span>
<span id="cb10-38"><a href="#cb10-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-39"><a href="#cb10-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-40"><a href="#cb10-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total_max<span class="op">;</span></span>
<span id="cb10-41"><a href="#cb10-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-42"><a href="#cb10-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-43"><a href="#cb10-43" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb10-44"><a href="#cb10-44" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb10-45"><a href="#cb10-45" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Longest Increasing Subsequence in Circular Array: &quot;</span> </span>
<span id="cb10-46"><a href="#cb10-46" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> longestIncreasingSubsequenceCircular<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb10-47"><a href="#cb10-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-48"><a href="#cb10-48" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code:</h3>
<ul>
<li>The <code>lis</code> function finds the length of the longest
increasing subsequence in a vector.</li>
<li>The <code>longestIncreasingSubsequenceCircular</code> function finds
the LIS for the normal array. Then it creates a circular version of the
array by changing the starting point.</li>
<li>The answer is the biggest LIS found in all cases. This way, we solve
the circular LIS problem.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis:</h3>
<ul>
<li>Time Complexity: O(n^2) for the LIS calculation where n is the size
of the array.</li>
<li>Space Complexity: O(n) because of the dynamic programming array we
use for LIS.</li>
</ul>
<p>This code gives us a good way to find the longest increasing
subsequence in a circular array using C++.</p>
<h2 id="optimizations-and-complexity-analysis">Optimizations and
Complexity Analysis</h2>
<p>We can improve the Longest Increasing Subsequence (LIS) problem in a
circular array by using a mix of methods. These methods include dynamic
programming and binary search. Let us break down the optimizations and
the complexity analysis.</p>
<h3 id="optimizations">Optimizations</h3>
<ol type="1">
<li><strong>Transforming the Circular Array</strong>:
<ul>
<li>To deal with the circular shape, we can duplicate the array. We
append the array to itself. This way, we can act like it is a straight
line.</li>
<li>For an array <code>A</code> with length <code>n</code>, we make
<code>A'</code> so that <code>A' = A + A</code>. We only look at parts
of size <code>n</code>.</li>
</ul></li>
<li><strong>Dynamic Programming with Binary Search</strong>:
<ul>
<li>We create a dynamic programming array <code>dp</code>. Here,
<code>dp[i]</code> holds the smallest last value for all increasing
subsequences of length <code>i+1</code>.</li>
<li>We use binary search to quickly find where to update in the
<code>dp</code> array. This helps us reduce the time it takes.</li>
</ul></li>
<li><strong>Time Complexity</strong>:
<ul>
<li><strong>Standard LIS</strong>: O(n^2) with dynamic programming.</li>
<li><strong>Optimized LIS</strong>: O(n log n) with dynamic programming
and binary search together.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>The space complexity stays at O(n) because we use the
<code>dp</code> array.</li>
</ul></li>
</ol>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Overall Time Complexity</strong>:
<ul>
<li>When we apply the changes and improvements, the total time
complexity for finding the longest increasing subsequence in a circular
array is O(n log n). This is much better than the O(n^2) method.</li>
</ul></li>
<li><strong>Implementation Details</strong>:
<ul>
<li>In Java, Python, or C++, we can use good libraries. These libraries
help with arrays and binary search. They make sure the performance stays
good.</li>
</ul></li>
</ul>
<p>Here is a Python code that shows these optimizations:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_increasing_subsequence(arr):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="im">from</span> bisect <span class="im">import</span> bisect_left</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> []</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect_left(dp, num)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(dp):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            dp.append(num)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>            dp[pos] <span class="op">=</span> num</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(dp)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> circular_lis(arr):</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    extended_arr <span class="op">=</span> arr <span class="op">+</span> arr</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    max_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        max_length <span class="op">=</span> <span class="bu">max</span>(max_length, longest_increasing_subsequence(extended_arr[i:i<span class="op">+</span>n]))</span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_length</span></code></pre></div>
<p>This code works well to find the longest increasing subsequence in a
circular array. It first changes the array and then uses the optimized
LIS method.</p>
<h3 id="practical-considerations">Practical Considerations</h3>
<ul>
<li>This method is fast and can work with big data sets. It is useful in
competitive programming and real-world tasks.</li>
<li>We should check edge cases. For example, we need to consider arrays
where all elements are the same or arrays with just one element.</li>
</ul>
<p>This way, we have a strong base to solve the Longest Increasing
Subsequence in a circular array problem quickly.</p>
<h2
id="practical-applications-of-longest-increasing-subsequence">Practical
Applications of Longest Increasing Subsequence</h2>
<p>The Longest Increasing Subsequence (LIS) problem is not just a
theory. It has many real-world uses in different fields. Here are some
important applications:</p>
<ol type="1">
<li><p><strong>Data Compression</strong>: In data compression
algorithms, we can use LIS to find the longest sequence of increasing
numbers. This helps in cutting down extra data.</p></li>
<li><p><strong>Genome Sequencing</strong>: In bioinformatics, we can use
LIS to look at DNA sequences. It helps us find patterns and differences
in gene sequences. This gives us a better idea of genetic
connections.</p></li>
<li><p><strong>Stock Market Analysis</strong>: Traders use LIS methods
to find the best order of stock prices over time. This helps them make
better choices about when to buy or sell based on past price
trends.</p></li>
<li><p><strong>Game Development</strong>: In video games, we can use LIS
to improve AI decision-making. It helps find the best moves or actions
to get the highest score or success.</p></li>
<li><p><strong>Network Security</strong>: In cybersecurity, we can use
LIS algorithms to look at network traffic patterns. This helps to find
unusual activities that might be security risks. This allows us to take
action before attacks happen.</p></li>
<li><p><strong>Image Processing</strong>: In computer vision, we can use
LIS to find the longest edge or line in image data. This is important
for detecting and recognizing objects.</p></li>
<li><p><strong>Resource Management</strong>: In project management, we
can use LIS to schedule tasks better. It helps find the longest chain of
dependent tasks, which can reduce delays.</p></li>
<li><p><strong>Natural Language Processing (NLP)</strong>: LIS
algorithms can help analyze text and find feelings. They can spot the
longest sequence of positive or negative words in text, which helps in
classifying sentiments.</p></li>
</ol>
<p>By using the methods from solving the Longest Increasing Subsequence
problem, these applications can work better and faster. If you want to
read more about dynamic programming techniques, you can visit <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-longest-increasing-subsequence-in-a-circular-array">What
is the Longest Increasing Subsequence in a Circular Array?</h3>
<p>The Longest Increasing Subsequence (LIS) in a circular array means we
find the longest sequence in an array where the numbers go up, and the
array wraps around. This problem is harder than the normal LIS because
of the circular part. We need special methods to solve it well. It is
important to understand this for people who like dynamic
programming.</p>
<h3
id="how-can-i-convert-a-circular-array-into-a-standard-array-for-lis-problems">How
can I convert a circular array into a standard array for LIS
problems?</h3>
<p>To change a circular array for the Longest Increasing Subsequence
problem, we can duplicate the array. By putting the array with itself,
we can treat it like a straight array. This way, we can find sequences
that wrap around. This change makes it easier to use normal LIS
methods.</p>
<h3
id="what-dynamic-programming-techniques-are-used-to-solve-the-longest-increasing-subsequence-in-a-circular-array">What
dynamic programming techniques are used to solve the Longest Increasing
Subsequence in a Circular Array?</h3>
<p>The dynamic programming method for the Longest Increasing Subsequence
in a Circular Array usually uses a changed LIS algorithm. We find the
longest increasing subsequence in the duplicated array. By managing the
indices carefully, we can find the circular LIS without counting
elements that are not in the right range.</p>
<h3
id="can-you-provide-a-sample-python-implementation-for-the-longest-increasing-subsequence-in-a-circular-array">Can
you provide a sample Python implementation for the Longest Increasing
Subsequence in a Circular Array?</h3>
<p>Sure! Here is a simple Python code to find the Longest Increasing
Subsequence in a Circular Array:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_increasing_subsequence(arr):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    arr <span class="op">=</span> arr <span class="op">+</span> arr  <span class="co"># Duplicate the array</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> (<span class="dv">2</span> <span class="op">*</span> n)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">*</span> n):</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j] <span class="kw">and</span> j <span class="op">&lt;</span> i:  <span class="co"># Ensure the increasing condition and index validity.</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[:n <span class="op">+</span> n])  <span class="co"># Return the maximum length of LIS considering circular nature.</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longest_increasing_subsequence(arr))</span></code></pre></div>
<h3
id="what-are-the-time-and-space-complexities-of-the-lis-in-a-circular-array">What
are the time and space complexities of the LIS in a Circular Array?</h3>
<p>The time complexity for solving the Longest Increasing Subsequence in
a Circular Array with dynamic programming usually goes from O(n^2) to
O(n log n). This depends on the method we use. The space complexity is
about O(n) because we need to store the dynamic programming table.
Knowing these complexities helps us make better solutions for bigger
datasets.</p>
<p>For more topics on dynamic programming, you can read articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Sum Subarray</a> for more ideas on algorithm
techniques.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            