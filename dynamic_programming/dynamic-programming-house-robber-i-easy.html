
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] House Robber I - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the House Robber I problem using dynamic programming. Learn easy strategies for optimal solutions!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] House Robber I - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic Programming is a strong method we use to solve optimization
problems. We break these problems into smaller, easier problems. The
House Robber I problem is a well-known example. In this problem, we need
to find out the most money we can rob from a row of houses. The rule is
that we cannot rob two houses that are next to each other. We use the
ideas of dynamic programming to create a good plan that helps us get the
most money while following this rule.</p>
<p>In this article, we will look closely at the House Robber I problem.
We will start by explaining the problem. Then, we will talk about the
main ideas of dynamic programming. We will discuss the optimal
substructure and overlapping subproblems that are part of this problem.
After that, we will show how to implement dynamic programming with
tabulation in Java, Python, and C++. We will also talk about ways to use
less space in these languages. Finally, we will answer some common
questions to help you understand better.</p>
<ul>
<li>Diving into Dynamic Programming for House Robber I Easy</li>
<li>Understanding the Problem Statement for House Robber I</li>
<li>Optimal Substructure and Overlapping Subproblems in House Robber
I</li>
<li>Dynamic Programming Approach with Tabulation in Java</li>
<li>Dynamic Programming Approach with Tabulation in Python</li>
<li>Dynamic Programming Approach with Tabulation in C++</li>
<li>Space Optimized Approach for House Robber I in Java</li>
<li>Space Optimized Approach for House Robber I in Python</li>
<li>Space Optimized Approach for House Robber I in C++</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming, we can look at
topics like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>, or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming Maximum Subarray (Kadane’s Algorithm)</a>. These links will
help us understand more about how we can use dynamic programming in
different ways.</p>
<h2
id="understanding-the-problem-statement-for-house-robber-i">Understanding
the Problem Statement for House Robber I</h2>
<p>The House Robber I problem is a well-known challenge in dynamic
programming. We can explain the problem like this:</p>
<p>We are a robber planning to steal money from houses on a street. Each
house has some money inside. But we must be careful. If we rob two
houses next to each other, the security will call the police. Our goal
is to get the most money we can without setting off any alarms.</p>
<h3 id="problem-specification">Problem Specification:</h3>
<ul>
<li>We get an array <code>nums</code>. In this array,
<code>nums[i]</code> shows how much money is in the <code>i-th</code>
house.</li>
<li>We cannot rob two houses that are next to each other.</li>
<li>We need to give back the most money we can rob at night without
calling the police.</li>
</ul>
<h3 id="example">Example:</h3>
<pre class="plaintext"><code>Input: nums = [1, 2, 3, 1]
Output: 4
Explanation: If we rob houses 1 and 3, we get the most money which is 4.</code></pre>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>The length of <code>nums</code> is from 1 to 100.</li>
<li>Each number in <code>nums</code> is a non-negative whole
number.</li>
</ul>
<p>This problem has a good structure and it shows overlapping problems.
So, it is a good fit for dynamic programming. If we want to learn more
about dynamic programming, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2
id="optimal-substructure-and-overlapping-subproblems-in-house-robber-i">Optimal
Substructure and Overlapping Subproblems in House Robber I</h2>
<p>In the House Robber I problem, we need to find the most money a
robber can take from a line of houses. We cannot rob two adjacent houses
because of alarms. This problem shows both optimal substructure and
overlapping subproblems. These features make it a good fit for dynamic
programming.</p>
<h3 id="optimal-substructure">Optimal Substructure</h3>
<p>The optimal substructure property means we can build the best
solution from the best solutions of smaller parts. For the House Robber
I problem, we can think about each house like this:</p>
<ul>
<li>If the robber robs house <code>i</code>, he can collect money from
house <code>i</code> plus the most money from houses <code>0</code> to
<code>i-2</code>.</li>
<li>If the robber skips house <code>i</code>, he can only take the most
money from houses <code>0</code> to <code>i-1</code>.</li>
</ul>
<p>We can write this as:</p>
<pre><code>maxAmount(i) = max(maxAmount(i-1), nums[i] + maxAmount(i-2))</code></pre>
<p>Here, <code>nums[i]</code> is the money in house <code>i</code>. The
base cases are:</p>
<ul>
<li><code>maxAmount(0) = nums[0]</code> (only one house)</li>
<li><code>maxAmount(1) = max(nums[0], nums[1])</code> (choose the bigger
amount from the first two houses)</li>
</ul>
<h3 id="overlapping-subproblems">Overlapping Subproblems</h3>
<p>The overlapping subproblems property tells us that we can break the
problem into smaller parts that we use many times. In the House Robber I
problem, when we calculate <code>maxAmount(i)</code> for different
<code>i</code>, we will need to find <code>maxAmount(i-1)</code> and
<code>maxAmount(i-2)</code> again and again.</p>
<p>Dynamic programming helps us save these results to avoid doing the
same work over and over. We can do this using a top-down approach with
memoization or a bottom-up approach with tabulation.</p>
<h3 id="example-1">Example</h3>
<p>Let’s look at the house values: <code>nums = [2, 7, 9, 3, 1]</code>.
We can show the optimal substructure like this:</p>
<ul>
<li>For house 0: <code>maxAmount(0) = 2</code></li>
<li>For house 1: <code>maxAmount(1) = max(2, 7) = 7</code></li>
<li>For house 2: <code>maxAmount(2) = max(7, 9 + 2) = 11</code></li>
<li>For house 3: <code>maxAmount(3) = max(11, 3 + 7) = 11</code></li>
<li>For house 4: <code>maxAmount(4) = max(11, 1 + 11) = 12</code></li>
</ul>
<p>So, the maximum money the robber can take is <code>12</code>.</p>
<p>By using the ideas of optimal substructure and overlapping
subproblems, we can solve the House Robber I problem quickly with
dynamic programming. For more about dynamic programming problems, check
out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2 id="dynamic-programming-approach-with-tabulation-in-java">Dynamic
Programming Approach with Tabulation in Java</h2>
<p>The tabulation method in dynamic programming is a bottom-up way to
solve problems. We build a table step by step. For the House Robber I
problem, we will make an array to keep the maximum money we can rob up
to each house.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is how we can use the tabulation approach for the House Robber I
problem in Java:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> HouseRobber <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        HouseRobber robber <span class="op">=</span> <span class="kw">new</span> <span class="fu">HouseRobber</span><span class="op">();</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> houses <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum amount robbed: &quot;</span> <span class="op">+</span> robber<span class="op">.</span><span class="fu">rob</span><span class="op">(</span>houses<span class="op">));</span> <span class="co">// Output: 12</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We first take care of special
cases. This is when there are no houses or just one house.</li>
<li><strong>Dynamic Programming Array</strong>: We create an array
<code>dp</code>. In this array, <code>dp[i]</code> shows the maximum
money we can rob from the first <code>i+1</code> houses.</li>
<li><strong>Recurrence Relation</strong>: For each house starting from
the third one, we choose to rob the current house or not. If we rob it,
we add its value to the money robbed from houses up to <code>i-2</code>.
If we skip it, we keep the value from <code>i-1</code>.</li>
<li><strong>Result</strong>: The last part of the <code>dp</code> array
has the most money we can rob.</li>
</ul>
<p>This method works in O(n) time and uses O(n) space. The tabulation
method is good for problems with overlapping parts and good structure.
So, it fits well for the House Robber I problem.</p>
<h2 id="dynamic-programming-approach-with-tabulation-in-python">Dynamic
Programming Approach with Tabulation in Python</h2>
<p>We can use the dynamic programming approach with tabulation for the
House Robber I problem. This method builds a table to keep track of the
most money we can rob from each house. It helps us avoid repeating
calculations for the same problems by storing results step by step.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a list of non-negative numbers. Each number shows how much
money is in each house. We cannot rob two houses that are next to each
other. Our goal is to find out the most money we can rob without getting
caught by the police.</p>
<h3 id="tabulation-approach">Tabulation Approach</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create an array <code>dp</code>.
In this array, <code>dp[i]</code> shows the most money we can rob from
the first <code>i</code> houses.</li>
<li><strong>State Transition</strong>: For each house <code>i</code>, we
have two choices:
<ul>
<li><p>Rob house <code>i</code>: We add the money from house
<code>i</code> to the maximum money we can rob from houses up to
<code>i-2</code> (which is <code>dp[i-2] + nums[i]</code>).</p></li>
<li><p>Skip house <code>i</code>: We take the maximum amount we can rob
from houses up to <code>i-1</code> (which is
<code>dp[i-1]</code>).</p></li>
<li><p>So, we can say:</p>
<pre><code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code></pre></li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li>If there are no houses, the most money is <code>0</code>.</li>
<li>If there is one house, the most money is the amount in that
house.</li>
</ul></li>
</ol>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rob(nums):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> nums[<span class="dv">0</span>]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(nums[<span class="dv">0</span>], nums[<span class="dv">1</span>])</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>], dp[i<span class="op">-</span><span class="dv">2</span>] <span class="op">+</span> nums[i])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="example-2">Example</h3>
<p>If we have the list <code>nums = [2, 7, 9, 3, 1]</code>, the
<code>rob</code> function will give us <code>12</code>. This is the most
money we can rob by taking money from house <code>1</code>,
<code>2</code>, and <code>4</code> (which is
<code>2 + 9 + 1</code>).</p>
<p>This dynamic programming method is good because it has a time
complexity of O(n) and a space complexity of O(n) because we store the
<code>dp</code> array. To use less space, we can change the space
complexity to O(1) by only keeping track of the last two values we
computed.</p>
<h2 id="dynamic-programming-approach-with-tabulation-in-c">Dynamic
Programming Approach with Tabulation in C++</h2>
<p>We can use the tabulation method for the House Robber I problem. This
method creates a table to store the most money we can rob from each
house. The main idea is to choose at each house if we will rob it or
skip it. We must make sure we do not rob two houses next to each
other.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is how we can write the tabulation approach in C++:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> rob<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a DP array</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the DP array</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Maximum money that can be robbed</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> houses <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum amount robbed: &quot;</span> <span class="op">&lt;&lt;</span> rob<span class="op">(</span>houses<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Input:</strong> We have a vector <code>nums</code> which
shows how much money is in each house.</li>
<li><strong>Base Cases:</strong>
<ul>
<li>If there are no houses, we return 0.</li>
<li>If there is only one house, we return its money.</li>
</ul></li>
<li><strong>DP Array Initialization:</strong>
<ul>
<li><code>dp[0]</code> means the maximum money from the first
house.</li>
<li><code>dp[1]</code> is the maximum money we can get from the first
and second house.</li>
</ul></li>
<li><strong>DP Array Filling:</strong>
<ul>
<li>For each house from the third one, we calculate the maximum money.
We either skip this house or rob it and add its money to what we got
from two houses before.</li>
</ul></li>
<li><strong>Return Value:</strong> The last value in the DP array gives
the most money we can rob.</li>
</ul>
<p>This method has time complexity O(n) and space complexity O(n)
because of the DP array. For better ways to optimize space, we can see
the space-optimized methods below.</p>
<p>For more on dynamic programming techniques, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> article.</p>
<h2 id="space-optimized-approach-for-house-robber-i-in-java">Space
Optimized Approach for House Robber I in Java</h2>
<p>We can make the Space Optimized Approach for the House Robber I
problem better. This method cuts down the space we need from O(n) to
O(1). We only keep the last two biggest amounts we robbed. We do not
need to save all amounts from each house. This method is good for
solving the problem and uses less memory.</p>
<h3 id="code-implementation-in-java">Code Implementation in Java</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> HouseRobber <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Max amount robbed from previous house</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Max amount robbed from house before previous</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> prev1<span class="op">;</span> <span class="co">// Store the value of prev1</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> num<span class="op">);</span> <span class="co">// Max amount if robbing current house</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> temp<span class="op">;</span> <span class="co">// Update prev2 to be the old prev1</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1<span class="op">;</span> <span class="co">// Maximum amount robbed</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        HouseRobber robber <span class="op">=</span> <span class="kw">new</span> <span class="fu">HouseRobber</span><span class="op">();</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> houses <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum amount that can be robbed: &quot;</span> <span class="op">+</span> robber<span class="op">.</span><span class="fu">rob</span><span class="op">(</span>houses<span class="op">));</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We start with two variables,
<code>prev1</code> and <code>prev2</code>. They save the biggest amounts
robbed from the last two houses.</li>
<li><strong>Iteration</strong>: For each house, we check which value is
bigger:
<ul>
<li>Not robbing the current house (we keep <code>prev1</code>).</li>
<li>Robbing the current house (we add its value to
<code>prev2</code>).</li>
</ul></li>
<li><strong>Updating Values</strong>: After we check, we update
<code>prev1</code> with the new biggest amount. Then, we set
<code>prev2</code> to the old value of <code>prev1</code>.</li>
<li><strong>Result</strong>: At the end, <code>prev1</code> has the
biggest amount we can rob from the houses.</li>
</ul>
<p>This method uses constant space and makes sure the algorithm runs in
O(n) time. It is good for large inputs. If you want to learn more about
dynamic programming, you can check articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="space-optimized-approach-for-house-robber-i-in-python">Space
Optimized Approach for House Robber I in Python</h2>
<p>The Space Optimized Approach for the House Robber I problem helps us
save space. It cuts down space usage from O(n) to O(1) while keeping the
time needed at O(n). We do this by only tracking the last two biggest
amounts robbed instead of keeping a whole array of results.</p>
<h3 id="implementation">Implementation</h3>
<p>In this method, we use two variables. They hold the most money that
we can rob up to the current house and the house before it. The way we
decide to rob or skip each house stays the same.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rob(nums):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    prev1, prev2 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        temp <span class="op">=</span> prev1</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> <span class="bu">max</span>(prev2 <span class="op">+</span> num, prev1)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> temp</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We start with <code>prev1</code>
and <code>prev2</code> at 0. This shows the most money we can rob up to
the last house and the house before that.</li>
<li><strong>Iteration</strong>: We go through each house’s money:
<ul>
<li>We keep the value of <code>prev1</code> in a temporary
variable.</li>
<li>We update <code>prev1</code> to be the bigger amount. This is either
robbing the current house (adding <code>num</code> to
<code>prev2</code>) or not robbing it (keeping <code>prev1</code>).</li>
<li>We set <code>prev2</code> to the old value of <code>prev1</code>
(that we saved in <code>temp</code>).</li>
</ul></li>
<li><strong>Result</strong>: After we finish going through the list,
<code>prev1</code> has the most money that we can rob.</li>
</ul>
<h3 id="example-3">Example</h3>
<p>For the input <code>nums = [2, 7, 9, 3, 1]</code>, the function will
give back <code>12</code>. The best choice is to rob houses with amounts
2, 9, and 1.</p>
<p>This space-optimized way works well for the House Robber I problem
while keeping the good performance of dynamic programming.</p>
<p>For more about dynamic programming, you can look at related topics
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="space-optimized-approach-for-house-robber-i-in-c">Space
Optimized Approach for House Robber I in C++</h2>
<p>To solve the House Robber I problem with a space-optimized way in
C++, we can use just two variables. We do not need a whole array for
dynamic programming. This lowers the space use from O(n) to O(1).</p>
<h3 id="problem-recap">Problem Recap</h3>
<p>In the House Robber problem, there is a robber. He wants to rob
houses along a street. Each house has a certain amount of money. The
robber cannot rob two houses that are next to each other on the same
night. The goal is to take the most money possible.</p>
<h3 id="space-optimized-algorithm">Space Optimized Algorithm</h3>
<p>The main idea is to track the most money we can rob up to the current
house using two variables: - <code>prev1</code>: This is the most money
robbed up to the house before the last one. - <code>prev2</code>: This
is the most money robbed up to the last house.</p>
<h3 id="c-implementation-1">C++ Implementation</h3>
<p>Here is the C++ code for the space-optimized way:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rob<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> max<span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    Solution solution<span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> houses <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum amount robbed: &quot;</span> <span class="op">&lt;&lt;</span> solution<span class="op">.</span>rob<span class="op">(</span>houses<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<ul>
<li>We start with <code>prev1</code> and <code>prev2</code> set to
zero.</li>
<li>We go through each house’s money value in the <code>nums</code>
array.</li>
<li>For each house, we find the most money we can rob. We can either rob
the current house (adding its value to <code>prev2</code>) or skip it
(keeping <code>prev1</code>).</li>
<li>At the end, we return <code>prev1</code>, which has the most money
that can be robbed.</li>
</ul>
<p>This method keeps space use low while keeping the time speed at O(n).
It makes it a good solution for the House Robber I problem in C++. For
more about dynamic programming, see <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-house-robber-i-problem-in-dynamic-programming">1.
What is the House Robber I problem in dynamic programming?</h3>
<p>The House Robber I problem is a famous challenge in dynamic
programming. It asks us to find the most money we can take from a line
of houses. We cannot rob two houses that are next to each other. This
problem teaches us about optimal substructure and overlapping
subproblems. It is a good start to learn dynamic programming
methods.</p>
<h3 id="how-do-i-implement-the-house-robber-i-solution-in-java">2. How
do I implement the House Robber I solution in Java?</h3>
<p>We can implement the House Robber I algorithm in Java using dynamic
programming. We can use tabulation or a space-saving method. The main
idea is to have an array. This array will hold the maximum money we can
rob at each house. We must make sure not to rob two houses that are next
to each other. You can see a full example in our section on <a
href="#">Dynamic Programming Approach with Tabulation in Java</a>.</p>
<h3
id="what-are-the-common-dynamic-programming-techniques-used-in-house-robber-i">3.
What are the common dynamic programming techniques used in House Robber
I?</h3>
<p>The common methods to solve the House Robber I problem are tabulation
and memoization. Tabulation is a bottom-up method. Memoization is a
top-down method. Both methods use dynamic programming ideas. They break
down the problem into smaller parts. This helps us to find the most
money we can rob without getting caught by the police.</p>
<h3 id="can-i-solve-house-robber-i-using-python">4. Can I solve House
Robber I using Python?</h3>
<p>Yes, we can solve the House Robber I problem easily in Python. We can
use either tabulation or a space-saving method. Python’s list is very
helpful for the dynamic programming solution. You can check our section
on <a href="#">Dynamic Programming Approach with Tabulation in
Python</a> for a complete example.</p>
<h3 id="what-is-the-space-optimized-approach-for-house-robber-i-in-c">5.
What is the space-optimized approach for House Robber I in C++?</h3>
<p>The space-optimized approach for the House Robber I problem in C++
helps us to use less space. It changes the space from O(n) to O(1). We
only need to remember the last two values we calculated. This method
lets us find the maximum money we can rob without needing a big array.
Look at our detailed code example in the section on <a href="#">Space
Optimized Approach for House Robber I in C++</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            