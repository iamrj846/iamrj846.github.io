
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Simple Grid Path Sum - Easy</title>
            <meta name="description" content="Discover the basics of dynamic programming with our simple guide on grid path sums. Learn techniques to solve pathfinding problems!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Simple Grid Path Sum - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong method we use to solve hard problems.
We do this by breaking them into easier parts. For the Simple Grid Path
Sum problem, we want to find the highest path sum from the top-left
corner to the bottom-right corner of a grid. We can only move down or
right. We can solve this problem fast with dynamic programming. This
helps us avoid doing the same calculations again.</p>
<p>In this article, we will look at different parts of the Simple Grid
Path Sum using dynamic programming. First, we will explain the problem
and the optimal substructure property. This property helps us use
dynamic programming. Then, we will check dynamic programming solutions
in Java, Python, and C++. We will also talk about space optimization
methods. We will compare different ways to solve the problem. We will
point out common mistakes and answer questions that people often ask
about this topic.</p>
<ul>
<li>Dynamic Programming Techniques for Simple Grid Path Sum - Easy</li>
<li>Understanding the Problem Statement for Simple Grid Path Sum</li>
<li>Optimal Substructure in Simple Grid Path Sum</li>
<li>Dynamic Programming Approach in Java for Simple Grid Path Sum</li>
<li>Dynamic Programming Approach in Python for Simple Grid Path Sum</li>
<li>Dynamic Programming Approach in C++ for Simple Grid Path Sum</li>
<li>Space Optimization Techniques for Simple Grid Path Sum</li>
<li>Comparative Analysis of Different Approaches for Simple Grid Path
Sum</li>
<li>Common Mistakes in Implementing Simple Grid Path Sum</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we are interested in related topics in dynamic programming, we can
check the <strong><a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a></strong> and <strong><a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming Unique Paths in a Grid</a></strong> articles.</p>
<h2
id="understanding-the-problem-statement-for-simple-grid-path-sum">Understanding
the Problem Statement for Simple Grid Path Sum</h2>
<p>The Simple Grid Path Sum problem is about moving through a grid that
has non-negative numbers. We want to find the smallest path sum from the
top-left corner to the bottom-right corner. We can only move down or
right.</p>
<h3 id="problem-definition">Problem Definition:</h3>
<ul>
<li>We have a 2D grid called <code>grid</code>. Each
<code>grid[i][j]</code> shows the cost to enter cell
<code>(i, j)</code>.</li>
<li>We start at <code>(0, 0)</code> and need to reach
<code>(m-1, n-1)</code>. Here <code>m</code> is the number of rows and
<code>n</code> is the number of columns.</li>
<li>The path sum is the total cost of the cells we visit. Our goal is to
make this sum as small as possible.</li>
</ul>
<h3 id="example">Example:</h3>
<p>Look at this grid:</p>
<pre><code>[
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]</code></pre>
<p>The smallest path sum from the top-left corner to the bottom-right
corner is <code>7</code>. We can follow this path:
<code>1 → 3 → 1 → 1</code>.</p>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>The grid will have at least one cell.</li>
<li>The size of the grid can change, but the number of rows and columns
will be reasonable for calculations.</li>
</ul>
<p>This problem is a classic example of dynamic programming. It has an
optimal substructure and shares subproblems.</p>
<h2 id="optimal-substructure-in-simple-grid-path-sum">Optimal
Substructure in Simple Grid Path Sum</h2>
<p>The Simple Grid Path Sum problem shows optimal substructure. This
means we can find the best solution by using the best solutions of
smaller problems. When moving through a grid, we can find the lowest
path sum to reach a cell at position <code>(i, j)</code>. We get this by
looking at the lowest path sums from the cell above it
<code>(i-1, j)</code> and the cell to the left
<code>(i, j-1)</code>.</p>
<h3 id="recursive-relation">Recursive Relation</h3>
<p>The formula to find the minimum path sum <code>dp[i][j]</code>
is:</p>
<pre><code>dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code></pre>
<p>In this formula, <code>grid[i][j]</code> is the cost of the current
cell. The <code>dp[i-1][j]</code> and <code>dp[i][j-1]</code> show the
minimum path sums from the nearby cells. The base cases are:</p>
<ul>
<li><code>dp[0][0] = grid[0][0]</code> - This is where we start.</li>
<li>For the first row, <code>dp[0][j] = dp[0][j-1] + grid[0][j]</code>
for all <code>j</code>.</li>
<li>For the first column,
<code>dp[i][0] = dp[i-1][0] + grid[i][0]</code> for all
<code>i</code>.</li>
</ul>
<h3 id="example-1">Example</h3>
<p>Let’s look at this grid:</p>
<pre><code>[
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]</code></pre>
<p>To find the optimal path sum to reach the cell <code>(2, 2)</code>
(the bottom-right corner), we can do these steps:</p>
<ol type="1">
<li><code>dp[0][0] = 1</code></li>
<li><code>dp[0][1] = 1 + 3 = 4</code></li>
<li><code>dp[0][2] = 4 + 1 = 5</code></li>
<li><code>dp[1][0] = 1 + 1 = 2</code></li>
<li><code>dp[1][1] = min(4, 2) + 5 = 7</code></li>
<li><code>dp[1][2] = min(5, 7) + 1 = 6</code></li>
<li><code>dp[2][0] = 2 + 4 = 6</code></li>
<li><code>dp[2][1] = min(6, 7) + 2 = 8</code></li>
<li><code>dp[2][2] = min(6, 8) + 1 = 7</code></li>
</ol>
<p>So, the minimum path sum for this grid is <code>7</code>.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is a simple way to implement the grid path sum using dynamic
programming in Python:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid <span class="kw">or</span> <span class="kw">not</span> grid[<span class="dv">0</span>]:</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>This code uses the optimal substructure of the Simple Grid Path Sum
problem. It helps us find the minimum path sum fast.</p>
<h2
id="dynamic-programming-approach-in-java-for-simple-grid-path-sum">Dynamic
Programming Approach in Java for Simple Grid Path Sum</h2>
<p>In this section, we will look at the dynamic programming way to solve
the Simple Grid Path Sum problem with Java. The problem is to find the
smallest path sum from the top-left corner to the bottom-right corner of
a grid. Each cell in the grid has a non-negative number.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a 2D grid of numbers. We need to find the smallest path sum
to get to the bottom-right corner from the top-left corner. You can only
move down or right at any time.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>We can use a 2D array called <code>dp</code> to keep the smallest
path sum to each cell. The value of <code>dp[i][j]</code> shows the
smallest path sum to reach the cell <code>(i, j)</code> from
<code>(0, 0)</code>.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> GridPathSum <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>grid <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rows <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cols <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create a DP array.</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>rows<span class="op">][</span>cols<span class="op">];</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the top-left cell.</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first row.</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first column.</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP array.</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Return the minimum path sum to the bottom-right cell.</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>rows <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>cols <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>        GridPathSum gps <span class="op">=</span> <span class="kw">new</span> <span class="fu">GridPathSum</span><span class="op">();</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> grid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum Path Sum: &quot;</span> <span class="op">+</span> gps<span class="op">.</span><span class="fu">minPathSum</span><span class="op">(</span>grid<span class="op">));</span>  <span class="co">// Output: 7</span></span>
<span id="cb5-43"><a href="#cb5-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-44"><a href="#cb5-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>We start by checking if the grid is empty.</li>
<li>Next, we set up the first row and first column of the
<code>dp</code> array using the grid values.</li>
<li>The main loop fills the <code>dp</code> array. We take the smallest
value from the top or left cells and add the current cell’s value.</li>
<li>Finally, we return the value in the bottom-right cell of the
<code>dp</code> array. This value shows the smallest path sum.</li>
</ul>
<p>This dynamic programming method is good with a time complexity of O(m
* n) and a space complexity of O(m * n). Here, m and n are the number of
rows and columns in the grid. To make it better, we can change space to
O(n) by using one-dimensional array.</p>
<p>For more problems like this, you can read articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Unique
Paths in a Grid</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs</a>.</p>
<h2
id="dynamic-programming-approach-in-python-for-simple-grid-path-sum">Dynamic
Programming Approach in Python for Simple Grid Path Sum</h2>
<p>We can solve the Simple Grid Path Sum problem using dynamic
programming in Python. We will use a 2D array called dp to keep track of
the minimum path sums at each cell. Our goal is to find the path from
the top-left corner to the bottom-right corner of a grid. We want to
minimize the sum of the cell values along the way. We can only move
right or down at each step.</p>
<h3 id="implementation-1">Implementation</h3>
<p>Here is the Python code to use the dynamic programming approach for
the Simple Grid Path Sum problem:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid <span class="kw">or</span> <span class="kw">not</span> grid[<span class="dv">0</span>]:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the first row</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][c] <span class="op">=</span> dp[<span class="dv">0</span>][c <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][c]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the first column</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        dp[r][<span class="dv">0</span>] <span class="op">=</span> dp[r <span class="op">-</span> <span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> grid[r][<span class="dv">0</span>]</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, rows):</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, cols):</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            dp[r][c] <span class="op">=</span> <span class="bu">min</span>(dp[r <span class="op">-</span> <span class="dv">1</span>][c], dp[r][c <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> grid[r][c]</span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[rows <span class="op">-</span> <span class="dv">1</span>][cols <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">1</span>],</span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>],</span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minPathSum(grid))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>:
<ul>
<li>We create a dp array with same size as the grid.</li>
<li>Set the starting point dp[0][0] to grid[0][0].</li>
</ul></li>
<li><strong>First Row and Column</strong>:
<ul>
<li>The first row can only be filled by moving right. So each cell is
the sum of its left neighbor.</li>
<li>The first column can only be filled by moving down. So each cell is
the sum of its top neighbor.</li>
</ul></li>
<li><strong>Filling the DP Array</strong>:
<ul>
<li>For each cell, we calculate minimum path sum. We take the minimum of
the two paths (from left or from above) and add the current cell’s
value.</li>
</ul></li>
<li><strong>Result</strong>: The minimum path sum to reach the
bottom-right corner is found at dp[rows - 1][cols - 1].</li>
</ul>
<p>This approach helps us find the minimum path sum using a 2D dynamic
programming table. It gives us an optimal solution with time complexity
of O(m * n). Here, m and n are the size of the grid. For more topics,
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2
id="dynamic-programming-approach-in-c-for-simple-grid-path-sum">Dynamic
Programming Approach in C++ for Simple Grid Path Sum</h2>
<p>We can solve the Simple Grid Path Sum problem with dynamic
programming in C++. We will make a 2D array called dp. This array will
keep the minimum path sum to reach each cell in the grid. We will build
this dp table using values we computed before.</p>
<h3 id="implementation-steps">Implementation Steps:</h3>
<ol type="1">
<li><strong>Initialize the dp array</strong>: The dp array should have
the same size as the grid.</li>
<li><strong>Base case</strong>: Set the starting cell (0, 0) to be the
value of the grid at that cell.</li>
<li><strong>Fill the first row and first column</strong>: To reach any
cell in the first row or first column, we can only come from the left or
above.</li>
<li><strong>Fill the rest of the dp table</strong>: For each cell (i,
j), the minimum path sum is the value of the current cell in the grid
plus the minimum of the path sums from the left (dp[i][j-1]) and from
above (dp[i-1][j]).</li>
<li><strong>Return the value in the bottom-right cell</strong>: This
cell will have the minimum path sum to reach the end.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the first row</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the first column</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the rest of the dp array</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> min<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> grid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum Path Sum: &quot;</span> <span class="op">&lt;&lt;</span> minPathSum<span class="op">(</span>grid<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li><strong>Input</strong>: A 2D vector <code>grid</code> which shows
the grid where each cell has a non-negative number.</li>
<li><strong>Output</strong>: The minimum path sum to reach the
bottom-right corner of the grid.</li>
<li>The <code>minPathSum</code> function calculates the minimum path
sums with dynamic programming. It fills the <code>dp</code> table as
needed.</li>
<li>In the end, it returns the value at <code>dp[m - 1][n - 1]</code>.
This gives us the result we want.</li>
</ul>
<p>This dynamic programming method is good and helps us find the minimum
path sum in O(m<em>n) time with O(m</em>n) space. If we want to save
space, we can think about using a 1D array if we only need the current
and previous rows.</p>
<p>For more reading about dynamic programming, you may like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a> article.</p>
<h2 id="space-optimization-techniques-for-simple-grid-path-sum">Space
Optimization Techniques for Simple Grid Path Sum</h2>
<p>When we solve the Simple Grid Path Sum problem with dynamic
programming, space optimization is very important. It helps us improve
efficiency, especially with larger grids. Normally, the dynamic
programming approach uses a 2D array to keep intermediate results. This
can take up a lot of memory. But we can lower the space needed to O(n).
We notice that we only need the current and previous rows of the grid at
any time.</p>
<h3 id="optimized-approach">Optimized Approach</h3>
<ol type="1">
<li><p><strong>1D Array Transformation</strong>: Instead of using a 2D
array for the path sums, we can use a single 1D array. This array will
track the total sums of paths for each column in the current
row.</p></li>
<li><p><strong>Iterative Updates</strong>: As we go through each cell in
the grid, we update our 1D array based on values from the previous
row.</p></li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SimpleGridPathSum <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">,</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first row</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update for remaining rows</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Update the first column</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the first row</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        dp[j] <span class="op">=</span> dp[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update for remaining rows</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>] <span class="op">+=</span> grid[i][<span class="dv">0</span>]  <span class="co"># Update the first column</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">=</span> <span class="bu">min</span>(dp[j], dp[j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> grid[i][j]</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first row</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update for remaining rows</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Update the first column</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="key-advantages">Key Advantages</h3>
<ul>
<li><strong>Reduced Memory Usage</strong>: By using a 1D array, we lower
the space needed from O(m*n) to O(n). This is very helpful for big
grids.</li>
<li><strong>Maintained Efficiency</strong>: The time complexity stays
O(m*n). So we still have good performance while saving space.</li>
</ul>
<p>This space optimization method is very important for problems like
the Simple Grid Path Sum. It helps us use memory wisely without losing
performance. For more details, we can check related dynamic programming
problems like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Unique
Paths in a Grid</a>.</p>
<h2
id="comparative-analysis-of-different-approaches-for-simple-grid-path-sum">Comparative
Analysis of Different Approaches for Simple Grid Path Sum</h2>
<p>When we solve the Simple Grid Path Sum problem, we can use different
methods. Each method has its own pros and cons. These include time
complexity and space complexity. We will look at the most common
methods: brute force, memoization, and dynamic programming.</p>
<h3 id="brute-force-approach">1. Brute Force Approach</h3>
<ul>
<li><strong>Description</strong>: We explore all paths from the top-left
corner to the bottom-right corner using recursion.</li>
<li><strong>Time Complexity</strong>: O(2^(m+n)), where m is the number
of rows and n is the number of columns.</li>
<li><strong>Space Complexity</strong>: O(m+n) for the recursion
stack.</li>
<li><strong>Advantages</strong>: It is simple to use and easy to
understand for small grids.</li>
<li><strong>Disadvantages</strong>: It becomes very slow for larger
grids.</li>
</ul>
<h3 id="memoization-top-down-dynamic-programming">2. Memoization
(Top-Down Dynamic Programming)</h3>
<ul>
<li><strong>Description</strong>: We improve the brute force method by
saving results we already calculated. This helps us avoid doing the same
work again.</li>
<li><strong>Time Complexity</strong>: O(m*n).</li>
<li><strong>Space Complexity</strong>: O(m*n) for the memoization
table.</li>
<li><strong>Advantages</strong>: It is much faster than brute force and
still easy to use.</li>
<li><strong>Disadvantages</strong>: It uses more space because we store
results.</li>
</ul>
<p><strong>Example in Python</strong>:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grid_path_sum_memo(grid):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(x, y):</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> m <span class="op">-</span> <span class="dv">1</span> <span class="kw">and</span> y <span class="op">==</span> n <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> grid[x][y]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="kw">in</span> memo:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        right <span class="op">=</span> dfs(x, y <span class="op">+</span> <span class="dv">1</span>) <span class="cf">if</span> y <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> n <span class="cf">else</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        down <span class="op">=</span> dfs(x <span class="op">+</span> <span class="dv">1</span>, y) <span class="cf">if</span> x <span class="op">+</span> <span class="dv">1</span> <span class="op">&lt;</span> m <span class="cf">else</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        memo[(x, y)] <span class="op">=</span> grid[x][y] <span class="op">+</span> <span class="bu">min</span>(right, down)</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="dv">0</span>, <span class="dv">0</span>)</span></code></pre></div>
<h3 id="dynamic-programming-bottom-up">3. Dynamic Programming
(Bottom-Up)</h3>
<ul>
<li><strong>Description</strong>: We fill a DP table step by step using
values we already calculated.</li>
<li><strong>Time Complexity</strong>: O(m*n).</li>
<li><strong>Space Complexity</strong>: O(m*n) for the DP table. We can
make it O(n) if we only keep the last row.</li>
<li><strong>Advantages</strong>: It is good for both time and space. It
does not use recursion.</li>
<li><strong>Disadvantages</strong>: It is a bit harder to use than
memoization.</li>
</ul>
<p><strong>Example in Python</strong>:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grid_path_sum_dp(grid):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>]<span class="op">*</span>n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="space-optimization-techniques">4. Space Optimization
Techniques</h3>
<p>We can notice that we only need the current and previous rows or
columns at each step. So we can reduce the space complexity to O(n).</p>
<p><strong>Optimized Space Example</strong>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> grid_path_sum_optimized(grid):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    prev_row <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    prev_row[<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        prev_row[<span class="dv">0</span>] <span class="op">+=</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        prev_row[j] <span class="op">=</span> prev_row[j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        current_row <span class="op">=</span> [<span class="dv">0</span>]<span class="op">*</span>n</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        current_row[<span class="dv">0</span>] <span class="op">=</span> prev_row[<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>            current_row[j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(prev_row[j], current_row[j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        prev_row <span class="op">=</span> current_row</span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev_row[n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<p>In the end, the best method to choose depends on the problem limits
like grid size and how much memory we have. For bigger grids, we usually
like the dynamic programming method because it is quick and uses less
computer power. If you want to learn more about dynamic programming,
check out related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="common-mistakes-in-implementing-simple-grid-path-sum">Common
Mistakes in Implementing Simple Grid Path Sum</h2>
<p>When we implement the Simple Grid Path Sum with dynamic programming,
we often make some common mistakes. These mistakes can give us wrong
results or slow solutions. Here are some important pitfalls we should
watch out for:</p>
<ol type="1">
<li><strong>Incorrect Base Case Initialization</strong>:
<ul>
<li><p>We must start the dynamic programming table correctly. For a
grid, we often need to set the starting position right.<br />
</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Set the starting point correctly  </span></span></code></pre></div></li>
</ul></li>
<li><strong>Not Considering Edge Cases</strong>:
<ul>
<li>If we don’t handle edge cases, like when the grid has just one row
or one column, we can get runtime errors or wrong calculations.<br />
</li>
<li>We should make sure our algorithm checks for these cases
clearly.</li>
</ul></li>
<li><strong>Misunderstanding the Transition Formula</strong>:
<ul>
<li><p>The transition must show the allowed movements, usually right and
down. If we miss something in the formula, we can get wrong path
sums.<br />
</p></li>
<li><p>Example:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])<span class="op">;</span>  </span></code></pre></div></li>
</ul></li>
<li><strong>Using a Non-Optimal Data Structure</strong>:
<ul>
<li>Choosing the wrong data structure for the DP table can waste space.
For example, using a 2D array when we only need one row can be a
mistake.<br />
</li>
<li>We should use space optimization techniques when we can.</li>
</ul></li>
<li><strong>Overlooking In-Boundary Checks</strong>:
<ul>
<li>When we fill the DP table, we need to check that indices stay within
limits. This is very important in loops that go over grid
dimensions.</li>
</ul></li>
<li><strong>Improperly Handling Path Sums</strong>:
<ul>
<li>We need to calculate the path sums correctly, especially when we add
values from previous cells. Wrong addition can cause wrong results.</li>
</ul></li>
<li><strong>Forgetting to Return the Final Result</strong>:
<ul>
<li>After we fill the DP table, we must return the final result
correctly. Many times, we forget to return the last cell of the DP array
which has the result.</li>
</ul></li>
<li><strong>Neglecting to Reset the DP Table</strong>:
<ul>
<li>If we call the function many times, we need to reset or reinitialize
the DP table. This avoids using old data from previous
calculations.</li>
</ul></li>
<li><strong>Inadequate Testing</strong>:
<ul>
<li>Not testing with different grid setups, including edge cases like
empty grids, can hide bugs. We need to test carefully.</li>
</ul></li>
<li><strong>Assuming Zero Initialization</strong>:
<ul>
<li>Thinking the grid starts with zero values can cause errors if we do
not check for that. We should always set the DP table based on the grid
values.</li>
</ul></li>
</ol>
<p>By knowing these common mistakes when we implement the Simple Grid
Path Sum with dynamic programming, we can make more reliable and
efficient solutions. For more on dynamic programming techniques, we can
look at related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-for-solving-the-simple-grid-path-sum-problem">1.
What is the dynamic programming approach for solving the Simple Grid
Path Sum problem?</h3>
<p>We use a dynamic programming approach to solve the Simple Grid Path
Sum problem by breaking it into smaller parts. We store the results of
these parts in a table. This way, we can easily find the maximum path
sum from the top-left to the bottom-right of the grid. This method helps
us avoid doing the same calculations again and again. It makes our
solution faster. So, this is a good way to solve path sum problems in
grids.</p>
<h3 id="how-do-i-implement-the-simple-grid-path-sum-in-java">2. How do I
implement the Simple Grid Path Sum in Java?</h3>
<p>To implement the Simple Grid Path Sum in Java, we can use a 2D array
to show the grid. Then we apply a dynamic programming method. We go
through the grid and update each cell with the best sum we can get from
the start to that cell. If you want more details, you can check our <a
href="#">Dynamic Programming Approach in Java for Simple Grid Path
Sum</a>.</p>
<h3 id="can-i-solve-the-simple-grid-path-sum-using-recursion">3. Can I
solve the Simple Grid Path Sum using recursion?</h3>
<p>Yes, we can use recursion to solve the Simple Grid Path Sum problem.
But it is not very efficient. This is because we might calculate the
same path sums many times. It is better to use dynamic programming. This
way we can get a better solution without repeating work. For a better
way, see our <a href="#">Dynamic Programming Techniques for Simple Grid
Path Sum</a>.</p>
<h3
id="what-are-common-mistakes-to-avoid-when-implementing-the-simple-grid-path-sum">4.
What are common mistakes to avoid when implementing the Simple Grid Path
Sum?</h3>
<p>Some common mistakes when we implement the Simple Grid Path Sum are
not handling grid edges properly, not starting the grid right, and
missing some paths. Also, if we do not use dynamic programming ideas
well, it can give us wrong answers. For more help, check our guide on <a
href="#">Common Mistakes in Implementing Simple Grid Path Sum</a>.</p>
<h3
id="how-is-the-simple-grid-path-sum-problem-related-to-other-dynamic-programming-problems">5.
How is the Simple Grid Path Sum problem related to other dynamic
programming problems?</h3>
<p>The Simple Grid Path Sum problem is similar to other dynamic
programming problems. This includes problems like the Fibonacci sequence
and the climbing stairs problem. They all involve finding the best path
or sum using dynamic programming. If you want to learn more, visit our
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            