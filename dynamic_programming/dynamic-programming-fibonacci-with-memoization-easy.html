
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Fibonacci with Memoization - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn dynamic programming through Fibonacci with memoization. Simplify complex problems and boost your coding skills easily!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Fibonacci with Memoization - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Fibonacci with memoization is a smart way to find Fibonacci numbers.
We store values we calculated before. This helps us not to do the same
work again. It makes the time needed go from very high to low. This is
good for bigger numbers. We can use an array or a map to keep the
Fibonacci results. This makes our program faster and better.</p>
<p>In this article, we will explore the dynamic programming way to use
Fibonacci with memoization. We will look at the main ideas and how we
can use this technique in real life. We will show you how to write
Fibonacci with memoization in Java, Python, and C++. After that, we will
compare these different ways. We will also talk about how to save
memory, common mistakes we can make with memoization, and answer some
questions that many people have. This will help us understand this
useful programming method better.</p>
<ul>
<li>Dynamic Programming Approach to Fibonacci with Memoization in
Depth</li>
<li>Understanding the Fibonacci Sequence and Its Applications</li>
<li>Java Implementation of Fibonacci with Memoization</li>
<li>Python Implementation of Fibonacci with Memoization</li>
<li>C++ Implementation of Fibonacci with Memoization</li>
<li>Comparative Analysis of Fibonacci Implementations</li>
<li>Optimizing Memory Usage in Fibonacci with Memoization</li>
<li>Common Pitfalls in Fibonacci Memoization</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming and the Fibonacci
sequence, we can check this article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2
id="understanding-the-fibonacci-sequence-and-its-applications">Understanding
the Fibonacci Sequence and Its Applications</h2>
<p>The Fibonacci sequence is a series of numbers. Each number is the sum
of the two numbers before it. It usually starts with 0 and 1. We can
write it like this:</p>
<p>[ F(n) = F(n-1) + F(n-2) ]</p>
<p>The starting points are:</p>
<p>[ F(0) = 0, F(1) = 1 ]</p>
<p>The first few numbers in the Fibonacci sequence are:</p>
<p>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, â€¦</p>
<h3 id="applications-of-the-fibonacci-sequence">Applications of the
Fibonacci Sequence</h3>
<ol type="1">
<li><p><strong>Computer Science</strong>: We often use the Fibonacci
sequence in algorithms. It is important in dynamic programming and
recursive algorithms. It shows how to improve recursive solutions using
memoization.</p></li>
<li><p><strong>Mathematics</strong>: Fibonacci numbers show up in many
math topics. This includes combinatorics and number theory. They help us
describe recursive structures.</p></li>
<li><p><strong>Nature</strong>: We can see Fibonacci numbers in nature.
They show up in how trees branch, how leaves grow on plants, and how the
scales of a pine cone are arranged.</p></li>
<li><p><strong>Financial Markets</strong>: Traders use Fibonacci
retracement levels. They help find support and resistance levels in
stock prices.</p></li>
<li><p><strong>Art and Architecture</strong>: The Fibonacci sequence
connects to the Golden Ratio. People use it in art, buildings, and
design to make nice-looking works.</p></li>
</ol>
<p>For more about dynamic programming and the Fibonacci sequence, we can
check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming tutorial on Fibonacci numbers</a>.</p>
<h2 id="java-implementation-of-fibonacci-with-memoization">Java
Implementation of Fibonacci with Memoization</h2>
<p>In Java, we can calculate the Fibonacci sequence quickly using
memoization. This means we store results we already found. This way, we
do not need to do the same work again. It makes our calculations much
faster. The time complexity goes from exponential to linear.</p>
<p>Here is a simple way to implement Fibonacci with memoization in
Java:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> FibonacciMemoization <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Long</span><span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="fu">FibonacciMemoization</span><span class="op">()</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">fibonacci</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> result <span class="op">=</span> <span class="fu">fibonacci</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">fibonacci</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        FibonacciMemoization fib <span class="op">=</span> <span class="kw">new</span> <span class="fu">FibonacciMemoization</span><span class="op">();</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">50</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Fibonacci of &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; is: &quot;</span> <span class="op">+</span> fib<span class="op">.</span><span class="fu">fibonacci</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-features-of-the-implementation">Key Features of the
Implementation:</h3>
<ul>
<li><strong>HashMap for Memoization</strong>: We use a
<code>HashMap</code> to keep Fibonacci values. Each value is saved by
its position in the sequence.</li>
<li><strong>Base Cases</strong>: The function takes care of base cases
for <code>n = 0</code> and <code>n = 1</code> directly.</li>
<li><strong>Recursive Calls</strong>: The function calls itself to find
Fibonacci numbers. It checks the memoization map to use values we found
before.</li>
</ul>
<p>This Java implementation computes Fibonacci numbers well. It works
good for larger values of <code>n</code> because of memoization. If we
want to learn more about dynamic programming and Fibonacci, we can look
at this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming tutorial</a>.</p>
<h2 id="python-implementation-of-fibonacci-with-memoization">Python
Implementation of Fibonacci with Memoization</h2>
<p>The Fibonacci sequence is a well-known example. It shows how dynamic
programming works, especially with memoization. In Python, we can write
Fibonacci with memoization. We use a dictionary to keep track of numbers
we already calculated. This makes the time needed to solve the problem
go from slow to fast.</p>
<p>Here is a simple way to do it:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n, memo<span class="op">=</span>{}):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> fibonacci(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> fibonacci(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Fibonacci of </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> is </span><span class="sc">{</span>fibonacci(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="key-features">Key Features:</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) because of memoization.</li>
<li><strong>Space Complexity</strong>: O(n) for the memo
dictionary.</li>
<li><strong>Base Cases</strong>: It handles base cases like 0 and 1
directly.</li>
</ul>
<h3 id="explanation">Explanation:</h3>
<p>The function <code>fibonacci</code> checks if we already have the
answer for <code>n</code> in the <code>memo</code> dictionary. If we do,
it gives back that value. If not, it calculates the Fibonacci number
again while saving the results in <code>memo</code>.</p>
<p>This way of doing it is a good way to find Fibonacci numbers. It can
also be changed for other tricky dynamic programming problems. If we
want to learn more about dynamic programming, we can read this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">detailed
article on Fibonacci number using dynamic programming</a>.</p>
<h2 id="c-implementation-of-fibonacci-with-memoization">C++
Implementation of Fibonacci with Memoization</h2>
<p>We can implement the Fibonacci sequence using memoization in C++. We
use an array to keep track of Fibonacci numbers that we already
calculated. This helps to reduce the number of times we call the
function and makes it faster.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is a simple code to implement the Fibonacci sequence with
memoization in C++:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    Fibonacci<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span>resize<span class="op">(</span><span class="dv">100</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">);</span> <span class="co">// We can change size if needed</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fib<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span> <span class="co">// These are base cases</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span> <span class="co">// We return the saved result</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// We calculate and save the result in memo</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> fib<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> fib<span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> memo<span class="op">;</span> <span class="co">// This vector stores the calculated values</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    Fibonacci fibonacci<span class="op">;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">10</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Fibonacci of &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; is &quot;</span> <span class="op">&lt;&lt;</span> fibonacci<span class="op">.</span>fib<span class="op">(</span>n<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ul>
<li><strong>Memoization Vector</strong>: We have a vector called
<code>memo</code> that starts with <code>-1</code>. This shows that we
have not yet calculated those Fibonacci numbers.</li>
<li><strong>Base Cases</strong>: The function checks if <code>n</code>
is 0 or 1. If it is, it returns <code>n</code> directly.</li>
<li><strong>Recursive Calls</strong>: If we have not calculated the
Fibonacci number for <code>n</code>, we calculate it again using
<code>fib(n - 1)</code> and <code>fib(n - 2)</code>. Then we save the
result in <code>memo[n]</code>.</li>
</ul>
<h3 id="performance">Performance</h3>
<p>This way of doing it makes the performance much better. The time it
takes to run is O(n) instead of the slower way. The space we use is also
O(n) because of the memoization storage.</p>
<p>If you want to learn more about dynamic programming, you can visit <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number - Easy</a>.</p>
<h2 id="comparative-analysis-of-fibonacci-implementations">Comparative
Analysis of Fibonacci Implementations</h2>
<p>When we implement the Fibonacci sequence, we can use different
methods. Each method has its own pros and cons for speed and memory use.
In this analysis, we look at three main methods: recursive, dynamic
programming with memoization, and iterative.</p>
<h3 id="recursive-implementation">Recursive Implementation</h3>
<p>The easiest way to calculate Fibonacci numbers is with a simple
recursive approach. But this method is slow because it has exponential
time complexity. This happens due to repeating the same calculations
many times.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">fibonacciRecursive</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">fibonacciRecursive</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">fibonacciRecursive</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li><strong>Space Complexity</strong>: O(n) because of the recursion
stack.</li>
</ul>
<h3 id="dynamic-programming-with-memoization">Dynamic Programming with
Memoization</h3>
<p>To make it faster, we can use dynamic programming with memoization.
This method saves the Fibonacci numbers we already calculated. So we do
not repeat those calculations.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacciMemo(n, memo<span class="op">=</span>{}):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> fibonacciMemo(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> fibonacciMemo(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span></code></pre></div>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) for storing the
memoization.</li>
</ul>
<h3 id="iterative-implementation">Iterative Implementation</h3>
<p>An iterative method uses a loop to find Fibonacci numbers. This
method is quick and uses less memory.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> fibonacciIterative<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1) because it only uses a small
amount of space.</li>
</ul>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Recursive</strong>: Easy to understand but slow for big
<code>n</code> because it grows fast.</li>
<li><strong>Dynamic Programming with Memoization</strong>: Much faster
because it saves results. Good for big <code>n</code>.</li>
<li><strong>Iterative</strong>: Best for space and usually faster than
recursive and memoization methods.</li>
</ul>
<h3 id="use-cases">Use Cases</h3>
<ul>
<li><strong>Recursive</strong>: Good for learning or when inputs are
very small.</li>
<li><strong>Dynamic Programming with Memoization</strong>: Best when we
need speed and inputs could be large.</li>
<li><strong>Iterative</strong>: Best choice for real-world applications
where we need to save resources.</li>
</ul>
<p>By knowing the performance of these Fibonacci methods, we can pick
the right one based on what we need. For more information on dynamic
programming, check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">this
article</a>.</p>
<h2
id="optimizing-memory-usage-in-fibonacci-with-memoization">Optimizing
Memory Usage in Fibonacci with Memoization</h2>
<p>When we implement the Fibonacci sequence using memoization, it is
important to optimize memory use. This is especially true for large
input values. The usual way uses an array to save computed Fibonacci
numbers. But this can take a lot of memory. Here are some ways to use
less memory while still using memoization well.</p>
<h3 id="use-a-hash-map">1. Use a Hash Map</h3>
<p>Instead of a fixed-size array, we can use a hash map (or dictionary).
This will store only the computed Fibonacci numbers. This saves memory,
especially for large <code>n</code> where many values are not
needed.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Long</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">long</span> <span class="fu">fib</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> result <span class="op">=</span> <span class="fu">fib</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">fib</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="limit-the-depth-of-recursion">2. Limit the Depth of
Recursion</h3>
<p>We can control the recursion depth. This helps to avoid using too
much stack space. It is especially useful in languages like Python,
where we can limit recursion depth.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(n, memo<span class="op">=</span>{}):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">not</span> <span class="kw">in</span> memo:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> fib(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> fib(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span></code></pre></div>
<h3 id="use-iterative-approach-with-minimal-state">3. Use Iterative
Approach with Minimal State</h3>
<p>An iterative approach helps to reduce memory use a lot. We only need
to keep track of the last two Fibonacci numbers. This requires only a
small amount of space.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> fib<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> a <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> b <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> c<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> a <span class="op">+</span> b<span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> b<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        b <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> b<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="tail-recursion-optimization">4. Tail Recursion Optimization</h3>
<p>In languages that support tail recursion optimization, we can write
the Fibonacci function in a tail-recursive way. This can help to lower
memory use because it optimizes stack usage.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fib(n, a<span class="op">=</span><span class="dv">0</span>, b<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> b</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> fib(n <span class="op">-</span> <span class="dv">1</span>, b, a <span class="op">+</span> b)</span></code></pre></div>
<p>These methods help us to reduce memory use when we implement the
Fibonacci sequence with memoization. This makes our solution efficient
and scalable. For more information about dynamic programming and
Fibonacci sequences, we can check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming tutorial</a>.</p>
<h2 id="common-pitfalls-in-fibonacci-memoization">Common Pitfalls in
Fibonacci Memoization</h2>
<p>When we implement Fibonacci with memoization, we can face some common
mistakes. By knowing these mistakes, we can make our code better and
avoid errors.</p>
<ol type="1">
<li><p><strong>Incorrect Base Cases</strong>: If we do not define the
base cases right, we can get wrong results or run into infinite loops.
The Fibonacci sequence is:</p>
<ul>
<li>F(0) = 0</li>
<li>F(1) = 1 We need to handle these cases clearly in our code.</li>
</ul></li>
<li><p><strong>Non-Optimal Data Structures</strong>: Using an array or
list instead of a dictionary can waste space. A dictionary is better
because it can change size and allows quicker lookups.</p></li>
<li><p><strong>Not Storing Results</strong>: If we forget to store
results in our memoization, our algorithm may do the same calculations
again. We should always check if we already computed the result before
going on with the recursion.</p></li>
<li><p><strong>Overwriting Memoized Values</strong>: We must make sure
that we do not accidentally overwrite memoized values. This can happen
if we compute the same index many times without checking.</p></li>
<li><p><strong>Incorrect Function Arguments</strong>: If we pass wrong
or strange arguments to the recursive function, we can get unexpected
behavior. We should always check inputs before we process them.</p></li>
<li><p><strong>Recursion Depth Issues</strong>: In Python, for example,
there is a limit for recursion. If we calculate Fibonacci for large
numbers, we might hit this limit. We can think about using an iterative
method if the index is too big.</p></li>
<li><p><strong>Memory Leaks</strong>: In languages like Java or C++, if
we do not clear memoized values, it can cause memory leaks. We need to
manage our memoization structure well.</p></li>
</ol>
<h3 id="example-in-python">Example in Python</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> fibonacci(n, memo<span class="op">=</span>{}):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    memo[n] <span class="op">=</span> fibonacci(n <span class="op">-</span> <span class="dv">1</span>, memo) <span class="op">+</span> fibonacci(n <span class="op">-</span> <span class="dv">2</span>, memo)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[n]</span></code></pre></div>
<h3 id="example-in-java">Example in Java</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">fibonacci</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="fu">fibonacci</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">fibonacci</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> result<span class="op">);</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-in-c">Example in C++</h3>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Fibonacci <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fibonacci<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span>find<span class="op">(</span>n<span class="op">)</span> <span class="op">!=</span> memo<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> fibonacci<span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> fibonacci<span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>By knowing these common mistakes in Fibonacci memoization, we can
make our code more effective and trustworthy. For more information on
dynamic programming methods, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Best
Online Tutorial on Dynamic Programming</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-memoization-in-dynamic-programming">1. What is
Memoization in Dynamic Programming?</h3>
<p>Memoization is a way we use in dynamic programming to make recursive
algorithms faster. We store the results of costly function calls. Then
we can use these results again when we get the same inputs. This helps
to lower the time it takes for algorithms. For example, when we
calculate Fibonacci numbers, we avoid doing the same math over and over.
For more details, look at this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number article</a>.</p>
<h3
id="how-does-the-fibonacci-sequence-relate-to-dynamic-programming">2.
How does the Fibonacci sequence relate to dynamic programming?</h3>
<p>The Fibonacci sequence is a well-known example for showing how
dynamic programming works. In this sequence, each number is the sum of
the two numbers before it. By using dynamic programming with
memoization, we can find Fibonacci numbers more quickly. This changes an
algorithm that takes a lot of time into one that takes less time. We
store and reuse the Fibonacci numbers we already calculated.</p>
<h3
id="what-are-the-time-and-space-complexities-of-fibonacci-with-memoization">3.
What are the time and space complexities of Fibonacci with
memoization?</h3>
<p>When we use memoization for the Fibonacci sequence, the time
complexity becomes O(n). This is because we compute each Fibonacci
number just one time. The space complexity is also O(n). This is for the
memoization table that keeps the Fibonacci values. This makes
memoization much better than the basic recursive way, which takes a lot
of time.</p>
<h3
id="can-i-implement-fibonacci-with-memoization-in-multiple-programming-languages">4.
Can I implement Fibonacci with memoization in multiple programming
languages?</h3>
<p>Yes, we can implement Fibonacci with memoization in many programming
languages like Java, Python, and C++. Each language has its own way of
writing code and using data structures. But the basic idea stays the
same. You can see how this works in different languages by checking our
sections for <a href="#">Java Implementation of Fibonacci with
Memoization</a>, <a href="#">Python Implementation</a>, and <a
href="#">C++ Implementation</a>.</p>
<h3
id="what-common-mistakes-should-i-avoid-when-implementing-fibonacci-with-memoization">5.
What common mistakes should I avoid when implementing Fibonacci with
memoization?</h3>
<p>When we do Fibonacci with memoization, we should avoid some common
mistakes. One mistake is forgetting to see if a value is already
calculated. This makes memoization useless. Also, if we use the wrong
data structure to keep the computed values, it can waste memory. Always
check that your memoization table is set up right and that we access it
correctly. This helps avoid errors and makes our implementation better.
For more tips, look at our <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming article</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            