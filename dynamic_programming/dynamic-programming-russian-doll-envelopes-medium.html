
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Russian Doll Envelopes - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how dynamic programming can solve the Russian Doll Envelopes problem. Unlock efficiency in your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Russian Doll Envelopes - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p><strong>Russian Doll Envelopes Problem</strong></p>
<p>Russian Doll Envelopes is a dynamic programming problem. It is about
finding the most envelopes we can nest inside each other. Each envelope
has a width and a height. One envelope can fit into another if both its
width and height are smaller. To solve this, we need to sort the
envelopes. Then we use a longest increasing subsequence (LIS) strategy
to find the biggest group of envelopes that can nest.</p>
<p>In this article, we will look closely at the Russian Doll Envelopes
problem. We will explain the input and output needs. We will also check
different dynamic programming ways to solve this problem in Java,
Python, and C++. We will talk about binary search improvements for these
languages. We will give a code walkthrough for the solutions. Lastly, we
will answer common questions to help you understand the Russian Doll
Envelopes problem better.</p>
<ul>
<li>[Dynamic Programming] Russian Doll Envelopes Problem
Explanation</li>
<li>Understanding the Input and Output Requirements</li>
<li>Dynamic Programming Approach for Russian Doll Envelopes in Java</li>
<li>Dynamic Programming Approach for Russian Doll Envelopes in
Python</li>
<li>Dynamic Programming Approach for Russian Doll Envelopes in C++</li>
<li>Binary Search Optimization for Russian Doll Envelopes in Java</li>
<li>Binary Search Optimization for Russian Doll Envelopes in Python</li>
<li>Binary Search Optimization for Russian Doll Envelopes in C++</li>
<li>Code Walkthrough for Russian Doll Envelopes Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-input-and-output-requirements">Understanding
the Input and Output Requirements</h2>
<p>In the Russian Doll Envelopes problem, we want to find out the most
envelopes we can nest inside each other. An envelope can hold another
envelope only if both the width and height of the inside envelope are
less than those of the outside envelope.</p>
<h3 id="input-requirements">Input Requirements</h3>
<ul>
<li><p><strong>Input</strong>: A 2D array of integers called
<code>envelopes</code>. Each element shows an envelope. It has two
numbers:</p>
<ul>
<li><code>envelopes[i][0]</code>: the width of the i-th envelope.</li>
<li><code>envelopes[i][1]</code>: the height of the i-th envelope.</li>
</ul>
<p>Example:</p>
<pre class="plaintext"><code>envelopes = [[5,4],[6,4],[6,7],[2,3]]</code></pre></li>
</ul>
<h3 id="output-requirements">Output Requirements</h3>
<ul>
<li><strong>Output</strong>: An integer that shows the maximum number of
envelopes that can be nested inside each other.</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The number of envelopes is from 1 to 1000.</li>
<li>The width and height of each envelope are from 1 to 10^4.</li>
</ul>
<h3 id="example">Example</h3>
<p>For the input:</p>
<pre class="plaintext"><code>envelopes = [[5,4],[6,4],[6,7],[2,3]]</code></pre>
<p>The output should be:</p>
<pre class="plaintext"><code>3</code></pre>
<p>This means a maximum of 3 envelopes can be nested. The specific
nesting is: <code>[[2,3] -&gt; [5,4] -&gt; [6,7]]</code>.</p>
<p>We can solve this problem well by using dynamic programming. We can
also use sorting or binary search to help find the longest increasing
subsequence by looking at the sizes of the envelopes.</p>
<h2
id="dynamic-programming-approach-for-russian-doll-envelopes-in-java">Dynamic
Programming Approach for Russian Doll Envelopes in Java</h2>
<p>To solve the Russian Doll Envelopes problem using dynamic programming
in Java, we take a clear approach. The main goal is to find the longest
increasing subsequence of envelopes based on their width and height.</p>
<h3 id="steps-to-implement-the-dynamic-programming-approach">Steps to
Implement the Dynamic Programming Approach:</h3>
<ol type="1">
<li><p><strong>Sort Envelopes</strong>: First, we sort the envelopes. We
sort mainly by width in increasing order. If two envelopes have the same
width, we sort by height in decreasing order. This way, we do not count
envelopes with the same width.</p></li>
<li><p><strong>Dynamic Programming Array</strong>: We create a DP array.
Here <code>dp[i]</code> shows the maximum number of envelopes that can
be nested ending with envelope <code>i</code>.</p></li>
<li><p><strong>Fill the DP Array</strong>: For each envelope, we look at
all previous envelopes to see if the current envelope can fit inside the
previous ones.</p></li>
</ol>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> RussianDollEnvelopes <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxEnvelopes</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sort the envelopes</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>envelopes<span class="op">,</span> <span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">-&gt;</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="cf">return</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> a<span class="op">[</span><span class="dv">1</span><span class="op">];</span> <span class="co">// Descending order for height</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Ascending order for width</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// DP array to store the maximum envelopes ending at each index</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> envelopes<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP array</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Each envelope can at least hold itself</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">&amp;&amp;</span> envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>            maxCount <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxCount<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span> <span class="co">// Update the maximum count</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxCount<span class="op">;</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        RussianDollEnvelopes solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">RussianDollEnvelopes</span><span class="op">();</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> envelopes <span class="op">=</span> <span class="op">{{</span><span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">},</span> <span class="op">{</span><span class="dv">7</span><span class="op">,</span> <span class="dv">8</span><span class="op">}};</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum number of envelopes that can be nested: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">maxEnvelopes</span><span class="op">(</span>envelopes<span class="op">));</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Sorting</strong>: We sort the envelopes using a custom rule.
We sort by width in increasing order. If widths are equal, we sort by
height in decreasing order.</li>
<li><strong>DP Array Initialization</strong>: We set up a DP array. Each
element starts as 1 because each envelope can at least hold itself.</li>
<li><strong>Nested Loops</strong>: The outer loop goes through each
envelope. The inner loop checks all earlier envelopes to find if they
can fit.</li>
<li><strong>Result</strong>: The maximum number in the DP array gives
the answer. This shows the maximum number of envelopes that can fit
inside each other.</li>
</ul>
<p>This way, we use dynamic programming to solve the Russian Doll
Envelopes problem in Java. For more details on dynamic programming, you
can read <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2
id="dynamic-programming-approach-for-russian-doll-envelopes-in-python">Dynamic
Programming Approach for Russian Doll Envelopes in Python</h2>
<p>The Russian Doll Envelopes problem is a well-known challenge in
dynamic programming. We need to find the most envelopes that can fit
inside each other. One envelope fits into another if its width and
height are both bigger than the other envelope’s width and height.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have a list of envelopes shown as pairs of numbers. Each pair has
a width and a height. Our goal is to find the maximum number of
envelopes that can nest.</p>
<h3 id="steps-for-the-dynamic-programming-approach">Steps for the
Dynamic Programming Approach</h3>
<ol type="1">
<li><strong>Sort Envelopes</strong>: First, we sort the envelopes by
width. If two envelopes have the same width, we sort them by height but
in reverse order. This keeps us from counting envelopes with the same
width.</li>
<li><strong>Apply Longest Increasing Subsequence (LIS)</strong>: After
we sort, we need to find the longest increasing subsequence based on the
heights of the envelopes.</li>
</ol>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is how we can implement the solution in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxEnvelopes(envelopes):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort the envelopes. First by width, then by height in descending order</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    envelopes.sort(key<span class="op">=</span><span class="kw">lambda</span> x: (x[<span class="dv">0</span>], <span class="op">-</span>x[<span class="dv">1</span>]))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract the heights for LIS calculation</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    heights <span class="op">=</span> [h <span class="cf">for</span> _, h <span class="kw">in</span> envelopes]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function to find the length of LIS</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> lis(sequence):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> []</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> h <span class="kw">in</span> sequence:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            pos <span class="op">=</span> bisect.bisect_left(dp, h)</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(dp):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                dp.append(h)</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>                dp[pos] <span class="op">=</span> h</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(dp)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lis(heights)</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>envelopes <span class="op">=</span> [[<span class="dv">5</span>,<span class="dv">4</span>],[<span class="dv">6</span>,<span class="dv">4</span>],[<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">2</span>,<span class="dv">3</span>]]</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxEnvelopes(envelopes))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>We sort the input <code>envelopes</code> first by width and then by
height in reverse order.</li>
<li>The <code>lis</code> function finds the length of the longest
increasing subsequence. It uses binary search to keep the process fast
with O(n log n) time.</li>
<li>In the end, the function gives us the maximum number of envelopes we
can nest.</li>
</ul>
<p>This dynamic programming method works well for the Russian Doll
Envelopes problem in Python. It uses sorting and the longest increasing
subsequence method. If you want to learn more about dynamic programming,
you can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-approach-for-russian-doll-envelopes-in-c">Dynamic
Programming Approach for Russian Doll Envelopes in C++</h2>
<p>The Russian Doll Envelopes problem is about finding the most
envelopes we can put inside each other. Each envelope has two numbers,
width and height. An envelope can fit inside another if both its width
and height are smaller than the other.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><p><strong>Sort the Envelopes</strong>: First, we need to sort the
envelopes by width. If two envelopes have the same width, we sort them
by height from high to low. This way, we avoid putting envelopes with
the same width inside each other.</p></li>
<li><p><strong>Apply Longest Increasing Subsequence (LIS)</strong>:
After sorting, we will use the Longest Increasing Subsequence (LIS)
method on the heights of the envelopes.</p></li>
</ol>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxEnvelopes<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort envelopes: first by width, then by height in descending order</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>envelopes<span class="op">.</span>begin<span class="op">(),</span> envelopes<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">||</span> <span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&amp;&amp;</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Vector to store the heights for LIS</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> envelope <span class="op">:</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> height <span class="op">=</span> envelope<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Use binary search to find the position of height in dp</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> lower_bound<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">(),</span> height<span class="op">);</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> dp<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">.</span>push_back<span class="op">(</span>height<span class="op">);</span> <span class="co">// If height is larger than all, add it</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>it <span class="op">=</span> height<span class="op">;</span> <span class="co">// Change it with the current height</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">.</span>size<span class="op">();</span> <span class="co">// The size of dp is the most envelopes we can nest</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Sorting</strong>: We sort the envelopes so we can easily
find the longest increasing subsequence in heights.</li>
<li><strong>Binary Search</strong>: We use the <code>lower_bound</code>
function to keep the <code>dp</code> vector updated fast. This helps
keep the time at O(n log n).</li>
<li><strong>Result</strong>: The length of the <code>dp</code> vector
tells us the maximum number of envelopes that can be nested.</li>
</ul>
<p>This dynamic programming way helps us solve the Russian Doll
Envelopes problem well in C++. For more similar problems, you can look
at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2
id="binary-search-optimization-for-russian-doll-envelopes-in-java">Binary
Search Optimization for Russian Doll Envelopes in Java</h2>
<p>We can solve the Russian Doll Envelopes problem in a smart way. We
will use dynamic programming and binary search together. This method
helps us save time and works well with large datasets.</p>
<h3 id="problem-overview">Problem Overview</h3>
<p>The Russian Doll Envelopes problem wants us to find the biggest
number of envelopes that can fit inside each other. Each envelope is
shown by two numbers. The first number is the width and the second is
the height. Envelope A can fit inside envelope B only if both the width
and height of A are less than those of B.</p>
<h3 id="steps-to-implement-binary-search-optimization">Steps to
Implement Binary Search Optimization</h3>
<ol type="1">
<li><p><strong>Sort the Envelopes</strong>: First, we need to sort the
envelopes. We sort by width in increasing order. If two envelopes have
the same width, we sort them by height in decreasing order. This way, we
avoid nesting envelopes that have the same width.</p></li>
<li><p><strong>Use Dynamic Programming with Binary Search</strong>: We
will create a dynamic programming array to keep track of the increasing
heights. For each envelope, we will use binary search to find its
position in the array and update it.</p></li>
</ol>
<h3 id="java-implementation-1">Java Implementation</h3>
<p>Here is how we can implement the binary search optimization in
Java:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Comparator</span><span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> RussianDollEnvelopes <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxEnvelopes</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Sort envelopes first by width and then by height in descending order</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>envelopes<span class="op">,</span> <span class="kw">new</span> <span class="bu">Comparator</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">[]&gt;()</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compare</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">return</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> a<span class="op">[</span><span class="dv">1</span><span class="op">];</span> <span class="co">// Descending order for heights</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Ascending order for widths</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// DP array to hold the heights</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>envelopes<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> length <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span><span class="op">[]</span> envelope <span class="op">:</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> height <span class="op">=</span> envelope<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> index <span class="op">=</span> <span class="fu">binarySearch</span><span class="op">(</span>dp<span class="op">,</span> length<span class="op">,</span> height<span class="op">);</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>index<span class="op">]</span> <span class="op">=</span> height<span class="op">;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>index <span class="op">==</span> length<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                length<span class="op">++;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> length<span class="op">;</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">binarySearch</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> dp<span class="op">,</span> <span class="dt">int</span> length<span class="op">,</span> <span class="dt">int</span> height<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> left <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> right <span class="op">=</span> length<span class="op">;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>left <span class="op">&lt;</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> mid <span class="op">=</span> left <span class="op">+</span> <span class="op">(</span>right <span class="op">-</span> left<span class="op">)</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>dp<span class="op">[</span>mid<span class="op">]</span> <span class="op">&lt;</span> height<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>                left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>                right <span class="op">=</span> mid<span class="op">;</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> left<span class="op">;</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>        RussianDollEnvelopes solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">RussianDollEnvelopes</span><span class="op">();</span></span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> envelopes <span class="op">=</span> <span class="op">{{</span><span class="dv">5</span><span class="op">,</span><span class="dv">4</span><span class="op">},{</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">},{</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">},{</span><span class="dv">1</span><span class="op">,</span><span class="dv">1</span><span class="op">},{</span><span class="dv">7</span><span class="op">,</span><span class="dv">8</span><span class="op">}};</span></span>
<span id="cb7-49"><a href="#cb7-49" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum number of envelopes: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">maxEnvelopes</span><span class="op">(</span>envelopes<span class="op">));</span></span>
<span id="cb7-50"><a href="#cb7-50" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-51"><a href="#cb7-51" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<ul>
<li><strong>Sorting</strong>: The envelopes get sorted using a special
method to make sure they are in the right order for nesting.</li>
<li><strong>Dynamic Programming Array (<code>dp</code>)</strong>: This
array keeps track of the heights of the envelopes that can be
stacked.</li>
<li><strong>Binary Search Method</strong>: The <code>binarySearch</code>
method finds the place to change or add in the <code>dp</code> array
quickly.</li>
<li><strong>Time Complexity</strong>: The total time complexity is O(n
log n). This is because of the sorting and binary search steps.</li>
</ul>
<p>This optimization really helps us make the solution better for the
Russian Doll Envelopes problem in Java. If you want to learn more about
similar dynamic programming problems, you can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2
id="binary-search-optimization-for-russian-doll-envelopes-in-python">Binary
Search Optimization for Russian Doll Envelopes in Python</h2>
<p>To solve the Russian Doll Envelopes problem well, we can use a binary
search optimization after sorting the envelopes. Our main goal is to
find the longest increasing subsequence (LIS) of envelopes based on
their sizes. This way, we can reduce the time needed to O(n log n). This
is much better than the O(n^2) dynamic programming method.</p>
<h3 id="steps-to-implement-binary-search-optimization-1">Steps to
Implement Binary Search Optimization</h3>
<ol type="1">
<li><p><strong>Sort the Envelopes:</strong> First, we sort the envelopes
by their width in order from smallest to largest. If two envelopes have
the same width, we sort them by height from tallest to shortest. This
helps us avoid counting envelopes that cannot fit inside each
other.</p></li>
<li><p><strong>Use a List to Track the LIS:</strong> We keep a list that
will hold the heights of the envelopes in the current increasing
subsequence.</p></li>
<li><p><strong>Binary Search for Insertion:</strong> For each envelope’s
height, we use binary search to find the spot where it can replace an
element in the LIS list. If it is bigger than all elements, we add it to
the end of the list.</p></li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<p>Here is the Python code that shows how to use binary search
optimization for the Russian Doll Envelopes problem:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> bisect <span class="im">import</span> bisect_left</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxEnvelopes(envelopes):</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Sort envelopes</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    envelopes.sort(key<span class="op">=</span><span class="kw">lambda</span> x: (x[<span class="dv">0</span>], <span class="op">-</span>x[<span class="dv">1</span>]))</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Initialize a list to store the LIS</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    lis <span class="op">=</span> []</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _, height <span class="kw">in</span> envelopes:</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Step 3: Perform binary search</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        pos <span class="op">=</span> bisect_left(lis, height)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># If pos is equal to the length of lis, it means height is greater than all elements in lis</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> pos <span class="op">==</span> <span class="bu">len</span>(lis):</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>            lis.append(height)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            lis[pos] <span class="op">=</span> height</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(lis)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage:</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>envelopes <span class="op">=</span> [[<span class="dv">5</span>,<span class="dv">4</span>],[<span class="dv">6</span>,<span class="dv">7</span>],[<span class="dv">2</span>,<span class="dv">3</span>],[<span class="dv">7</span>,<span class="dv">8</span>]]</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> maxEnvelopes(envelopes)</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum number of envelopes that can be Russian dolled:&quot;</span>, result)</span></code></pre></div>
<h3 id="explanation-of-the-code-4">Explanation of the Code</h3>
<ul>
<li><strong>Sorting:</strong> The <code>sort</code> method with a
special key sorts the envelopes by width and height.</li>
<li><strong>LIS Calculation:</strong> The <code>bisect_left</code>
function finds where to put the current envelope’s height in the
<code>lis</code> list.</li>
<li><strong>Building the LIS:</strong> If the position equals the length
of <code>lis</code>, it means the current height is bigger than all
heights in <code>lis</code>. We then add it to the list. If not, we
replace an existing height to keep the smallest possible values for
future checks.</li>
</ul>
<p>This method quickly calculates the maximum number of envelopes that
can fit inside each other, following the rules of the Russian Doll
Envelopes problem.</p>
<h2
id="binary-search-optimization-for-russian-doll-envelopes-in-c">Binary
Search Optimization for Russian Doll Envelopes in C++</h2>
<p>To make a better solution for the Russian Doll Envelopes problem in
C++, we can use a binary search method after we sort the envelopes. This
method makes the time it takes to solve the problem faster, reducing it
to O(n log n).</p>
<h3 id="problem-recap">Problem Recap</h3>
<p>We have a list of envelopes that have widths and heights. Our goal is
to find the most envelopes we can fit inside each other. An envelope
<code>A</code> can go into envelope <code>B</code> if both the width and
height of <code>A</code> are less than those of <code>B</code>.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Sorting</strong>: First, we sort the envelopes. We sort
by width in rising order. If two envelopes have the same width, we sort
by height in falling order. This stops us from counting envelopes that
are the same width.</p></li>
<li><p><strong>Dynamic Programming with Binary Search</strong>: After we
sort, we can use a dynamic programming technique plus binary search to
find the longest increasing sequence based on heights.</p></li>
</ol>
<h3 id="c-code">C++ Code</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxEnvelopes<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Sort envelopes. First by width in ascending order, then by height in descending order</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>envelopes<span class="op">.</span>begin<span class="op">(),</span> envelopes<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">:</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">});</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Apply a dynamic programming approach to find the longest increasing subsequence in heights</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> env <span class="op">:</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> height <span class="op">=</span> env<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> it <span class="op">=</span> lower_bound<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">(),</span> height<span class="op">);</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> dp<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">.</span>push_back<span class="op">(</span>height<span class="op">);</span> <span class="co">// If height is greater than all in dp, add it</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">*</span>it <span class="op">=</span> height<span class="op">;</span> <span class="co">// Replace the found position with the new height</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">.</span>size<span class="op">();</span> <span class="co">// The size of dp will be the maximum number of envelopes</span></span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> envelopes <span class="op">=</span> <span class="op">{{</span><span class="dv">5</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span><span class="dv">4</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span><span class="dv">7</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span><span class="dv">3</span><span class="op">}};</span></span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum number of envelopes: &quot;</span> <span class="op">&lt;&lt;</span> maxEnvelopes<span class="op">(</span>envelopes<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-5">Explanation of the Code</h3>
<ul>
<li><strong>Sorting</strong>: The <code>sort</code> function puts the
envelopes in order like we said.</li>
<li><strong>Dynamic Programming Array</strong>: The <code>dp</code>
vector keeps the heights of the longest increasing sequence we
found.</li>
<li><strong>Binary Search</strong>: The <code>lower_bound</code>
function helps us quickly find the place to replace or add in the
<code>dp</code> vector.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li>The sorting step takes O(n log n). The binary search inside the loop
also runs in O(n log n). So the total time complexity is O(n log n).
This makes it good for large inputs.</li>
</ul>
<p>This binary search optimization for the Russian Doll Envelopes
problem in C++ shows how we can mix sorting with dynamic programming for
a smart solution to tough problems. For more learning on dynamic
programming ideas, you can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a> which is very useful.</p>
<h2 id="code-walkthrough-for-russian-doll-envelopes-solutions">Code
Walkthrough for Russian Doll Envelopes Solutions</h2>
<p>The Russian Doll Envelopes problem is about finding how many
envelopes can fit inside each other. Each envelope has two sizes: width
and height. An envelope can go inside another one if both its width and
height are smaller.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>To solve this with dynamic programming, we need to sort the
envelopes. Then, we will use a version of the Longest Increasing
Subsequence (LIS) algorithm.</p>
<ol type="1">
<li><p><strong>Sort the envelopes</strong> by width from smallest to
biggest. If two envelopes have the same width, sort them by height from
biggest to smallest. This way, we do not count envelopes that have the
same width.</p></li>
<li><p><strong>Use a DP array</strong> to keep track of the longest
increasing subsequence based on height.</p></li>
</ol>
<h4 id="java-code-example">Java Code Example</h4>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Comparator</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> RussianDollEnvelopes <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxEnvelopes</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>envelopes<span class="op">,</span> <span class="kw">new</span> <span class="bu">Comparator</span><span class="op">&lt;</span><span class="dt">int</span><span class="op">[]&gt;()</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="kw">public</span> <span class="dt">int</span> <span class="fu">compare</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> a<span class="op">,</span> <span class="dt">int</span><span class="op">[]</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">-</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">:</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">-</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> envelopes<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLen <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Each envelope can at least fit itself</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>envelopes<span class="op">[</span>i<span class="op">][</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> envelopes<span class="op">[</span>j<span class="op">][</span><span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>            maxLen <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLen<span class="op">,</span> dp<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLen<span class="op">;</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python-code-example">Python Code Example</h4>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> maxEnvelopes(<span class="va">self</span>, envelopes: List[List[<span class="bu">int</span>]]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        envelopes.sort(key<span class="op">=</span><span class="kw">lambda</span> x: (x[<span class="dv">0</span>], <span class="op">-</span>x[<span class="dv">1</span>]))</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> []</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> _, h <span class="kw">in</span> envelopes:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            idx <span class="op">=</span> bisect.bisect_left(dp, h)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> idx <span class="op">==</span> <span class="bu">len</span>(dp):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>                dp.append(h)</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                dp[idx] <span class="op">=</span> h</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(dp)</span></code></pre></div>
<h4 id="c-code-example">C++ Code Example</h4>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxEnvelopes<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        sort<span class="op">(</span>envelopes<span class="op">.</span>begin<span class="op">(),</span> envelopes<span class="op">.</span>end<span class="op">(),</span> <span class="op">[](</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> a<span class="op">,</span> <span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> b<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> b<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">?</span> a<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">&gt;</span> b<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">:</span> a<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">&lt;</span> b<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">});</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="at">const</span> <span class="kw">auto</span><span class="op">&amp;</span> envelope <span class="op">:</span> envelopes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> h <span class="op">=</span> envelope<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span class="kw">auto</span> it <span class="op">=</span> lower_bound<span class="op">(</span>dp<span class="op">.</span>begin<span class="op">(),</span> dp<span class="op">.</span>end<span class="op">(),</span> h<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>it <span class="op">==</span> dp<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">.</span>push_back<span class="op">(</span>h<span class="op">);</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">*</span>it <span class="op">=</span> h<span class="op">;</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb12-24"><a href="#cb12-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-25"><a href="#cb12-25" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="binary-search-optimization">Binary Search Optimization</h3>
<p>We can make the dynamic programming solution faster by using binary
search to manage the DP array better.</p>
<ol type="1">
<li><p><strong>Sort envelopes</strong> just like before.</p></li>
<li><p>Use binary search to find where the current height fits in the DP
array.</p></li>
</ol>
<p>This change makes finding the position faster. The time needed is now
O(log n).</p>
<p>For more on dynamic programming and its uses, we can check topics
like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-russian-doll-envelopes-problem-in-dynamic-programming">What
is the Russian Doll Envelopes problem in dynamic programming?</h3>
<p>The Russian Doll Envelopes problem is a well-known challenge in
dynamic programming. The goal is to find the most envelopes that can fit
into each other. Each envelope has a width and height. One envelope can
fit into another only if the outer envelope is bigger in both width and
height. This problem is similar to the Longest Increasing Subsequence
problem.</p>
<h3
id="how-can-i-implement-the-russian-doll-envelopes-solution-in-java">How
can I implement the Russian Doll Envelopes solution in Java?</h3>
<p>To solve the Russian Doll Envelopes problem in Java, we can use a
method that combines dynamic programming and sorting. First, we should
sort the envelopes by their width and height. Next, we apply a dynamic
programming algorithm to find the longest increasing subsequence based
on the heights of the sorted envelopes. This helps us find the maximum
number of envelopes that can be nested. For detailed code, check our
section on the Dynamic Programming Approach for Russian Doll Envelopes
in Java.</p>
<h3
id="what-is-the-time-complexity-of-the-russian-doll-envelopes-problem">What
is the time complexity of the Russian Doll Envelopes problem?</h3>
<p>The time complexity to solve the Russian Doll Envelopes problem using
dynamic programming is O(n^2). Here, n is the number of envelopes. This
happens because we use a nested loop to compare each envelope with every
other envelope. But if we use a binary search after sorting the
envelopes, we can lower the time complexity to O(n log n).</p>
<h3 id="can-i-solve-the-russian-doll-envelopes-problem-using-python">Can
I solve the Russian Doll Envelopes problem using Python?</h3>
<p>Yes, we can solve the Russian Doll Envelopes problem with Python. The
method is to sort the envelopes by their size and then use dynamic
programming to find the longest increasing subsequence. This method is
easy and works well in Python. For a detailed guide, look at our section
on the Dynamic Programming Approach for Russian Doll Envelopes in
Python.</p>
<h3
id="how-is-binary-search-utilized-in-optimizing-the-russian-doll-envelopes-solution">How
is binary search utilized in optimizing the Russian Doll Envelopes
solution?</h3>
<p>We use binary search in the Russian Doll Envelopes problem to quickly
find where to put an envelope’s height in a list. This list keeps track
of the maximum heights of envelopes in the longest increasing
subsequence. After we sort the envelopes, binary search helps us place
each envelope’s height fast. This makes the solution more efficient and
brings the time complexity down to O(n log n). For more information, see
our section on Binary Search Optimization for Russian Doll Envelopes in
Java, Python, or C++.</p>
<p>With these dynamic programming and optimization techniques, we can
solve the Russian Doll Envelopes problem effectively. This will also
help us improve our skills in competitive programming.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            