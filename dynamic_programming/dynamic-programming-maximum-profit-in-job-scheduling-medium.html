
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Profit in Job Scheduling - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to maximize profits in job scheduling using dynamic programming. Unlock efficient strategies for optimal scheduling!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Profit in Job Scheduling - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic Programming is a strong method. It helps us solve hard
problems by breaking them into easier parts. The Maximum Profit in Job
Scheduling problem wants us to pick jobs that give us the most profit.
We must also make sure that no two jobs run at the same time. This
problem is important when we have many tasks to schedule. We need to
organize them well to use our resources and make profit.</p>
<p>In this article, we will look closely at the Maximum Profit in Job
Scheduling problem. First, we will understand what the problem is about.
Then, we will talk about different ways to solve it. We will start with
the brute force method. After that, we will discuss an improved
recursive solution. Next, we will go deep into a dynamic programming
solution. We will show how to do this in Java, Python, and C++. At the
end, we will compare the different ways to solve the problem. We will
also check the complexity of each method and answer some common
questions about job scheduling.</p>
<ul>
<li>Dynamic Programming Solution for Maximum Profit in Job Scheduling -
Medium</li>
<li>Understanding the Problem Statement for Maximum Profit in Job
Scheduling</li>
<li>Brute Force Approach for Job Scheduling Problem</li>
<li>Optimized Recursive Solution for Maximum Profit in Job
Scheduling</li>
<li>Dynamic Programming Approach for Maximum Profit in Job Scheduling in
Java</li>
<li>Dynamic Programming Approach for Maximum Profit in Job Scheduling in
Python</li>
<li>Dynamic Programming Approach for Maximum Profit in Job Scheduling in
C++</li>
<li>Comparing Different Approaches for Job Scheduling Problem</li>
<li>Complexity Analysis of Job Scheduling Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information about dynamic programming, you can check
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
numbers</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack problem</a>.</p>
<h2
id="understanding-the-problem-statement-for-maximum-profit-in-job-scheduling">Understanding
the Problem Statement for Maximum Profit in Job Scheduling</h2>
<p>The Maximum Profit in Job Scheduling problem is about planning jobs
to get the most profit. We have to keep in mind the time each job takes
and its deadline. Each job has a start time, an end time, and a profit
amount. Our aim is to choose some jobs that do not overlap and get the
highest total profit.</p>
<h3 id="problem-definition">Problem Definition:</h3>
<ul>
<li><strong>Input:</strong>
<ul>
<li>A list of jobs. Each job is shown as a tuple
<code>(start_time, end_time, profit)</code>.</li>
</ul></li>
<li><strong>Output:</strong>
<ul>
<li>The maximum profit we can get by scheduling jobs that do not
overlap.</li>
</ul></li>
</ul>
<h3 id="example">Example:</h3>
<p>Here is a list of jobs:</p>
<table>
<thead>
<tr class="header">
<th>Job</th>
<th>Start Time</th>
<th>End Time</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>3</td>
<td>50</td>
</tr>
<tr class="even">
<td>2</td>
<td>3</td>
<td>5</td>
<td>20</td>
</tr>
<tr class="odd">
<td>3</td>
<td>6</td>
<td>19</td>
<td>100</td>
</tr>
<tr class="even">
<td>4</td>
<td>2</td>
<td>100</td>
<td>200</td>
</tr>
<tr class="odd">
<td>5</td>
<td>5</td>
<td>6</td>
<td>70</td>
</tr>
</tbody>
</table>
<ul>
<li>If we pick jobs 1 and 3, we get a total profit of
<code>50 + 100 = 150</code>.</li>
<li>If we pick job 4, we get a profit of <code>200</code>. This is the
highest profit we can achieve.</li>
</ul>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>Jobs must not overlap. If job A finishes at time <code>t</code>, job
B can only start at <code>t</code> or later.</li>
<li>We need to schedule jobs to maximize profit without going over the
allowed job limits.</li>
</ul>
<h3 id="approach">Approach:</h3>
<p>We can solve this problem using different methods. Some methods are
brute-force and dynamic programming. It helps to sort the jobs by their
finish times. This step is very important for many efficient ways to
solve this problem.</p>
<p>This problem is similar to interval scheduling maximization. We can
solve it using techniques from dynamic programming or greedy
algorithms.</p>
<p>If we want to learn more about related topics, we can read articles
on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">Dynamic
Programming - 0/1 Knapsack Problem</a>.</p>
<h2 id="brute-force-approach-for-job-scheduling-problem">Brute Force
Approach for Job Scheduling Problem</h2>
<p>In the brute force approach for the job scheduling problem, we look
at every possible way to schedule jobs. We calculate the profit for each
option. This method makes sure we check every combination. But, it can
take a lot of time, especially when we have many jobs.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have a set of jobs. Each job has a start time, an end time, and a
profit. Our goal is to schedule these jobs to get the highest total
profit. We should also make sure that no two jobs happen at the same
time.</p>
<h3 id="steps-for-brute-force-approach">Steps for Brute Force
Approach</h3>
<ol type="1">
<li><strong>Generate All Subsets</strong>: We create all possible groups
of jobs.</li>
<li><strong>Check for Conflicts</strong>: For each group, we see if any
jobs overlap in time.</li>
<li><strong>Calculate Profit</strong>: If a group of jobs does not have
conflicts, we add up the profit for that group.</li>
<li><strong>Track Maximum Profit</strong>: We keep track of the highest
profit we find.</li>
</ol>
<h3 id="pseudocode">Pseudocode</h3>
<pre class="plaintext"><code>function maxProfit(jobs):
    maxProfit = 0
    for each subset of jobs:
        if no conflicts in subset:
            currentProfit = sum(profits of jobs in subset)
            if currentProfit &gt; maxProfit:
                maxProfit = currentProfit
    return maxProfit</code></pre>
<h3 id="example-1">Example</h3>
<p>Letâ€™s look at these jobs:</p>
<table>
<thead>
<tr class="header">
<th>Job</th>
<th>Start Time</th>
<th>End Time</th>
<th>Profit</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1</td>
<td>3</td>
<td>50</td>
</tr>
<tr class="even">
<td>2</td>
<td>2</td>
<td>5</td>
<td>20</td>
</tr>
<tr class="odd">
<td>3</td>
<td>4</td>
<td>6</td>
<td>70</td>
</tr>
<tr class="even">
<td>4</td>
<td>6</td>
<td>7</td>
<td>30</td>
</tr>
<tr class="odd">
<td>5</td>
<td>5</td>
<td>9</td>
<td>60</td>
</tr>
</tbody>
</table>
<ul>
<li>We generate subsets and check overlaps like {1, 3} and {2, 4}.</li>
<li>We find the maximum profit from the valid groups.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n) because we check all
subsets.</li>
<li><strong>Space Complexity</strong>: O(n) for saving the subsets.</li>
</ul>
<p>The brute force approach is simple but not fast for big datasets. For
a better way, we can use dynamic programming techniques. These methods
make the process easier by not doing the same calculations over and
over. For more information, see the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-two-non-overlapping-subarrays-medium.html">Dynamic
Programming Solution for Maximum Profit in Job Scheduling</a>
article.</p>
<h2
id="optimized-recursive-solution-for-maximum-profit-in-job-scheduling">Optimized
Recursive Solution for Maximum Profit in Job Scheduling</h2>
<p>The Job Scheduling problem is to get the most profit by scheduling
jobs that have deadlines and profits. We can use an optimized recursive
solution to make the calculation faster. This way, we avoid doing the
same calculations over and over.</p>
<p>We will use recursion with memoization. This means we store results
of calculations we have done before. This helps us find the best
solutions without repeating work.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a list of jobs. Each job has a deadline and a profit. Our
goal is to maximize the total profit by scheduling jobs. We need to make
sure that no two jobs overlap their deadlines.</p>
<h3 id="recursive-function">Recursive Function</h3>
<ol type="1">
<li><strong>Base Case</strong>: If there are no jobs left or the
deadline is zero, we return zero profit.</li>
<li><strong>Recursion</strong>: For each job, we can either include it
in our schedule or skip it. If we include it, we must check if it fits
within the available deadline.</li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is an example in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_max_profit(jobs, n):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort jobs based on profit in descending order</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    jobs.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">1</span>], reverse<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize result array and deadline tracker</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> n</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    job_schedule <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(jobs)):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(n, jobs[i][<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> result[j] <span class="kw">is</span> <span class="va">False</span>:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                result[j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                job_schedule[j] <span class="op">=</span> i</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>    max_profit <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> job_schedule[i] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            max_profit <span class="op">+=</span> jobs[job_schedule[i]][<span class="dv">1</span>]</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_profit</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>jobs <span class="op">=</span> [(<span class="dv">2</span>, <span class="dv">100</span>), (<span class="dv">1</span>, <span class="dv">19</span>), (<span class="dv">2</span>, <span class="dv">27</span>), (<span class="dv">1</span>, <span class="dv">25</span>), (<span class="dv">3</span>, <span class="dv">15</span>)]</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of jobs</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Maximum Profit: </span><span class="sc">{</span>find_max_profit(jobs, n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Input</strong>: We give a list of tuples. Each tuple shows
(deadline, profit).</li>
<li><strong>Sorting</strong>: We sort the jobs by profit from highest to
lowest.</li>
<li><strong>Job Scheduling</strong>: The nested loop looks for the
latest open spot (up to the jobâ€™s deadline). It marks the spot as filled
if we schedule a job.</li>
<li><strong>Profit Calculation</strong>: In the end, we add up the
profits of the jobs we scheduled and return the maximum profit.</li>
</ul>
<p>Using this optimized approach with memoization helps us explore job
scheduling options better. This is very useful when we deal with bigger
datasets. For more learning about dynamic programming, you can check out
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming with Fibonacci</a>.</p>
<h2
id="dynamic-programming-approach-for-maximum-profit-in-job-scheduling-in-java">Dynamic
Programming Approach for Maximum Profit in Job Scheduling in Java</h2>
<p>In this section, we look at the dynamic programming method to solve
the Maximum Profit in Job Scheduling problem using Java. The problem is
like this: we have a list of jobs. Each job has a start time, finish
time, and profit. We want to schedule jobs so that no two jobs overlap.
Also, we want to make the total profit as high as possible.</p>
<h3 id="problem-representation">Problem Representation</h3>
<p>We can show each job like this:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Job <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> finish<span class="op">;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> profit<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="fu">Job</span><span class="op">(</span><span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> finish<span class="op">,</span> <span class="dt">int</span> profit<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">start</span> <span class="op">=</span> start<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">finish</span> <span class="op">=</span> finish<span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="kw">this</span><span class="op">.</span><span class="fu">profit</span> <span class="op">=</span> profit<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><strong>Sort Jobs</strong>: First, we sort the jobs based on their
finish times.</li>
<li><strong>Define DP Array</strong>: We use a dynamic programming array
<code>dp[]</code>. Here, <code>dp[i]</code> shows the maximum profit we
can get by looking at jobs up to the i-th job.</li>
<li><strong>Recurrence Relation</strong>: For every job, we calculate
the maximum profit. We can either include the job or not:
<ul>
<li>If we include the current job, we add its profit to the maximum
profit of the last job that does not overlap.</li>
<li>If we do not include the current job, we take the maximum profit
from the previous job.</li>
</ul></li>
<li><strong>Implementation</strong>:</li>
</ol>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Comparator</span><span class="op">;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> JobScheduling <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxProfit</span><span class="op">(</span>Job<span class="op">[]</span> jobs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>jobs<span class="op">,</span> <span class="bu">Comparator</span><span class="op">.</span><span class="fu">comparingInt</span><span class="op">(</span>job <span class="op">-&gt;</span> job<span class="op">.</span><span class="fu">finish</span><span class="op">));</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> jobs<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> jobs<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">profit</span><span class="op">;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> inclProfit <span class="op">=</span> jobs<span class="op">[</span>i<span class="op">].</span><span class="fu">profit</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> l <span class="op">=</span> <span class="fu">latestNonConflict</span><span class="op">(</span>jobs<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>l <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                inclProfit <span class="op">+=</span> dp<span class="op">[</span>l<span class="op">];</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>inclProfit<span class="op">,</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">latestNonConflict</span><span class="op">(</span>Job<span class="op">[]</span> jobs<span class="op">,</span> <span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>jobs<span class="op">[</span>j<span class="op">].</span><span class="fu">finish</span> <span class="op">&lt;=</span> jobs<span class="op">[</span>i<span class="op">].</span><span class="fu">start</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                <span class="cf">return</span> j<span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>        Job<span class="op">[]</span> jobs <span class="op">=</span> <span class="op">{</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">Job</span><span class="op">(</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">50</span><span class="op">),</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">Job</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">20</span><span class="op">),</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">Job</span><span class="op">(</span><span class="dv">6</span><span class="op">,</span> <span class="dv">19</span><span class="op">,</span> <span class="dv">100</span><span class="op">),</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>            <span class="kw">new</span> <span class="fu">Job</span><span class="op">(</span><span class="dv">2</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">200</span><span class="op">)</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxProfit <span class="op">=</span> <span class="fu">maxProfit</span><span class="op">(</span>jobs<span class="op">);</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum Profit: &quot;</span> <span class="op">+</span> maxProfit<span class="op">);</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Sorting</strong>: We sort the jobs based on their finish
times using <code>Arrays.sort()</code>.</li>
<li><strong>Dynamic Programming Array</strong>: We start the
<code>dp</code> array and calculate profits in a loop.</li>
<li><strong>Finding Non-Conflicting Job</strong>: The method
<code>latestNonConflict</code> finds the last job that ends before the
current job starts. This way, we make sure there is no overlap.</li>
<li><strong>Output</strong>: We print the maximum profit to the
console.</li>
</ul>
<p>This Java code works well to find the maximum profit from job
scheduling with dynamic programming. If you want to read more about
similar dynamic programming problems, you can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="dynamic-programming-approach-for-maximum-profit-in-job-scheduling-in-python">Dynamic
Programming Approach for Maximum Profit in Job Scheduling in Python</h2>
<p>We can solve the problem of getting maximum profit in job scheduling
using a dynamic programming method. In this problem, we have a list of
jobs. Each job has a start time, finish time, and profit. Our goal is to
find the maximum profit we can get by scheduling jobs that do not
overlap.</p>
<h3 id="problem-definition-2">Problem Definition</h3>
<ul>
<li>We will have <code>jobs</code> as a list of tuples. Each tuple has
(start_time, finish_time, profit).</li>
<li>We need to pick jobs so that no two jobs overlap. We want to make
the total profit as high as possible.</li>
</ul>
<h3 id="dynamic-programming-solution-in-python">Dynamic Programming
Solution in Python</h3>
<ol type="1">
<li><strong>Sort the Jobs</strong>: First, we sort jobs by their finish
time.</li>
<li><strong>Create a DP Array</strong>: We make a DP array where
<code>dp[i]</code> shows the maximum profit we can get by looking at the
first <code>i</code> jobs.</li>
<li><strong>Binary Search for Previous Job</strong>: For each job, we
will find the last job that does not overlap using binary search.</li>
<li><strong>DP Transition</strong>: We update the DP array like this:
<ul>
<li>If we include the current job, profit is
<code>profit[i] + dp[last_non_conflicting_job]</code>.</li>
<li>If we do not include it, profit is <code>dp[i-1]</code>.</li>
</ul></li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Job:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, start, finish, profit):</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.start <span class="op">=</span> start</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.finish <span class="op">=</span> finish</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.profit <span class="op">=</span> profit</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_last_non_conflicting(jobs, n):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> jobs[j].finish <span class="op">&lt;=</span> jobs[n].start:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> j</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_profit(jobs):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort jobs based on finish time</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    jobs.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x.finish)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(jobs)</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> jobs[<span class="dv">0</span>].profit</span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>        include_profit <span class="op">=</span> jobs[i].profit</span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>        l <span class="op">=</span> find_last_non_conflicting(jobs, i)</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> l <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>            include_profit <span class="op">+=</span> dp[l]</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(include_profit, dp[i <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>jobs <span class="op">=</span> [</span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>    Job(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">50</span>),</span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a>    Job(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">20</span>),</span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>    Job(<span class="dv">6</span>, <span class="dv">19</span>, <span class="dv">100</span>),</span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    Job(<span class="dv">2</span>, <span class="dv">100</span>, <span class="dv">200</span>)</span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Maximum Profit in Job Scheduling is:&quot;</span>, max_profit(jobs))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Job Class</strong>: This class represents a job. It has
start time, finish time, and profit.</li>
<li><strong>find_last_non_conflicting</strong>: This function finds the
last job that does not overlap with the current job and returns its
index.</li>
<li><strong>max_profit</strong>: This function uses the dynamic
programming method. It calculates the maximum profit by going through
the sorted jobs and using the DP array to track the maximum
profits.</li>
</ul>
<p>This method finds the maximum profit in job scheduling very well. It
has a time complexity of <code>O(n log n)</code> because of sorting.
Filling the DP array takes <code>O(n)</code>, so the total complexity is
<code>O(n log n)</code>.</p>
<p>For more related dynamic programming problems, we can look at
articles about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack Problem</a>.</p>
<h2
id="dynamic-programming-approach-for-maximum-profit-in-job-scheduling-in-c">Dynamic
Programming Approach for Maximum Profit in Job Scheduling in C++</h2>
<p>To solve the Job Scheduling problem with a Dynamic Programming method
in C++, we need to understand the problem well. We have a list of jobs.
Each job has a start time, finish time, and profit. Our goal is to
choose jobs that do not overlap and get the highest total profit.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">struct</span> Job <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> start<span class="op">,</span> finish<span class="op">,</span> profit<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to sort jobs by finish time</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="dt">bool</span> jobComparison<span class="op">(</span>Job s1<span class="op">,</span> Job s2<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>s1<span class="op">.</span>finish <span class="op">&lt;</span> s2<span class="op">.</span>finish<span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to find the last job that does not overlap with the current job</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> findLastNonConflictingJob<span class="op">(</span>vector<span class="op">&lt;</span>Job<span class="op">&gt;&amp;</span> jobs<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>jobs<span class="op">[</span>j<span class="op">].</span>finish <span class="op">&lt;=</span> jobs<span class="op">[</span>n<span class="op">].</span>start<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> j<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co">// Dynamic Programming function to find maximum profit</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> jobScheduling<span class="op">(</span>vector<span class="op">&lt;</span>Job<span class="op">&gt;&amp;</span> jobs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>jobs<span class="op">.</span>begin<span class="op">(),</span> jobs<span class="op">.</span>end<span class="op">(),</span> jobComparison<span class="op">);</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> jobs<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span> <span class="co">// dp[i] is max profit up to job i</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> jobs<span class="op">[</span><span class="dv">0</span><span class="op">].</span>profit<span class="op">;</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add profit of the current job</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> inclProfit <span class="op">=</span> jobs<span class="op">[</span>i<span class="op">].</span>profit<span class="op">;</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> l <span class="op">=</span> findLastNonConflictingJob<span class="op">(</span>jobs<span class="op">,</span> i<span class="op">);</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>l <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>            inclProfit <span class="op">+=</span> dp<span class="op">[</span>l<span class="op">];</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Save the maximum of including and not including the job</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>inclProfit<span class="op">,</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>Job<span class="op">&gt;</span> jobs <span class="op">=</span> <span class="op">{</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">50</span><span class="op">},</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">20</span><span class="op">},</span> <span class="op">{</span><span class="dv">6</span><span class="op">,</span> <span class="dv">19</span><span class="op">,</span> <span class="dv">100</span><span class="op">},</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">100</span><span class="op">,</span> <span class="dv">200</span><span class="op">}</span> <span class="op">};</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxProfit <span class="op">=</span> jobScheduling<span class="op">(</span>jobs<span class="op">);</span></span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Profit in Job Scheduling: &quot;</span> <span class="op">&lt;&lt;</span> maxProfit <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-53"><a href="#cb6-53" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ol type="1">
<li><strong>Job Struct</strong>: This shows each job with its start
time, finish time, and profit.</li>
<li><strong>jobComparison Function</strong>: This sorts jobs by their
finish times. It helps us pick jobs that do not overlap.</li>
<li><strong>findLastNonConflictingJob Function</strong>: This finds the
last job that does not conflict with the current job.</li>
<li><strong>jobScheduling Function</strong>: This uses Dynamic
Programming to calculate the maximum profit. It keeps a <code>dp</code>
array where <code>dp[i]</code> is the maximum profit up to job
<code>i</code>.</li>
<li><strong>Main Function</strong>: This sets up a list of jobs, calls
the job scheduling function, and shows the maximum profit.</li>
</ol>
<p>This way to solve the Job Scheduling problem using Dynamic
Programming helps us to avoid overlapping jobs while getting the most
profit. For more info about dynamic programming methods, you can check
this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming - Coin Change</a>.</p>
<h2
id="comparing-different-approaches-for-job-scheduling-problem">Comparing
Different Approaches for Job Scheduling Problem</h2>
<p>In job scheduling problems, especially to get the most profit, we can
use different methods. Each method works differently. Some are more
complex and take longer to run. Here, we will compare three main
methods: Brute Force, Optimized Recursive, and Dynamic Programming.</p>
<h3 id="brute-force-approach">1. Brute Force Approach</h3>
<ul>
<li><strong>Description</strong>: This method checks every possible
combination of jobs to find the maximum profit. It takes a lot of time,
especially with larger datasets.</li>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li><strong>Example</strong>: For jobs that have different start and end
times, we look at all combinations.</li>
</ul>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxProfitBruteForce(jobs):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate all subsets of jobs and calculate profits</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Implementation omitted for brevity</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_profit</span></code></pre></div>
<h3 id="optimized-recursive-approach">2. Optimized Recursive
Approach</h3>
<ul>
<li><strong>Description</strong>: This method uses recursion and
memoization. This helps to avoid doing the same calculations again. It
is better than brute force because it saves results of smaller
problems.</li>
<li><strong>Time Complexity</strong>: O(n log n) for sorting jobs, O(n)
for recursion</li>
<li><strong>Example</strong>: After we sort jobs by their finish time,
we use recursion to find the maximum profit.</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> findLastNonConflictingJob(jobs, n):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Implementation to find the last non-conflicting job</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> index</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxProfitOptimizedRecursion(jobs):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort jobs and use recursion with memoization</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_profit</span></code></pre></div>
<h3 id="dynamic-programming-approach">3. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Description</strong>: This method builds a table from the
bottom up. It saves the maximum profit for each job. It combines results
from smaller problems.</li>
<li><strong>Time Complexity</strong>: O(n log n) for sorting jobs, O(n)
for filling DP table</li>
<li><strong>Example</strong>: We create a DP array. Each part of the
array holds the maximum profit up to that job.</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">jobScheduling</span><span class="op">(</span>Job<span class="op">[]</span> jobs<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>jobs<span class="op">,</span> <span class="op">(</span>a<span class="op">,</span> b<span class="op">)</span> <span class="op">-&gt;</span> a<span class="op">.</span><span class="fu">end</span> <span class="op">-</span> b<span class="op">.</span><span class="fu">end</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>jobs<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> jobs<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">profit</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> jobs<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate max profit including or excluding the current job</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">],</span> jobs<span class="op">[</span>i<span class="op">].</span><span class="fu">profit</span> <span class="op">+</span> <span class="fu">findLastNonConflictingJob</span><span class="op">(</span>jobs<span class="op">,</span> i<span class="op">));</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>jobs<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comparison-summary">Comparison Summary</h3>
<ul>
<li><strong>Brute Force</strong>: Simple but not good for large
datasets.</li>
<li><strong>Optimized Recursive</strong>: Faster than brute force but
has some overhead.</li>
<li><strong>Dynamic Programming</strong>: Best in terms of time and
works well for larger datasets.</li>
</ul>
<p>Each method has its own use depending on the needs of the job
scheduling problem. For more information on dynamic programming, we can
look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming methods for the Fibonacci sequence</a> and other related
algorithms in the links above.</p>
<h2 id="complexity-analysis-of-job-scheduling-solutions">Complexity
Analysis of Job Scheduling Solutions</h2>
<p>We look at the complexity of job scheduling solutions. We focus on
finding the maximum profit in job scheduling. We will evaluate the time
and space complexity of different methods: brute force, optimized
recursive, and dynamic programming.</p>
<h3 id="brute-force-approach-1">Brute Force Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n) where n is the number of
jobs. We explore all job combinations to find the maximum profit.</li>
<li><strong>Space Complexity</strong>: O(1) because we only need a small
amount of space to keep profits and job numbers.</li>
</ul>
<h3 id="optimized-recursive-solution">Optimized Recursive Solution</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n log n) because we need to sort
the jobs by their finish times. Then we use binary search to find the
last job that does not conflict.</li>
<li><strong>Space Complexity</strong>: O(n) for the recursion
stack.</li>
</ul>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2) since we may check all
previous jobs for each job to find the best solution.</li>
<li><strong>Space Complexity</strong>: O(n) to keep the maximum profit
for the first i jobs in a DP array.</li>
</ul>
<h3 id="summary-of-complexity">Summary of Complexity</h3>
<ol type="1">
<li><strong>Brute Force</strong>: O(2^n) time, O(1) space.</li>
<li><strong>Optimized Recursive</strong>: O(n log n) time, O(n)
space.</li>
<li><strong>Dynamic Programming</strong>: O(n^2) time, O(n) space.</li>
</ol>
<p>This analysis helps us choose the best method based on needs and
limits for getting the maximum profit in job scheduling problems. For
more understanding, we can check related dynamic programming topics like
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0-1
Knapsack Problem</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray Problem</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-job-scheduling-problem-in-dynamic-programming">What
is the Job Scheduling Problem in Dynamic Programming?</h3>
<p>The Job Scheduling Problem is a well-known problem. Our goal is to
get the most profit from a group of jobs that have specific start and
finish times. Each job has a profit. The challenge is to pick jobs that
do not overlap in time. This way, we can achieve the highest total
profit. Dynamic programming helps us solve this problem well. It breaks
the problem into smaller parts. This way, we do not have to do extra
calculations.</p>
<h3
id="how-does-the-dynamic-programming-approach-work-for-job-scheduling">How
does the Dynamic Programming approach work for Job Scheduling?</h3>
<p>The Dynamic Programming approach for the Job Scheduling Problem
creates a way to show the maximum profit we can get up to each job. We
sort the jobs by their finish times. Then, we use a binary search to
find the last job that does not conflict with the current job. With
this, we can make a DP table. This table helps us find the maximum
profit while making sure jobs do not overlap.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-job-scheduling">What
is the time complexity of the Dynamic Programming solution for Job
Scheduling?</h3>
<p>The time complexity of the Dynamic Programming solution for the Job
Scheduling Problem is O(n log n). We first sort the jobs based on their
finish times. This takes O(n log n). Then, we fill the DP table. We use
binary search to find the last job that does not conflict for each job.
This also takes O(n log n) in the worst case.</p>
<h3
id="can-you-explain-the-difference-between-the-brute-force-and-dynamic-programming-approaches">Can
you explain the difference between the Brute Force and Dynamic
Programming approaches?</h3>
<p>The Brute Force approach for the Job Scheduling Problem tries all
possible combinations of jobs to find the maximum profit. This takes a
lot of time, with a complexity of O(2^n). On the other hand, the Dynamic
Programming approach uses optimal substructure and overlapping
subproblems. It builds a solution step by step. This makes it faster
with a complexity of O(n log n). So, it is better for larger
datasets.</p>
<h3
id="are-there-any-related-problems-that-can-be-solved-using-dynamic-programming-techniques">Are
there any related problems that can be solved using Dynamic Programming
techniques?</h3>
<p>Yes, many problems can be solved with Dynamic Programming techniques
like the Job Scheduling Problem. For example, we can look at the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">0/1
Knapsack Problem</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray Sum</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>. These problems use the same ideas of
optimizing choices under limits. They also break down into smaller
problems and use results we already have to be more efficient.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            