
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Min Cost Climbing Stairs - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to solve the Min Cost Climbing Stairs problem using dynamic programming. Easy steps and clear examples await!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Min Cost Climbing Stairs - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <h3 id="min-cost-climbing-stairs-problem">Min Cost Climbing Stairs
Problem</h3>
<p>The Min Cost Climbing Stairs problem is a well-known dynamic
programming challenge. It asks us to find the lowest cost to reach the
top of a staircase. Each step has its own cost. Our goal is to find the
cheapest way to the top. We can step one or two stairs at a time. We can
solve this problem using dynamic programming techniques. By breaking the
problem into smaller parts, we can find a solution that lowers the total
cost.</p>
<p>In this article, we will look closely at the Min Cost Climbing Stairs
problem. We will talk about the problem statement. We will also discuss
the dynamic programming method for solving it. Additionally, we will
explain how to write the solution in Java, Python, and C++. We will talk
about some possible optimizations. We will also compare different ways
to solve this problem. Lastly, we will answer some common questions
about the Min Cost Climbing Stairs problem.</p>
<p>Here are the topics we will cover:</p>
<ul>
<li>Dynamic Programming Min Cost Climbing Stairs Solution Overview</li>
<li>Understanding the Problem Statement for Min Cost Climbing
Stairs</li>
<li>Dynamic Programming Approach for Min Cost Climbing Stairs</li>
<li>Java Implementation of Min Cost Climbing Stairs</li>
<li>Python Implementation of Min Cost Climbing Stairs</li>
<li>C++ Implementation of Min Cost Climbing Stairs</li>
<li>Optimizations in Min Cost Climbing Stairs Solutions</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to read more, you can check these articles on similar
dynamic programming topics: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming Fibonacci with Memoization</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2
id="understanding-the-problem-statement-for-min-cost-climbing-stairs">Understanding
the Problem Statement for Min Cost Climbing Stairs</h2>
<p>The Min Cost Climbing Stairs problem is about finding the least cost
to get to the top of a staircase. Each step has a cost. We can start at
step 0 or step 1. We can climb one or two steps at a time. The main goal
is to reach the top with the smallest total cost.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: We have an array <code>cost</code>. Each
<code>cost[i]</code> shows the cost of stepping on step
<code>i</code>.</li>
<li><strong>Output</strong>: We need to find the minimum cost to get to
step <code>n</code>. Here, <code>n</code> is the total number of
steps.</li>
</ul>
<h3 id="example">Example</h3>
<p>For <code>cost = [10, 15, 20]</code>, the costs to climb the stairs
are: - If we start at step 0 (cost 10) and jump to step 2 (cost 20), the
total cost is 10 + 20 = 30. - If we start at step 1 (cost 15) and jump
to step 2 (cost 20), the total cost is 15 + 20 = 35.</p>
<p>The least total cost to reach the top is 30.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The <code>cost</code> array has a length between 2 and 1000.</li>
<li>Each cost value is a non-negative whole number.</li>
</ul>
<p>This problem shows how we can use dynamic programming. It helps us
find the minimum cost without repeating calculations. By breaking the
problem into smaller parts, we can build the solution step by step or
use recursion with memoization. For more about dynamic programming,
check this <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs article</a>.</p>
<h2
id="dynamic-programming-approach-for-min-cost-climbing-stairs">Dynamic
Programming Approach for Min Cost Climbing Stairs</h2>
<p>We can solve the Min Cost Climbing Stairs problem well using a
dynamic programming method. The aim is to find the lowest cost to reach
the top of the stairs. We can take either one or two steps at a
time.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ul>
<li><p>We have an array <code>cost</code>. Here, <code>cost[i]</code>
shows the cost of stepping on the <code>i-th</code> step.</p></li>
<li><p>We can start at step 0 or step 1.</p></li>
<li><p>We can say that the minimum cost to reach step <code>i</code>
is:</p>
<p>[ dp[i] = cost[i] + (dp[i-1], dp[i-2]) ]</p></li>
<li><p>The base cases are:</p>
<ul>
<li><code>dp[0] = cost[0]</code></li>
<li><code>dp[1] = cost[1]</code></li>
</ul></li>
</ul>
<h3 id="dynamic-programming-implementation">Dynamic Programming
Implementation</h3>
<p>The dynamic programming way needs us to fill an array
<code>dp</code>. In this array, <code>dp[i]</code> will keep the minimum
cost to reach step <code>i</code>.</p>
<h4 id="java-implementation">Java Implementation</h4>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinCostClimbingStairs <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minCostClimbingStairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python-implementation">Python Implementation</h4>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_cost_climbing_stairs(cost):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cost)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> cost[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="bu">min</span>(dp[i <span class="op">-</span> <span class="dv">1</span>], dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h4 id="c-implementation">C++ Implementation</h4>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minCostClimbingStairs<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> min<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="space-optimization">Space Optimization</h3>
<p>We can save space by not keeping a full <code>dp</code> array. We
only need the last two costs because the current cost depends only on
the last two steps.</p>
<h4 id="optimized-java-implementation">Optimized Java
Implementation</h4>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinCostClimbingStairs <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minCostClimbingStairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> cost<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>first<span class="op">,</span> second<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="optimized-python-implementation">Optimized Python
Implementation</h4>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> min_cost_climbing_stairs(cost):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    first, second <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(cost) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> cost[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="bu">min</span>(first, second)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> second, current</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second</span></code></pre></div>
<h4 id="optimized-c-implementation">Optimized C++ Implementation</h4>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minCostClimbingStairs<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> first <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> cost<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> min<span class="op">(</span>first<span class="op">,</span> second<span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>With this dynamic programming method, we can find the minimum cost to
climb the stairs. Also, we reduce space use from O(n) to O(1). For more
related information, you can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="java-implementation-of-min-cost-climbing-stairs">Java
Implementation of Min Cost Climbing Stairs</h2>
<p>We can solve the Min Cost Climbing Stairs problem in Java with a
simple method called dynamic programming. Our goal is to find the lowest
cost to reach the top of the stairs. Each step has a cost.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<p>Here is a simple Java code:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinCostClimbingStairs <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minCostClimbingStairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// DP array to store min cost at each step</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base cases</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Starting point</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Cost to reach the first step</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP array</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">==</span> n <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]),</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">==</span> n <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]));</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span> <span class="co">// Minimum cost to reach the top</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        MinCostClimbingStairs solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MinCostClimbingStairs</span><span class="op">();</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> cost <span class="op">=</span> <span class="op">{</span><span class="dv">10</span><span class="op">,</span> <span class="dv">15</span><span class="op">,</span> <span class="dv">20</span><span class="op">};</span> <span class="co">// Example costs</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> solution<span class="op">.</span><span class="fu">minCostClimbingStairs</span><span class="op">(</span>cost<span class="op">);</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum cost to climb stairs: &quot;</span> <span class="op">+</span> result<span class="op">);</span> <span class="co">// Output: 15</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Dynamic Programming Array (dp)</strong>: We make an array
called <code>dp</code>. Here, <code>dp[i]</code> shows the minimum cost
to get to step <code>i</code>.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>We set <code>dp[0]</code> to 0. There is no cost to start.</li>
<li>We set <code>dp[1]</code> to <code>cost[0]</code>, which is the cost
of the first step.</li>
</ul></li>
<li><strong>Filling the DP Array</strong>: For each step from 2 to
<code>n</code>, we find the lowest cost to reach that step. We check the
two steps before it. We can come from the step right below or the step
before that.</li>
<li><strong>Return Value</strong>: In the end, we return
<code>dp[n]</code>. This gives us the minimum cost to reach the
top.</li>
</ul>
<p>This method works well. It has a time complexity of O(n) and space
complexity of O(n).</p>
<p>For more details on dynamic programming, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a> article.</p>
<h2 id="python-implementation-of-min-cost-climbing-stairs">Python
Implementation of Min Cost Climbing Stairs</h2>
<p>We can solve the Min Cost Climbing Stairs problem using Python with a
simple method called dynamic programming. Our goal is to find the least
cost to get to the top of the stairs. We can climb each step from the
step before it or the step before that. The cost for each step is in an
array.</p>
<p>Here is a simple Python code example:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minCostClimbingStairs(cost):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cost)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cost[<span class="dv">0</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a dp array to store the minimum cost to reach each step</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> cost[<span class="dv">0</span>]</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> cost[<span class="dv">1</span>]</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> cost[i] <span class="op">+</span> <span class="bu">min</span>(dp[i <span class="op">-</span> <span class="dv">1</span>], dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The result is the minimum cost to reach the top</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">min</span>(dp[n <span class="op">-</span> <span class="dv">1</span>], dp[n <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>cost <span class="op">=</span> [<span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">20</span>]</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minCostClimbingStairs(cost))  <span class="co"># Output: 15</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>First, we check if there are steps. If there are no steps, the cost
is 0. If there is one step, the cost is just the cost of that step.</li>
<li>We start a dynamic programming array called <code>dp</code> to save
the minimum cost for each step.</li>
<li>The loop fills the <code>dp</code> array by finding the least cost
to reach each step using the last two steps.</li>
<li>At the end, we look at the last two numbers in the <code>dp</code>
array to find the least cost to reach the top.</li>
</ul>
<p>This code works well to solve the Min Cost Climbing Stairs problem in
O(n) time complexity and O(n) space complexity.</p>
<p>For more about dynamic programming ideas, we can check this link <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs - Easy</a>.</p>
<h2 id="c-implementation-of-min-cost-climbing-stairs">C++ Implementation
of Min Cost Climbing Stairs</h2>
<p>To solve the Min Cost Climbing Stairs problem with C++, we use a
simple method called dynamic programming. This problem asks us to find
the lowest cost to reach the top of a staircase. Each step has a cost.
We can take one or two steps at once.</p>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<p>Here is the C++ code for the Min Cost Climbing Stairs method:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minCostClimbingStairs<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> cost<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Starting before the first step</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> cost<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Cost to reach the first step</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>min<span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">==</span> n <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]),</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>i <span class="op">==</span> n <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]));</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a vector called
<code>dp</code>. Here, <code>dp[i]</code> shows the minimum cost to get
to the i-th step.</li>
<li><strong>Base Cases</strong>:
<ul>
<li><code>dp[0]</code> is 0. There is no cost to stand before the first
step.</li>
<li><code>dp[1]</code> is the cost of the first step.</li>
</ul></li>
<li><strong>Dynamic Programming Transition</strong>:
<ul>
<li>For each step from 2 to n, we find the minimum cost to reach that
step. We look at the costs from the last one and two steps.</li>
</ul></li>
<li><strong>Final Result</strong>: The lowest cost to reach the top of
the stairs is in <code>dp[n]</code>.</li>
</ul>
<p>This method works in O(n) time and O(n) space. Here n is the number
of steps in the staircase.</p>
<p>You can also read related articles to understand more, like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">dynamic
programming approach for climbing stairs</a>.</p>
<h2
id="optimizations-in-min-cost-climbing-stairs-solutions">Optimizations
in Min Cost Climbing Stairs Solutions</h2>
<p>We can make the Min Cost Climbing Stairs problem better in many ways.
This helps us improve performance and save space. Here are some good
optimizations:</p>
<ol type="1">
<li><p><strong>Space Optimization</strong>:<br />
We do not need an array to keep all step costs. We just need to remember
the last two steps. The cost of the current step only depends on the
last two steps.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minCostClimbingStairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>first <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> second <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minCostClimbingStairs(cost):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    first, second <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(cost) <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> <span class="bu">min</span>(first <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">1</span>], second <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        first, second <span class="op">=</span> second, current</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second</span></code></pre></div>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minCostClimbingStairs<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> second <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> cost<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> min<span class="op">(</span>first <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> second <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        first <span class="op">=</span> second<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        second <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> second<span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Using Dynamic Programming with
Memoization</strong>:<br />
If we like a top-down way, we can use memoization. This means we save
the results of smaller problems so we do not need to calculate them
again.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minCostClimbingStairs(cost):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(i):</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">not</span> <span class="kw">in</span> memo:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            memo[i] <span class="op">=</span> <span class="bu">min</span>(dp(i <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">1</span>], dp(i <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[i]</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(<span class="bu">len</span>(cost))</span></code></pre></div></li>
<li><p><strong>Iterative Tabulation</strong>:<br />
Instead of keeping a whole DP array, we can use less space with
iterative tabulation. We can do this just like we showed above.</p></li>
<li><p><strong>Early Exit</strong>:<br />
If the cost array is shorter than 2, we should return the smaller of the
first cost or 0. This way we avoid doing extra calculations.</p></li>
<li><p><strong>Tailoring Input</strong>:<br />
We can change the cost array to remove high costs or make it simpler.
This helps make the algorithm work better.</p></li>
</ol>
<p>These optimizations help a lot in making the space and time
complexity better for the Min Cost Climbing Stairs problem. We can find
efficient solutions even for larger inputs. For more about dynamic
programming methods, we can read <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we try to solve the Min Cost Climbing Stairs problem, we have
several ways to do it. Here, we will compare the dynamic programming
method with other common methods like recursion and memoization.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<p>We find that the dynamic programming approach works best for this
problem. It builds solutions step by step. It uses results from previous
steps to solve bigger parts of the problem.</p>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) (but we can make it
O(1))</li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minCostClimbingStairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> cost<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> cost<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="memoization-approach">2. Memoization Approach</h3>
<p>Memoization improves the simple recursive method. It keeps results we
already calculated. This way, we do not do the same work again.</p>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n)</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minCostClimbingStairs(cost):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(cost)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(i):</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;=</span> <span class="dv">1</span>:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memo[i] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[i]</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>        memo[i] <span class="op">=</span> <span class="bu">min</span>(dp(i <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">1</span>], dp(i <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> cost[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[i]</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(n)</span></code></pre></div>
<h3 id="recursive-approach">3. Recursive Approach</h3>
<p>The simple recursive approach calculates the minimum cost directly.
It does not save any results. This leads to a lot of repeated work and
makes it slow.</p>
<ul>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li><strong>Space Complexity</strong>: O(n) (due to call stack)</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minCostClimbingStairs<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min<span class="op">(</span>minCost<span class="op">(</span>cost<span class="op">,</span> cost<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> minCost<span class="op">(</span>cost<span class="op">,</span> cost<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minCost<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> cost<span class="op">,</span> <span class="dt">int</span> i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> cost<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> min<span class="op">(</span>minCost<span class="op">(</span>cost<span class="op">,</span> i <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> minCost<span class="op">(</span>cost<span class="op">,</span> i <span class="op">-</span> <span class="dv">2</span><span class="op">));</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comparison-summary">Comparison Summary</h3>
<ul>
<li><strong>Dynamic Programming</strong>: This is the best choice for
being fast and clear. Iterative DP also uses less space.</li>
<li><strong>Memoization</strong>: This helps for a recursive solution
but still uses extra space for results.</li>
<li><strong>Recursive</strong>: This method is easy to understand but
not good for big inputs because it is slow.</li>
</ul>
<p>If we want to learn more about dynamic programming, we can check out
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-min-cost-climbing-stairs-problem-in-dynamic-programming">1.
What is the Min Cost Climbing Stairs problem in dynamic
programming?</h3>
<p>The Min Cost Climbing Stairs problem is a well-known challenge in
dynamic programming. We need to find the smallest cost to reach the top
of a staircase. We can climb one or two steps at a time. Each step has a
cost. The aim is to find the cheapest way to get to the last step. This
problem helps us learn how to use dynamic programming.</p>
<h3
id="how-does-dynamic-programming-help-in-solving-the-min-cost-climbing-stairs-problem">2.
How does dynamic programming help in solving the Min Cost Climbing
Stairs problem?</h3>
<p>Dynamic programming is useful for the Min Cost Climbing Stairs
problem. It breaks the problem into smaller parts. We store results to
avoid doing the same calculations again. We use an array to keep track
of the minimum costs to reach each step. This makes the solution faster.
If we want to learn more about dynamic programming, we can read the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs article</a>.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-min-cost-climbing-stairs">3.
What is the time complexity of the dynamic programming solution for Min
Cost Climbing Stairs?</h3>
<p>The time complexity of the dynamic programming solution for the Min
Cost Climbing Stairs problem is O(n). Here, n is the number of steps.
This is efficient because we calculate the minimum cost for each step
only once. We store these results in an array. This is better than a
simple recursive method that can take a lot of time because it does many
repeated calculations.</p>
<h3
id="can-the-min-cost-climbing-stairs-problem-be-solved-using-memoization">4.
Can the Min Cost Climbing Stairs problem be solved using
memoization?</h3>
<p>Yes, we can solve the Min Cost Climbing Stairs problem using
memoization. This is a method that saves the results of expensive
function calls. When the same inputs come again, it gives back the saved
result. This way, we reduce the time it takes to solve the problem. It
is more efficient than just using recursion. If you want to know more
about memoization, you can read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming Fibonacci with Memoization</a>.</p>
<h3
id="what-programming-languages-are-commonly-used-for-implementing-min-cost-climbing-stairs-solutions">5.
What programming languages are commonly used for implementing Min Cost
Climbing Stairs solutions?</h3>
<p>We can implement the Min Cost Climbing Stairs problem in many
programming languages. Some common ones are Java, Python, and C++. Each
language has its own syntax and features. This allows us to pick the one
we like best. The article shows complete implementations in these
languages. This way, we can follow along and change the solution to fit
what we need.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            