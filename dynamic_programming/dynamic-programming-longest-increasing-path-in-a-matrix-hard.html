
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Increasing Path in a Matrix - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover the Longest Increasing Path in a Matrix with our dynamic programming guide. Master this challenging algorithm today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Increasing Path in a Matrix - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Increasing Path in a Matrix is a tough problem. It is
about finding the longest path in a matrix. Each step must go to a
nearby cell with a higher value. We can solve this problem well using
simple methods from dynamic programming. These methods include
memoization and topological sorting. The best solution helps us move
through the matrix so we can make the increasing path as long as
possible while staying within the matrix limits.</p>
<p>In this article, we will look into the Longest Increasing Path
problem. We will explore different ways to find good solutions. We will
talk about the dynamic programming method in Java, Python, and C++. We
will also discuss memoization techniques and topological sorting. We
will check how well these solutions perform and answer common questions
about the problem.</p>
<ul>
<li>[Dynamic Programming] Longest Increasing Path in a Matrix - Optimal
Solutions</li>
<li>Understanding the Longest Increasing Path Problem</li>
<li>Dynamic Programming Approach in Java</li>
<li>Dynamic Programming Approach in Python</li>
<li>Dynamic Programming Approach in C++</li>
<li>Memoization Technique for Longest Increasing Path in a Matrix</li>
<li>Topological Sorting Method for Longest Increasing Path</li>
<li>Iterative Approach for Longest Increasing Path in a Matrix</li>
<li>Performance Analysis of Longest Increasing Path Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-longest-increasing-path-problem">Understanding
the Longest Increasing Path Problem</h2>
<p>The Longest Increasing Path (LIP) problem is about finding the
longest path in a matrix. We can move through nearby cells, which means
we can go up, down, left, or right. Each cell we visit must have a
number that is bigger than the number in the last cell we visited. Our
goal is to find out how long this path can be.</p>
<h3 id="key-properties">Key Properties</h3>
<ul>
<li><strong>Matrix Dimensions</strong>: We have a 2D matrix with integer
numbers.</li>
<li><strong>Path Constraints</strong>: We can only move to nearby cells
with bigger numbers.</li>
<li><strong>Return Value</strong>: We need to return the length of the
longest increasing path.</li>
</ul>
<h3 id="example">Example</h3>
<p>Look at this matrix:</p>
<pre><code>[
  [9, 9, 4],
  [6, 6, 8],
  [2, 1, 1]
]</code></pre>
<p>Here, the longest increasing path is
<code>1 -&gt; 2 -&gt; 6 -&gt; 8</code>. This path has a length of 4.</p>
<h3 id="problem-complexity">Problem Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: The simple way to solve this is
O(2^(m*n)). This happens because there are many paths in the worst
case.</li>
<li><strong>Space Complexity</strong>: We need O(m*n) space to keep
track of the longest path length for each cell.</li>
</ul>
<h3 id="applications">Applications</h3>
<ul>
<li><strong>Grid-based Pathfinding</strong>: This problem helps in grid
games and other tasks that need path optimization.</li>
<li><strong>Data Analysis</strong>: We can use this in cases where we
look at data over time and want to find increasing trends.</li>
</ul>
<p>This problem is great for using dynamic programming and other methods
to get the answer faster. If you want a fast solution, we can check out
dynamic programming methods in Java, Python, and C++ sections.</p>
<h2 id="dynamic-programming-approach-in-java">Dynamic Programming
Approach in Java</h2>
<p>We can solve the Longest Increasing Path in a Matrix problem using
dynamic programming in Java. We will use a depth-first search (DFS)
method with memoization. This way, we can find the longest path without
doing the same work again.</p>
<h3 id="code-implementation">Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestIncreasingPath <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> rows<span class="op">,</span> cols<span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span><span class="op">[][]</span> memo<span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">longestIncreasingPath</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> matrix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        rows <span class="op">=</span> matrix<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        memo <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>rows<span class="op">][</span>cols<span class="op">];</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxPath <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                maxPath <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxPath<span class="op">,</span> <span class="fu">dfs</span><span class="op">(</span>matrix<span class="op">,</span> i<span class="op">,</span> j<span class="op">));</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxPath<span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">dfs</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> matrix<span class="op">,</span> <span class="dt">int</span> row<span class="op">,</span> <span class="dt">int</span> col<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>row<span class="op">][</span>col<span class="op">];</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// At least the cell itself</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> directions <span class="op">=</span> <span class="op">{{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">}};</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span><span class="op">[]</span> dir <span class="op">:</span> directions<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newRow <span class="op">=</span> row <span class="op">+</span> dir<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newCol <span class="op">=</span> col <span class="op">+</span> dir<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>newRow <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> newRow <span class="op">&lt;</span> rows <span class="op">&amp;&amp;</span> newCol <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> newCol <span class="op">&lt;</span> cols </span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">&amp;&amp;</span> matrix<span class="op">[</span>newRow<span class="op">][</span>newCol<span class="op">]</span> <span class="op">&gt;</span> matrix<span class="op">[</span>row<span class="op">][</span>col<span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>                maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> <span class="fu">dfs</span><span class="op">(</span>matrix<span class="op">,</span> newRow<span class="op">,</span> newCol<span class="op">));</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>row<span class="op">][</span>col<span class="op">]</span> <span class="op">=</span> maxLength<span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: In the
<code>longestIncreasingPath</code> method, we set up the size of the
matrix and the memoization array.</li>
<li><strong>DFS Function</strong>: The <code>dfs</code> method looks at
all four directions from each cell. If the next cell has a bigger
number, we keep searching.</li>
<li><strong>Memoization</strong>: We store the results of paths we
already calculated in the <code>memo</code> array. This stops us from
doing the same work many times and makes it faster.</li>
</ul>
<p>This way of doing it has a time complexity of O(m * n). Here, m is
the number of rows and n is the number of columns in the matrix. The
space complexity is also O(m * n) because of the memoization table.</p>
<p>By using this dynamic programming method, we can find the longest
increasing path in a matrix in Java very well. If you want to learn more
about dynamic programming, you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="dynamic-programming-approach-in-python">Dynamic Programming
Approach in Python</h2>
<p>We can solve the Longest Increasing Path in a Matrix problem using
dynamic programming in Python. We will use Depth-First Search (DFS) with
memoization. Our goal is to find the longest path of increasing values
starting from any cell in the matrix.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>DFS with Memoization</strong>: We will create a function
that checks all four directions (up, down, left, right) from the current
cell. We will save results of paths we already calculated to avoid doing
the same work again.</p></li>
<li><p><strong>Initialization</strong>: We need a table to store the
longest increasing paths for each cell. We will start by filling it with
<code>-1</code> to show that we have not calculated the path
yet.</p></li>
</ol>
<h3 id="python-code-example">Python Code Example</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longestIncreasingPath(matrix):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> matrix <span class="kw">or</span> <span class="kw">not</span> matrix[<span class="dv">0</span>]:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(r, c):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memo[r][c] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[r][c]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        longest <span class="op">=</span> <span class="dv">1</span>  <span class="co"># At least the current cell itself</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        directions <span class="op">=</span> [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)]  <span class="co"># Down, Up, Right, Left</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dr, dc <span class="kw">in</span> directions:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nr <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nc <span class="op">&lt;</span> cols <span class="kw">and</span> matrix[nr][nc] <span class="op">&gt;</span> matrix[r][c]:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                longest <span class="op">=</span> <span class="bu">max</span>(longest, <span class="dv">1</span> <span class="op">+</span> dfs(nr, nc))</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        memo[r][c] <span class="op">=</span> longest</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> longest</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    max_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            max_length <span class="op">=</span> <span class="bu">max</span>(max_length, dfs(r, c))</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_length</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> [</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">4</span>],</span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">8</span>],</span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>]</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(longestIncreasingPath(matrix))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Matrix Check</strong>: First, we check if the matrix is
empty.</li>
<li><strong>Memoization Table</strong>: We create a 2D list called
<code>memo</code> to store results for each cell.</li>
<li><strong>DFS Function</strong>: The <code>dfs</code> function does
the depth-first search. It checks all four directions and finds the
longest path.</li>
<li><strong>Result Calculation</strong>: We find the maximum length of
the increasing path by looking at each cell of the matrix and calling
the <code>dfs</code> function.</li>
</ul>
<p>This method helps us find the longest increasing path while reducing
work with memoization. For more on dynamic programming in Python, we can
check other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2 id="dynamic-programming-approach-in-c">Dynamic Programming Approach
in C++</h2>
<p>To solve Longest Increasing Path in a Matrix problem with Dynamic
Programming in C++, we can use depth-first search (DFS) with
memoization. We will go through each cell in the matrix. We calculate
the longest increasing path starting from that cell. We will save the
results of paths we already computed. This helps us avoid doing the same
work again.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> longestIncreasingPath<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>matrix<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rows <span class="op">=</span> matrix<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cols <span class="op">=</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> memo<span class="op">(</span>rows<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>cols<span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">));</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> r <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> r <span class="op">&lt;</span> rows<span class="op">;</span> r<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> c <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> c <span class="op">&lt;</span> cols<span class="op">;</span> c<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                maxLength <span class="op">=</span> max<span class="op">(</span>maxLength<span class="op">,</span> dfs<span class="op">(</span>matrix<span class="op">,</span> r<span class="op">,</span> c<span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dfs<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> matrix<span class="op">,</span> <span class="dt">int</span> r<span class="op">,</span> <span class="dt">int</span> c<span class="op">,</span> vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>r<span class="op">][</span>c<span class="op">]</span> <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>r<span class="op">][</span>c<span class="op">];</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> directions<span class="op">[</span><span class="dv">4</span><span class="op">][</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="op">{{</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">},</span> <span class="op">{</span><span class="dv">0</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">},</span> <span class="op">{-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">}};</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxPath <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> dir <span class="op">:</span> directions<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newRow <span class="op">=</span> r <span class="op">+</span> dir<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newCol <span class="op">=</span> c <span class="op">+</span> dir<span class="op">[</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>newRow <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> newRow <span class="op">&lt;</span> matrix<span class="op">.</span>size<span class="op">()</span> <span class="op">&amp;&amp;</span> newCol <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> newCol <span class="op">&lt;</span> matrix<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">()</span> </span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>                <span class="op">&amp;&amp;</span> matrix<span class="op">[</span>newRow<span class="op">][</span>newCol<span class="op">]</span> <span class="op">&gt;</span> matrix<span class="op">[</span>r<span class="op">][</span>c<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>                maxPath <span class="op">=</span> max<span class="op">(</span>maxPath<span class="op">,</span> <span class="dv">1</span> <span class="op">+</span> dfs<span class="op">(</span>matrix<span class="op">,</span> newRow<span class="op">,</span> newCol<span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>r<span class="op">][</span>c<span class="op">]</span> <span class="op">=</span> maxPath<span class="op">;</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxPath<span class="op">;</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ol type="1">
<li><strong>Matrix Traversal</strong>: We go through each cell in the
matrix.</li>
<li><strong>DFS Function</strong>: For each cell, we call a DFS
function. It checks all four directions (up, down, left, right).</li>
<li><strong>Memoization</strong>: We keep longest paths we calculated
before in a <code>memo</code> 2D vector. This helps us not to compute
again.</li>
<li><strong>Path Calculation</strong>: For each valid move to a neighbor
cell with a higher value, we call the DFS function again. We update the
maximum path length.</li>
<li><strong>Complexity</strong>: The time complexity is O(m * n). Here,
m and n are the size of the matrix. Each cell is processed only
once.</li>
</ol>
<p>This C++ code works well to find the longest increasing path in the
matrix. We use dynamic programming with memoization to make it
efficient.</p>
<h2
id="memoization-technique-for-longest-increasing-path-in-a-matrix">Memoization
Technique for Longest Increasing Path in a Matrix</h2>
<p>We can use the memoization technique to solve the Longest Increasing
Path problem in a matrix. This method helps us store results of costly
function calls. We can reuse these results when we see the same inputs
again. This way, we avoid doing the same calculations over and over.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have an <code>m x n</code> matrix of integers. Our goal is to find
the length of the longest increasing path. From each cell, we can move
to neighboring cells (up, down, left, right) if their values are greater
than the value of the current cell.</p>
<h3 id="approach-1">Approach</h3>
<ol type="1">
<li><p><strong>Define a memoization matrix</strong>: We create a 2D
array called <code>memo</code> with the same size as the input matrix.
We fill it with <code>-1</code> to show that we have not computed those
cells yet.</p></li>
<li><p><strong>Depth-First Search (DFS)</strong>: We write a DFS
function. This function explores all paths starting from each cell. It
uses the memoization matrix to save results that we have already
calculated.</p></li>
<li><p><strong>Recursive Function</strong>: For every cell, we check if
we have already computed its value in <code>memo</code>. If we have, we
just return that value. If not, we calculate the longest increasing path
from that cell by looking in all four directions.</p></li>
</ol>
<h3 id="code-example">Code Example</h3>
<p>Here is a simple code example in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longestIncreasingPath(matrix):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> matrix:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> [[<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(x, y):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> memo[x][y] <span class="op">!=</span> <span class="op">-</span><span class="dv">1</span>:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[x][y]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        max_length <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        directions <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)]  <span class="co"># right, down, left, up</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> directions:</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x <span class="op">+</span> dx, y <span class="op">+</span> dy</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> cols <span class="kw">and</span> matrix[nx][ny] <span class="op">&gt;</span> matrix[x][y]:</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>                max_length <span class="op">=</span> <span class="bu">max</span>(max_length, <span class="dv">1</span> <span class="op">+</span> dfs(nx, ny))</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        memo[x][y] <span class="op">=</span> max_length</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max_length</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    longest_path <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            longest_path <span class="op">=</span> <span class="bu">max</span>(longest_path, dfs(i, j))</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> longest_path</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: First, we check if the matrix is
empty. Then we set up the <code>memo</code> matrix.</li>
<li><strong>DFS Function</strong>: The DFS function finds the longest
path for each cell. It saves results in <code>memo</code> to avoid
calculating them again.</li>
<li><strong>Direction Array</strong>: The <code>directions</code> array
shows the ways we can move to neighboring cells.</li>
<li><strong>Final Calculation</strong>: We find the longest increasing
path by going through each cell and calling the DFS function.</li>
</ul>
<p>This memoization technique makes the time complexity O(m * n). Here,
m is the number of rows and n is the number of columns. This makes it
fast for larger matrices.</p>
<p>For more about dynamic programming techniques, we can look at the
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2
id="topological-sorting-method-for-longest-increasing-path">Topological
Sorting Method for Longest Increasing Path</h2>
<p>We can use the Topological Sorting Method to solve the Longest
Increasing Path problem in a matrix. We treat the matrix like a directed
graph. Each cell in the matrix is a node. There are directed edges from
a cell to its adjacent cells if the adjacent cell has a greater
value.</p>
<h3 id="steps-to-implement-topological-sorting">Steps to Implement
Topological Sorting</h3>
<ol type="1">
<li><strong>Graph Representation</strong>: We create a graph where each
cell points to its neighbors that have greater values.</li>
<li><strong>Calculate In-Degree</strong>: We keep an in-degree count for
each node (cell). This count shows how many edges point into the
node.</li>
<li><strong>Queue Initialization</strong>: We start a queue with all
nodes that have an in-degree of 0. These nodes can be processed
first.</li>
<li><strong>Process Queue</strong>: We use a BFS-like approach:
<ul>
<li>We take a node from the queue. This node is a cell in the
matrix.</li>
<li>For each neighbor with a greater value, we decrease its in-degree.
If the in-degree becomes 0, we add it to the queue.</li>
<li>We keep a distance array to track the longest path that ends at each
node.</li>
</ul></li>
</ol>
<h3 id="example-code-implementation-in-python">Example Code
Implementation in Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> deque</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longestIncreasingPath(matrix):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> matrix:</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    in_degree <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    graph <span class="op">=</span> {}</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Build the graph and calculate in-degrees</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            graph[(r, c)] <span class="op">=</span> []</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> dr, dc <span class="kw">in</span> [(<span class="dv">1</span>, <span class="dv">0</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>)]:</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>                nr, nc <span class="op">=</span> r <span class="op">+</span> dr, c <span class="op">+</span> dc</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nr <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> nc <span class="op">&lt;</span> cols <span class="kw">and</span> matrix[nr][nc] <span class="op">&gt;</span> matrix[r][c]:</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                    graph[(r, c)].append((nr, nc))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                    in_degree[nr][nc] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the queue with nodes of in-degree 0</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    queue <span class="op">=</span> deque()</span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> in_degree[r][c] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                queue.append((r, c))</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Topological sorting process</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    distance <span class="op">=</span> [[<span class="dv">1</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> queue:</span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        r, c <span class="op">=</span> queue.popleft()</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> nr, nc <span class="kw">in</span> graph[(r, c)]:</span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>            distance[nr][nc] <span class="op">=</span> <span class="bu">max</span>(distance[nr][nc], distance[r][c] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            in_degree[nr][nc] <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> in_degree[nr][nc] <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>                queue.append((nr, nc))</span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(<span class="bu">max</span>(row) <span class="cf">for</span> row <span class="kw">in</span> distance)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Graph Construction</strong>: For each cell, we check its
neighbors. If a neighbor is greater, we create an edge and update the
in-degree.</li>
<li><strong>Queue Processing</strong>: We process cells with zero
in-degree first. We update the longest path based on the distances from
the processed cells.</li>
<li><strong>Final Result</strong>: The maximum value in the distance
matrix gives the length of the longest increasing path in the
matrix.</li>
</ul>
<p>This method finds the longest increasing path using topological
sorting. It makes sure we consider all paths without revisiting nodes.
If you want to learn more about dynamic programming and similar
algorithms, you can read articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2
id="iterative-approach-for-longest-increasing-path-in-a-matrix">Iterative
Approach for Longest Increasing Path in a Matrix</h2>
<p>We can use an iterative method to solve the Longest Increasing Path
in a Matrix problem. This method combines topological sort and dynamic
programming. It is efficient and does not have the problems that
recursion can bring.</p>
<h3 id="steps-to-implement-the-iterative-approach">Steps to Implement
the Iterative Approach</h3>
<ol type="1">
<li><p><strong>Topological Sorting</strong>: First, we sort the matrix
so that we follow the increasing order of values. We can do this by
sorting the matrix elements with their coordinates.</p></li>
<li><p><strong>Dynamic Programming Array</strong>: We create a DP array
called <code>dp</code>. In this array, <code>dp[i][j]</code> shows the
longest increasing path that ends at cell <code>(i, j)</code>.</p></li>
<li><p><strong>Direction Vectors</strong>: We define the directions we
can move. These directions are up, down, left, and right. We use them to
check neighboring cells.</p></li>
<li><p><strong>Processing</strong>: We go through the sorted list of
matrix cells. For each cell, we check its neighbors. If the neighbor can
make an increasing path, we update it.</p></li>
</ol>
<h3 id="code-implementation-1">Code Implementation</h3>
<p>Here is the code for the iterative approach in Python:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longestIncreasingPath(matrix):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> matrix <span class="kw">or</span> <span class="kw">not</span> matrix[<span class="dv">0</span>]:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(matrix), <span class="bu">len</span>(matrix[<span class="dv">0</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">1</span>] <span class="op">*</span> cols <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(rows)]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Directions for moving in the matrix</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    directions <span class="op">=</span> [(<span class="dv">0</span>, <span class="dv">1</span>), (<span class="dv">1</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>), (<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>)]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a list of all cells</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    cells <span class="op">=</span> [(matrix[i][j], i, j) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols)]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort cells by their values</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    cells.sort()</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Process each cell in sorted order</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> value, x, y <span class="kw">in</span> cells:</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> dx, dy <span class="kw">in</span> directions:</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>            nx, ny <span class="op">=</span> x <span class="op">+</span> dx, y <span class="op">+</span> dy</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Check if the neighbor is within bounds and forms an increasing path</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="dv">0</span> <span class="op">&lt;=</span> nx <span class="op">&lt;</span> rows <span class="kw">and</span> <span class="dv">0</span> <span class="op">&lt;=</span> ny <span class="op">&lt;</span> cols <span class="kw">and</span> matrix[nx][ny] <span class="op">&gt;</span> value:</span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                dp[nx][ny] <span class="op">=</span> <span class="bu">max</span>(dp[nx][ny], dp[x][y] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The result is the maximum value in the dp array</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(<span class="bu">max</span>(row) <span class="cf">for</span> row <span class="kw">in</span> dp)</span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> [[<span class="dv">9</span>, <span class="dv">9</span>, <span class="dv">4</span>], [<span class="dv">6</span>, <span class="dv">6</span>, <span class="dv">8</span>], [<span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">1</span>]]</span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> longestIncreasingPath(matrix)</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(M * N * log(M * N)). M is the
number of rows and N is the number of columns. This is because we sort
the cells.</li>
<li><strong>Space Complexity</strong>: O(M * N) for the DP array and the
list of cells.</li>
</ul>
<p>This iterative method is good for solving the Longest Increasing Path
in a Matrix problem. It works well without using recursion. For more
about dynamic programming, we can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">dynamic
programming minimum path sum in a grid</a> articles.</p>
<h2
id="performance-analysis-of-longest-increasing-path-solutions">Performance
Analysis of Longest Increasing Path Solutions</h2>
<p>We can look at the performance of the Longest Increasing Path (LIP)
in a matrix by checking different ways to solve the problem. The common
methods are dynamic programming, memoization, topological sorting, and
iterative methods. Each method has its own time and space complexities.
These are important for us to know how well a solution works.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>For a matrix that is <code>m x n</code>, the dynamic programming
method usually has a time complexity of <code>O(m * n)</code>. We find
the longest path for each cell one time. The space complexity is also
<code>O(m * n)</code> because we keep results in a 2D DP array.</p>
<h3 id="memoization-technique">Memoization Technique</h3>
<p>When we use memoization, we can avoid doing the same calculations
many times. The time complexity stays <code>O(m * n)</code> since we
process each cell one time. The space complexity is
<code>O(m * n)</code> for the memoization table.</p>
<h3 id="topological-sorting">Topological Sorting</h3>
<p>With topological sorting, the average case time complexity is still
<code>O(m * n)</code>. But the sorting step can take extra time. The
space complexity is <code>O(m * n)</code> because we need to store the
graph representation.</p>
<h3 id="iterative-approach">Iterative Approach</h3>
<p>The iterative method uses a queue to handle the processing of cells.
It also has a time complexity of <code>O(m * n)</code>. The space
complexity is <code>O(m * n)</code> for the queue.</p>
<h3 id="summary-of-performance-metrics">Summary of Performance
Metrics</h3>
<ul>
<li><strong>Dynamic Programming</strong>:
<ul>
<li>Time Complexity: <code>O(m * n)</code></li>
<li>Space Complexity: <code>O(m * n)</code></li>
</ul></li>
<li><strong>Memoization</strong>:
<ul>
<li>Time Complexity: <code>O(m * n)</code></li>
<li>Space Complexity: <code>O(m * n)</code></li>
</ul></li>
<li><strong>Topological Sorting</strong>:
<ul>
<li>Time Complexity: <code>O(m * n)</code></li>
<li>Space Complexity: <code>O(m * n)</code></li>
</ul></li>
<li><strong>Iterative Approach</strong>:
<ul>
<li>Time Complexity: <code>O(m * n)</code></li>
<li>Space Complexity: <code>O(m * n)</code></li>
</ul></li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>All methods for solving the Longest Increasing Path in a matrix have
similar time complexities. But the choice of method can change how well
it works based on the specific limits and features of the input data.
For more ways to improve and different types of the problem, we can
check other dynamic programming problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-longest-increasing-path-in-a-matrix-problem">1. What
is the Longest Increasing Path in a Matrix problem?</h3>
<p>The Longest Increasing Path in a Matrix problem is about finding the
longest way in a grid. Each step must go to a nearby cell that has a
bigger value. We can solve this problem with different methods. Some
methods are dynamic programming, memoization, and topological sorting.
Each method has its own good points for being fast and easy to use.</p>
<h3
id="how-does-the-dynamic-programming-approach-work-for-finding-the-longest-increasing-path">2.
How does the dynamic programming approach work for finding the Longest
Increasing Path?</h3>
<p>In dynamic programming for the Longest Increasing Path in a Matrix,
we keep a 2D array. This array holds the length of the longest
increasing paths starting from each cell. We look at neighboring cells
and use values we already found. This way, we can find the longest path
from each cell without doing the same work again. This gives us a good
solution.</p>
<h3
id="what-is-the-difference-between-memoization-and-tabulation-in-dynamic-programming">3.
What is the difference between memoization and tabulation in dynamic
programming?</h3>
<p>Memoization and tabulation are two ways to do dynamic programming.
Memoization means we save the results of expensive function calls. We
use these saved results again when we have the same inputs. This usually
uses recursion. Tabulation makes a table from the bottom up. We fill the
table step by step using values we found before. For the Longest
Increasing Path in a Matrix, both can give us the best results.</p>
<h3
id="can-the-longest-increasing-path-problem-be-solved-iteratively">4.
Can the Longest Increasing Path problem be solved iteratively?</h3>
<p>Yes, we can solve the Longest Increasing Path in a Matrix problem
with an iterative method. This method often uses a queue or stack. We
check cells based on their values and only move to valid neighbors with
bigger values. This way can be fast and avoids the extra work of
recursion.</p>
<h3
id="what-are-the-common-performance-considerations-when-solving-the-longest-increasing-path-problem">5.
What are the common performance considerations when solving the Longest
Increasing Path problem?</h3>
<p>When we solve the Longest Increasing Path in a Matrix, we need to
think about performance. Important points are time complexity. This is
usually O(m*n) for an m x n matrix. Space complexity is also important,
especially when we use memoization or save results. We should look at
the input size and try different algorithms like topological sorting or
iterative methods. This can help make performance better.</p>
<p>For more insights on dynamic programming techniques, check out our
articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            