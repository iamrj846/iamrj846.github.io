
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Minimum Path Sum in a Grid - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Minimum Path Sum problem in a grid using dynamic programming. Optimize your coding skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Minimum Path Sum in a Grid - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Minimum Path Sum in a Grid is a problem. We need to find the path
from the top-left corner to the bottom-right corner of a grid. Each cell
has a non-negative number. Our goal is to get the smallest sum of the
numbers along the path. We can only move down or to the right. We often
solve this problem using dynamic programming. This method builds
solutions step by step by keeping track of the results we find.</p>
<p>In this article, we will look closely at the Minimum Path Sum in a
Grid problem. First, we will give a short overview of the solution and
explain the problem statement. After that, we will talk about the
dynamic programming approach. We will show you how to do this in Java,
Python, and C++. We will also talk about iterative methods, how to make
space use better, common mistakes we can make, and answer some questions
people often ask about this problem.</p>
<ul>
<li>[Dynamic Programming] Minimum Path Sum in a Grid - Medium Solution
Overview</li>
<li>Understanding the Problem Statement for Minimum Path Sum</li>
<li>Dynamic Programming Approach for Minimum Path Sum in a Grid</li>
<li>Java Implementation of Minimum Path Sum in a Grid</li>
<li>Python Implementation of Minimum Path Sum in a Grid</li>
<li>C++ Implementation of Minimum Path Sum in a Grid</li>
<li>Iterative Approach for Minimum Path Sum in a Grid</li>
<li>Optimizing Space Complexity in Minimum Path Sum Solution</li>
<li>Common Mistakes to Avoid in Minimum Path Sum Problem</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-minimum-path-sum">Understanding
the Problem Statement for Minimum Path Sum</h2>
<p>The Minimum Path Sum problem is about finding a way from the top-left
corner to the bottom-right corner of a grid. Each cell has a value that
is a non-negative number. Our goal is to make the sum of the values
along the path as small as possible. We can only move down or to the
right.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>: A 2D grid <code>grid</code> with size
<code>m x n</code>. Each cell <code>grid[i][j]</code> shows the cost of
entering that cell.</li>
<li><strong>Output</strong>: The minimum path sum from the top-left
corner <code>(0, 0)</code> to the bottom-right corner
<code>(m-1, n-1)</code>.</li>
</ul>
<h3 id="example">Example</h3>
<p>Look at this grid:</p>
<pre><code>[
  [1, 3, 1],
  [1, 5, 1],
  [4, 2, 1]
]</code></pre>
<p>The minimum path sum is <code>7</code>. We get this by taking the
path <code>1 → 3 → 1 → 1</code>. This gives us the sum
<code>1 + 3 + 1 + 1 = 6</code>.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The grid must be at least 1x1.</li>
<li>All values in the grid are non-negative integers.</li>
</ul>
<p>We need to understand the problem well to find a good solution using
dynamic programming. We break the problem into smaller parts. Then, we
store results we find along the way. Finally, we build the solution step
by step.</p>
<h2
id="dynamic-programming-approach-for-minimum-path-sum-in-a-grid">Dynamic
Programming Approach for Minimum Path Sum in a Grid</h2>
<p>The Minimum Path Sum problem in a grid is about finding the smallest
sum of a path from the top-left corner to the bottom-right corner. We
can only move down or right. We can solve this problem well with a
dynamic programming method.</p>
<h3 id="dynamic-programming-table">Dynamic Programming Table</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We can say
<code>dp[i][j]</code> is the minimum path sum to reach cell
<code>(i, j)</code>.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li><p>For the first cell:</p>
<pre><code>dp[0][0] = grid[0][0]</code></pre></li>
<li><p>For the first row and first column:</p>
<pre><code>dp[i][0] = dp[i-1][0] + grid[i][0]  (for all i)
dp[0][j] = dp[0][j-1] + grid[0][j]  (for all j)</code></pre></li>
<li><p>For other cells:</p>
<pre><code>dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code></pre></li>
</ul></li>
<li><p><strong>Base Case</strong>: We start with <code>dp[0][0]</code>
set to the value in the top-left corner of the grid.</p></li>
<li><p><strong>Result</strong>: We find the answer in
<code>dp[m-1][n-1]</code>, where <code>m</code> and <code>n</code> are
the grid sizes.</p></li>
</ol>
<h3 id="example-1">Example</h3>
<p>For a grid like this:</p>
<pre><code>1 3 1
1 5 1
4 2 1</code></pre>
<p>The <code>dp</code> table will look like this:</p>
<pre><code>1  4  5
2  7  6
6  8  7</code></pre>
<p>The minimum path sum is <code>7</code>.</p>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(m n))</li>
<li><strong>Space Complexity</strong>: (O(m n)) for the <code>dp</code>
table.</li>
</ul>
<h3 id="implementation-example">Implementation Example</h3>
<p>Here is a Java code for the dynamic programming solution to the
Minimum Path Sum problem:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumPathSum <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>We can also make this approach better for space by using just two
arrays instead of a full <code>dp</code> table. The main point is that
dynamic programming helps us break the problem down into smaller parts.
This leads to a good solution for the Minimum Path Sum in a grid. For
more on dynamic programming, check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="java-implementation-of-minimum-path-sum-in-a-grid">Java
Implementation of Minimum Path Sum in a Grid</h2>
<p>To solve the Minimum Path Sum problem in a grid with Java, we can use
dynamic programming. We will go through the grid and update each cell.
Each cell will show the minimum path sum from the top-left corner to
that cell.</p>
<p>Here is a simple implementation:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumPathSum <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>grid <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the first row</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the first column</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> m<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            grid<span class="op">[</span>j<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Update the rest of the grid</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> grid<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a>        MinimumPathSum solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MinimumPathSum</span><span class="op">();</span></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> grid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum Path Sum: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">minPathSum</span><span class="op">(</span>grid<span class="op">));</span> <span class="co">// Output: 7</span></span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Input Check</strong>: The function starts by checking if the
grid is empty.</li>
<li><strong>Grid Size</strong>: We find out the number of rows
(<code>m</code>) and columns (<code>n</code>).</li>
<li><strong>First Row Setup</strong>: We fill the first row by adding
sums from the left side.</li>
<li><strong>First Column Setup</strong>: We fill the first column by
adding sums from above.</li>
<li><strong>Dynamic Programming Update</strong>: For each cell, we add
its value to the minimum of the two cells we can come from (above or
left).</li>
<li><strong>Final Result</strong>: The bottom-right cell of the grid
gives the minimum path sum.</li>
</ul>
<p>This Java implementation helps to find the minimum path sum in a grid
using dynamic programming ideas. For more reading, you can check out
similar problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Minimum
Path Sum in a Grid with No Obstacles</a>.</p>
<h2 id="python-implementation-of-minimum-path-sum-in-a-grid">Python
Implementation of Minimum Path Sum in a Grid</h2>
<p>To solve the Minimum Path Sum problem in a grid with Python, we use a
simple dynamic programming method. We create a 2D array called
<code>dp</code>. Each <code>dp[i][j]</code> shows the minimum path sum
to reach the cell <code>(i, j)</code> from the starting cell
<code>(0, 0)</code>.</p>
<p>Here is the step-by-step way to do it:</p>
<ol type="1">
<li><p><strong>Initialize the DP array</strong>: First, we make a 2D
list <code>dp</code> that has the same size as the input grid. The value
<code>dp[i][j]</code> will be the minimum path sum to get to that
cell.</p></li>
<li><p><strong>Base case</strong>: Set the starting point
<code>dp[0][0]</code> equal to <code>grid[0][0]</code>.</p></li>
<li><p><strong>Fill the first row and column</strong>: We can only reach
any cell in the first row from the left. For the first column, we can
only come from above.</p></li>
<li><p><strong>Fill the rest of the DP array</strong>: For each cell
<code>(i, j)</code>, we can find the minimum path sum like this:</p>
<pre><code>dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1])</code></pre></li>
<li><p><strong>Result</strong>: The value at <code>dp[m-1][n-1]</code>
(where <code>m</code> is the number of rows and <code>n</code> is the
number of columns) will tell us the minimum path sum to the bottom-right
corner of the grid.</p></li>
</ol>
<p>Here is the Python code for this method:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the first row</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the first column</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the rest of the dp array</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> [[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">1</span>],[<span class="dv">1</span>,<span class="dv">5</span>,<span class="dv">1</span>],[<span class="dv">4</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minPathSum(grid))  <span class="co"># Output: 7</span></span></code></pre></div>
<p>In this code, the function <code>minPathSum</code> takes a 2D list
called <code>grid</code> and gives back the minimum path sum from the
top-left corner to the bottom-right corner. The example shows how to use
the function with a sample grid.</p>
<p>For more examples about path sums in grids, you can check the article
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="c-implementation-of-minimum-path-sum-in-a-grid">C++
Implementation of Minimum Path Sum in a Grid</h2>
<p>To solve the Minimum Path Sum problem in a grid using C++, we can use
a simple dynamic programming method. We will create a 2D DP array. Each
cell in this array shows the minimum path sum to reach that cell from
the top-left corner.</p>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Create a DP table</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize the top-left corner</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the first row</span></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the first column</span></span>
<span id="cb11-23"><a href="#cb11-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-24"><a href="#cb11-24" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb11-25"><a href="#cb11-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-26"><a href="#cb11-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-27"><a href="#cb11-27" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the rest of the dp table</span></span>
<span id="cb11-28"><a href="#cb11-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-29"><a href="#cb11-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-30"><a href="#cb11-30" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb11-31"><a href="#cb11-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-32"><a href="#cb11-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-33"><a href="#cb11-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-34"><a href="#cb11-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">// The bottom-right corner contains the answer</span></span>
<span id="cb11-35"><a href="#cb11-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-36"><a href="#cb11-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-37"><a href="#cb11-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-38"><a href="#cb11-38" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-39"><a href="#cb11-39" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> grid <span class="op">=</span> <span class="op">{</span></span>
<span id="cb11-40"><a href="#cb11-40" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb11-41"><a href="#cb11-41" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">},</span></span>
<span id="cb11-42"><a href="#cb11-42" aria-hidden="true" tabindex="-1"></a>        <span class="op">{</span><span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">}</span></span>
<span id="cb11-43"><a href="#cb11-43" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb11-44"><a href="#cb11-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-45"><a href="#cb11-45" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum Path Sum: &quot;</span> <span class="op">&lt;&lt;</span> minPathSum<span class="op">(</span>grid<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb11-46"><a href="#cb11-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-47"><a href="#cb11-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li>The <code>minPathSum</code> function takes a 2D vector called
<code>grid</code> as input.</li>
<li>We create a DP table with the same size as the grid.</li>
<li>We start by setting the first cell with the value from the grid’s
top-left corner.</li>
<li>We fill the first row and the first column based on the sums.</li>
<li>For the other cells, we calculate the DP value by adding the current
grid cell with the smallest value from the cell above or the cell to the
left.</li>
<li>Finally, the value in the bottom-right corner of the DP table gives
us the minimum path sum.</li>
</ul>
<p>This method runs in O(m<em>n) time and uses O(m</em>n) space. If you
want to learn more about similar dynamic programming problems, we can
check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a> article.</p>
<h2 id="iterative-approach-for-minimum-path-sum-in-a-grid">Iterative
Approach for Minimum Path Sum in a Grid</h2>
<p>We can solve the Minimum Path Sum in a grid by using a simple method
called bottom-up dynamic programming. This way, we fill the grid so that
each cell shows the minimum path sum to reach that cell from the
top-left corner. The main idea is to go through each cell and update its
value based on the minimum sum from the cell above and the cell to the
left.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>: First, we look at the first row and
first column. They can only be reached from one way.</li>
<li><strong>Iterate through the grid</strong>: For each cell in the grid
starting from (1,1), we update its value. The new value is its own value
plus the minimum of the value from the cell above it and the cell to its
left.</li>
<li><strong>Result</strong>: The value in the bottom-right corner of the
grid gives us the minimum path sum.</li>
</ol>
<h3 id="pseudocode">Pseudocode:</h3>
<pre class="plaintext"><code>function minPathSum(grid):
    if grid is empty:
        return 0
    
    rows = grid.length
    cols = grid[0].length
    
    for i from 0 to rows - 1:
        for j from 0 to cols - 1:
            if i == 0 and j == 0:
                continue
            if i == 0:
                grid[i][j] += grid[i][j - 1]
            else if j == 0:
                grid[i][j] += grid[i - 1][j]
            else:
                grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])
    
    return grid[rows - 1][cols - 1]</code></pre>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rows <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> cols <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grid<span class="op">[</span>rows <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>cols <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation:</h3>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(rows):</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(cols):</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>                grid[i][j] <span class="op">+=</span> grid[i][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> j <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>                grid[i][j] <span class="op">+=</span> grid[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>                grid[i][j] <span class="op">+=</span> <span class="bu">min</span>(grid[i <span class="op">-</span> <span class="dv">1</span>][j], grid[i][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> grid[rows <span class="op">-</span> <span class="dv">1</span>][cols <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation:</h3>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rows <span class="op">=</span> grid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> cols <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> rows<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> cols<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>j <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">else</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> min<span class="op">(</span>grid<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">],</span> grid<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-17"><a href="#cb15-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> grid<span class="op">[</span>rows <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>cols <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb15-18"><a href="#cb15-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-19"><a href="#cb15-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This iterative way helps us find the minimum path sum in
<code>O(m * n)</code> time. We can also make it use less space, which we
will explain next. For more on dynamic programming, please check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2
id="optimizing-space-complexity-in-minimum-path-sum-solution">Optimizing
Space Complexity in Minimum Path Sum Solution</h2>
<p>In the Minimum Path Sum problem, we want to find the path from the
top-left corner to the bottom-right corner of a grid. This path should
have the smallest sum of values. The usual way to solve this uses a 2D
array to keep track of results. But this can use a lot of space. We can
optimize it and use less space.</p>
<h3 id="space-optimization">Space Optimization</h3>
<ol type="1">
<li><p><strong>In-Place Updates</strong>: We can update the original
grid instead of using a separate 2D array. This means we store the
minimum path sums directly in the grid. This change will reduce the
extra space needed to O(1).</p></li>
<li><p><strong>Single Array Approach</strong>: We can use just one 1D
array to store the minimum path sums for the current row. This works
well because we only need the values from the previous row to find the
current row’s values.</p></li>
</ol>
<h3 id="java-implementation-example">Java Implementation Example</h3>
<div class="sourceCode" id="cb16"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">minPathSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> grid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">,</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Use a single array to store the minimum path sums</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Initialize the first cell</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the first row</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the rest of the grid</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Update first column</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Bottom-right corner</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-example">Python Implementation
Example</h3>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minPathSum(grid):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid <span class="kw">or</span> <span class="kw">not</span> grid[<span class="dv">0</span>]:</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> grid[<span class="dv">0</span>][<span class="dv">0</span>]</span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>        dp[j] <span class="op">=</span> dp[j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> grid[<span class="dv">0</span>][j]</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>] <span class="op">+=</span> grid[i][<span class="dv">0</span>]</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">=</span> <span class="bu">min</span>(dp[j], dp[j <span class="op">-</span> <span class="dv">1</span>]) <span class="op">+</span> grid[i][j]</span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation-example">C++ Implementation Example</h3>
<div class="sourceCode" id="cb18"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minPathSum<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">.</span>empty<span class="op">()</span> <span class="op">||</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">+=</span> grid<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>j<span class="op">],</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">+</span> grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li>We optimize the space complexity to O(n) instead of O(m*n).</li>
<li>The implementation updates the DP array in place. This really helps
in using less memory.</li>
<li>This optimization is very important for big grids. It helps improve
performance and reduce memory use.</li>
</ul>
<p>For more reading on dynamic programming and similar topics, you can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid with No Obstacles</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2 id="common-mistakes-to-avoid-in-minimum-path-sum-problem">Common
Mistakes to Avoid in Minimum Path Sum Problem</h2>
<p>When we solve the Minimum Path Sum problem with dynamic programming,
we should be careful. Some common mistakes can make our solution wrong.
Here are some important points to keep in mind:</p>
<ol type="1">
<li><strong>Incorrect Initialization</strong>:
<ul>
<li>If we do not start the DP table correctly, we can get wrong answers.
Make sure the first cell, usually the top-left one, starts with the
value from the grid.</li>
</ul>
<div class="sourceCode" id="cb19"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">];</span></span></code></pre></div></li>
<li><strong>Boundary Conditions</strong>:
<ul>
<li>We must handle special cases. For example, single-row or
single-column grids can cause errors if we do not check the grid size
first. Always check the grid’s size before using its values.</li>
</ul></li>
<li><strong>Updating the DP Table</strong>:
<ul>
<li>If we overwrite values in the DP table without looking at previous
results, we can get wrong path sums. Always update the current cell by
using the smallest value from the cell above or the cell to the
left.</li>
</ul>
<div class="sourceCode" id="cb20"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> grid[i][j] <span class="op">+</span> <span class="bu">min</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j], dp[i][j<span class="op">-</span><span class="dv">1</span>])<span class="op">;</span></span></code></pre></div></li>
<li><strong>Ignoring Grid Values</strong>:
<ul>
<li>We should always include values from the grid cells in our
calculations. The total path sum depends on the grid’s values, not just
the path we take.</li>
</ul></li>
<li><strong>Space Complexity Optimization</strong>:
<ul>
<li>We can save memory by using space-saving techniques. Instead of a
two-dimensional array, we can use a one-dimensional array when we
can.</li>
</ul>
<div class="sourceCode" id="cb21"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span></code></pre></div></li>
<li><strong>Not Saving Intermediate Results</strong>:
<ul>
<li>If we do not save intermediate results in the DP table, we will
calculate values again and again. This makes our solution slow. Always
save results to avoid repeating calculations.</li>
</ul></li>
<li><strong>Incorrect Result Extraction</strong>:
<ul>
<li>We need to get the final result from the right cell in the DP table.
Usually, the minimum path sum is in the bottom-right cell after all
calculations.</li>
</ul></li>
<li><strong>Overlooking Obstacle Handling</strong>:
<ul>
<li>If the problem has obstacles, we must handle them correctly. Cells
with obstacles should not add to the path sum and should be marked
properly.</li>
</ul></li>
<li><strong>Misunderstanding Grid Traversal</strong>:
<ul>
<li>We must know how to move (only down and right) and apply the logic
correctly to go through the grid. If we make mistakes in this logic, we
can check wrong paths.</li>
</ul></li>
<li><strong>Not Testing Edge Cases</strong>:<br />
</li>
</ol>
<ul>
<li>We need to test edge cases like empty grids or grids with just one
element. If we do not test these, we can see unexpected problems. Always
include tests for these cases.</li>
</ul>
<p>By avoiding these mistakes, we can implement the Minimum Path Sum
solution well using dynamic programming. This will give us correct
answers and good performance. For more reading on similar dynamic
programming problems, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid with No Obstacles</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-minimum-path-sum-problem-in-a-grid">1. What is the
Minimum Path Sum problem in a grid?</h3>
<p>The Minimum Path Sum problem is about finding the best path from the
top-left corner to the bottom-right corner of a grid. This path should
have the smallest sum of values along the way. We can only move down or
to the right at any time. This problem is a good example of dynamic
programming. It helps us understand how to work with grid-based
algorithms.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-minimum-path-sum-in-a-grid">2.
How can dynamic programming be applied to solve Minimum Path Sum in a
grid?</h3>
<p>We can use dynamic programming to solve the Minimum Path Sum problem
by breaking it into smaller parts. We store the minimum path sums at
each cell in the grid. This way, we can build the final answer without
doing the same work again. It makes our solution faster and easier to
manage.</p>
<h3
id="what-is-the-time-complexity-of-the-minimum-path-sum-algorithm">3.
What is the time complexity of the Minimum Path Sum algorithm?</h3>
<p>The time complexity of the Minimum Path Sum algorithm is O(m * n).
Here m is the number of rows and n is the number of columns in the grid.
We get this speed by filling a DP table using values we already
calculated. This means we visit each cell only one time.</p>
<h3
id="how-can-i-optimize-the-space-complexity-in-the-minimum-path-sum-problem">4.
How can I optimize the space complexity in the Minimum Path Sum
problem?</h3>
<p>To make space usage better in the Minimum Path Sum problem, we can
use one array instead of a two-dimensional array. By updating this
single array as we go, we can lower the space complexity from O(m * n)
to O(n). This way, we still keep the information we need to find the
minimum path sum.</p>
<h3
id="are-there-common-mistakes-to-avoid-when-solving-the-minimum-path-sum-problem">5.
Are there common mistakes to avoid when solving the Minimum Path Sum
problem?</h3>
<p>Some common mistakes when working on the Minimum Path Sum problem are
not starting the DP array correctly, not checking the grid boundaries,
and not understanding that we can only move down or right. We should
carefully check edge cases and test with different grid sizes. For more
practice, we can look at other dynamic programming problems like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Unique
Paths in a Grid</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            