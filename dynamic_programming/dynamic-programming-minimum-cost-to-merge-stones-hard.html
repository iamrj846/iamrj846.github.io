
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Minimum Cost to Merge Stones - Hard</title>
            <meta name="description" content="Learn how to solve the Minimum Cost to Merge Stones problem using dynamic programming techniques in our in-depth guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Minimum Cost to Merge Stones - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Minimum Cost to Merge Stones problem is a hard task in dynamic
programming. Our goal is to merge several stones into one. We want to do
this with the least cost. The cost to merge stones is the total of all
stones that are merged in that step. This problem is tricky because
there are limits on how many stones we can merge at once.</p>
<p>In this article, we will explore the Minimum Cost to Merge Stones
problem. We will start by looking at the problem statement and what it
needs. Then, we will explain the dynamic programming way to find the
best solution. We will also show Java, Python, and C++ code examples to
make it clearer. Also, we will talk about ways to make the dynamic
programming solution better. We will analyze the complexity of the
solution and answer some common questions about the topic.</p>
<ul>
<li>Dynamic Programming Approach to Minimum Cost to Merge Stones
Hard</li>
<li>Understanding the Problem Statement for Minimum Cost to Merge
Stones</li>
<li>Dynamic Programming Solution Explanation for Minimum Cost to Merge
Stones</li>
<li>Java Implementation of Minimum Cost to Merge Stones</li>
<li>Python Implementation of Minimum Cost to Merge Stones</li>
<li>C++ Implementation of Minimum Cost to Merge Stones</li>
<li>Optimizing Dynamic Programming Solution for Minimum Cost to Merge
Stones</li>
<li>Complexity Analysis of Minimum Cost to Merge Stones Solution</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For anyone who likes dynamic programming problems, we can suggest
these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming - Minimum Cost Climbing Stairs</a>.</p>
<h2
id="understanding-the-problem-statement-for-minimum-cost-to-merge-stones">Understanding
the Problem Statement for Minimum Cost to Merge Stones</h2>
<p>The problem of “Minimum Cost to Merge Stones” is about merging
<code>n</code> stones into one. Each merge operation has a cost. We show
the stones as an array of integers. Each integer shows the weight of a
stone.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We get an array <code>stones</code> with length <code>n</code>. Here,
<code>stones[i]</code> is the weight of the <code>i-th</code> stone. Our
goal is to merge all the stones into one. The cost to merge stones comes
from the total weight of the stones we merge.</p>
<p>For example, if we merge stones with weights <code>a</code> and
<code>b</code>, the cost we pay is <code>a + b</code>. After merging,
the new stone has a weight of <code>a + b</code>.</p>
<h3 id="key-constraints">Key Constraints</h3>
<ol type="1">
<li>We can merge stones in groups of <code>k</code> (where
<code>k</code> is a number we choose).</li>
<li>If we cannot make all stones into one using groups of
<code>k</code>, we cannot do the operation.</li>
<li>We want to keep the total cost as low as possible when we
merge.</li>
</ol>
<h3 id="example">Example</h3>
<p>If we have <code>stones = [3, 2, 4, 1]</code> and <code>k = 2</code>,
we can see the possible merge operations and their costs like this:</p>
<ol type="1">
<li>We merge the first two stones <code>3</code> and <code>2</code> →
cost = <code>5</code>, so we have <code>[5, 4, 1]</code>.</li>
<li>Next, we merge the last two stones <code>4</code> and <code>1</code>
→ cost = <code>5</code>, so we have <code>[5, 5]</code>.</li>
<li>Finally, we merge <code>5</code> and <code>5</code> → cost =
<code>10</code>.</li>
</ol>
<p>So the total cost is <code>5 + 5 + 10 = 20</code>.</p>
<h3 id="objective">Objective</h3>
<p>Our goal is to find a way to minimize the total merging cost while
following the rules of merging stones in groups of <code>k</code>. We
can use dynamic programming to solve this problem. We focus on
memoization to make overlapping subproblems easier to solve.</p>
<p>For more information about dynamic programming, we can look at
articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Minimum Cost Climbing Stairs</a>.</p>
<h2
id="dynamic-programming-solution-explanation-for-minimum-cost-to-merge-stones">Dynamic
Programming Solution Explanation for Minimum Cost to Merge Stones</h2>
<p>To find the minimum cost to merge stones, we use a dynamic
programming method. We have an array of stones. The cost to merge stones
is the total value of the stones being merged. Our goal is to combine
all stones into one while keeping the cost as low as possible.</p>
<h3 id="problem-formulation">Problem Formulation</h3>
<ol type="1">
<li><strong>State Definition</strong>:
<ul>
<li>We define <code>dp[i][j]</code> as the minimum cost to merge stones
from index <code>i</code> to index <code>j</code>.</li>
<li>We define <code>sum[i][j]</code> as the total sum of stones from
index <code>i</code> to index <code>j</code>.</li>
</ul></li>
<li><strong>Base Case</strong>:
<ul>
<li>If there is only one stone, <code>dp[i][i] = 0</code> because we do
not spend anything to merge it.</li>
</ul></li>
<li><strong>Recurrence Relation</strong>:
<ul>
<li>To merge stones between indices <code>i</code> and <code>j</code>,
we look at possible split points <code>k</code> where
<code>i &lt;= k &lt; j</code>. We can calculate the cost to merge from
<code>i</code> to <code>j</code> like this: [ dp[i][j] = _{k=i}^{j-1}
(dp[i][k] + dp[k+1][j] + sum[i][j]) ]</li>
<li>We also check the merging rule. We need to make sure that we end up
with <code>1</code> merged stone.</li>
</ul></li>
<li><strong>Optimization</strong>:
<ul>
<li>To avoid doing the same work again, we keep a prefix sum array. This
helps us get the sum of any part of the array in O(1) time.</li>
</ul></li>
</ol>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li>Create a 2D array <code>dp</code> and set all values to
infinity.</li>
<li>Create a 2D array <code>sum</code> to store the total sums of
stones.</li>
<li>Calculate the sums for all parts of the array and fill the
<code>sum</code> array.</li>
<li>Fill the <code>dp</code> table using the rules we defined.</li>
</ol>
<h3 id="example-code-in-java">Example Code in Java</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">mergeStones</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> sum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                sum<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> sum<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> K<span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MAX_VALUE</span><span class="op">;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i<span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k <span class="op">+=</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> sum<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-code-in-python">Example Code in Python</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> mergeStones(<span class="va">self</span>, stones: List[<span class="bu">int</span>], K: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> <span class="bu">len</span>(stones)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> (K <span class="op">-</span> <span class="dv">1</span>) <span class="op">!=</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        sum_stones <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            sum_stones[i][i] <span class="op">=</span> stones[i]</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                sum_stones[i][j] <span class="op">=</span> sum_stones[i][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> stones[j]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(K, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, j, K <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i][j], dp[i][k] <span class="op">+</span> dp[k <span class="op">+</span> <span class="dv">1</span>][j])</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> (length <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> (K <span class="op">-</span> <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> sum_stones[i][j]</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="example-code-in-c">Example Code in C++</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mergeStones<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stones<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> INT_MAX<span class="op">));</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> sum<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                sum<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> sum<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> K<span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> k <span class="op">=</span> i<span class="op">;</span> k <span class="op">&lt;</span> j<span class="op">;</span> k <span class="op">+=</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>k<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> sum<span class="op">[</span>i<span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This dynamic programming method helps us find the minimum cost to
merge the stones while following the rules for merging. By using a clear
state transition and taking advantage of cumulative sums, we make the
solution both easy to understand and efficient.</p>
<h2 id="java-implementation-of-minimum-cost-to-merge-stones">Java
Implementation of Minimum Cost to Merge Stones</h2>
<p>We can solve the Minimum Cost to Merge Stones problem in Java using
dynamic programming. We create a DP table. Here, <code>dp[i][j]</code>
shows the minimum cost to merge stones from index <code>i</code> to
<code>j</code>. We look at every position to merge the stones in a valid
way.</p>
<p>Here is how we can implement it:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumCostToMergeStones <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">mergeStones</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// If not possible to merge</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> sum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Precompute the sum of stones from index i to j</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> sum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize DP array</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> K<span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MAX_VALUE</span><span class="op">;</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Try merging stones from i to j</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> i<span class="op">;</span> m <span class="op">&lt;</span> j<span class="op">;</span> m <span class="op">+=</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>m<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>                <span class="co">// If we can merge the last group</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> sum<span class="op">[</span>j <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> sum<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>        MinimumCostToMergeStones solver <span class="op">=</span> <span class="kw">new</span> <span class="fu">MinimumCostToMergeStones</span><span class="op">();</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> stones <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> K <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum cost to merge stones: &quot;</span> <span class="op">+</span> solver<span class="op">.</span><span class="fu">mergeStones</span><span class="op">(</span>stones<span class="op">,</span> K<span class="op">));</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li><strong>Input:</strong> We have an array of stones and an integer
<code>K</code>.</li>
<li><strong>DP Array:</strong> We use a 2D array <code>dp</code> to keep
the minimum cost of merging stones.</li>
<li><strong>Sum Array:</strong> We precompute sums for easier cost
calculations.</li>
<li><strong>Transition Logic:</strong> We look at possible lengths and
find minimum costs by merging stones.</li>
</ul>
<h3 id="complexity">Complexity:</h3>
<ul>
<li><strong>Time Complexity:</strong> O(n^3) because of the nested loops
for lengths and merging positions.</li>
<li><strong>Space Complexity:</strong> O(n^2) for the DP table.</li>
</ul>
<p>This Java implementation helps us find the minimum cost to merge
stones with the rules of the problem. For more insights into dynamic
programming, we can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2 id="python-implementation-of-minimum-cost-to-merge-stones">Python
Implementation of Minimum Cost to Merge Stones</h2>
<p>We can solve the Minimum Cost to Merge Stones problem in Python using
a simple dynamic programming method. Our aim is to merge stones into one
pile with the least cost. The cost of merging stones is equal to the
total of the stones we are merging.</p>
<p>We need to create a DP table to keep track of the minimum costs for
merging the stones. Here is how we can do this:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mergeStones(stones, K):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(stones)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> (K <span class="op">-</span> <span class="dv">1</span>) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prefix sum to calculate cost of merging easily</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        prefix_sum[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> prefix_sum[i] <span class="op">+</span> stones[i]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DP table</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[[<span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)] <span class="op">*</span> (K <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: merging single stone costs nothing</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        dp[i][i][<span class="dv">1</span>] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of the current segment</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span>  <span class="co"># end index of the segment</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, K <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># number of piles to merge</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(i, j):  <span class="co"># partition point</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                    dp[i][j][k] <span class="op">=</span> <span class="bu">min</span>(dp[i][j][k], dp[i][m][k] <span class="op">+</span> dp[m <span class="op">+</span> <span class="dv">1</span>][j][k])</span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> k <span class="op">&gt;</span> <span class="dv">1</span>:  <span class="co"># merging two segments into one pile</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>                    dp[i][j][<span class="dv">1</span>] <span class="op">=</span> <span class="bu">min</span>(dp[i][j][<span class="dv">1</span>], dp[i][j][k] <span class="op">+</span> prefix_sum[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">-</span> prefix_sum[i])</span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>][<span class="dv">1</span>]</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>stones <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>]</span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(mergeStones(stones, K))  <span class="co"># Output: 14</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code:</h3>
<ol type="1">
<li><strong>Prefix Sum Calculation</strong>: We find the prefix sums.
This helps us to easily calculate the cost of merging stones.</li>
<li><strong>Dynamic Programming Table</strong>:
<ul>
<li><code>dp[i][j][k]</code> shows the least cost to merge stones from
index <code>i</code> to <code>j</code> into <code>k</code> piles.</li>
<li>We set the cost to merge a single stone as <code>0</code>.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>: We go through possible
segment lengths, indices, and the number of piles to fill the DP
table.</li>
<li><strong>Return Value</strong>: The answer is in
<code>dp[0][n-1][1]</code>, which gives the least cost of merging all
stones into one pile.</li>
</ol>
<p>This code is a good way to solve the problem using dynamic
programming. It follows the rules we need for merging. If you want to
learn more about dynamic programming problems, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Approach to Fibonacci Numbers</a> and other similar
articles.</p>
<h2 id="c-implementation-of-minimum-cost-to-merge-stones">C++
Implementation of Minimum Cost to Merge Stones</h2>
<p>We can solve the problem of merging stones at the lowest cost using
dynamic programming. The goal is to merge all stones into one pile. We
also want to keep the total cost low. The cost depends on how many
stones we merge together.</p>
<p>Here is the C++ code for the “Minimum Cost to Merge Stones”
problem:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;limits&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> mergeStones<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stones<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// we cannot merge to one pile</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefix<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>            prefix<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> prefix<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> K<span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> numeric_limits<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;::</span>max<span class="op">();</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> m <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> m <span class="op">&lt;</span> len<span class="op">;</span> m <span class="op">+=</span> K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>i <span class="op">+</span> m <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">+</span> m<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> prefix<span class="op">[</span>j <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> prefix<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a>    Solution sol<span class="op">;</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> stones <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> K <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum cost to merge stones: &quot;</span> <span class="op">&lt;&lt;</span> sol<span class="op">.</span>mergeStones<span class="op">(</span>stones<span class="op">,</span> K<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>Function <code>mergeStones</code></strong>: This function
gets a vector of stones and an integer K. It returns the lowest cost to
merge all stones into one pile.</li>
<li><strong>Prefix Sum Array</strong>: We use a prefix sum array to find
the cost of merging stones easily.</li>
<li><strong>Dynamic Programming Array</strong>: We create a 2D DP array
<code>dp[i][j]</code>. This array stores the lowest cost to merge stones
from index <code>i</code> to <code>j</code>.</li>
<li><strong>Cost Calculation</strong>: We calculate the cost based on
merging the stones in groups of size K. The DP array gets updated with
this cost.</li>
<li><strong>Main Function</strong>: We show an example to explain how to
use the <code>mergeStones</code> function.</li>
</ul>
<p>This C++ code helps us solve the problem of merging stones at the
lowest cost using dynamic programming. It works well for larger inputs.
For more learning, we can check other dynamic programming topics like
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2
id="optimizing-dynamic-programming-solution-for-minimum-cost-to-merge-stones">Optimizing
Dynamic Programming Solution for Minimum Cost to Merge Stones</h2>
<p>We want to make the dynamic programming solution better for the
“Minimum Cost to Merge Stones” problem. Our aim is to reduce both time
and space used. We need to merge stones into one pile with the smallest
cost. The cost is the total of the stones in the piles we merge.</p>
<h3 id="key-observations">Key Observations:</h3>
<ol type="1">
<li><strong>Prefix Sums</strong>: We can use a prefix sum array to
quickly find the sum of stones in any range.</li>
<li><strong>State Definition</strong>: We define <code>dp[i][j]</code>
as the lowest cost to merge stones from index <code>i</code> to
<code>j</code>.</li>
<li><strong>Merge Conditions</strong>: We only merge piles when the
number of remaining piles is a multiple of <code>k</code>.</li>
</ol>
<h3 id="dynamic-programming-transition">Dynamic Programming
Transition:</h3>
<ul>
<li>For each range <code>(i, j)</code>, we check possible ways to split
and merge piles.</li>
<li>When we merge piles from <code>i</code> to <code>j</code> to make a
new pile, the cost is
<code>sum(i to j) + dp[i][mid] + dp[mid + 1][j]</code>, for all valid
<code>mid</code>.</li>
</ul>
<h3 id="space-optimization">Space Optimization:</h3>
<p>Instead of using a whole 2D array, we can save space by storing only
the needed states for the current and last iterations.</p>
<h3 id="example-code-python">Example Code (Python):</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> mergeStones(stones, k):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(stones)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> (n <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prefix sum to calculate ranges</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    prefix_sum <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        prefix_sum[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> prefix_sum[i] <span class="op">+</span> stones[i]</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP table</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: cost is 0 when there&#39;s one pile</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of the range</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> mid <span class="kw">in</span> <span class="bu">range</span>(i, j, k <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">min</span>(dp[i][j], dp[i][mid] <span class="op">+</span> dp[mid <span class="op">+</span> <span class="dv">1</span>][j])</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># If we can merge to one pile</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> (length <span class="op">-</span> <span class="dv">1</span>) <span class="op">%</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">+=</span> prefix_sum[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">-</span> prefix_sum[i]</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">mergeStones</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> prefixSum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        prefixSum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MAX_VALUE</span><span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mid <span class="op">=</span> i<span class="op">;</span> mid <span class="op">&lt;</span> j<span class="op">;</span> mid <span class="op">+=</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>mid<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> prefixSum<span class="op">[</span>j <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="c-implementation">C++ Implementation:</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> mergeStones<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> stones<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefixSum<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        prefixSum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> INT_MAX<span class="op">));</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>len<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span> <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>len <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">continue</span><span class="op">;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> mid <span class="op">=</span> i<span class="op">;</span> mid <span class="op">&lt;</span> j<span class="op">;</span> mid <span class="op">+=</span> k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> min<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i<span class="op">][</span>mid<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>mid <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> prefixSum<span class="op">[</span>j <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This way, we make the process to find the minimum cost to merge
stones more efficient. For more info, check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-to-merge-stones-simplified-medium.html">Dynamic
Programming Approach to Minimum Cost to Merge Stones</a>.</p>
<h2
id="complexity-analysis-of-minimum-cost-to-merge-stones-solution">Complexity
Analysis of Minimum Cost to Merge Stones Solution</h2>
<p>We will look at the complexity of the Minimum Cost to Merge Stones
problem. This mainly includes time and space complexities from the
dynamic programming method we use to solve it.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>We can break down the time complexity by looking at a few important
points.</p>
<ul>
<li><p><strong>State Representation</strong>: We use a DP table called
<code>dp[i][j]</code>. Here, <code>i</code> is the starting stone index
and <code>j</code> is the number of stones we want to merge. The DP
table size is (O(n^2)) for <code>n</code> stones. This is because there
are (n(n+1)/2) pairs of starting and ending indices.</p></li>
<li><p><strong>Transition Calculations</strong>: For each
<code>dp[i][j]</code>, we need to find all possible merges and their
costs. This means we check all partitions between <code>i</code> and
<code>i+j-1</code>. This leads to (O(n)) calculations for each
state.</p></li>
</ul>
<p>When we combine these points, the total time complexity is: [ O(n^3)
] This cubic complexity comes from the three nested loops. The first
loop is for the starting index. The second loop is for the length of the
segment. The innermost loop calculates the merge costs.</p>
<h3 id="space-complexity">Space Complexity</h3>
<p>We find the space complexity by looking at what we need to store in
the <code>dp</code> table.</p>
<ul>
<li><p><strong>DP Table</strong>: The <code>dp[i][j]</code> table needs
(O(n^2)) space to keep track of the minimum costs for merging
stones.</p></li>
<li><p><strong>Additional Space</strong>: We may need some extra space
for other variables like prefix sums. But this is usually small and fits
in the (O(n)) space.</p></li>
</ul>
<p>So, the total space complexity is: [ O(n^2) ]</p>
<p>In conclusion, the Minimum Cost to Merge Stones problem has a time
complexity of (O(n^3)) and a space complexity of (O(n^2)). This makes it
good for medium-sized inputs in competitive programming and algorithm
challenges. For more on dynamic programming, we can check other articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming: Minimum Cost Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-minimum-cost-to-merge-stones-problem">1. What is the
Minimum Cost to Merge Stones Problem?</h3>
<p>The Minimum Cost to Merge Stones problem is a well-known challenge in
dynamic programming. In this problem, we get an array of stones. The
goal is to merge all stones into one stone while keeping the cost low.
Each time we merge stones, we combine a certain number of them to make
one stone. The cost of merging is the total of the stones we combine. It
is important to know how to use dynamic programming for this problem to
find a good solution.</p>
<h3
id="how-does-dynamic-programming-apply-to-the-minimum-cost-to-merge-stones">2.
How does dynamic programming apply to the Minimum Cost to Merge
Stones?</h3>
<p>Dynamic programming helps us solve the Minimum Cost to Merge Stones
problem in an efficient way. We break the problem into smaller parts and
keep track of the results of these parts. This way, we do not repeat any
calculations. By defining a state that shows the cost of merging stones
from index <code>i</code> to <code>j</code>, we can calculate the
minimum costs step by step. This helps us build our solution and keeps
it fast.</p>
<h3
id="what-are-the-time-and-space-complexities-of-the-minimum-cost-to-merge-stones-solution">3.
What are the time and space complexities of the Minimum Cost to Merge
Stones solution?</h3>
<p>The time complexity for the Minimum Cost to Merge Stones solution
usually goes up to O(n^3). This happens because we have nested loops to
find the merging costs for all possible groups of stones. The space
complexity is about O(n^2) because we need a 2D array to store the
minimum merging costs. We can make some improvements to use less space.
But knowing these complexities is important for checking
performance.</p>
<h3
id="can-you-provide-a-java-implementation-of-the-minimum-cost-to-merge-stones">4.
Can you provide a Java implementation of the Minimum Cost to Merge
Stones?</h3>
<p>Sure! Here is a simple Java implementation of the Minimum Cost to
Merge Stones problem:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">mergeStones</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> stones<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> stones<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span> <span class="co">// Cannot merge</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> sum <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            sum<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> stones<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                sum<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> sum<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> stones<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> K<span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">+</span> len <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MAX_VALUE</span><span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> len<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> sum<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>i <span class="op">+</span> j<span class="op">]);</span></span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">((</span>len <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">%</span> <span class="op">(</span>K <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> sum<span class="op">[</span>i<span class="op">][</span>i <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-25"><a href="#cb10-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-26"><a href="#cb10-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-27"><a href="#cb10-27" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-28"><a href="#cb10-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-29"><a href="#cb10-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-30"><a href="#cb10-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="how-can-i-optimize-my-dynamic-programming-solution-for-the-minimum-cost-to-merge-stones">5.
How can I optimize my dynamic programming solution for the Minimum Cost
to Merge Stones?</h3>
<p>To make the dynamic programming solution for the Minimum Cost to
Merge Stones better, we can reduce the space we use. Instead of a full
2D array, we can use a one-dimensional array to keep only the results we
need. We can also use memoization to save the results of small problems.
This will help us cut down on calculations and make our solution faster
and use less space.</p>
<p>By answering these questions, we can understand the Minimum Cost to
Merge Stones problem and how to solve it using dynamic programming.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            