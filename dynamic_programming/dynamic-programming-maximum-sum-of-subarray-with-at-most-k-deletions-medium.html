
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Subarray with At Most k Deletions - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Sum of Subarray problem with at most k deletions using dynamic programming techniques.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Subarray with At Most k Deletions - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic Programming is a strong method we use to solve optimization
problems. We break these problems into simpler parts. One such problem
is finding the maximum sum of a subarray with at most k deletions. This
problem asks us to think about different ways to delete elements from
the array. Our goal is to maximize the sum of what remains. By using a
dynamic programming approach, we can find the best solution quickly. We
do this without having to redo calculations for parts that overlap. This
makes our work better and faster.</p>
<p>In this article, we will look closely at the Maximum Sum of Subarray
with At Most k Deletions problem. We will explain the problem statement
and its optimal substructure. We will show dynamic programming solutions
in Java, Python, and C++. We will also talk about ways to save space,
analyze time complexity, and point out common mistakes we should avoid
when we solve dynamic programming problems. Here is a list of the topics
we will talk about:</p>
<ul>
<li>Dynamic Programming Approach to Maximum Sum of Subarray with At Most
k Deletions - Medium</li>
<li>Understanding the Problem Statement for Maximum Sum of Subarray</li>
<li>Optimal Substructure and Overlapping Subproblems in Dynamic
Programming</li>
<li>Dynamic Programming Solution in Java for Maximum Sum of
Subarray</li>
<li>Dynamic Programming Solution in Python for Maximum Sum of
Subarray</li>
<li>Dynamic Programming Solution in C++ for Maximum Sum of Subarray</li>
<li>Space Optimization Techniques in Dynamic Programming</li>
<li>Analyzing Time Complexity of the Solution</li>
<li>Common Mistakes to Avoid in Dynamic Programming Problems</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-maximum-sum-of-subarray">Understanding
the Problem Statement for Maximum Sum of Subarray</h2>
<p>We have a problem to find the maximum sum of a subarray. We can
delete at most <code>k</code> elements to help us get the best sum. This
problem is an extension of the classic maximum subarray problem. We
usually solve that with Kadane’s algorithm. But here, we also get the
option to delete up to <code>k</code> items from the array.</p>
<h3 id="problem-definition">Problem Definition:</h3>
<p>We have an integer array <code>nums</code> and an integer
<code>k</code>. Our goal is to find the maximum sum of a subarray after
we delete at most <code>k</code> elements.</p>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>The length of <code>nums</code> can be up to <code>n</code> (1 ≤ n ≤
10^5).</li>
<li>Each number in <code>nums</code> can be from -10^4 to 10^4.</li>
<li>We can delete up to <code>k</code> elements and <code>k</code> is
not negative.</li>
</ul>
<h3 id="example">Example:</h3>
<p>For <code>nums = [1, -2, 0, 3]</code> and <code>k = 1</code>: - The
maximum sum of a subarray after deleting one element is <code>4</code>
(we delete <code>-2</code>, so the sum is <code>1 + 0 + 3</code>).</p>
<h3 id="approach">Approach:</h3>
<p>We can use dynamic programming to solve this problem in a good way.
We keep a DP array where <code>dp[i][j]</code> means the maximum sum of
subarrays that end at index <code>i</code> with exactly <code>j</code>
deletions. We can move between states by thinking about including or
excluding elements based on how many deletions we can make.</p>
<p>The transition can be explained like this: - If we do not delete the
current element:
<code>dp[i][j] = max(dp[i-1][j] + nums[i], nums[i])</code> - If we
delete the current element: <code>dp[i][j] = dp[i-1][j-1]</code> (only
if <code>j &gt; 0</code>)</p>
<p>In the end, we will find the maximum value in the last row of the DP
table. We check all possible deletions from <code>0</code> to
<code>k</code>.</p>
<p>This problem helps us understand dynamic programming better. It also
tests how fast the solution can be due to all the limits we have.</p>
<p>For more on similar dynamic programming methods, we can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2
id="optimal-substructure-and-overlapping-subproblems-in-dynamic-programming">Optimal
Substructure and Overlapping Subproblems in Dynamic Programming</h2>
<p>In dynamic programming, we need two main ideas to solve problems
well: <strong>optimal substructure</strong> and <strong>overlapping
subproblems</strong>. Knowing these ideas helps us when we want to find
the maximum sum of a subarray with at most k deletions.</p>
<h3 id="optimal-substructure">Optimal Substructure</h3>
<p>A problem shows optimal substructure when we can make a good solution
from good solutions of smaller problems. For our problem about the
maximum sum of a subarray with at most k deletions, this is how it
works:</p>
<ul>
<li><p>If <code>dp[i][j]</code> means the maximum sum of subarrays that
end at index <code>i</code> with at most <code>j</code> deletions, we
can write the relation like this:</p>
<p>[ dp[i][j] = (dp[i-1][j], dp[i-1][j-1] + nums[i]) ]</p>
<p>Here, <code>dp[i-1][j]</code> looks at the case where we do not
delete the element at index <code>i</code>. And
<code>dp[i-1][j-1] + nums[i]</code> is for the case where we include it
after deleting one element.</p></li>
</ul>
<h3 id="overlapping-subproblems">Overlapping Subproblems</h3>
<p>Overlapping subproblems happen when we solve the same smaller
problems many times while solving bigger problems. In our case:</p>
<ul>
<li>We can calculate <code>dp[i][j]</code> using results we already
found, like <code>dp[i-1][j]</code> and <code>dp[i-1][j-1]</code>. So
each <code>dp[i][j]</code> depends on earlier results. This leads to us
calculating the same things again unless we keep them stored.</li>
</ul>
<h3 id="example-1">Example</h3>
<p>Let’s look at a simple example to understand better:</p>
<p>Given the array <code>nums = [1, -2, 0, 3]</code> and
<code>k = 1</code>, we can do these calculations:</p>
<ul>
<li>For <code>dp[0][0]</code>, the value is <code>1</code> (there is
only one element).</li>
<li>For <code>dp[1][0]</code>, the maximum sum without any deletion is
<code>1</code>.</li>
<li>For <code>dp[1][1]</code>, we can either delete <code>-2</code> or
keep the previous maximum, which gives us <code>1</code>.</li>
</ul>
<p>The dynamic programming way uses optimal substructure and overlapping
subproblems to build the solution step by step.</p>
<p>This method is very important in problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray</a> where we use similar ideas to get the
best results.</p>
<h2
id="dynamic-programming-solution-in-java-for-maximum-sum-of-subarray">Dynamic
Programming Solution in Java for Maximum Sum of Subarray</h2>
<p>We want to find the maximum sum of a subarray with at most
<code>k</code> deletions using dynamic programming in Java. Here is how
we can do it:</p>
<ol type="1">
<li><p><strong>Define the DP Table</strong>: We will use a 2D array
called <code>dp</code>. The value <code>dp[i][j]</code> shows the
maximum sum we can get from the first <code>i</code> elements of the
array with <code>j</code> deletions allowed.</p></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li>When <code>j = 0</code>, <code>dp[i][0]</code> is just the maximum
subarray sum from the first <code>i</code> elements without any
deletions. We can find this using Kadane’s algorithm.</li>
<li>When <code>i = 0</code>, <code>dp[0][j] = 0</code> for all
<code>j</code> because there are no elements to look at.</li>
</ul></li>
<li><p><strong>Transition Formula</strong>: For each element
<code>nums[i-1]</code>, we can choose to:</p>
<ul>
<li>Include it in the subarray. We add it to the previous maximum
subarray sum without going over the deletion limit.</li>
<li>Delete it. We then check the maximum sum with one less
deletion.</li>
</ul></li>
</ol>
<p>We can write the transition like this:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">]);</span></span></code></pre></div>
<ol start="4" type="1">
<li><strong>Final Result</strong>: The answer is the maximum value in
the last row of the DP table for any <code>j</code> from <code>0</code>
to <code>k</code>.</li>
</ol>
<p>Here is the Java code for this:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumSumSubarray <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumAfterKDeletions</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case initialization</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// No elements to consider</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Include nums[i-1]</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                <span class="co">// If we can delete an element</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find the maximum sum with at most k deletions</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>        MaximumSumSubarray solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MaximumSumSubarray</span><span class="op">();</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of subarray with at most &quot;</span> <span class="op">+</span> k <span class="op">+</span> <span class="st">&quot; deletions: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">maxSumAfterKDeletions</span><span class="op">(</span>nums<span class="op">,</span> k<span class="op">));</span> <span class="co">// Output: 4</span></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This Java solution helps us find the maximum sum of a subarray with
at most <code>k</code> deletions. It uses dynamic programming ideas. We
take advantage of optimal substructure and overlapping problems that
come up in these types of tasks.</p>
<h2
id="dynamic-programming-solution-in-python-for-maximum-sum-of-subarray">Dynamic
Programming Solution in Python for Maximum Sum of Subarray</h2>
<p>To find the maximum sum of a subarray with at most <code>k</code>
deletions, we use dynamic programming. We can make a 2D DP array. Here,
<code>dp[i][j]</code> shows the maximum sum of a subarray ending at
index <code>i</code> with <code>j</code> deletions.</p>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maximum_sum(nums, k):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP array</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> nums[<span class="dv">0</span>]</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> <span class="bu">max</span>(dp[<span class="dv">0</span>][j <span class="op">-</span> <span class="dv">1</span>], nums[<span class="dv">0</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> nums[i], nums[i])</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> nums[i], dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the maximum value from the last row</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>]</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> maximum_sum(nums, k)</span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 4</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a DP table
<code>dp</code>. It holds the maximum sum of subarrays ending at index
<code>i</code> with <code>j</code> deletions.</li>
<li><strong>Base Case</strong>: The first element sets
<code>dp[0][0]</code> to <code>nums[0]</code>. For
<code>j &gt; 0</code>, it tracks the maximum sum with deletions.</li>
<li><strong>DP Transition</strong>:
<ul>
<li>If we do not make deletions, we can take the current number or add
it to the previous maximum (no deletions).</li>
<li>If deletions are allowed, we check both cases. One where we delete
the current element and one where we do not.</li>
</ul></li>
<li><strong>Result Extraction</strong>: The maximum value in the last
row of the DP table gives the maximum sum we want.</li>
</ul>
<p>This dynamic programming method finds the maximum sum of a subarray
with at most <code>k</code> deletions. It works in <code>O(n*k)</code>
time and uses <code>O(n*k)</code> space.</p>
<p>For more about dynamic programming methods, you can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2
id="dynamic-programming-solution-in-c-for-maximum-sum-of-subarray">Dynamic
Programming Solution in C++ for Maximum Sum of Subarray</h2>
<p>To find the maximum sum of a subarray with at most <code>k</code>
deletions using dynamic programming in C++, we define a table
<code>dp[i][j]</code>. Here:</p>
<ul>
<li><code>i</code> is the index in the array.</li>
<li><code>j</code> is the number of deletions we use.</li>
</ul>
<p>The value of <code>dp[i][j]</code> keeps the maximum sum we can get
using the first <code>i</code> elements of the array and <code>j</code>
deletions.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>We create a 2D array <code>dp</code> of size
<code>n x (k + 1)</code>. We fill it with 0. Here, <code>n</code> is the
length of the input array.</li>
<li>We set <code>dp[0][0] = arr[0]</code>. This is because we can only
take the first element without deleting anything.</li>
</ul></li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>We loop through each element <code>i</code> from 0 to
<code>n-1</code>.</li>
<li>For each element, we loop through each possible number of deletions
<code>j</code> from 0 to <code>k</code>.</li>
<li>We update <code>dp[i][j]</code> by looking at:
<ul>
<li>Not deleting the current element:
<code>dp[i][j] = max(dp[i][j], dp[i-1][j] + arr[i])</code></li>
<li>Deleting the current element (only if <code>j &gt; 0</code>):
<code>dp[i][j] = max(dp[i][j], dp[i-1][j-1])</code></li>
</ul></li>
</ul></li>
<li><strong>Result Extraction</strong>:
<ul>
<li>We find the maximum value in the last row of the <code>dp</code>
table. This considers all possible deletions from <code>0</code> to
<code>k</code>.</li>
</ul></li>
</ol>
<h3 id="c-implementation">C++ Implementation:</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumAfterKDeletions<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Initialize the first element</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Not deleting the current element</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Deleting the current element</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Get the maximum sum possible with at most k deletions</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSum <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        maxSum <span class="op">=</span> max<span class="op">(</span>maxSum<span class="op">,</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Sum of Subarray with at most &quot;</span> <span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot; deletions: &quot;</span> <span class="op">&lt;&lt;</span> maxSumAfterKDeletions<span class="op">(</span>arr<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code:</h3>
<ul>
<li>The function <code>maxSumAfterKDeletions</code> does the dynamic
programming solution.</li>
<li>It starts the DP table and goes through the input array. It checks
both options of deleting and not deleting.</li>
<li>In the end, it finds the maximum sum by looking at all possible
values in the last row of the DP table.</li>
</ul>
<p>This C++ code shows a simple way to solve the problem of finding the
maximum sum of a subarray with at most <code>k</code> deletions using
dynamic programming. If you want to learn more about similar problems,
check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Maximum
Subarray</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-medium.html">Minimum
Path Sum</a>.</p>
<h2 id="space-optimization-techniques-in-dynamic-programming">Space
Optimization Techniques in Dynamic Programming</h2>
<p>In dynamic programming, space optimization techniques are very
important. They help us reduce the memory used by algorithms while
keeping them efficient. Here are some good ways to optimize space in
dynamic programming problems. We focus on the maximum sum of subarray
with at most k deletions.</p>
<ol type="1">
<li><strong>Use Iterative Approaches Over Recursive</strong>:
<ul>
<li>We should prefer iterative methods. These use a bottom-up DP table.
This way, we avoid the extra memory used by recursive stack space.</li>
</ul></li>
<li><strong>Reduce the Size of the DP Table</strong>:
<ul>
<li>Instead of keeping a full table for all subproblems, we can only
store the previous states that we really need.</li>
<li>For example, when we calculate the maximum sum of subarrays, we
often only need the last two rows of the DP table.</li>
</ul></li>
<li><strong>Use One-Dimensional Arrays</strong>:
<ul>
<li>If the state only depends on the last state, we can use a
one-dimensional array.</li>
<li>Example: In the maximum sum of subarray problem, we can find the
current state using just the last state. This change reduces space
complexity from O(n^2) to O(n).</li>
</ul></li>
<li><strong>In-Place Modifications</strong>:
<ul>
<li>When we can, we should change the input array to save space. We need
to make sure that this does not change the final results.</li>
</ul></li>
</ol>
<h3 id="example-implementation-in-java">Example Implementation in
Java</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumAfterKDeletions</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Sum so far</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> del <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> del <span class="op">&lt;=</span> k<span class="op">;</span> del<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&gt;=</span> del<span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> del<span class="op">]);</span> <span class="co">// Consider deletion</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-implementation-in-python">Example Implementation in
Python</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_after_k_deletions(arr, k):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> arr[i <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># Sum so far</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> del_count <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n, del_count <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i], dp[i <span class="op">-</span> del_count])  <span class="co"># Consider deletion</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="example-implementation-in-c">Example Implementation in C++</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumAfterKDeletions<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Sum so far</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> del <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> del <span class="op">&lt;=</span> k<span class="op">;</span> del<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n<span class="op">;</span> i <span class="op">&gt;=</span> del<span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> del<span class="op">]);</span> <span class="co">// Consider deletion</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ol start="5" type="1">
<li><strong>Iterative Updates</strong>:
<ul>
<li>Instead of keeping the whole DP table, we can update the values in
the same array. We only keep the results we need for the
calculations.</li>
</ul></li>
<li><strong>Memoization</strong>:
<ul>
<li>We can use memoization to store results of subproblems only when we
need them. This can really help reduce the space we use.</li>
</ul></li>
</ol>
<p>When we use these space optimization techniques in dynamic
programming, we can improve performance. This makes algorithms work
better with memory. For more information about dynamic programming
principles, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2 id="analyzing-time-complexity-of-the-solution">Analyzing Time
Complexity of the Solution</h2>
<p>When we solve the problem of <strong>Maximum Sum of Subarray with At
Most k Deletions</strong> using dynamic programming, we need to look at
the time complexity. This helps us see how good our solution is.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>We have an array <code>arr</code> with size <code>n</code> and an
integer <code>k</code>. In the dynamic programming approach, we create a
DP table. In this table, <code>dp[i][j]</code> shows the maximum sum of
the subarray that ends at index <code>i</code> with at most
<code>j</code> deletions.</p>
<p>We can write the recurrence relation like this:</p>
<ul>
<li><p>If we do not delete the current element: [ dp[i][j] = dp[i -
1][j] + arr[i] ]</p></li>
<li><p>If we delete the current element: [ dp[i][j] = dp[i - 1][j - 1]
]</p></li>
</ul>
<p>We decide to take the current element or delete it. This helps us
build our solution.</p>
<h3 id="time-complexity-analysis">Time Complexity Analysis</h3>
<ol type="1">
<li><p><strong>DP Table Construction</strong>: The DP table has
dimensions of <code>(n+1) x (k+1)</code>. So, filling this table will
take: [ O(n k) ]</p></li>
<li><p><strong>Final Result Calculation</strong>: After we build the DP
table, we need to find the maximum value from the last row. This takes:
[ O(k) ]</p></li>
</ol>
<h3 id="overall-time-complexity">Overall Time Complexity</h3>
<p>When we combine these steps, the overall time complexity of the
solution is: [ O(n k) ]</p>
<h3 id="space-complexity-consideration">Space Complexity
Consideration</h3>
<p>The space complexity of this solution is (O(n k)) because of the DP
table. But we can make it better to (O(k)). We just need to store the
last row of the DP table. The current state only depends on the previous
state.</p>
<h3 id="example-implementation-in-python-1">Example Implementation in
Python</h3>
<p>Here is a simple implementation that shows the time complexity
ideas:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumAfterKDeletions(arr, k):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(i, k <span class="op">+</span> <span class="dv">1</span>)):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> arr[i <span class="op">-</span> <span class="dv">1</span>], dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[n][j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>))</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>]</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumAfterKDeletions(arr, k))  <span class="co"># Output: 4</span></span></code></pre></div>
<p>This Python function shows how the solution works and follows the
time complexity of (O(n k)). This makes it good for medium sizes of (n)
and (k).</p>
<h2 id="common-mistakes-to-avoid-in-dynamic-programming-problems">Common
Mistakes to Avoid in Dynamic Programming Problems</h2>
<p>Dynamic programming (DP) is a strong method for solving optimization
problems. But we can easily make small mistakes. These mistakes can lead
to wrong answers or slow algorithms. Here are some common mistakes to
watch out for in dynamic programming problems:</p>
<ol type="1">
<li><strong>Not Identifying the Optimal Substructure</strong>:
<ul>
<li>Before we use DP, we need to check if we can break the problem into
smaller parts. If we can build the best solution from the best solutions
of its smaller parts, then we have an optimal substructure.</li>
</ul></li>
<li><strong>Ignoring Overlapping Subproblems</strong>:
<ul>
<li>DP works best when we solve the same small problems many times. If
we calculate the same small problem again and again, we should use
memoization or tabulation to keep the results.</li>
</ul></li>
<li><strong>Misdefining State Variables</strong>:
<ul>
<li>We must clearly define the state variables that will show the
problem. If we define these variables wrong, we can get wrong
answers.</li>
</ul></li>
<li><strong>Incorrect Transition Formula</strong>:
<ul>
<li>The transition formula tells us how to make a solution from
subproblems. We need to make sure it matches the problem’s needs.
Mistakes in this formula can give us wrong values in the DP table.</li>
</ul></li>
<li><strong>Forgetting to Handle Base Cases</strong>:
<ul>
<li>Base cases are very important for starting our DP solution. If we
miss these cases or define them wrong, we can get errors when running or
wrong final answers.</li>
</ul></li>
<li><strong>Using Incorrect Data Types</strong>:
<ul>
<li>We need to check that the data types in our DP tables can handle the
values we are calculating. For example, if we use an integer type for
big sums, it can cause overflow.</li>
</ul></li>
<li><strong>Not Considering All Conditions</strong>:
<ul>
<li>DP often needs to think about many conditions. For example, we might
need to decide if we should include an element. We have to make sure we
think about all situations in the transition states.</li>
</ul></li>
<li><strong>Neglecting Space Optimization</strong>:
<ul>
<li>If the problem allows, we should save space by only keeping the
necessary states. We don’t need to keep a full DP table if we can avoid
it.</li>
</ul></li>
<li><strong>Not Testing Edge Cases</strong>:
<ul>
<li>We should always test our solution with edge cases. This means
testing things like empty inputs or inputs that can cause problems at
the limits.</li>
</ul></li>
<li><strong>Failure to Analyze Complexity</strong>:
<ul>
<li>After we create a DP solution, we should look at its time and space
complexity. This helps us see how good and scalable our solution
is.</li>
</ul></li>
</ol>
<p>By knowing these common mistakes, we can get better at dynamic
programming. We can create stronger solutions. For more information
about dynamic programming problems, we can read articles on topics like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-subarray-with-at-most-k-deletions-problem">1.
What is the maximum sum of subarray with at most k deletions
problem?</h3>
<p>The maximum sum of subarray with at most k deletions problem is about
finding the biggest sum of a continuous subarray in a given array. We
can delete up to k elements. We can solve this problem well by using
dynamic programming. This method helps us take advantage of the best
parts of the problem and the parts that repeat. By setting it up right,
we can find the best sum while following the deletion rules.</p>
<h3
id="how-can-dynamic-programming-be-applied-to-solve-the-maximum-sum-of-subarray-with-at-most-k-deletions">2.
How can dynamic programming be applied to solve the maximum sum of
subarray with at most k deletions?</h3>
<p>Dynamic programming works great for our problem. We can create a
state that shows the maximum sum we can get up to a certain index with a
certain number of deletions. Then, we can build a relation that helps us
find the maximum sum step by step. We update our state based on what we
calculated before and what the current element adds. This way, we get
the best solution.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-solution-for-the-maximum-sum-of-subarray-with-at-most-k-deletions">3.
What is the time complexity of the dynamic programming solution for the
maximum sum of subarray with at most k deletions?</h3>
<p>The time complexity of the dynamic programming way to solve our
problem is O(n * k). Here, n is the length of the array and k is the
maximum number of deletions we can make. This happens because for every
element in the array, we might have to check all the deletion options up
to k. This makes a nested loop structure.</p>
<h3
id="can-you-provide-a-sample-code-for-solving-the-maximum-sum-of-subarray-with-at-most-k-deletions-in-python">4.
Can you provide a sample code for solving the maximum sum of subarray
with at most k deletions in Python?</h3>
<p>Sure! Here is a simple Python code to solve the maximum sum of
subarray with at most k deletions:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumAfterKDeletions(arr, k):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> arr[<span class="dv">0</span>] <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">+</span> arr[i], dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span>)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[n <span class="op">-</span> <span class="dv">1</span>])</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">3</span>]</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumAfterKDeletions(arr, k))  <span class="co"># Output: 4</span></span></code></pre></div>
<h3
id="what-common-mistakes-should-be-avoided-when-solving-dynamic-programming-problems-like-this">5.
What common mistakes should be avoided when solving dynamic programming
problems like this?</h3>
<p>When we solve the maximum sum of subarray with at most k deletions,
we should avoid some common mistakes. First, we need to initialize the
dp array correctly. We also must not forget edge cases like when k is 0.
It is important to define the state transitions well. Lastly, we should
understand the optimal substructure idea, as it helps us make a good
dynamic programming solution.</p>
<p>For more insights into dynamic programming, we can check out related
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-minimum-path-sum-in-a-grid-no-obstacles-easy.html">Dynamic
Programming: Minimum Path Sum in a Grid</a> to understand similar ideas
better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            