
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Domino and Tromino Tiling (Advanced) - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover advanced techniques in dynamic programming with our guide on domino and tromino tiling. Challenge your skills today!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Domino and Tromino Tiling (Advanced) - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic Programming is a strong way to solve tough problems. We break
these problems into smaller and easier parts. The Domino and Tromino
Tiling problem is a well-known example. It asks how many ways we can
fill a 2 x n board using dominoes (1 x 2 tiles) and trominoes (L-shaped
tiles). We can solve this problem well with dynamic programming. This
method helps us build solutions step by step. We can also save results
to avoid doing the same calculations again.</p>
<p>In this article, we will look closely at the Domino and Tromino
Tiling problem. We will check out both recursive and iterative dynamic
programming methods. We will show how to implement them in Java, Python,
and C++. We will also do a complete analysis of their complexity. Plus,
we will point out common mistakes and give tips to help us master this
tough dynamic programming problem.</p>
<ul>
<li>Dynamic Programming Techniques for Domino and Tromino Tiling
Advanced Hard Problem</li>
<li>Understanding the Domino and Tromino Tiling Problem</li>
<li>Dynamic Programming Approach for Domino and Tromino Tiling in
Java</li>
<li>Dynamic Programming Approach for Domino and Tromino Tiling in
Python</li>
<li>Dynamic Programming Approach for Domino and Tromino Tiling in
C++</li>
<li>Recursive Solution with Memoization for Domino and Tromino
Tiling</li>
<li>Iterative Dynamic Programming Solution for Domino and Tromino
Tiling</li>
<li>Complexity Analysis of Domino and Tromino Tiling Solutions</li>
<li>Common Pitfalls and Tips for Domino and Tromino Tiling</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-domino-and-tromino-tiling-problem">Understanding
the Domino and Tromino Tiling Problem</h2>
<p>The Domino and Tromino Tiling problem is a well-known problem in
math. We often use dynamic programming to solve it. The goal is to count
how many ways we can tile a 2 x n board using dominoes (1 x 2 tiles) and
trominoes (1 x 3 tiles).</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Dominoes:</strong> They cover two squares that are next to
each other on the board.</li>
<li><strong>Trominoes:</strong> They cover three squares in a straight
line.</li>
<li>Our task is to find out how many different ways we can fill a 2 x n
board.</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The height of the board is always 2.</li>
<li>The width of the board can change (n can be any non-negative
number).</li>
</ul>
<h3 id="recurrence-relation">Recurrence Relation</h3>
<p>We can find the number of ways to tile a 2 x n board with this
relation: - Let <code>dp[n]</code> be the number of ways to tile a 2 x n
board. - The relation looks like this:</p>
<p>[ dp[n] = dp[n-1] + dp[n-2] + 2 dp[n-3] ]</p>
<p>Where: - <code>dp[n-1]</code> counts placing a domino vertically. -
<code>dp[n-2]</code> counts placing two dominoes horizontally. -
<code>2 \cdot dp[n-3]</code> counts placing a tromino, which can go in
two ways.</p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code>: We have one way to tile a 2 x 0 board (just
do nothing).</li>
<li><code>dp[1] = 1</code>: There is only one way to put a single
vertical domino.</li>
<li><code>dp[2] = 2</code>: We have two ways to tile a 2 x 2 board (two
vertical dominoes or two horizontal dominoes).</li>
<li><code>dp[3] = 4</code>: We can tile a 2 x 3 board in four different
ways.</li>
</ul>
<h3 id="example">Example</h3>
<p>For a board that is 2 x 4: - We can have different setups with
dominoes and trominoes.</p>
<p>The dynamic programming method helps us compute the number of ways to
tile the board efficiently. We build on results we already found. This
shows how powerful dynamic programming can be in solving math
problems.</p>
<p>If we want to learn more about dynamic programming, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number (Easy)</a> for basic ideas.</p>
<h2
id="dynamic-programming-approach-for-domino-and-tromino-tiling-in-java">Dynamic
Programming Approach for Domino and Tromino Tiling in Java</h2>
<p>We can solve the Domino and Tromino Tiling problem using dynamic
programming. The main idea is to create a formula based on how many ways
we can fill a 2 x n board with 1 x 2 dominoes and 2 x 1 trominoes.</p>
<h3 id="recurrence-relation-1">Recurrence Relation</h3>
<p>Let <code>dp[n]</code> mean the number of ways to fill a 2 x n board.
We can define the formula like this:</p>
<ul>
<li><strong>Base Cases</strong>:
<ul>
<li><code>dp[0] = 1</code>: There is one way to fill an empty
board.</li>
<li><code>dp[1] = 1</code>: There is one way to fill a 2 x 1 board (by
using one domino).</li>
<li><code>dp[2] = 2</code>: There are two ways to fill a 2 x 2 board
(either two dominoes or one tromino).</li>
</ul></li>
<li><strong>Recurrence Relation</strong>:
<ul>
<li><p>For <code>n &gt;= 3</code>:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> </span></code></pre></div>
<p>The first part (<code>dp[n - 1]</code>) is for putting a domino
vertically. The second part (<code>dp[n - 2] * 2</code>) is for putting
a tromino horizontally.</p></li>
</ul></li>
</ul>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is how we can write the Java code for the dynamic programming
method for Domino and Tromino Tiling:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DominoTrominoTiling <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numTilings</span><span class="op">(</span><span class="dt">int</span> N<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>N <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>N <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>N <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>N <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">])</span> <span class="op">%</span> <span class="dv">1000000007</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>N<span class="op">];</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        DominoTrominoTiling tiling <span class="op">=</span> <span class="kw">new</span> <span class="fu">DominoTrominoTiling</span><span class="op">();</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> N <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example input</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to tile a 2x&quot;</span> <span class="op">+</span> N <span class="op">+</span> <span class="st">&quot; board: &quot;</span> <span class="op">+</span> tiling<span class="op">.</span><span class="fu">numTilings</span><span class="op">(</span>N<span class="op">));</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<p>We create a method called <code>numTilings</code> which takes an
integer <code>N</code> as input. This <code>N</code> is the width of the
board.</p>
<p>We make an array <code>dp</code> where <code>dp[i]</code> saves how
many ways we can fill the board of width <code>i</code>.</p>
<p>The method fills the <code>dp</code> array using the formula we
made.</p>
<p>In the end, it gives back how many ways to fill a 2 x N board, using
<code>1000000007</code> to keep the numbers small.</p>
<p>This dynamic programming way helps us find the number of ways to fill
the board fast. The time needed is O(N) and the space we use is
O(N).</p>
<h2
id="dynamic-programming-approach-for-domino-and-tromino-tiling-in-python">Dynamic
Programming Approach for Domino and Tromino Tiling in Python</h2>
<p>The Domino and Tromino Tiling problem is about filling a 2 x n board
with 1 x 2 dominoes and L-shaped trominoes. Our goal is to count how
many ways we can completely tile the board.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>To solve this problem using dynamic programming, we define a function
<code>countTilings(n)</code>. This function gives us the number of ways
to tile a 2 x n board. We can get the recurrence relation by thinking
about placing pieces:</p>
<ul>
<li>If we put a vertical domino in the first column, we have a 2 x (n-1)
board left.</li>
<li>If we put two horizontal dominoes in the first two rows, we have a 2
x (n-2) board left.</li>
<li>If we place a tromino that covers the first row and two columns, we
also have a 2 x (n-2) board left. There are two ways to do this.</li>
</ul>
<p>So, the recurrence relation is:</p>
<p>[ (n) = (n-1) + (n-2) + 2 (n-3) ]</p>
<h3 id="base-cases-1">Base Cases</h3>
<ul>
<li><code>ways(0)</code> = 1 (this is an empty board)</li>
<li><code>ways(1)</code> = 1 (here is one vertical domino)</li>
<li><code>ways(2)</code> = 2 (we can have two vertical dominoes or two
horizontal dominoes)</li>
<li><code>ways(3)</code> = 5 (there are several combinations of dominoes
and trominoes)</li>
</ul>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countTilings(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> n <span class="op">==</span> <span class="dv">3</span>:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">5</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Dynamic Programming Array</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>], dp[<span class="dv">2</span>], dp[<span class="dv">3</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">4</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>] <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp[i <span class="op">-</span> <span class="dv">3</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Number of ways to tile a 2 x </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss"> board: </span><span class="sc">{</span>countTilings(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>The function starts by setting base cases for <code>n = 0</code>,
<code>n = 1</code>, <code>n = 2</code>, and <code>n = 3</code>.</li>
<li>We create a list called <code>dp</code> to store the number of ways
for each board size up to <code>n</code>.</li>
<li>We use a loop to calculate the number of ways for each
<code>n</code> from 4 to the input <code>n</code> based on the
recurrence relation.</li>
<li>In the end, the function gives back the number of ways to tile the 2
x n board.</li>
</ul>
<p>This dynamic programming way is efficient. The time complexity is
(O(n)) and the space complexity is (O(n)).</p>
<h2
id="dynamic-programming-approach-for-domino-and-tromino-tiling-in-c">Dynamic
Programming Approach for Domino and Tromino Tiling in C++</h2>
<p>We can solve the Domino and Tromino Tiling problem in a smart way
using dynamic programming in C++. This problem asks us to find how many
ways we can fill a 2 x n board with 1 x 2 dominoes and 2 x 1
trominoes.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have an integer <code>n</code>. Our goal is to find how many ways
we can completely fill a 2 x n board with the tiles we can use.</p>
<h3 id="dynamic-programming-solution-1">Dynamic Programming
Solution</h3>
<p>To solve this, we will create a dynamic programming array called
<code>dp</code>. Here, <code>dp[i]</code> shows the number of ways to
fill a 2 x i board. We can find the relation like this:</p>
<ul>
<li>To fill a 2 x n board, we can:
<ul>
<li>Put a vertical domino in the first column. This leaves a 2 x (n-1)
board: <code>dp[n-1]</code></li>
<li>Place two horizontal dominoes in the first two rows. This leaves a 2
x (n-2) board: <code>dp[n-2]</code></li>
<li>Use a tromino (L-shaped) that takes three squares. It can go in two
ways, covering positions (0,0), (1,0), (0,1) or (0,0), (0,1), (1,1).
This also leaves a 2 x (n-2) board: <code>dp[n-2]</code></li>
</ul></li>
</ul>
<p>So, the relation is:</p>
<pre><code>dp[n] = dp[n-1] + dp[n-2] * 2</code></pre>
<h3 id="base-cases-2">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code>: An empty board has one way to be filled (do
nothing).</li>
<li><code>dp[1] = 1</code>: There is one way to fill a 2 x 1 board (one
vertical domino).</li>
</ul>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWaysToTile<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n<span class="op">;</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Enter the length of the board (n): &quot;</span><span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cin<span class="op"> &gt;&gt;</span> n<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> countWaysToTile<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of ways to tile a 2 x &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; board: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The function <code>countWaysToTile</code> finds the number of ways
to fill a 2 x n board by using dynamic programming.</li>
<li>We start by setting up the <code>dp</code> vector. Then we set the
base cases and fill the array based on the relation we made.</li>
<li>At the end, the main function gets user input for <code>n</code> and
shows the result.</li>
</ul>
<p>This C++ solution works well to find how many ways we can tile a
board. It uses dynamic programming to get the best performance. For more
learning about dynamic programming, we can check topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2
id="recursive-solution-with-memoization-for-domino-and-tromino-tiling">Recursive
Solution with Memoization for Domino and Tromino Tiling</h2>
<p>We can solve the Domino and Tromino Tiling problem using a recursive
method with memoization. This helps us avoid doing the same calculations
over and over again. The main idea is to find the number of ways to tile
a length <code>n</code> using dominoes (2x1) and trominoes (1x3). We
store the results for lengths we have already calculated to make our
solution faster.</p>
<h3 id="recursive-function-definition">Recursive Function
Definition</h3>
<p>Let <code>dp[n]</code> show the number of ways to tile a strip of
length <code>n</code>. We can define our relation like this:</p>
<ul>
<li>If we place a domino, we look at <code>dp[n-2]</code> because a
domino takes up 2 units.</li>
<li>If we place a tromino, we can put it horizontally. This means we
look at <code>dp[n-3]</code>. Placing it vertically does not work in a
single strip.</li>
</ul>
<p>So, we can write the relation as:</p>
<pre><code>dp[n] = dp[n-1] + dp[n-2] + dp[n-3]</code></pre>
<h3 id="base-cases-3">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code> (There is one way to tile a strip of length
0)</li>
<li><code>dp[1] = 1</code> (There is one way to tile a strip of length 1
with one domino)</li>
<li><code>dp[2] = 2</code> (There are two ways: two dominoes or one
tromino)</li>
<li><code>dp[3] = 4</code> (There are four ways: three dominoes, one
tromino plus one domino, one domino plus one tromino, and one tromino
plus one domino)</li>
</ul>
<h3 id="implementation-in-python">Implementation in Python</h3>
<p>Here is the Python code for the recursive solution with
memoization:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> domino_tromino_tiling(n):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dp(n):</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="kw">in</span> memo:</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[n]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># We calculate recursively</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        memo[n] <span class="op">=</span> dp(n <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span> dp(n <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span> dp(n <span class="op">-</span> <span class="dv">3</span>)</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[n]</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp(n)</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Ways to tile a strip of length </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>domino_tromino_tiling(n)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<p>We create a helper function <code>dp(n)</code> that checks if we
already have the answer for <code>n</code>. If we do, it gives that
answer back. If not, we use our relation to find the value. The function
then returns how many ways we can tile a strip of length
<code>n</code>.</p>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity:</strong> O(n), because we calculate each
state only once.</li>
<li><strong>Space Complexity:</strong> O(n) for the memoization
storage.</li>
</ul>
<p>This recursive solution with memoization gives us a good way to solve
the Domino and Tromino Tiling problem. It changes the slow exponential
time of a simple method to a fast linear time. This makes it good for
bigger values of <code>n</code>.</p>
<h2
id="iterative-dynamic-programming-solution-for-domino-and-tromino-tiling">Iterative
Dynamic Programming Solution for Domino and Tromino Tiling</h2>
<p>We can solve the Domino and Tromino Tiling problem with an iterative
dynamic programming method. We will build a DP table. This table shows
how many ways we can tile a 2 x n board. We base our solution on how we
place the last tile.</p>
<ul>
<li>If the last tile is a vertical domino, the rest of the board is a 2
x (n-1) board.</li>
<li>If the last tile is a horizontal domino, we need another horizontal
domino. This leaves us with a 2 x (n-2) board.</li>
<li>If we place a tromino, it can cover three squares in different ways.
This gives us different paths from the previous states.</li>
</ul>
<p>We can write the recurrence relation like this:</p>
<pre><code>dp[n] = dp[n-1] + dp[n-2] * 2</code></pre>
<p>In this relation: - <code>dp[n-1]</code> is for the case where the
last tile is a vertical domino. - <code>dp[n-2] * 2</code> is for the
cases where the last tiles are two horizontal dominoes or one
tromino.</p>
<p>We also have base cases: - <code>dp[0] = 1</code> (an empty board has
one way to be tiled). - <code>dp[1] = 1</code> (a 2 x 1 board can only
be tiled with one vertical domino). - <code>dp[2] = 2</code> (a 2 x 2
board can be tiled with either two vertical dominoes or two horizontal
dominoes).</p>
<p>Next, we show how to implement this in Python, Java, and C++.</p>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> domino_tromino_tiling(n):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">2</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>], dp[<span class="dv">1</span>], dp[<span class="dv">2</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">2</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp[i <span class="op">-</span> <span class="dv">2</span>]</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DominoTromino <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">dominoTrominoTiling</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dominoTrominoTiling<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This iterative dynamic programming solution works well. It calculates
the number of ways to tile a 2 x n board with dominoes and trominoes. It
uses O(n) time and O(n) space.</p>
<h2
id="complexity-analysis-of-domino-and-tromino-tiling-solutions">Complexity
Analysis of Domino and Tromino Tiling Solutions</h2>
<p>We look at the complexity of the Domino and Tromino Tiling problem.
This means we need to understand both time and space complexities for
different ways to solve this problem.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li>The simple recursive method has an exponential time complexity of
(O(2^n)). Each time we call the function, it can create two more calls
for tiling. We keep doing this until we reach the base case.</li>
</ul></li>
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>The dynamic programming method makes the time complexity much
better, reducing it to (O(n)). We store results of smaller problems (the
number of ways to tile a floor of length (n)) in an array. Each state
depends on the ones before it. This gives us a linear solution.</li>
</ul></li>
<li><strong>Iterative DP Solution</strong>:
<ul>
<li>The iterative dynamic programming method also has a time complexity
of (O(n). We fill the DP table in one go.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li>The space complexity for the recursive method is (O(n)). This is
because of the call stack. The maximum depth of recursion can go up to
(n).</li>
</ul></li>
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>For the dynamic programming method, we can cut down the space
complexity to (O(1)). We only need to keep track of the last two values
instead of a whole array. The current state only depends on the previous
two states.</li>
</ul></li>
<li><strong>Memoization</strong>:
<ul>
<li>If we use a memoization method with recursion, the space complexity
stays at (O(n)). This is for storing results of smaller problems in a
hash map or array.</li>
</ul></li>
</ol>
<h3 id="example-complexity-calculation">Example Complexity
Calculation</h3>
<p>Letâ€™s say (n) is 10 (the length of the floor). We can calculate the
number of tiling setups like this:</p>
<ul>
<li>For recursive: (O(2^{10}) = 1024) ways (not good)</li>
<li>For dynamic programming: (O(10) = 10) ways (good)</li>
</ul>
<p>In conclusion, using dynamic programming techniques for the Domino
and Tromino Tiling problem gives us a big boost in both time and space
complexities. This makes it the best choice for larger input sizes.</p>
<h2 id="common-pitfalls-and-tips-for-domino-and-tromino-tiling">Common
Pitfalls and Tips for Domino and Tromino Tiling</h2>
<p>When we work on the Domino and Tromino Tiling problem with dynamic
programming, we can face some common mistakes that slow us down. Here
are some important tips to help us avoid those mistakes and make our
work better.</p>
<ul>
<li><p><strong>State Definition</strong>: We need to clearly say what
the state means. For example, if <code>dp[i]</code> shows how many ways
we can tile a board of size <code>i</code>, we must understand how to
move from one state to another.</p></li>
<li><p><strong>Base Cases</strong>: We should set our base cases
correctly. For Domino and Tromino Tiling, we usually have:</p>
<ul>
<li><code>dp[0] = 1</code> (one way to tile an empty board)</li>
<li><code>dp[1] = 0</code> (no way to fill a 1xN board)</li>
<li><code>dp[2] = 1</code> (one way to fill a 2xN board with
dominos)</li>
<li><code>dp[3] = 2</code> (two ways to fill a 3xN board)</li>
</ul></li>
<li><p><strong>Indexing Errors</strong>: We must watch out for array
indexing. Errors like off-by-one happen a lot, especially when we loop
or access the <code>dp</code> array.</p></li>
<li><p><strong>Transitions</strong>: We need to know the possible
transitions clearly:</p>
<ul>
<li>Placing a domino vertically takes up 2 units.</li>
<li>Placing a tromino takes up 3 units in different ways.</li>
</ul></li>
</ul>
<p>Here is an example of transition logic:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">2</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span> <span class="co">// Place a domino</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;=</span> <span class="dv">3</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">3</span><span class="op">]</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Place a tromino</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<ul>
<li><p><strong>Memory Optimization</strong>: We can think about how to
save space. Instead of using a whole <code>dp</code> array, we can keep
track of just the last few states (like using two or three
variables).</p></li>
<li><p><strong>Testing Edge Cases</strong>: We always test edge cases
like:</p>
<ul>
<li>Minimum values (like n = 0, n = 1).</li>
<li>Large values of <code>n</code> to check if our solution works fast
enough.</li>
</ul></li>
<li><p><strong>Reviewing Algorithm Complexity</strong>: We need to know
the time and space complexity of our method. The simple recursive
solution can take a lot of time, while the dynamic programming method is
much faster. This is important for big inputs.</p></li>
</ul>
<p>By knowing these pitfalls and using these tips, we can solve the
Domino and Tromino Tiling problem well. This will also help us improve
our dynamic programming skills. If we want to read more about dynamic
programming, we can look at articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming with Memoization</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-domino-and-tromino-tiling-problem-in-dynamic-programming">1.
What is the Domino and Tromino Tiling problem in dynamic
programming?</h3>
<p>We talk about the Domino and Tromino Tiling problem when we count how
many ways we can cover a 2Ã—n board using dominoes (2Ã—1 tiles) and
trominoes (L-shaped tiles). This problem is a classic in dynamic
programming. It helps us understand tiling methods and recursion. So, it
is a good example for learning algorithms.</p>
<h3
id="how-can-i-solve-the-domino-and-tromino-tiling-problem-using-dynamic-programming">2.
How can I solve the Domino and Tromino Tiling problem using dynamic
programming?</h3>
<p>We can solve the Domino and Tromino Tiling problem by using dynamic
programming. First, we need to make a relation based on our choices at
each step. We can put down a domino or a tromino. This leads to
overlapping problems. By saving results in a DP array, we can make our
solution better and save time.</p>
<h3
id="what-programming-languages-can-i-use-to-implement-the-domino-and-tromino-tiling-solution">3.
What programming languages can I use to implement the Domino and Tromino
Tiling solution?</h3>
<p>We can use many programming languages to implement the Domino and
Tromino Tiling solution. Some of them are Java, Python, and C++. Each
one has its own rules, but they all handle dynamic programming well. The
article shows how to do it in Java, Python, and C++ to give a clear
understanding.</p>
<h3
id="what-are-some-common-pitfalls-when-solving-the-domino-and-tromino-tiling-problem">4.
What are some common pitfalls when solving the Domino and Tromino Tiling
problem?</h3>
<p>When we work on the Domino and Tromino Tiling problem, we can face
some mistakes. These include misunderstanding the base cases and not
thinking about all the ways to place tiles. Not using memoization well
is another issue. It is important to see the board clearly and build the
relation carefully. This way we avoid missing good setups.</p>
<h3
id="how-do-i-analyze-the-time-and-space-complexity-of-the-domino-and-tromino-tiling-solutions">5.
How do I analyze the time and space complexity of the Domino and Tromino
Tiling solutions?</h3>
<p>The time complexity for the dynamic programming method for the Domino
and Tromino Tiling problem is usually O(n), where n is the board length.
The space complexity can also be O(n) if we keep results in a DP array.
But if we optimize, we can lower it to O(1) by only keeping track of the
last few states.</p>
<p>For more reading on similar dynamic programming problems, check out
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a> articles.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            