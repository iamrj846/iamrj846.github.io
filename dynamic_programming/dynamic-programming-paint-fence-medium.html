
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Paint Fence - Medium</title>
            <meta name="description" content="Learn how to solve the Paint Fence problem using dynamic programming. Enhance your coding skills with this comprehensive guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Paint Fence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Paint Fence problem is a well-known challenge in dynamic
programming. It asks us to find out how many ways we can paint a fence
with a certain number of posts and colors. We need to make sure that no
more than two posts next to each other have the same color. We can solve
this problem by using dynamic programming. This method lets us build a
solution from results we already have. This way, we save time and do not
repeat calculations.</p>
<p>In this article, we will look at many parts of the Paint Fence
problem. We will discuss the problem statement. We will also go over the
dynamic programming approach in different programming languages like
Java, Python, and C++. We will talk about how to optimize space
complexity. We will compare recursive methods with dynamic programming
methods. We will break down the time complexity too. We will point out
common mistakes. Lastly, we will answer some frequently asked questions
about the Paint Fence problem.</p>
<ul>
<li>Dynamics of the Paint Fence Problem Using Dynamic Programming</li>
<li>Understanding the Paint Fence Problem Statement</li>
<li>Dynamic Programming Approach for Paint Fence in Java</li>
<li>Dynamic Programming Approach for Paint Fence in Python</li>
<li>Dynamic Programming Approach for Paint Fence in C++</li>
<li>Optimizing Space Complexity in Paint Fence Problem</li>
<li>Comparative Analysis of Recursive and Dynamic Programming
Approaches</li>
<li>Time Complexity Breakdown of Paint Fence Solutions</li>
<li>Common Pitfalls in Implementing Paint Fence with Dynamic
Programming</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to read more about related dynamic programming topics,
you can check these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2 id="understanding-the-paint-fence-problem-statement">Understanding
the Paint Fence Problem Statement</h2>
<p>The Paint Fence problem is a popular dynamic programming problem. We
want to find how many ways we can paint a fence with <code>n</code>
posts using <code>k</code> different colors. The rule is that we cannot
paint more than two posts next to each other with the same color.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have: - <code>n</code>: the number of posts in the fence. -
<code>k</code>: the number of colors we can use.</p>
<p>We need to calculate the total ways to paint the fence while keeping
the adjacent color rule.</p>
<h3 id="example">Example</h3>
<ul>
<li>If <code>n = 3</code> and <code>k = 2</code>:
<ul>
<li>Some arrangements could be: RGB, RRG, RGR, GRR and more.</li>
<li>The answer would be 6.</li>
</ul></li>
</ul>
<h3 id="mathematical-formulation">Mathematical Formulation</h3>
<p>To find the solution, we can see this: - If we paint the first post
with a unique color, we can paint the next posts with any of the
<code>k</code> colors. - If we paint the first post with the same color
as the second, then we must paint the third post with one of the other
<code>k-1</code> colors.</p>
<p>This gives us the formula: -
<code>dp[n] = (k - 1) * dp[n - 1] + (k - 1) * dp[n - 2]</code></p>
<p>Where: - <code>dp[n]</code>: the number of ways to paint
<code>n</code> posts. - Base cases: - <code>dp[1] = k</code> -
<code>dp[2] = k * k</code></p>
<p>This way, we can solve the problem well using dynamic programming. We
can keep the results we find to help us with later calculations.</p>
<h2 id="dynamic-programming-approach-for-paint-fence-in-java">Dynamic
Programming Approach for Paint Fence in Java</h2>
<p>We can solve the Paint Fence problem really well with the dynamic
programming method in Java. The problem is about finding how many ways
we can paint a fence with <code>n</code> posts using <code>k</code>
colors. We need to make sure that no more than two posts next to each
other have the same color.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<ul>
<li><strong>Input:</strong>
<ul>
<li><code>n</code>: Number of posts (integer)</li>
<li><code>k</code>: Number of colors (integer)</li>
</ul></li>
<li><strong>Output:</strong> Number of ways to paint the fence.</li>
</ul>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>To solve this problem, we can use some simple rules:</p>
<ol type="1">
<li>If the last post has a different color than the one before it, the
ways to paint the last post is <code>(k-1)</code> times the ways to
paint the first <code>n-1</code> posts.</li>
<li>If the last post is the same color as the one before, there is only
1 way to paint the last two posts. So we multiply that by the ways to
paint the first <code>n-2</code> posts.</li>
</ol>
<h3 id="recurrence-relation">Recurrence Relation</h3>
<p>Let <code>dp[i]</code> be the number of ways to paint <code>i</code>
posts: - <code>dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])</code></p>
<h3 id="base-cases">Base Cases</h3>
<ul>
<li><code>dp[1] = k</code></li>
<li><code>dp[2] = k * k</code></li>
</ul>
<h3 id="implementation">Implementation</h3>
<p>Here is the Java code for the dynamic programming method for the
Paint Fence problem:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintFence <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of posts</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Number of colors</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to paint the fence: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The function <code>countWays</code> finds how many ways to paint
<code>n</code> posts with <code>k</code> colors using the rules we
talked about.</li>
<li>The base cases take care of simple situations directly.</li>
<li>We use a dynamic programming array <code>dp</code> to save results
of smaller problems. This way, we do not have to calculate them again,
and it makes things faster.</li>
</ul>
<p>This method works in O(n) time and uses O(n) space to keep track of
results.</p>
<h2 id="dynamic-programming-approach-for-paint-fence-in-python">Dynamic
Programming Approach for Paint Fence in Python</h2>
<p>We can solve the Paint Fence problem in a smart way using dynamic
programming. In this problem, we want to paint a fence that has
<code>n</code> posts using <code>k</code> colors. We need to make sure
that no two posts next to each other have the same color. Our goal is to
find out how many ways we can paint the fence.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<p>Let: - <code>n</code> = number of posts - <code>k</code> = number of
colors</p>
<p>We can define: - <code>dp[i]</code> = number of ways to paint the
fence with <code>i</code> posts.</p>
<h3 id="recurrence-relation-1">Recurrence Relation</h3>
<p>We can define the recurrence relation like this: - If the last post
has a different color than the one before it, we have <code>k-1</code>
choices. - If the last post has the same color as the previous one, then
the previous post must have a different color. This gives us
<code>dp[i-1]</code> arrangements.</p>
<p>So the relation looks like this:</p>
<pre><code>dp[i] = (k - 1) * (dp[i - 1] + dp[i - 2])</code></pre>
<p>And we have base cases: - <code>dp[1] = k</code> -
<code>dp[2] = k * k - k</code></p>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is the Python code that shows the dynamic programming
solution:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> paintFence(n, k):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> k</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>: <span class="cf">return</span> k <span class="op">*</span> k</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> k</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">2</span>] <span class="op">=</span> k <span class="op">*</span> k</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of posts</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Number of colors</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(paintFence(n, k))  <span class="co"># Output: 6</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>The function <code>paintFence</code> takes the number of posts
<code>n</code> and the number of colors <code>k</code>.</li>
<li>We check base cases first for when there are fewer than 3
posts.</li>
<li>The <code>dp</code> array stores the number of ways to paint the
fence for each number of posts up to <code>n</code>.</li>
<li>The loop calculates the number of ways using the relation we
defined.</li>
</ul>
<p>This dynamic programming approach helps us find the number of ways to
paint the fence in <code>O(n)</code> time with <code>O(n)</code> space.
If we want to optimize more, we can reduce space to <code>O(1)</code> by
keeping only the last two states. We only need those for each step.</p>
<p>If you want to learn more about dynamic programming techniques, you
can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> article.</p>
<h2 id="dynamic-programming-approach-for-paint-fence-in-c">Dynamic
Programming Approach for Paint Fence in C++</h2>
<p>In the Paint Fence problem, we want to paint <code>n</code> fences
using <code>k</code> colors. We need to make sure that no more than two
fences next to each other have the same color. Our goal is to find out
how many ways we can paint the fences.</p>
<h3 id="dynamic-programming-solution-1">Dynamic Programming
Solution</h3>
<p>We can use dynamic programming for solving this problem easily. We
define the following states:</p>
<ul>
<li><code>dp[i]</code>: This shows the number of ways to paint
<code>i</code> fences.</li>
<li>We also need to track the last two painted fences. This helps us
avoid using the same color too many times.</li>
</ul>
<h3 id="transition-relation">Transition Relation</h3>
<ol type="1">
<li>If we paint the <code>i-th</code> fence a different color from the
<code>(i-1)-th</code> fence, we can use any of the <code>k-1</code>
other colors.</li>
<li>If we paint the <code>i-th</code> fence the same color as the
<code>(i-1)-th</code> fence, we can only do this if the
<code>(i-2)-th</code> fence is painted a different color. This gives us
only 1 choice.</li>
</ol>
<p>We can write the relation like this:</p>
<pre><code>dp[i] = (dp[i-1] * (k - 1)) + (dp[i-2] * (k - 1))</code></pre>
<h3 id="base-cases-1">Base Cases</h3>
<ul>
<li><code>dp[0] = 1</code>: There is one way to paint zero fences.</li>
<li><code>dp[1] = k</code>: There are <code>k</code> ways to paint one
fence.</li>
</ul>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<p>Here is how we can solve the Paint Fence problem using dynamic
programming in C++:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWaysToPaintFence<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case for 0 fences</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span> <span class="co">// Base case for 1 fence</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">+</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of fences</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Number of colors</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Total ways to paint &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; fences with &quot;</span> <span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot; colors: &quot;</span> <span class="op">&lt;&lt;</span> countWaysToPaintFence<span class="op">(</span>n<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The function <code>countWaysToPaintFence</code> finds the total ways
to paint <code>n</code> fences using <code>k</code> colors.</li>
<li>We set up the base cases and a loop runs from 2 to <code>n</code> to
fill the <code>dp</code> array according to the relation.</li>
<li>In the end, we print the result in the <code>main</code>
function.</li>
</ul>
<p>This dynamic programming method works in O(n) time and needs O(n)
space. It is good for bigger values of <code>n</code>.</p>
<h2 id="optimizing-space-complexity-in-paint-fence-problem">Optimizing
Space Complexity in Paint Fence Problem</h2>
<p>In the Paint Fence problem, we want to use less space while still
having a good solution. We can use dynamic programming to solve this
problem. Normally, we keep results of smaller problems in an array. But
we can save space by knowing that we only need the last two results to
find the current result.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>Instead of keeping an array of size <code>n</code>, we can use two
variables to remember the last two results. This change makes the space
usage go from O(n) to O(1).</p>
<h3 id="optimized-dynamic-programming-approach">Optimized Dynamic
Programming Approach</h3>
<p>For <code>n</code> fences and <code>k</code> colors, we can say: -
<code>dp[i]</code> is the number of ways to paint up to the i-th
fence.</p>
<p>We can make the rule simpler: - If we paint the i-th fence with the
same color as the (i-1)-th fence, we can’t use the same color for the
(i-2)-th fence. - If we paint the i-th fence with a different color, we
can pick any of the other colors.</p>
<p>The new rule looks like this:</p>
<pre class="plaintext"><code>current = (k - 1) * (previous + second_previous)</code></pre>
<h3 id="example-code-in-java">Example Code in Java</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintFence <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">numWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> previous <span class="op">=</span> k<span class="op">;</span> <span class="co">// dp[i-1]</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> second_previous <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// dp[i-2]</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>previous <span class="op">+</span> second_previous<span class="op">);</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>            second_previous <span class="op">=</span> previous<span class="op">;</span> <span class="co">// update dp[i-2]</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            previous <span class="op">=</span> current<span class="op">;</span> <span class="co">// update dp[i-1]</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> previous<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// number of fences</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// number of colors</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to paint the fence: &quot;</span> <span class="op">+</span> <span class="fu">numWays</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-code-in-python">Example Code in Python</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_ways(n, k):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>: <span class="cf">return</span> k</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    previous <span class="op">=</span> k</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    second_previous <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (previous <span class="op">+</span> second_previous)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        second_previous <span class="op">=</span> previous</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        previous <span class="op">=</span> current</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> previous</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># number of fences</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span>  <span class="co"># number of colors</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to paint the fence:&quot;</span>, num_ways(n, k))</span></code></pre></div>
<h3 id="example-code-in-c">Example Code in C++</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> numWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> previous <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> second_previous <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>previous <span class="op">+</span> second_previous<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        second_previous <span class="op">=</span> previous<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        previous <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> previous<span class="op">;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// number of fences</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// number of colors</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to paint the fence: &quot;</span> <span class="op">&lt;&lt;</span> numWays<span class="op">(</span>n<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By using this method, we make big improvements in space usage while
solving the Paint Fence problem well. For more on dynamic programming,
you can check these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2
id="comparative-analysis-of-recursive-and-dynamic-programming-approaches">Comparative
Analysis of Recursive and Dynamic Programming Approaches</h2>
<p>We can solve the Paint Fence problem using both recursive and dynamic
programming methods. Each method has its own good points and bad
points.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<p>The simple recursive solution looks at all ways to paint the fence.
This can make the time it takes grow very fast. The main steps in the
recursive approach are:</p>
<ol type="1">
<li><strong>Base Cases</strong>:
<ul>
<li>If there is 1 post, we can paint it in as many ways as there are
colors.</li>
<li>If there are 2 posts, the ways to paint them is the number of colors
times the number of colors plus the number of colors raised to the power
of the number of posts minus 1.</li>
</ul></li>
<li><strong>Recursive Formula</strong>:
<ul>
<li>For more than two posts, we can write the formula like this: [ (n) =
(n-1) (k-1) + (n-2) (k-1) ] Here ( n ) means the number of posts and ( k
) means the number of colors.</li>
</ul></li>
</ol>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<p>Dynamic programming helps us by keeping the results we already
calculated. This makes the time to solve the problem much faster,
reducing it to linear time. The steps in the dynamic programming
solution are:</p>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>We create a <code>dp</code> array of size ( n+1 ) where ( dp[i] )
will hold the number of ways to paint ( i ) posts.</li>
</ul></li>
<li><strong>Base Cases</strong>:
<ul>
<li>We set ( dp[1] = k )</li>
<li>We set ( dp[2] = k^2 )</li>
</ul></li>
<li><strong>Dynamic Programming Formula</strong>:
<ul>
<li>For ( i ) from 3 to ( n ): [ dp[i] = (k-1) (dp[i-1] + dp[i-2])
]</li>
</ul></li>
<li><strong>Final Result</strong>:
<ul>
<li>The answer will be in ( dp[n] ).</li>
</ul></li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintFence <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">numWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_ways(n, k):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k <span class="op">*</span> k</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> k</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">2</span>] <span class="op">=</span> k <span class="op">*</span> k</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="time-and-space-complexity">Time and Space Complexity</h3>
<ul>
<li><strong>Recursive Approach</strong>:
<ul>
<li>Time Complexity: ( O(2^n) )</li>
<li>Space Complexity: ( O(n) ) because of the recursion stack.</li>
</ul></li>
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>Time Complexity: ( O(n) )</li>
<li>Space Complexity: ( O(n) ) for the <code>dp</code> array. We can
make this ( O(1) ) if we only keep the last two values.</li>
</ul></li>
</ul>
<p>We can understand the differences in these methods. This helps us to
choose the best way based on the problem needs. If you want to learn
more about dynamic programming, you can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-coin-change-medium.html">Dynamic
Programming: Coin Change Problem</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming: Fibonacci with Memoization</a>.</p>
<h2 id="time-complexity-breakdown-of-paint-fence-solutions">Time
Complexity Breakdown of Paint Fence Solutions</h2>
<p>We can solve the Paint Fence problem in different ways. The main
methods are recursion and dynamic programming. Knowing the time
complexity for each method helps us make the performance better.</p>
<h3 id="recursive-approach-1">Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n)</li>
<li>The simple recursive solution finds the number of ways to paint the
fence by checking all combinations. This gives us an exponential time
complexity because we have overlapping subproblems.</li>
</ul>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li>The dynamic programming method makes the recursive solution better.
It saves the results of subproblems. This way, we do not need to
recalculate how to paint the earlier sections of the fence.</li>
</ul>
<h3 id="breakdown-of-dynamic-programming-steps">Breakdown of Dynamic
Programming Steps</h3>
<ol type="1">
<li><strong>State Definition</strong>: We let <code>dp[i]</code> show
the number of ways to paint the first <code>i</code> sections of the
fence.</li>
<li><strong>Transition Formula</strong>:
<ul>
<li><p>When we paint the <code>i-th</code> section, we have two
cases:</p>
<ul>
<li>The <code>i-th</code> section is a different color than the
<code>(i-1)-th</code> section.</li>
<li>The <code>i-th</code> section is the same color as the
<code>(i-1)-th</code> section.</li>
</ul></li>
<li><p>We can write the recurrence relation as:</p>
<pre><code>dp[i] = (k - 1) * dp[i - 1] + (k - 1) * dp[i - 2]</code></pre></li>
<li><p>Here, <code>k</code> is the number of colors we can use.</p></li>
</ul></li>
</ol>
<h3 id="example-implementation-in-java">Example Implementation in
Java</h3>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintFence <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-implementation-in-python">Example Implementation in
Python</h3>
<div class="sourceCode" id="cb15"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> num_ways(n, k):</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k <span class="op">*</span> k</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> k</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">2</span>] <span class="op">=</span> k <span class="op">*</span> k</span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-16"><a href="#cb15-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span></code></pre></div>
<h3 id="example-implementation-in-c">Example Implementation in C++</h3>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> k<span class="op">;</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>In conclusion, we see that the dynamic programming solution is much
better. It changes the time complexity from exponential to linear. This
makes it good for larger values of <code>n</code>.</p>
<p>For more reading on similar dynamic programming problems, we can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2
id="common-pitfalls-in-implementing-paint-fence-with-dynamic-programming">Common
Pitfalls in Implementing Paint Fence with Dynamic Programming</h2>
<p>When we implement the Paint Fence problem with Dynamic Programming,
we can face some common problems. These issues can give us wrong answers
or slow solutions. Here are some key points to remember:</p>
<ol type="1">
<li><p><strong>Incorrect Base Cases</strong>: We need to set the initial
conditions correctly. For example, if there are zero fences, we have 0
ways to paint them. If there is one fence, we can paint it in
<code>k</code> ways.</p></li>
<li><p><strong>State Transition Errors</strong>: We must derive the
recurrence relation correctly. A common mistake is not considering that
we cannot paint adjacent fences the same color. The right relation
is:</p>
<ul>
<li><code>ways(n) = (k - 1) * (ways(n-1) + ways(n-2))</code></li>
<li>This helps us think about different situations for the last fence
painted.</li>
</ul></li>
<li><p><strong>Overlapping Subproblems</strong>: If we forget to save
intermediate results, we may recalculate the same results many times.
This loses the efficiency of Dynamic Programming. We can use an array or
hashmap to store these values.</p></li>
<li><p><strong>Space Complexity Mismanagement</strong>: The basic method
can use a 2D array for states. But we can save space by only keeping
track of the last two states. This reduces space to O(1).</p></li>
<li><p><strong>Off-By-One Errors</strong>: We should pay close attention
to indices when we write the solution. This is especially important with
loops and array accesses. Mistakes in indexing can cause runtime errors
or wrong results.</p></li>
<li><p><strong>Wrong Data Types</strong>: If we use wrong data types, we
may face overflow problems. This can happen with larger values of
<code>n</code> and <code>k</code>. We should use data types that can
handle big integers, like <code>long</code> in Java or <code>int</code>
in Python when needed.</p></li>
<li><p><strong>Neglecting Edge Cases</strong>: We must test edge cases
like:</p>
<ul>
<li><code>n = 0</code> (no fences)</li>
<li><code>n = 1</code> (one fence)</li>
<li><code>k = 1</code> (only one color)</li>
<li>Big values of <code>n</code> and <code>k</code> to check
performance.</li>
</ul></li>
<li><p><strong>Inefficient Initialization</strong>: If we start arrays
or lists without knowing their size or purpose, we waste memory and
time. We should size them correctly based on the problem.</p></li>
</ol>
<p>Here’s a simple implementation in Java as an example:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintFence <span class="op">{</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> same <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> </span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> diff <span class="op">=</span> k<span class="op">;</span> </span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> total <span class="op">=</span> k<span class="op">;</span> </span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            same <span class="op">=</span> diff<span class="op">;</span> </span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>            diff <span class="op">=</span> total <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>            total <span class="op">=</span> same <span class="op">+</span> diff<span class="op">;</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code shows these ideas. It helps us compute efficiently by
managing states and transitions well.</p>
<p>By keeping these pitfalls in mind, we can implement the Paint Fence
problem using Dynamic Programming correctly and efficiently. For more
ideas on dynamic programming, we can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Dynamic
Programming - Paint House</a> article.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-paint-fence-problem-in-dynamic-programming">1. What
is the Paint Fence Problem in dynamic programming?</h3>
<p>The Paint Fence Problem is a well-known challenge in dynamic
programming. It asks how many ways we can paint a fence with
<code>n</code> posts using <code>k</code> colors. We need to make sure
that no more than two posts next to each other have the same color. When
we understand this problem, we can use dynamic programming techniques to
find a good solution.</p>
<h3
id="how-do-you-derive-the-recurrence-relation-for-the-paint-fence-problem">2.
How do you derive the recurrence relation for the Paint Fence
Problem?</h3>
<p>To get the recurrence relation for the Paint Fence Problem, we look
at the color of the last post. If this color is different from the one
before it, we can use all <code>k</code> colors for it. If it is the
same color, we can only use <code>k-1</code> colors. This gives us the
relation <code>dp[n] = (k - 1) * (dp[n - 1] + dp[n - 2])</code>. Here,
<code>dp[n]</code> shows how many ways we can paint <code>n</code>
posts.</p>
<h3
id="what-is-the-time-complexity-of-the-paint-fence-problem-solution">3.
What is the time complexity of the Paint Fence Problem solution?</h3>
<p>The time complexity for the dynamic programming solution to the Paint
Fence Problem is O(n). This means the time it takes grows linearly with
the number of posts. This good complexity comes from using a bottom-up
approach. We build solutions from smaller parts. This makes it much
faster than using a simple recursive approach.</p>
<h3 id="can-the-paint-fence-problem-be-solved-using-recursion">4. Can
the Paint Fence Problem be solved using recursion?</h3>
<p>Yes, we can solve the Paint Fence Problem with recursion. But this
method is not very efficient because it has overlapping subproblems. A
recursive solution without memoization takes a lot of time. To make it
better, we can use dynamic programming. This way, we store results we
have already calculated, which makes the process faster.</p>
<h3
id="what-are-some-common-pitfalls-when-implementing-the-paint-fence-problem">5.
What are some common pitfalls when implementing the Paint Fence
Problem?</h3>
<p>Some common mistakes when doing the Paint Fence Problem include not
understanding the rules about adjacent colors. It is also easy to forget
to set the base cases right. Another mistake is not managing space
complexity well by using only the needed variables. If we understand the
problem clearly and plan our code well, we can avoid these issues.</p>
<p>For more information on dynamic programming techniques, you can read
other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            