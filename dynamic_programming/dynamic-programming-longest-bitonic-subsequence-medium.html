
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Longest Bitonic Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn how to solve the Longest Bitonic Subsequence problem using dynamic programming. Step-by-step guide and examples!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Longest Bitonic Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Longest Bitonic Subsequence (LBS) problem is about finding the
longest part of a sequence of numbers that first goes up and then goes
down. We can solve this problem well using dynamic programming. We do
this by splitting it into two smaller problems: the Longest Increasing
Subsequence (LIS) and the Longest Decreasing Subsequence (LDS). When we
combine the results of these two, we get the length of the longest
bitonic subsequence.</p>
<p>In this article, we will look at the Longest Bitonic Subsequence in
detail. We will start with a simple explanation of what the problem is.
Then, we will talk about how to solve it using dynamic programming in
Java, Python, and C++. We will also check how to make the solution
better, look at its complexity, point out common mistakes we can make
while coding, and answer some frequently asked questions.</p>
<ul>
<li>Dynamic Programming Longest Bitonic Subsequence Explained</li>
<li>Understanding the Problem Statement of Longest Bitonic
Subsequence</li>
<li>Dynamic Programming Approach for Longest Bitonic Subsequence in
Java</li>
<li>Dynamic Programming Approach for Longest Bitonic Subsequence in
Python</li>
<li>Dynamic Programming Approach for Longest Bitonic Subsequence in
C++</li>
<li>Optimizing the Longest Bitonic Subsequence Solution</li>
<li>Complexity Analysis of Longest Bitonic Subsequence Algorithm</li>
<li>Common Mistakes in Implementing Longest Bitonic Subsequence</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to learn more about related dynamic programming topics,
you can check these articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>, <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>, and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-0-1-knapsack-problem-medium.html">Dynamic
Programming: 0-1 Knapsack Problem</a>.</p>
<h2
id="understanding-the-problem-statement-of-longest-bitonic-subsequence">Understanding
the Problem Statement of Longest Bitonic Subsequence</h2>
<p>The Longest Bitonic Subsequence (LBS) is a well-known problem in
dynamic programming. A bitonic subsequence is a sequence that goes up
first and then goes down. Our goal is to find out the length of the
longest subsequence that is bitonic.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an array of integers. Our task is to find the maximum length
of the subsequence that meets these rules:</p>
<ol type="1">
<li><strong>Increasing Phase</strong>: The numbers in the subsequence
must be in a strictly increasing order.</li>
<li><strong>Decreasing Phase</strong>: After reaching the highest point,
the numbers must be in a strictly decreasing order.</li>
</ol>
<h3 id="example">Example</h3>
<p>Letâ€™s look at this array:</p>
<pre><code>arr = [1, 11, 2, 10, 4, 5, 2, 1]</code></pre>
<ul>
<li>One longest bitonic subsequence is <code>[1, 2, 10, 4, 2, 1]</code>
and it has length 6.</li>
<li>Another valid bitonic subsequence is
<code>[1, 11, 10, 4, 2, 1]</code>, which also has length 6.</li>
</ul>
<h3 id="input-and-output">Input and Output</h3>
<ul>
<li><strong>Input</strong>: An array of integers.</li>
<li><strong>Output</strong>: A number that shows the length of the
longest bitonic subsequence.</li>
</ul>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The array must have at least one element.</li>
<li>The input array can be as big as (10^3).</li>
</ul>
<p>We can solve this problem in a good way using dynamic programming.
This means we will find the longest increasing subsequence (LIS) for all
the elements first. Then we will find the longest decreasing subsequence
(LDS) in reverse.</p>
<p>For more about similar dynamic programming problems, we can check the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a> article.</p>
<h2
id="dynamic-programming-approach-for-longest-bitonic-subsequence-in-java">Dynamic
Programming Approach for Longest Bitonic Subsequence in Java</h2>
<p>The Longest Bitonic Subsequence (LBS) is a sequence that first goes
up and then goes down. We can solve this problem using dynamic
programming. We will break it into two parts: finding the Longest
Increasing Subsequence (LIS) and the Longest Decreasing Subsequence
(LDS).</p>
<h3 id="steps-to-implement-the-dynamic-programming-solution">Steps to
Implement the Dynamic Programming Solution:</h3>
<ol type="1">
<li><strong>Calculate LIS</strong>: For each number, we find the length
of the longest increasing subsequence that ends with that number.</li>
<li><strong>Calculate LDS</strong>: For each number, we find the length
of the longest decreasing subsequence that starts with that number.</li>
<li><strong>Combine Results</strong>: The length of the longest bitonic
subsequence at each number is the sum of its LIS and LDS lengths minus
one. This is to avoid counting the peak number twice.</li>
</ol>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestBitonicSubsequence <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestBitonicSubsequence</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 1: Calculate LIS</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> lis <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Start LIS values</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> lis<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                    lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 2: Calculate LDS</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> lds <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Start LDS values</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> lds<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> lds<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                    lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> lds<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 3: Combine LIS and LDS</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>            maxLength <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLength<span class="op">,</span> lis<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> lds<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb2-35"><a href="#cb2-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-36"><a href="#cb2-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-37"><a href="#cb2-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-38"><a href="#cb2-38" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb2-39"><a href="#cb2-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Bitonic Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">longestBitonicSubsequence</span><span class="op">(</span>arr<span class="op">));</span></span>
<span id="cb2-40"><a href="#cb2-40" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-41"><a href="#cb2-41" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>longestBitonicSubsequence</code> method finds the length
of the longest bitonic subsequence.</li>
<li>We use two arrays <code>lis</code> and <code>lds</code> to keep the
lengths of the longest increasing and decreasing subsequences.</li>
<li>We fill these arrays with nested loops based on the rules for
increasing and decreasing subsequences.</li>
<li>Finally, we find the maximum length by combining values from both
arrays.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis:</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). Here, n is the length of
the input array.</li>
<li><strong>Space Complexity</strong>: O(n). This is for storing the LIS
and LDS arrays.</li>
</ul>
<p>This method finds the longest bitonic subsequence using dynamic
programming in Java. For more techniques on dynamic programming, we can
look at other articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2
id="dynamic-programming-approach-for-longest-bitonic-subsequence-in-python">Dynamic
Programming Approach for Longest Bitonic Subsequence in Python</h2>
<p>To solve the Longest Bitonic Subsequence (LBS) problem with dynamic
programming in Python, we can split the problem into two main parts.
First, we need to find the Longest Increasing Subsequence (LIS). Second,
we find the Longest Decreasing Subsequence (LDS). After that, we can
calculate the LBS using these two sequences.</p>
<h3 id="steps-to-implement-the-dynamic-programming-approach">Steps to
Implement the Dynamic Programming Approach:</h3>
<ol type="1">
<li>We compute the Longest Increasing Subsequence (LIS) for every
element.</li>
<li>We compute the Longest Decreasing Subsequence (LDS) for every
element.</li>
<li>For each element in the array, we can find the LBS as
<code>LIS[i] + LDS[i] - 1</code>.</li>
<li>The final answer is the biggest LBS value from all indices.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_bitonic_subsequence(arr):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Calculate LIS</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    lis <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                lis[i] <span class="op">=</span> <span class="bu">max</span>(lis[i], lis[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Calculate LDS</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    lds <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">1</span>, i, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                lds[i] <span class="op">=</span> <span class="bu">max</span>(lds[i], lds[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 3: Calculate LBS</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    lbs <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        lbs <span class="op">=</span> <span class="bu">max</span>(lbs, lis[i] <span class="op">+</span> lds[i] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lbs</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">12</span>, <span class="dv">4</span>, <span class="dv">78</span>, <span class="dv">90</span>, <span class="dv">45</span>, <span class="dv">23</span>]</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Bitonic Subsequence is:&quot;</span>, longest_bitonic_subsequence(arr))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The <code>longest_bitonic_subsequence</code> function takes an array
<code>arr</code> as input. It starts by making two lists,
<code>lis</code> and <code>lds</code>, to keep the lengths of the
longest increasing and decreasing subsequences for each index.</li>
<li>We use two loops to calculate LIS and LDS. The first loop goes
through each element. The second loop checks the previous elements for
LIS and the next elements for LDS.</li>
<li>At the end, we calculate the LBS by adding the values of
<code>lis</code> and <code>lds</code> for each index and subtracting 1.
This is to avoid counting the peak element twice.</li>
</ul>
<h3 id="complexity">Complexity:</h3>
<ul>
<li>Time Complexity: O(n^2) because we have nested loops for LIS and
LDS.</li>
<li>Space Complexity: O(n) for saving the lengths of LIS and LDS.</li>
</ul>
<p>For more reading on similar dynamic programming problems, you can
check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a> article.</p>
<h2
id="dynamic-programming-approach-for-longest-bitonic-subsequence-in-c">Dynamic
Programming Approach for Longest Bitonic Subsequence in C++</h2>
<p>We will solve the Longest Bitonic Subsequence (LBS) problem using
dynamic programming in C++. First, we need to know that a bitonic
subsequence goes up and then goes down. We can do this in two main
steps:</p>
<ol type="1">
<li><strong>Calculate the Longest Increasing Subsequence (LIS)</strong>
for each item from the left side.</li>
<li><strong>Calculate the Longest Decreasing Subsequence (LDS)</strong>
for each item from the right side.</li>
</ol>
<p>After we finish both steps, we can find the LBS for each item by
adding these two results together. Finally, we will take the biggest
value from these combined results.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a simple code for the logic we explained above in C++:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestIncreasingSubsequence<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lis<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>lis<span class="op">[</span>i<span class="op">],</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lis<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestDecreasingSubsequence<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lds<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>                lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>lds<span class="op">[</span>i<span class="op">],</span> lds<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> lds<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestBitonicSubsequence<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lis <span class="op">=</span> longestIncreasingSubsequence<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lds <span class="op">=</span> longestDecreasingSubsequence<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxLength <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> arr<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        maxLength <span class="op">=</span> max<span class="op">(</span>maxLength<span class="op">,</span> lis<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> lds<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxLength<span class="op">;</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> longestBitonicSubsequence<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Bitonic Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>Function <code>longestIncreasingSubsequence</code></strong>:
This function finds the length of the longest increasing subsequence for
each item.</li>
<li><strong>Function <code>longestDecreasingSubsequence</code></strong>:
This function finds the length of the longest decreasing subsequence for
each item.</li>
<li><strong>Function <code>longestBitonicSubsequence</code></strong>:
This function adds the results from LIS and LDS for each index and finds
the maximum length of the bitonic subsequence.</li>
</ul>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time complexity</strong>: O(n^2), where n is the size of the
input array.</li>
<li><strong>Space complexity</strong>: O(n) for keeping LIS and LDS
values.</li>
</ul>
<p>This method uses dynamic programming well to solve the Longest
Bitonic Subsequence problem in C++. If you want to learn more about
dynamic programming, you can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2 id="optimizing-the-longest-bitonic-subsequence-solution">Optimizing
the Longest Bitonic Subsequence Solution</h2>
<p>To make the solution for finding the Longest Bitonic Subsequence
(LBS) better, we can use the ideas from the Longest Increasing
Subsequence (LIS) and the Longest Decreasing Subsequence (LDS). We can
get the LBS from these two parts.</p>
<h3 id="steps-to-optimize">Steps to Optimize</h3>
<ol type="1">
<li><strong>Calculate LIS</strong>: We find the longest increasing
subsequence for each index.</li>
<li><strong>Calculate LDS</strong>: We find the longest decreasing
subsequence for each index.</li>
<li><strong>Combine Results</strong>: The length of the longest bitonic
subsequence at each index is the sum of LIS and LDS minus one. This is
to make sure we do not count the peak element twice.</li>
</ol>
<h3 id="time-complexity">Time Complexity</h3>
<p>The improved algorithm works in (O(n^2)) because of the nested loops
to calculate LIS and LDS. We can make it faster to (O(n n)) using binary
search, but we will use the (O(n^2)) method for simplicity here.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LongestBitonicSubsequence <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">longestBitonicSubsequence</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> lis <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> lds <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute LIS values</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                    lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>lis<span class="op">[</span>i<span class="op">],</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Compute LDS values</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>            lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>                    lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>lds<span class="op">[</span>i<span class="op">],</span> lds<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Combine LIS and LDS</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxLBS <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-32"><a href="#cb5-32" aria-hidden="true" tabindex="-1"></a>            maxLBS <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxLBS<span class="op">,</span> lis<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> lds<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb5-33"><a href="#cb5-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-34"><a href="#cb5-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-35"><a href="#cb5-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxLBS<span class="op">;</span></span>
<span id="cb5-36"><a href="#cb5-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-37"><a href="#cb5-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-38"><a href="#cb5-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-39"><a href="#cb5-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb5-40"><a href="#cb5-40" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Bitonic Subsequence: &quot;</span> <span class="op">+</span> <span class="fu">longestBitonicSubsequence</span><span class="op">(</span>arr<span class="op">));</span></span>
<span id="cb5-41"><a href="#cb5-41" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-42"><a href="#cb5-42" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_bitonic_subsequence(arr):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    lis <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    lds <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute LIS values</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>                lis[i] <span class="op">=</span> <span class="bu">max</span>(lis[i], lis[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute LDS values</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, i, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                lds[i] <span class="op">=</span> <span class="bu">max</span>(lds[i], lds[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine LIS and LDS</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>    max_lbs <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        max_lbs <span class="op">=</span> <span class="bu">max</span>(max_lbs, lis[i] <span class="op">+</span> lds[i] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_lbs</span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">11</span>, <span class="dv">2</span>, <span class="dv">10</span>, <span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">1</span>]</span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Length of Longest Bitonic Subsequence:&quot;</span>, longest_bitonic_subsequence(arr))</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> longestBitonicSubsequence<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lis<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> lds<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute LIS values</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>                lis<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>lis<span class="op">[</span>i<span class="op">],</span> lis<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Compute LDS values</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&gt;</span> i<span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>j<span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>                lds<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>lds<span class="op">[</span>i<span class="op">],</span> lds<span class="op">[</span>j<span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Combine LIS and LDS</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxLBS <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        maxLBS <span class="op">=</span> max<span class="op">(</span>maxLBS<span class="op">,</span> lis<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> lds<span class="op">[</span>i<span class="op">]</span> <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> maxLBS<span class="op">;</span></span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">11</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of Longest Bitonic Subsequence: &quot;</span> <span class="op">&lt;&lt;</span> longestBitonicSubsequence<span class="op">(</span>arr<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This method helps to find the longest bitonic subsequence by mixing
results from longest increasing and decreasing subsequences. If you want
to learn more about dynamic programming, you can look at other
algorithms like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Longest
Increasing Subsequence</a>.</p>
<h2
id="complexity-analysis-of-longest-bitonic-subsequence-algorithm">Complexity
Analysis of Longest Bitonic Subsequence Algorithm</h2>
<p>We can look at the Longest Bitonic Subsequence (LBS) problem by
checking its time and space complexity when we use dynamic programming.
The LBS is a subsequence that first goes up and then goes down.</p>
<h3 id="time-complexity-1">Time Complexity</h3>
<ol type="1">
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>The algorithm has two main steps.
<ul>
<li>First, we find the Longest Increasing Subsequence (LIS) for each
element from the left.</li>
<li>Then, we find the Longest Decreasing Subsequence (LDS) for each
element from the right.</li>
</ul></li>
<li>Each LIS and LDS calculation takes (O(n^2)) time. Here, (n) is the
length of the input sequence.</li>
<li>So, the overall time complexity for the LBS algorithm is: [ O(n^2)
]</li>
</ul></li>
<li><strong>Optimized Approach</strong> (Using Binary Search):
<ul>
<li>If we use binary search to find the LIS and LDS, we can make the
time for each (O(n n)).</li>
<li>So, with this method, the overall time complexity can be better to:
[ O(n n) ]</li>
<li>We do this by keeping an extra array. This array helps us track the
longest subsequence better.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ol type="1">
<li><strong>Dynamic Programming Approach</strong>:
<ul>
<li>The space complexity mostly comes from storing the results of LIS
and LDS calculations.</li>
<li>We need two extra arrays to keep track of the lengths of the
sequences. Each array has size (n): [ O(n) ]</li>
<li>Therefore, the total space complexity for the normal dynamic
programming method is: [ O(n) ]</li>
</ul></li>
<li><strong>Optimized Approach</strong>:
<ul>
<li>If we use the better method with binary search, the space complexity
can still be (O(n)) for storing the lengths of LIS and LDS.</li>
<li>The extra array for binary search can also be small. This leads to:
[ O(n) ]</li>
</ul></li>
</ol>
<p>The complexity analysis shows that we can solve the LBS algorithm in
(O(n^2)), but we can also make it faster to (O(n n)) with the right
method. We keep the space complexity linear. This makes dynamic
programming a good way to solve the Longest Bitonic Subsequence problem
well.</p>
<h2
id="common-mistakes-in-implementing-longest-bitonic-subsequence">Common
Mistakes in Implementing Longest Bitonic Subsequence</h2>
<p>When we implement the Longest Bitonic Subsequence (LBS) algorithm, we
often make some common mistakes. Knowing these mistakes can help us make
our solution better and more correct.</p>
<ol type="1">
<li><strong>Incorrect Calculation of Increasing and Decreasing
Subsequences</strong>:
<ul>
<li>We must make sure we calculate both the increasing and decreasing
subsequences right. Sometimes, we forget about boundary conditions or do
not reset indices when we switch from increasing to decreasing
parts.</li>
</ul></li>
<li><strong>Improper Use of Dynamic Programming Arrays</strong>:
<ul>
<li>Many times, we do not start the dynamic programming (DP) arrays
correctly. Both the <code>increasing</code> and <code>decreasing</code>
arrays should start at 1 because the smallest length of any subsequence
is 1. This means just the single element.</li>
</ul></li>
<li><strong>Missing Edge Cases</strong>:
<ul>
<li>We need to handle edge cases like sequences with all same elements
or sequences that only go up or down. If we do not think about these, we
can get wrong answers.</li>
</ul></li>
<li><strong>Inefficient Time Complexity</strong>:
<ul>
<li>Some of us may use nested loops without making the DP filling
process better. The time we expect is O(n^2), but sometimes we make it
O(n^3) by putting loops in the wrong place.</li>
</ul></li>
<li><strong>Confusing the Length of the Bitonic Subsequence</strong>:
<ul>
<li>We must remember that the length of the longest bitonic subsequence
comes from adding the lengths of the longest increasing and longest
decreasing subsequences. If we forget about the peak element, which we
count twice, we can get incorrect results.</li>
</ul></li>
<li><strong>Not Handling Input Validations</strong>:
<ul>
<li>We often forget to check the input before we start. The algorithm
should work well when the input array is empty or has only one
element.</li>
</ul></li>
<li><strong>Verbose Code Leading to Logic Errors</strong>:
<ul>
<li>If we write complicated code, it can lead to logic mistakes. Keeping
our code simple and clear will help keep the algorithm correct.</li>
</ul></li>
</ol>
<p>Hereâ€™s a sample implementation of the Longest Bitonic Subsequence in
Python to show a good structure:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> longest_bitonic_subsequence(arr):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize DP arrays</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    increasing <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    decreasing <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill increasing subsequence DP array</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                increasing[i] <span class="op">=</span> <span class="bu">max</span>(increasing[i], increasing[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill decreasing subsequence DP array</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, i, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">&gt;</span> arr[j]:</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                decreasing[i] <span class="op">=</span> <span class="bu">max</span>(decreasing[i], decreasing[j] <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find maximum value of LBS</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    max_length <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        max_length <span class="op">=</span> <span class="bu">max</span>(max_length, increasing[i] <span class="op">+</span> decreasing[i] <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_length</span></code></pre></div>
<p>By avoiding these mistakes and following some best practices, we can
make a stronger and faster Longest Bitonic Subsequence algorithm. For
more reading about dynamic programming methods and other problems, check
out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-definition-of-the-longest-bitonic-subsequence">What
is the definition of the Longest Bitonic Subsequence?</h3>
<p>The Longest Bitonic Subsequence (LBS) is a special type of
subsequence. It starts by increasing and then it decreases. This is a
common problem in dynamic programming. The goal is to find the longest
length of this subsequence. We need to understand bitonic sequences well
to use dynamic programming methods effectively.</p>
<h3
id="how-can-i-implement-the-longest-bitonic-subsequence-algorithm-in-java">How
can I implement the Longest Bitonic Subsequence algorithm in Java?</h3>
<p>To implement the Longest Bitonic Subsequence in Java, we usually make
two arrays. One array is for the longest increasing subsequence (LIS)
and the other is for the longest decreasing subsequence (LDS) for each
element. Next, we go through the sequence to find the values. Finally,
we find the maximum value by combining LIS and LDS at each index. You
can see our guide for the <a href="#">Dynamic Programming Approach for
Longest Bitonic Subsequence in Java</a>.</p>
<h3
id="what-are-the-time-and-space-complexities-of-the-longest-bitonic-subsequence-algorithm">What
are the time and space complexities of the Longest Bitonic Subsequence
algorithm?</h3>
<p>The time complexity for the Longest Bitonic Subsequence algorithm
using dynamic programming is O(n^2). Here, n is the length of the input
sequence. The space complexity is O(n) because we use extra arrays to
keep intermediate results. We can try to reduce space complexity if we
want.</p>
<h3
id="can-you-explain-the-difference-between-longest-increasing-subsequence-and-longest-bitonic-subsequence">Can
you explain the difference between Longest Increasing Subsequence and
Longest Bitonic Subsequence?</h3>
<p>The Longest Increasing Subsequence (LIS) has elements that only
increase. The Longest Bitonic Subsequence allows for an initial increase
followed by a decrease. So, an LBS has a LIS and then a LDS. This makes
it a bit more complex and suitable for dynamic programming. For more
details, check out our article on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming Longest Increasing Subsequence</a>.</p>
<h3
id="what-are-some-common-mistakes-to-avoid-when-implementing-the-longest-bitonic-subsequence">What
are some common mistakes to avoid when implementing the Longest Bitonic
Subsequence?</h3>
<p>Common mistakes in implementing the Longest Bitonic Subsequence
include not calculating the LIS and LDS arrays correctly. We might also
forget edge cases, like single-element arrays. Not combining the results
properly is another mistake. It is very important to manage your indices
well and to consider all subsequences. For more tips, look at the
section on <a href="#">Common Mistakes in Implementing Longest Bitonic
Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            