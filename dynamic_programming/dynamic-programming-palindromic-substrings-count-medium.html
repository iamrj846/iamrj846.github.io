
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Palindromic Substrings Count - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to count palindromic substrings using dynamic programming. Master this algorithm with our in-depth guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Palindromic Substrings Count - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a strong method we use to solve hard problems.
We do this by breaking them into easier parts. When we want to count
palindromic substrings, dynamic programming helps us find all the
palindromic parts of a string quickly. We create a 2D table. Each spot
in the table tells us if a substring is a palindrome. This helps us
count them easily.</p>
<p>In this article, we will look at different ways to count palindromic
substrings using dynamic programming. We will check out how to do this
in Java, Python, and C++. We also look at better methods and the expand
around center method. Furthermore, we will compare dynamic programming
with the expand around center method. We will study time and space
complexities. We will also point out common mistakes and answer
questions people often ask about this topic.</p>
<ul>
<li>Dynamic Programming Palindromic Substrings Count Approach
Overview</li>
<li>Dynamic Programming Solution in Java for Palindromic Substrings
Count</li>
<li>Dynamic Programming Solution in Python for Palindromic Substrings
Count</li>
<li>Dynamic Programming Solution in C++ for Palindromic Substrings
Count</li>
<li>Optimized Dynamic Programming Techniques for Palindromic Substrings
Count</li>
<li>Exploring Expand Around Center Method for Palindromic
Substrings</li>
<li>Comparative Analysis of Dynamic Programming and Expand Around
Center</li>
<li>Time Complexity and Space Complexity Analysis for Palindromic
Substrings</li>
<li>Common Mistakes to Avoid in Palindromic Substrings Count</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you want to read more about dynamic programming, you can check out
these articles. They are <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming Longest Palindromic Subsequence</a>.</p>
<h2
id="dynamic-programming-solution-in-java-for-palindromic-substrings-count">Dynamic
Programming Solution in Java for Palindromic Substrings Count</h2>
<p>We can count palindromic substrings in a string using dynamic
programming in Java. We use a 2D array to check if substrings are
palindromic. We will look at all possible substrings and fill the DP
table based on results we already have.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PalindromicSubstrings <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// All substrings of length 1 are palindromic</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for substrings of length 2</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for substrings longer than 2</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> length<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> length<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>                    count<span class="op">++;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>        PalindromicSubstrings ps <span class="op">=</span> <span class="kw">new</span> <span class="fu">PalindromicSubstrings</span><span class="op">();</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> input <span class="op">=</span> <span class="st">&quot;abc&quot;</span><span class="op">;</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> ps<span class="op">.</span><span class="fu">countSubstrings</span><span class="op">(</span>input<span class="op">);</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Total palindromic substrings: &quot;</span> <span class="op">+</span> result<span class="op">);</span> <span class="co">// Output: 3</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We create a DP table
<code>dp</code> with size <code>n x n</code>. Here <code>n</code> is the
length of the string. We also make a counter <code>count</code> to keep
track of palindromic substrings.</li>
<li><strong>Base Case</strong>: All substrings of length 1 are
palindromic. We handle this in the first loop.</li>
<li><strong>Two-character Palindromes</strong>: We check pairs of
characters for palindromes.</li>
<li><strong>Longer Substrings</strong>: For substrings that are longer
than two characters, we check the first and last characters. We look at
the DP value for the substring in between.</li>
<li>Finally, we return the count of palindromic substrings.</li>
</ul>
<p>This dynamic programming solution counts palindromic substrings
quickly. It has time complexity of O(n^2) and space complexity of
O(n^2). If we want to use less space, we can optimize the DP table to
use a 1D array instead.</p>
<h2
id="dynamic-programming-solution-in-python-for-palindromic-substrings-count">Dynamic
Programming Solution in Python for Palindromic Substrings Count</h2>
<p>We can solve the problem of counting palindromic substrings using
dynamic programming in Python. We will create a 2D array
<code>dp</code>. Here, <code>dp[i][j]</code> will be <code>True</code>
if the substring from index <code>i</code> to <code>j</code> is a
palindrome. We will fill this table and count the palindromic
substrings.</p>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_palindromic_substrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(s)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="va">False</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All substrings of length 1 are palindromes</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        dp[i][i] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for substrings of length 2</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> s[i] <span class="op">==</span> s[i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            dp[i][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check for substrings of length greater than 2</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># substring length</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i] <span class="op">==</span> s[j] <span class="kw">and</span> dp[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>input_string <span class="op">=</span> <span class="st">&quot;abc&quot;</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_palindromic_substrings(input_string))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We make a 2D list <code>dp</code>
to keep track of palindromic substrings. We also make a counter
<code>count</code> to store the total number of palindromic
substrings.</li>
<li><strong>Single Character Palindromes</strong>: Each single character
is a palindrome. So we set all <code>dp[i][i]</code> to
<code>True</code> and increase the count.</li>
<li><strong>Two Character Palindromes</strong>: We check pairs of
characters. If they are same, we set <code>dp[i][i + 1]</code> to
<code>True</code> and increase the count.</li>
<li><strong>Longer Substrings</strong>: For substrings longer than 2, we
check if the outer characters are the same. Then we check if the inner
substring is also a palindrome (<code>dp[i + 1][j - 1]</code>).</li>
<li><strong>Return Count</strong>: At the end, we return the total count
of palindromic substrings.</li>
</ul>
<p>This method counts palindromic substrings in O(n^2) time and uses
O(n^2) space. If we want to learn more about dynamic programming, we can
check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Longest
Palindromic Subsequence</a> problem.</p>
<h2
id="dynamic-programming-solution-in-c-for-palindromic-substrings-count">Dynamic
Programming Solution in C++ for Palindromic Substrings Count</h2>
<p>We can count palindromic substrings using dynamic programming in C++.
We will use a 2D boolean array <code>dp</code>. Here,
<code>dp[i][j]</code> tells us if the substring from index
<code>i</code> to <code>j</code> is a palindrome. We start by setting up
the array for single characters and two-character substrings. Then we
will look at longer substrings.</p>
<h3 id="c-implementation">C++ Implementation:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPalindromicSubstrings<span class="op">(</span><span class="at">const</span> string<span class="op">&amp;</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="kw">false</span><span class="op">));</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Every single character is a palindrome</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        count<span class="op">++;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check for two character palindromes</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check for palindromes longer than 2 characters</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> length <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> length <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>length<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> length<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a>    string input <span class="op">=</span> <span class="st">&quot;abba&quot;</span><span class="op">;</span></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> countPalindromicSubstrings<span class="op">(</span>input<span class="op">);</span></span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Total palindromic substrings: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code:</h3>
<p>We have the function <code>countPalindromicSubstrings</code> that
takes a string <code>s</code>. It starts by making a 2D vector
<code>dp</code> to keep track of palindromic substrings.</p>
<p>First, we count single-character palindromes. Then we check pairs of
two characters if they are the same. For substrings longer than two
characters, we see if the first and last characters are the same. We
also check if the substring between them is a palindrome. We use the
results we saved in <code>dp</code>.</p>
<p>At the end, we return the total count of palindromic substrings found
in the input string.</p>
<p>This dynamic programming method counts palindromic substrings fast.
It has a time complexity of O(n^2) and a space complexity of O(n^2).
This makes it good for medium-sized strings. If we want to learn more
ways to make this better, we can look at the Expand Around Center
technique.</p>
<h2
id="optimized-dynamic-programming-techniques-for-palindromic-substrings-count">Optimized
Dynamic Programming Techniques for Palindromic Substrings Count</h2>
<p>We can use optimized dynamic programming techniques to count
palindromic substrings. These techniques help us save space and time.
They also let us work with bigger input sizes better. The main goal is
to lower the complexity of storing results while keeping everything
correct.</p>
<h3 id="space-optimization">1. Space Optimization</h3>
<p>We do not need to use a 2D array for all substrings. Instead, we can
use one or two arrays to store results for the last two rows of the DP
table. This change brings down the space complexity from (O(n^2)) to
(O(n)).</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">-</span> i <span class="op">&lt;=</span> <span class="dv">2</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="expand-around-center">2. Expand Around Center</h3>
<p>This method counts palindromic substrings by expanding around
possible centers. Each character and each space between characters can
be a center. The time complexity is (O(n^2)), but the space complexity
is (O(1)).</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> expandAroundCenter(s, i, i)   <span class="co"># Odd length palindromes</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> expandAroundCenter(s, i, i <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># Even length palindromes</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> expandAroundCenter(s: <span class="bu">str</span>, left: <span class="bu">int</span>, right: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> right <span class="op">&lt;</span> <span class="bu">len</span>(s) <span class="kw">and</span> s[left] <span class="op">==</span> s[right]:</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h3 id="manachers-algorithm">3. Manacher’s Algorithm</h3>
<p>If we want an even better solution, we can use Manacher’s algorithm.
It finds all palindromic substrings in linear time (O(n)). This
algorithm prepares the string first and then calculates the maximum
radius of palindromes centered at each character.</p>
<h3 id="using-a-hashmap">4. Using a HashMap</h3>
<p>We can also use a HashMap to store results that we computed before.
This way, we can access them quicker. It reduces the need to repeat
calculations while counting palindromic substrings.</p>
<h3 id="iterative-dynamic-programming-with-reduced-memory">5. Iterative
Dynamic Programming with Reduced Memory</h3>
<p>We can iterate over the string and update only the needed values in a
linear array. This method helps us use memory well while still using
dynamic programming.</p>
<h3 id="example-of-iterative-dp">Example of Iterative DP</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countSubstrings<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">bool</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="kw">false</span><span class="op">);</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> len <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> len <span class="op">&lt;=</span> n<span class="op">;</span> len<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> start <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> start <span class="op">&lt;=</span> n <span class="op">-</span> len<span class="op">;</span> start<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> end <span class="op">=</span> start <span class="op">+</span> len <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>start<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>end<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>len <span class="op">&lt;=</span> <span class="dv">2</span> <span class="op">||</span> dp<span class="op">[</span>start <span class="op">+</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>start<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">.</span>assign<span class="op">(</span>n<span class="op">,</span> <span class="kw">false</span><span class="op">);</span> <span class="co">// Reset the DP array for the next length</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>These optimized techniques help us count palindromic substrings
better. Now, we can handle larger strings more easily. For more
information about dynamic programming, we can read articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming Longest Palindromic Subsequence</a>.</p>
<h2
id="exploring-expand-around-center-method-for-palindromic-substrings">Exploring
Expand Around Center Method for Palindromic Substrings</h2>
<p>We can use the Expand Around Center method to count palindromic
substrings. This method finds possible centers of palindromes. Then, it
expands outwards to check if they are palindromic.</p>
<h3 id="algorithm-overview">Algorithm Overview</h3>
<ol type="1">
<li><strong>Identify Centers</strong>: Each palindrome expands around
its center. For a string with length <code>n</code>, we have
<code>2n - 1</code> potential centers. This includes each character and
each gap between characters.</li>
<li><strong>Expand</strong>: For every center, we expand outwards while
the characters on both sides are the same. We count valid palindromes as
we do this.</li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is a Java code for the Expand Around Center method to count
palindromic substrings:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PalindromicSubstrings <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> center <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> center <span class="op">&lt;</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span> center<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="fu">expandAroundCenter</span><span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center<span class="op">);</span> <span class="co">// Odd length palindromes</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="fu">expandAroundCenter</span><span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// Even length palindromes</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">expandAroundCenter</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> right <span class="op">&lt;</span> s<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">&amp;&amp;</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>left<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>right<span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            left<span class="op">--;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            right<span class="op">++;</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is the same algorithm in Python:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> countSubstrings(<span class="va">self</span>, s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> center <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="va">self</span>.expandAroundCenter(s, center, center)   <span class="co"># Odd length palindromes</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="va">self</span>.expandAroundCenter(s, center, center <span class="op">+</span> <span class="dv">1</span>)  <span class="co"># Even length palindromes</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expandAroundCenter(<span class="va">self</span>, s: <span class="bu">str</span>, left: <span class="bu">int</span>, right: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> right <span class="op">&lt;</span> <span class="bu">len</span>(s) <span class="kw">and</span> s[left] <span class="op">==</span> s[right]:</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count</span></code></pre></div>
<h3 id="c-implementation-1">C++ Implementation</h3>
<p>Here is the C++ version of the method:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countSubstrings<span class="op">(</span>string s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> center <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> center <span class="op">&lt;</span> s<span class="op">.</span>length<span class="op">();</span> center<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> expandAroundCenter<span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center<span class="op">);</span> <span class="co">// Odd length palindromes</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> expandAroundCenter<span class="op">(</span>s<span class="op">,</span> center<span class="op">,</span> center <span class="op">+</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// Even length palindromes</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> expandAroundCenter<span class="op">(</span>string s<span class="op">,</span> <span class="dt">int</span> left<span class="op">,</span> <span class="dt">int</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> right <span class="op">&lt;</span> s<span class="op">.</span>length<span class="op">()</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>left<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>right<span class="op">])</span> <span class="op">{</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>            left<span class="op">--;</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>            right<span class="op">++;</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="advantages">Advantages</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2). The <code>n</code> is the
length of the input string. Each center gets processed in linear
time.</li>
<li><strong>Space Complexity</strong>: O(1). It uses only a constant
amount of space.</li>
</ul>
<h3 id="use-cases">Use Cases</h3>
<p>We find the Expand Around Center method very useful for problems with
palindromic substrings. It can be a good choice instead of dynamic
programming when we need to save space. For more information on similar
dynamic programming methods, we can check out articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">dynamic
programming Fibonacci number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">longest
palindromic subsequence</a>.</p>
<h2
id="comparative-analysis-of-dynamic-programming-and-expand-around-center">Comparative
Analysis of Dynamic Programming and Expand Around Center</h2>
<p>When we try to count palindromic substrings, two main techniques come
up: Dynamic Programming (DP) and the Expand Around Center method. Each
technique has its own benefits and downsides. They work better in
different situations.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ul>
<li><strong>Algorithm</strong>: This method creates a 2D boolean array
<code>dp</code>. Here, <code>dp[i][j]</code> shows if the substring from
index <code>i</code> to <code>j</code> is a palindrome.</li>
<li><strong>Time Complexity</strong>: O(n^2), where n is the length of
the string.</li>
<li><strong>Space Complexity</strong>: O(n^2) for the <code>dp</code>
array.</li>
<li><strong>Implementation</strong>:</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">-</span> i <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="expand-around-center-approach">Expand Around Center
Approach</h3>
<ul>
<li><strong>Algorithm</strong>: This method counts palindromic
substrings by expanding around each character and pairs of characters as
centers.</li>
<li><strong>Time Complexity</strong>: O(n^2), because each expansion
takes O(n) time at worst.</li>
<li><strong>Space Complexity</strong>: O(1), as it needs no extra space
except for a few variables.</li>
<li><strong>Implementation</strong>:</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countSubstrings(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> expand_around_center(left: <span class="bu">int</span>, right: <span class="bu">int</span>):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">nonlocal</span> count</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> left <span class="op">&gt;=</span> <span class="dv">0</span> <span class="kw">and</span> right <span class="op">&lt;</span> <span class="bu">len</span>(s) <span class="kw">and</span> s[left] <span class="op">==</span> s[right]:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            left <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            right <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        expand_around_center(i, i)    <span class="co"># Odd length palindromes</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        expand_around_center(i, i <span class="op">+</span> <span class="dv">1</span>) <span class="co"># Even length palindromes</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h3 id="key-differences">Key Differences</h3>
<ul>
<li><strong>Space Efficiency</strong>: Expand Around Center uses O(1)
space. This is better than O(n^2) used by the dynamic programming
method.</li>
<li><strong>Implementation Complexity</strong>: DP might be easier for
those who know about matrices. Expand Around Center needs careful index
handling but is usually simpler.</li>
<li><strong>Performance</strong>: Both methods have similar time
complexities. But the actual performance can differ. Expand Around
Center can be faster than DP for smaller strings because it has less
overhead.</li>
</ul>
<p>When we care about space or work with large strings, we often choose
the Expand Around Center method. On the other hand, if we need a clear
structure that shows relationships among substrings, Dynamic Programming
is a good option.</p>
<p>For more information on dynamic programming techniques, we can check
out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming: Longest Palindromic Subsequence</a>.</p>
<h2
id="time-complexity-and-space-complexity-analysis-for-palindromic-substrings">Time
Complexity and Space Complexity Analysis for Palindromic Substrings</h2>
<p>When we count palindromic substrings with dynamic programming, we
need to look at time and space complexity. This helps us understand how
good the algorithm works.</p>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for our dynamic programming method to count
palindromic substrings is O(n^2). Here, n is the length of the input
string. This happens because:</p>
<ul>
<li>We create a 2D array (table) that is n x n. This table shows if
substrings are palindromic.</li>
<li>We check all possible substrings, which makes a nested loop:
<ul>
<li>The outer loop goes through each starting index of the
substring.</li>
<li>The inner loop checks each ending index. This gives us n * n
operations in total.</li>
</ul></li>
</ul>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity of our dynamic programming solution is also
O(n^2). This is because of the 2D table we use to keep the results of
smaller problems. Each spot in this table tells us if the substring from
index i to j is a palindrome.</p>
<h3 id="example">Example</h3>
<p>Here is a simple example of the dynamic programming method:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span><span class="bu">String</span> s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">boolean</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">boolean</span><span class="op">[</span>n<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> j<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">-</span> i <span class="op">&lt;</span> <span class="dv">2</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this code: - We start with a 2D boolean array <code>dp</code>. -
We use loops to fill this table and count palindromic substrings.</p>
<h3 id="summary-of-complexities">Summary of Complexities</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2)</li>
<li><strong>Space Complexity</strong>: O(n^2)</li>
</ul>
<p>If you want to learn more about dynamic programming methods, you can
look at articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming - Longest Palindromic Subsequence</a>.</p>
<h2 id="common-mistakes-to-avoid-in-palindromic-substrings-count">Common
Mistakes to Avoid in Palindromic Substrings Count</h2>
<p>When we use dynamic programming to count palindromic substrings, we
need to avoid common mistakes. These errors can cause our solutions to
be bad or give wrong results. Here are some mistakes we often make:</p>
<ol type="1">
<li><p><strong>Incorrect Initialization of DP Table</strong>:<br />
We must initialize the dynamic programming table correctly. Single
characters are always palindromes. Here is an example in Java:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>i<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span> <span class="co">// Each character is a palindrome</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Neglecting Two-Character Palindromes</strong>:<br />
When we look at substrings of length two, we must check if both
characters are the same. Here is how to do it in Python:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> s[i] <span class="op">==</span> s[i <span class="op">+</span> <span class="dv">1</span>]:</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>        dp[i][i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></span></code></pre></div></li>
<li><p><strong>Wrong Transition Logic</strong>:<br />
The transition must check the characters around the current substring
correctly. For substring <code>s[i:j]</code>, we use this condition:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>j <span class="op">-</span> i <span class="op">&lt;</span> <span class="dv">3</span> <span class="op">||</span> dp<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="kw">true</span><span class="op">;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Counting Duplicates</strong>:<br />
We need to count each palindromic substring only once. We should keep
track of counts well as we fill the DP table.</p></li>
<li><p><strong>Ignoring Edge Cases</strong>:<br />
We should be careful with strings that are empty or have only one
character. The count should be set up and handled right:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="bu">len</span>(s) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span></span></code></pre></div></li>
<li><p><strong>Failing to Optimize Space Complexity</strong>:<br />
If we care about space, we can use a 1D array instead of a 2D array for
the DP approach. This is because we only need the previous
states.</p></li>
<li><p><strong>Not Handling Non-Alphanumeric Characters</strong>:<br />
If the problem says we can only use certain characters, we must filter
inputs correctly before we start.</p></li>
<li><p><strong>Overlooking the Final Count</strong>:<br />
We need to make sure that our logic for adding up palindromic substrings
at the end of our algorithm counts all valid substrings.</p></li>
</ol>
<p>By avoiding these mistakes, we can make sure our dynamic programming
solution for counting palindromic substrings is better and works well.
For more information on related dynamic programming techniques, we can
check out articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Dynamic
Programming: Longest Palindromic Subsequence</a> and other dynamic
programming problems on our site.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-for-counting-palindromic-substrings">1.
What is the dynamic programming approach for counting palindromic
substrings?</h3>
<p>We use a dynamic programming approach to count palindromic substrings
by making a 2D table. This table helps us keep track of which substrings
are palindromic. We look at different substring lengths and starting
points. Then, we fill the table based on what we found before. This way,
we check each substring only one time. It makes our solution faster with
a time complexity of O(n^2).</p>
<h3
id="how-does-the-expand-around-center-method-work-for-palindromic-substrings">2.
How does the Expand Around Center method work for palindromic
substrings?</h3>
<p>The Expand Around Center method finds palindromic substrings by using
each character and the space between characters as possible centers. We
expand outwards while the characters are the same. We count the
palindromes that we find. This method is simple and works well. It also
has a time complexity of O(n^2), which makes it a good choice next to
dynamic programming for counting palindromic substrings.</p>
<h3
id="what-are-the-common-mistakes-to-avoid-when-counting-palindromic-substrings">3.
What are the common mistakes to avoid when counting palindromic
substrings?</h3>
<p>When we count palindromic substrings, we should avoid common
mistakes. One mistake is forgetting to include single-character
palindromes. Another mistake is not handling overlapping substrings
correctly. Also, we must set up our dynamic programming table right. If
we do not, we might get wrong results. It is very important to test edge
cases too. For example, we should check empty strings and strings with
all the same characters to make sure our code works well.</p>
<h3
id="what-is-the-time-and-space-complexity-of-the-dynamic-programming-solution-for-palindromic-substrings">4.
What is the time and space complexity of the dynamic programming
solution for palindromic substrings?</h3>
<p>The dynamic programming solution for counting palindromic substrings
has a time complexity of O(n^2). Here, n is the length of the string.
The space complexity is also O(n^2) because we use a 2D table to store
palindromic substrings. If we want to save space, we can use the Expand
Around Center method, which only needs O(1) space.</p>
<h3
id="how-does-the-dynamic-programming-solution-for-palindromic-substrings-compare-to-other-dynamic-programming-problems">5.
How does the dynamic programming solution for palindromic substrings
compare to other dynamic programming problems?</h3>
<p>The dynamic programming solution for palindromic substrings is
similar to other dynamic programming problems like the longest common
subsequence or the maximum subarray problem. They all use a table to
save results of smaller problems. But the way we find palindromes is
different. If you want to learn more about dynamic programming, you can
read the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-palindromic-subsequence-medium.html">Longest
Palindromic Subsequence</a> article to see related strategies.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            