
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Paint Houses - Medium</title>
            <meta name="description" content="Discover how to solve the "Count Ways to Paint Houses" problem using dynamic programming. Learn techniques and examples!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Paint Houses - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a method we use to solve hard problems. We do
this by breaking them into smaller problems. We save the results of
these smaller problems. This way, we don’t have to do the same
calculation again.</p>
<p>When we talk about painting houses, the problem is about finding the
number of ways to paint a line of houses. We have a limited number of
colors and some rules to follow. The goal is to make sure that no two
houses next to each other have the same color. We can solve this problem
well by using dynamic programming.</p>
<p>In this article, we will look closely at the problem. We will talk
about different dynamic programming methods to count the ways to paint
houses. We will show you how to do this in Java, Python, and C++. We
will also share tips on how to make our space use better in dynamic
programming. Furthermore, we will check different methods and give
advice on how to test edge cases. This will help us understand the
problem completely.</p>
<p>Here is a list of topics we will cover:<br />
- [Dynamic Programming] Ways to Count Painting Houses - Medium<br />
- Understanding the Problem Statement<br />
- Dynamic Programming Approach to Count Ways to Paint Houses<br />
- Java Implementation for Count Ways to Paint Houses<br />
- Python Solution for Count Ways to Paint Houses<br />
- C++ Code Example for Count Ways to Paint Houses<br />
- Optimizing Space Complexity in Dynamic Programming<br />
- Comparative Analysis of Different Approaches<br />
- Testing and Edge Cases for Painting Houses Problem<br />
- Frequently Asked Questions</p>
<p>If you want to read more about dynamic programming, check these
articles: <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>We have a problem about counting how many ways we can paint houses.
This is a common problem in dynamic programming. We have <code>n</code>
houses in a row and <code>k</code> colors. Our goal is to find out how
many ways we can paint all the houses. We must make sure that no two
houses next to each other have the same color.</p>
<h3 id="problem-constraints">Problem Constraints:</h3>
<ul>
<li>Each house can be painted with one of <code>k</code> colors.</li>
<li>Houses that are next to each other must not have the same
color.</li>
<li>We need to calculate the total number of valid ways to paint the
<code>n</code> houses.</li>
</ul>
<h3 id="example">Example:</h3>
<p>For example, if we have 3 houses and 2 colors (let’s say Color 1 and
Color 2), some valid ways to paint the houses could be: - House 1: Color
1, House 2: Color 2, House 3: Color 1 - House 1: Color 2, House 2: Color
1, House 3: Color 2</p>
<p>The answer for this example is 6. We can find this by: - For the
first house, we have <code>k</code> choices. - For each house after the
first one, we have <code>k-1</code> choices. This is to make sure it is
different from the house before it.</p>
<h3 id="mathematical-representation">Mathematical Representation:</h3>
<p>We can let <code>dp[i]</code> show how many ways to paint
<code>i</code> houses. We can write the relationship like this:</p>
<p>[ dp[i] = dp[i-1] (k - 1) + dp[i-2] (k - 1) ]</p>
<p>Base cases: - <code>dp[1] = k</code> -
<code>dp[2] = k \times (k - 1)</code></p>
<p>This relationship helps us build a dynamic programming method to
solve the problem in a smart way.</p>
<p>For more details on dynamic programming methods, check out articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Count
Ways to Climb Stairs</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Paint
House Problem</a>.</p>
<h2
id="dynamic-programming-approach-to-count-ways-to-paint-houses">Dynamic
Programming Approach to Count Ways to Paint Houses</h2>
<p>In the “Count Ways to Paint Houses” problem, we want to find out how
many ways we can paint a row of houses. We have some colors to choose
from. We need to make sure that no two houses next to each other have
the same color. We can solve this problem well with dynamic
programming.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have <code>n</code> houses and <code>k</code> colors. Our task is
to find out how many ways we can paint these houses so that the houses
next to each other do not have the same color.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><p><strong>State Definition</strong>: We say <code>dp[i]</code> is
the number of ways to paint the first <code>i</code> houses.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>For the first house, we have <code>k</code> choices. So,
<code>dp[1] = k</code>.</li>
<li>For the second house, it can be painted in <code>k - 1</code> ways
because it cannot be the same color as the first house. Thus,
<code>dp[2] = k * (k - 1)</code>.</li>
<li>For any house after the second, we can paint the <code>i-th</code>
house differently from the <code>(i-1)-th</code> house. We look at all
the ways we painted the previous houses: [ dp[i] = (k - 1) (dp[i - 1] +
dp[i - 2]) ]</li>
</ul></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li><code>dp[0] = 1</code> because there are no houses to paint.</li>
<li><code>dp[1] = k</code>.</li>
</ul></li>
<li><p><strong>Final Result</strong>: The answer we want is
<code>dp[n]</code>, which tells us how many ways we can paint
<code>n</code> houses.</p></li>
</ol>
<h3 id="implementation">Implementation</h3>
<p>Here is a Java code for the dynamic programming approach:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintHouses <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWaysToPaintHouses</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// number of houses</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// number of colors</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Ways to paint houses: &quot;</span> <span class="op">+</span> <span class="fu">countWaysToPaintHouses</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is a Python code for the same problem:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways_to_paint_houses(n, k):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> k</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">2</span>] <span class="op">=</span> k <span class="op">*</span> (k <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> (k <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> (dp[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">2</span>])</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># number of houses</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span>  <span class="co"># number of colors</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Ways to paint houses:&quot;</span>, count_ways_to_paint_houses(n, k))</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is a C++ code for counting ways to paint houses:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWaysToPaintHouses<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> dp<span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">2</span><span class="op">]</span> <span class="op">=</span> k <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// number of houses</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// number of colors</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Ways to paint houses: &quot;</span> <span class="op">&lt;&lt;</span> countWaysToPaintHouses<span class="op">(</span>n<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This dynamic programming way helps us to find the number of ways to
paint the houses while following the rules. It works good for larger
values of <code>n</code> and <code>k</code>. For more insights about
dynamic programming, check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Dynamic
Programming: Ways to Count Painting Houses</a>.</p>
<h2 id="java-implementation-for-count-ways-to-paint-houses">Java
Implementation for Count Ways to Paint Houses</h2>
<p>To solve the problem of counting how many ways we can paint houses
using dynamic programming in Java, we can do these steps:</p>
<ol type="1">
<li><p><strong>Define the Problem</strong>: We have <code>n</code>
houses and <code>k</code> colors. We must count how many ways we can
paint the houses. We cannot paint two adjacent houses with the same
color.</p></li>
<li><p><strong>Dynamic Programming State</strong>: We use
<code>dp[i][j]</code> to show how many ways we can paint the first
<code>i</code> houses. The <code>i-th</code> house will be painted with
color <code>j</code>.</p></li>
<li><p><strong>Transition Formula</strong>: We can define the transition
like this: [ dp[i][j] = _{c=0}^{k-1} dp[i-1][c] c j ] This means the
number of ways to paint the <code>i-th</code> house with color
<code>j</code> is the total ways to paint the previous house using all
colors except <code>j</code>.</p></li>
<li><p><strong>Base Case</strong>: For the first house, we can paint it
with any of the <code>k</code> colors: [ dp[1][j] = 1 j ]</p></li>
<li><p><strong>Final Calculation</strong>: The total ways to paint all
<code>n</code> houses is the sum of ways to paint the last house with
any of the <code>k</code> colors.</p></li>
</ol>
<p>Here is the Java code:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> PaintHouses <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWaysToPaintHouses</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> k <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// dp[i] is the number of ways to paint i houses</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> k<span class="op">;</span> <span class="co">// First house can be painted in k ways</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// For the second house and more</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">];</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Number of houses</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of colors</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;The number of ways to paint &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; houses with &quot;</span> <span class="op">+</span> k <span class="op">+</span> <span class="st">&quot; colors is: &quot;</span> <span class="op">+</span> <span class="fu">countWaysToPaintHouses</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The function <code>countWaysToPaintHouses</code> takes the number of
houses <code>n</code> and the number of colors <code>k</code>.</li>
<li>We use an array <code>dp</code> to store how many ways we can paint
from 1 to <code>n</code> houses.</li>
<li>The loop calculates the ways for each house based on the last two
houses. We make sure adjacent houses do not have the same color.</li>
<li>Finally, the main method tests the function with an example of 4
houses and 3 colors.</li>
</ul>
<p>This code calculates the number of ways to paint houses using dynamic
programming. It works well for larger numbers too. For more examples
about dynamic programming, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Dynamic
Programming: Paint House</a>.</p>
<h2 id="python-solution-for-count-ways-to-paint-houses">Python Solution
for Count Ways to Paint Houses</h2>
<p>To solve the problem of counting the ways to paint houses using
dynamic programming in Python, we can follow this simple approach. The
main idea is to keep a DP array. In this array, <code>dp[i][j]</code>
shows the number of ways to paint the <code>i-th</code> house with color
<code>j</code>. We must make sure that no two adjacent houses are the
same color.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have <code>n</code> houses in a line. Each house can be painted in
<code>k</code> different colors. The rule is that no two adjacent houses
can have the same color. Our task is to find the total number of ways to
paint these houses.</p>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><strong>Initialization</strong>: First, we define a DP array with
size <code>n x k</code>.</li>
<li><strong>Base Case</strong>: For the first house, we can paint it
with any of the <code>k</code> colors. So we set
<code>dp[0][j] = 1</code> for all <code>j</code> from <code>0</code> to
<code>k-1</code>.</li>
<li><strong>Recurrence Relation</strong>:
<ul>
<li><p>For each house <code>i</code> (from 1 to <code>n-1</code>), we
calculate:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> <span class="bu">sum</span>(dp[i<span class="op">-</span><span class="dv">1</span>][m]) <span class="cf">for</span> <span class="bu">all</span> m <span class="op">!=</span> j</span></code></pre></div></li>
<li><p>This means for each color <code>j</code>, we add all the ways to
paint the previous house with colors that are not
<code>j</code>.</p></li>
</ul></li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<p>Here is how we can write this logic in Python:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysToPaintHouses(n, k):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># dp[i][j] will show the number of ways to paint house i with color j</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> k <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: For the first house, we can use any of the k colors</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp table</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">sum</span>(dp[i<span class="op">-</span><span class="dv">1</span>][m] <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(k) <span class="cf">if</span> m <span class="op">!=</span> j)</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Total ways to paint all houses</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(dp[n<span class="op">-</span><span class="dv">1</span>][j] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of houses</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span>  <span class="co"># Number of colors</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countWaysToPaintHouses(n, k))  <span class="co"># Output: 6</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li>The function <code>countWaysToPaintHouses</code> takes
<code>n</code> (number of houses) and <code>k</code> (number of colors)
as input.</li>
<li>We create a DP table to store the number of ways to paint each
house.</li>
<li>The nested loops fill the DP table based on the rules we
discussed.</li>
<li>In the end, we add the values of the last row of the DP table to
find the total ways to paint all houses.</li>
</ul>
<p>This Python solution counts the ways to paint the houses while
following the rules of the problem. We can also look into more related
problems using dynamic programming, like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-fence-medium.html">Paint
Fence Problem</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Paint
House Problem</a>.</p>
<h2 id="c-code-example-for-count-ways-to-paint-houses">C++ Code Example
for Count Ways to Paint Houses</h2>
<p>In this section, we share a C++ code to count the ways to paint
houses. We use dynamic programming to solve this problem. The problem
says we have <code>n</code> houses in a row. Each house can be painted
in <code>k</code> colors. But we cannot paint two adjacent houses the
same color.</p>
<h3 id="problem-statement-2">Problem Statement</h3>
<p>Given <code>n</code> (number of houses) and <code>k</code> (number of
colors), we want to count how many ways we can paint the houses with
these rules.</p>
<h3 id="c-implementation-1">C++ Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWaysToPaintHouses<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// No houses</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span> <span class="co">// Only one way to paint one house</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// For the first house, there are k options. For the second house, there are (k-1) options.</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> same <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> diff <span class="op">=</span> k<span class="op">;</span> <span class="co">// We set same and diff for the first two houses</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        same <span class="op">=</span> diff<span class="op">;</span> <span class="co">// Current house can be painted same as the one before</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span>same <span class="op">+</span> diff<span class="op">);</span> <span class="co">// Current house can be painted different</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> same <span class="op">+</span> diff<span class="op">;</span> <span class="co">// Total ways is sum of both cases</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> <span class="co">// Number of houses</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Number of colors</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to paint &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; houses with &quot;</span> <span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot; colors: &quot;</span> <span class="op">&lt;&lt;</span> countWaysToPaintHouses<span class="op">(</span>n<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The function <code>countWaysToPaintHouses</code> takes
<code>n</code> and <code>k</code> as inputs.</li>
<li>We start two variables: <code>same</code> for ways to paint the
house the same color as before, and <code>diff</code> for ways to paint
it a different color.</li>
<li>We use a loop to calculate ways for each house based on the previous
counts.</li>
<li>At the end, we return the total ways by adding both cases.</li>
</ul>
<p>This way, we get the answer fast with O(n) time and O(1) space.</p>
<p>For more reading and similar problems in dynamic programming, check
the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Dynamic
Programming: Paint House - Medium</a>.</p>
<h2 id="optimizing-space-complexity-in-dynamic-programming">Optimizing
Space Complexity in Dynamic Programming</h2>
<p>In dynamic programming, we can often reduce space complexity using
simple methods. This is important when our solution needs a straight
line of states. The aim is to use less memory while keeping our
calculations fast. Here are some easy ways to optimize space complexity
in dynamic programming problems. We will look at the “Count Ways to
Paint Houses” problem as an example.</p>
<h3 id="iterative-approach-with-rolling-arrays">1. <strong>Iterative
Approach with Rolling Arrays</strong></h3>
<p>Instead of keeping a whole table of past states, we can often store
only the last few states we need. For instance, if our problem needs
<code>n</code> past states, we just keep the last two or three.</p>
<p><strong>Example</strong>: In the “Count Ways to Paint Houses”
problem, if we only need the results from the last two houses to find
the current house, we can cut the space complexity from O(n) to
O(1).</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> k<span class="op">;</span> <span class="co">// ways to paint the last house</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev2 <span class="op">=</span> k <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// ways to paint the second last house</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">3</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> <span class="op">(</span>prev1 <span class="op">+</span> prev2<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="in-place-updates">2. <strong>In-Place Updates</strong></h3>
<p>For problems where we can fill the state table, we can change the
entries in the table while we find new values. This way, we do not need
to keep old values.</p>
<h3 id="constant-space-solutions">3. <strong>Constant Space
Solutions</strong></h3>
<p>Sometimes, we can find a clear formula to calculate the result. This
means we do not need to keep any extra states. This is good for problems
with linear or polynomial properties.</p>
<h3 id="recursive-with-memoization">4. <strong>Recursive with
Memoization</strong></h3>
<p>Recursion can use a lot of space because of the stack depth. But we
can use memoization to save results of smaller problems. This helps
reduce the need to recalculate. Still, we should remember that this can
keep a cache that may take up space.</p>
<h3 id="bit-manipulation">5. <strong>Bit Manipulation</strong></h3>
<p>For some problems, we can use bit manipulation to store states in a
small way. This is helpful for combinatorial problems or when we have
few states.</p>
<p>By using these methods, we can improve space complexity in dynamic
programming. This makes our algorithms work better, especially when we
deal with large inputs. For more details on dynamic programming methods
and tips, we can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-paint-house-medium.html">Dynamic
Programming: Count Ways to Paint Houses</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we solve the problem of counting ways to paint houses with
dynamic programming, we can use different methods. The main ways are the
simple recursive solution, memoization, and the bottom-up dynamic
programming method. Let’s look at these methods side by side.</p>
<h3 id="naive-recursive-approach">Naive Recursive Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: Exponential, O(2^n).</li>
<li><strong>Space Complexity</strong>: O(n) because of the call
stack.</li>
<li><strong>Description</strong>: This method calculates the number of
ways to paint houses again and again. It does not keep any results, so
it repeats the same work.</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> k<span class="op">));</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="memoization-approach">Memoization Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n).</li>
<li><strong>Space Complexity</strong>: O(n) to store results.</li>
<li><strong>Description</strong>: This method makes the recursive method
better by saving the results of smaller problems. This way, it does not
do the same calculations again.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Integer</span><span class="op">[]</span> memo <span class="op">=</span> <span class="kw">new</span> <span class="bu">Integer</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fu">helper</span><span class="op">(</span>n<span class="op">,</span> k<span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span> <span class="dt">int</span> <span class="fu">helper</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">,</span> <span class="bu">Integer</span><span class="op">[]</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>memo<span class="op">[</span>n<span class="op">]</span> <span class="op">!=</span> <span class="kw">null</span><span class="op">)</span> <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    memo<span class="op">[</span>n<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">*</span> <span class="op">(</span><span class="fu">helper</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> k<span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">helper</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">2</span><span class="op">,</span> k<span class="op">,</span> memo<span class="op">));</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="bottom-up-dynamic-programming-approach">Bottom-Up Dynamic
Programming Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n).</li>
<li><strong>Space Complexity</strong>: O(1) when we do it smartly.</li>
<li><strong>Description</strong>: This method builds the solution step
by step from the base cases. It saves space by only using the last two
values we calculate.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> k<span class="op">;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> same <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> diff <span class="op">=</span> k<span class="op">,</span> total <span class="op">=</span> k<span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        same <span class="op">=</span> diff<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> <span class="op">(</span>total<span class="op">)</span> <span class="op">*</span> <span class="op">(</span>k <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        total <span class="op">=</span> same <span class="op">+</span> diff<span class="op">;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-comparison">Summary of Comparison</h3>
<ul>
<li><strong>Efficiency</strong>: The naive recursive method is not good
for big inputs because it takes a long time. But memoization and
bottom-up dynamic programming run much faster in linear time.</li>
<li><strong>Space Usage</strong>: Memoization needs extra space to keep
results. The bottom-up method can use less space if we optimize it.</li>
<li><strong>Implementation Complexity</strong>: The naive method is easy
to understand. But memoization and bottom-up are a bit more complex.
They do give big improvements in performance.</li>
</ul>
<p>In cases where speed is very important, we usually choose the
bottom-up dynamic programming method. It is fast and needs less space.
For more learning, we can check out related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Numbers</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2 id="testing-and-edge-cases-for-painting-houses-problem">Testing and
Edge Cases for Painting Houses Problem</h2>
<p>When we test the “Count Ways to Paint Houses” problem, we need to
think about different edge cases and situations. These can affect if the
solution works well or not. Here are some important test cases and edge
cases we should check:</p>
<ol type="1">
<li><strong>Minimum Input Values</strong>:
<ul>
<li>We can test with <code>n = 0</code> (no houses). The output should
be <code>0</code>. This is because no houses can be painted.</li>
<li>We can test with <code>n = 1</code> (one house). The output should
be <code>k</code>, where <code>k</code> is the number of colors.</li>
</ul></li>
<li><strong>Single Color</strong>:
<ul>
<li>We test with <code>k = 1</code> (only one color) and
<code>n &gt; 1</code>. The output should be <code>0</code>. This is
because we cannot paint adjacent houses the same color.</li>
</ul></li>
<li><strong>Multiple Houses with Colors</strong>:
<ul>
<li>We can test with <code>n = 3</code> and <code>k = 2</code>. The
output should be <code>2</code>:
<ul>
<li>Possible combinations are: RGY, RGB (R: Red, G: Green, B:
Blue).</li>
</ul></li>
</ul></li>
<li><strong>Large Input Values</strong>:
<ul>
<li>We should test with large values for <code>n</code> (like
<code>n = 1000</code>) and reasonable values for <code>k</code> (like
<code>k = 10</code>). This checks if the algorithm runs well without
crashing or taking too much time.</li>
</ul></li>
<li><strong>All Houses Same Color</strong>:
<ul>
<li>We test with <code>n = 5</code> and <code>k = 3</code>. The output
should be <code>30</code> because all houses can be painted in different
color combinations.</li>
</ul></li>
<li><strong>Performance Under Constraints</strong>:
<ul>
<li>We need to check how the algorithm deals with maximum values for
both <code>n</code> and <code>k</code>. This is to make sure it runs in
time and does not use too much memory.</li>
</ul></li>
<li><strong>Randomized Input</strong>:
<ul>
<li>We can create random values for <code>n</code> and <code>k</code>.
Then we verify if the output matches the expected number of ways to
paint according to the rules.</li>
</ul></li>
</ol>
<h3 id="example-code-for-testing">Example Code for Testing</h3>
<p>Here is a simple example in Python to test the function that counts
the ways to paint houses:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysToPaintHouses(n, k):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> k</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> k <span class="op">*</span> ((k <span class="op">-</span> <span class="dv">1</span>) <span class="op">**</span> (n <span class="op">-</span> <span class="dv">1</span>))</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing the function</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>test_cases <span class="op">=</span> [</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">3</span>),  <span class="co"># Expected: 0</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">3</span>),  <span class="co"># Expected: 3</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">2</span>),  <span class="co"># Expected: 2</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">5</span>, <span class="dv">1</span>),  <span class="co"># Expected: 0</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">5</span>, <span class="dv">3</span>),  <span class="co"># Expected: 30</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1000</span>, <span class="dv">10</span>)  <span class="co"># Performance test</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n, k <span class="kw">in</span> test_cases:</span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;n = </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, k = </span><span class="sc">{</span>k<span class="sc">}</span><span class="ss"> =&gt; Count Ways: </span><span class="sc">{</span>countWaysToPaintHouses(n, k)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<p>In conclusion, we need to test edge cases, minimum and maximum
inputs, and performance situations. This is very important to make sure
the solution to the painting houses problem is strong. This testing will
help us find any problems in the algorithm and keep it within the
rules.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-to-count-ways-to-paint-houses">1.
What is the dynamic programming approach to count ways to paint
houses?</h3>
<p>The dynamic programming approach to count ways to paint houses is
about breaking the problem into smaller parts. Each house can be painted
in many ways. But we have rules that say adjacent houses can’t be the
same color. We use a table to keep track of how many ways we can paint
up to each house while following these rules. This way, we can quickly
find the total ways to paint all the houses.</p>
<h3
id="how-can-i-implement-the-count-ways-to-paint-houses-problem-in-java">2.
How can I implement the count ways to paint houses problem in Java?</h3>
<p>To implement the count ways to paint houses problem in Java, we can
make a dynamic programming array. This array will record how many ways
we can paint each house. We will use a recurrence relation to find the
valid combinations based on previous houses. You can look at the Java
implementation section in the article for a complete code example that
shows this method well.</p>
<h3
id="what-are-the-edge-cases-to-consider-when-counting-ways-to-paint-houses">3.
What are the edge cases to consider when counting ways to paint
houses?</h3>
<p>When we count ways to paint houses, we should think about edge cases.
For example, if there are no houses to paint, we should say there are
zero ways. If there is only one house, the number of ways to paint it is
the same as the number of colors we have. These cases help us to make
sure our dynamic programming solution is strong.</p>
<h3
id="how-does-the-space-complexity-affect-the-count-ways-to-paint-houses-solution">4.
How does the space complexity affect the count ways to paint houses
solution?</h3>
<p>Space complexity in the count ways to paint houses solution is very
important, especially with big inputs. The usual dynamic programming
approach uses O(n) space, where n is the number of houses. But we can
make it better to O(1) space. We only need to keep track of the last two
states because each house’s state only depends on the previous two. This
makes our solution more efficient while still being correct.</p>
<h3
id="can-you-explain-the-differences-between-the-count-ways-to-paint-houses-and-related-dynamic-programming-problems">5.
Can you explain the differences between the count ways to paint houses
and related dynamic programming problems?</h3>
<p>The count ways to paint houses problem is similar to other dynamic
programming problems like climbing stairs and the house robber problem.
They all involve making choices under certain rules. The main difference
is in the specific rules for the choices next to each other. Looking at
these different problems helps us understand dynamic programming better.
You can find more about similar problems in our article on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">dynamic
programming house robber problem</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            