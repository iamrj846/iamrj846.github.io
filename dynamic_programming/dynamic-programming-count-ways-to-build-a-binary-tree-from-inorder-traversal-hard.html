
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Build a Binary Tree from Inorder Traversal - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to count ways to build a binary tree from inorder traversal using dynamic programming techniques. Learn more!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Build a Binary Tree from Inorder Traversal - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>In this article, we will look at how to count the unique binary trees
we can make from a given inorder traversal. This topic is part of
dynamic programming. We will use simple math and some recursive methods
to find a good solution. The main idea is to see that the number of
unique binary trees depends on how we choose the root node. Then, we can
divide the rest of the elements into left and right subtrees.</p>
<p>We will talk about the problem and its limits. We will explain the
dynamic programming method. We will also show how to write code in Java,
Python, and C++ for counting binary tree setups. Moreover, we will look
at how to make space use better in dynamic programming methods. We will
compare different ways to count binary trees. Finally, we will answer
some common questions about this topic.</p>
<ul>
<li>[Dynamic Programming] Count Ways to Construct Binary Tree from
Inorder Traversal - Hard</li>
<li>Understanding the Problem Statement and Constraints</li>
<li>Dynamic Programming Approach Overview</li>
<li>Java Implementation for Counting Binary Tree Configurations</li>
<li>Python Implementation for Counting Binary Tree Configurations</li>
<li>C++ Implementation for Counting Binary Tree Configurations</li>
<li>Optimizing Space Complexity in Dynamic Programming Solutions</li>
<li>Comparison of Different Approaches for Binary Tree Counting</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-and-constraints">Understanding
the Problem Statement and Constraints</h2>
<p>We need to count how many different binary trees we can make from an
inorder traversal sequence of a binary tree. The main points of the
problem are:</p>
<ul>
<li><p><strong>Inorder Traversal</strong>: This is a way to visit the
nodes. We go to the left child first, then the root, and finally the
right child. The sequence shows us the values of the nodes in sorted
order. But it does not tell us how the tree looks.</p></li>
<li><p><strong>Distinct Structures</strong>: We can create different
binary trees using the same set of values. For example, using the array
<code>[1, 2, 3]</code>, we can make different trees that look
different.</p></li>
<li><p><strong>Constraints</strong>:</p>
<ul>
<li>The number of nodes <code>n</code> can be from <code>1</code> to
<code>30</code>.</li>
<li>Each node has a unique integer value.</li>
<li>We need to return the answer modulo (10^9 + 7) to handle big
numbers.</li>
</ul></li>
</ul>
<p>Our main goal is to find how many unique binary trees we can make
from the given inorder traversal. We will use dynamic programming to
make this process faster.</p>
<p>For example, if we look at the inorder sequence
<code>[1, 2, 3]</code>: - Possible trees: - Tree with <code>1</code> as
root: <code>1          \           2            \             3</code> -
Tree with <code>2</code> as root: <code>2        / \       1   3</code>
- Tree with <code>3</code> as root:
<code>3          /         2        /       1</code></p>
<p>Each different arrangement shows a unique binary tree structure. So,
in this case, the total number of trees is <code>5</code>.</p>
<p>In dynamic programming, we will make a table. This table will keep
track of how many unique trees we can create with a certain number of
nodes. We will use the properties of binary trees and some math to get
the final count quickly.</p>
<h2 id="dynamic-programming-approach-overview">Dynamic Programming
Approach Overview</h2>
<p>We can count the ways to build a binary tree from its inorder
traversal using a Dynamic Programming (DP) approach. The main idea is to
find out how many unique binary trees we can make with a set of nodes.
We will use the properties of binary trees and their structure to help
us.</p>
<h3 id="key-concepts">Key Concepts</h3>
<ul>
<li><strong>Inorder Traversal</strong>: In this method, we first visit
the left subtree, then the root node, and finally the right subtree.
From a given inorder sequence, we can find the number of different
binary trees.</li>
<li><strong>Catalan Numbers</strong>: The shape of binary trees relates
closely to Catalan numbers. The nth Catalan number tells us how many
unique binary search trees we can form with n distinct keys.</li>
</ul>
<h3 id="dynamic-programming-approach">Dynamic Programming Approach</h3>
<ol type="1">
<li><p><strong>Define DP State</strong>: We let <code>dp[i][j]</code> be
the number of unique binary trees we can build using the nodes from
<code>i</code> to <code>j</code> in the inorder sequence.</p></li>
<li><p><strong>Base Case</strong>: If <code>i</code> is greater than
<code>j</code>, we have no nodes to make a tree. So, we set:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> <span class="dv">1</span></span></code></pre></div></li>
<li><p><strong>Recursive Relation</strong>: For every root node we pick
from <code>i</code> to <code>j</code>, we can count the number of trees
like this:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> <span class="bu">sum</span>(dp[i][k<span class="op">-</span><span class="dv">1</span>] <span class="op">*</span> dp[k<span class="op">+</span><span class="dv">1</span>][j]) <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, j<span class="op">+</span><span class="dv">1</span>)</span></code></pre></div>
<p>Here, <code>k</code> is the chosen root index.
<code>dp[i][k-1]</code> and <code>dp[k+1][j]</code> show how many ways
we can build the left and right subtrees.</p></li>
<li><p><strong>Final Count</strong>: The result for the whole inorder
traversal will be in <code>dp[0][n-1]</code>, where <code>n</code> is
the number of nodes.</p></li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^3) because of nested loops for
filling the DP table.</li>
<li><strong>Space Complexity</strong>: O(n^2) to store the DP
results.</li>
</ul>
<h3 id="example">Example</h3>
<p>For an inorder sequence of length <code>n</code>, we can build the DP
table step by step.</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_trees(n):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):  <span class="co"># length of the subtree</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Base case: single node</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> j:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> k <span class="kw">in</span> <span class="bu">range</span>(i, j <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                    left <span class="op">=</span> dp[i][k <span class="op">-</span> <span class="dv">1</span>] <span class="cf">if</span> k <span class="op">&gt;</span> i <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                    right <span class="op">=</span> dp[k <span class="op">+</span> <span class="dv">1</span>][j] <span class="cf">if</span> k <span class="op">&lt;</span> j <span class="cf">else</span> <span class="dv">1</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> left <span class="op">*</span> right</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="dv">0</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<p>This function finds the number of unique binary trees we can form
from <code>n</code> nodes based on the given inorder traversal.</p>
<p>By using this dynamic programming method, we can quickly find the
count of different binary trees we can make from any inorder traversal,
using the relationships between nodes and their positions.</p>
<h2
id="java-implementation-for-counting-binary-tree-configurations">Java
Implementation for Counting Binary Tree Configurations</h2>
<p>We can count how many ways to build a binary tree from an inorder
traversal by using a dynamic programming method. The main idea is that
for each root, we can multiply the number of ways to make the left
subtree with the number of ways to make the right subtree. We need to do
this for every possible root in the inorder traversal.</p>
<h3 id="key-steps-in-the-algorithm">Key Steps in the Algorithm:</h3>
<ol type="1">
<li><strong>Dynamic Programming Table Initialization</strong>: We create
a DP table to keep the number of ways to build trees for different
subtree sizes.</li>
<li><strong>Recursive Counting</strong>: For each possible root index in
the inorder array, we calculate how many ways to make the left and right
subtrees.</li>
<li><strong>Combination Calculation</strong>: We use combinatorial
logic, specifically binomial coefficients, to find the number of
different trees for each root.</li>
<li><strong>Modular Arithmetic</strong>: Since the result can be very
big, we apply a modulus operation to keep the numbers small.</li>
</ol>
<h3 id="java-code-implementation">Java Code Implementation:</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> BinaryTreeCount <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">final</span> <span class="dt">int</span> MOD <span class="op">=</span> <span class="dv">1000000007</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> factorialCache <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">countBinaryTrees</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">long</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base cases</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> j<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">binomialCoefficient</span><span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">&gt;</span> n<span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>k <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> k <span class="op">==</span> n<span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> <span class="op">((</span><span class="fu">factorial</span><span class="op">(</span>n<span class="op">)</span> <span class="op">*</span> <span class="fu">modInverse</span><span class="op">(</span><span class="fu">factorial</span><span class="op">(</span>k<span class="op">))</span> <span class="op">%</span> MOD <span class="op">*</span> <span class="fu">modInverse</span><span class="op">(</span><span class="fu">factorial</span><span class="op">(</span>n <span class="op">-</span> k<span class="op">))</span> <span class="op">%</span> MOD<span class="op">)</span> <span class="op">%</span> MOD<span class="op">);</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">long</span> <span class="fu">factorial</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>factorialCache<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>n<span class="op">))</span> <span class="cf">return</span> factorialCache<span class="op">.</span><span class="fu">get</span><span class="op">(</span>n<span class="op">);</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> result <span class="op">=</span> <span class="op">(</span>n <span class="op">*</span> <span class="fu">factorial</span><span class="op">(</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        factorialCache<span class="op">.</span><span class="fu">put</span><span class="op">(</span>n<span class="op">,</span> <span class="op">(</span><span class="dt">int</span><span class="op">)</span> result<span class="op">);</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">long</span> <span class="fu">modInverse</span><span class="op">(</span><span class="dt">long</span> x<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">power</span><span class="op">(</span>x<span class="op">,</span> MOD <span class="op">-</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">long</span> <span class="fu">power</span><span class="op">(</span><span class="dt">long</span> x<span class="op">,</span> <span class="dt">int</span> y<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> result <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(</span>y <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>y <span class="op">&amp;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> result <span class="op">=</span> <span class="op">(</span>result <span class="op">*</span> x<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a>            x <span class="op">=</span> <span class="op">(</span>x <span class="op">*</span> x<span class="op">)</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb4-44"><a href="#cb4-44" aria-hidden="true" tabindex="-1"></a>            y <span class="op">&gt;&gt;=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-45"><a href="#cb4-45" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-46"><a href="#cb4-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-47"><a href="#cb4-47" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-48"><a href="#cb4-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-49"><a href="#cb4-49" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-50"><a href="#cb4-50" aria-hidden="true" tabindex="-1"></a>        BinaryTreeCount btc <span class="op">=</span> <span class="kw">new</span> <span class="fu">BinaryTreeCount</span><span class="op">();</span></span>
<span id="cb4-51"><a href="#cb4-51" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: number of nodes</span></span>
<span id="cb4-52"><a href="#cb4-52" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of unique binary trees with &quot;</span> <span class="op">+</span> n <span class="op">+</span> <span class="st">&quot; nodes: &quot;</span> <span class="op">+</span> btc<span class="op">.</span><span class="fu">countBinaryTrees</span><span class="op">(</span>n<span class="op">));</span></span>
<span id="cb4-53"><a href="#cb4-53" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-54"><a href="#cb4-54" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>countBinaryTrees</code> method sets up a DP array. Here
<code>dp[i]</code> shows the number of unique binary trees that we can
make with <code>i</code> nodes.</li>
<li>A nested loop goes through the possible roots for each subtree. It
updates the DP table based on the combinations of left and right
subtrees.</li>
<li>The <code>binomialCoefficient</code> method finds the needed
binomial coefficients using factorials and modular math.</li>
<li>The <code>main</code> method shows how to use the code with an
example of 5 nodes.</li>
</ul>
<p>This Java code counts the number of unique binary tree configurations
from an inorder traversal. It uses dynamic programming and combinatorial
ideas. For more on dynamic programming techniques, we can check other
resources like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="python-implementation-for-counting-binary-tree-configurations">Python
Implementation for Counting Binary Tree Configurations</h2>
<p>We can count the ways to build a binary tree from a given inorder
traversal using dynamic programming. The main idea is to use the rules
of binary trees and some math. For each node, we can find the number of
ways to build a binary tree based on how many nodes are in the left and
right subtrees.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<p>In the dynamic programming approach, we create a DP table. In this
table, <code>dp[i][j]</code> shows the number of ways to build a binary
tree using the inorder sequence from index <code>i</code> to index
<code>j</code>. We choose each index as the root and then calculate the
ways for left and right subtrees.</p>
<h4 id="python-code-implementation">Python Code Implementation</h4>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_trees(n):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a DP array to store results</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case: empty tree</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> nodes <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> root <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, nodes <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            left_trees <span class="op">=</span> dp[root <span class="op">-</span> <span class="dv">1</span>]      <span class="co"># Count of left subtrees</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            right_trees <span class="op">=</span> dp[nodes <span class="op">-</span> root] <span class="co"># Count of right subtrees</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            dp[nodes] <span class="op">+=</span> left_trees <span class="op">*</span> right_trees</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">3</span>  <span class="co"># Number of nodes</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_trees(n))  <span class="co"># Output: 5</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We set up the <code>dp</code> list
with size <code>n + 1</code>. We set <code>dp[0]</code> to 1 because
there is one way to make an empty tree.</li>
<li><strong>Double Loop</strong>: The first loop goes through each
number of nodes. The second loop goes through each possible root
position.</li>
<li><strong>Combinations</strong>: For each root, we multiply the number
of left and right subtrees to get the total ways for that root.</li>
<li><strong>Final Result</strong>: The total number of unique binary
trees with <code>n</code> nodes is saved in <code>dp[n]</code>.</li>
</ul>
<p>This code counts how many ways we can build a binary tree from its
inorder traversal using dynamic programming. It is efficient. If we want
to learn more about dynamic programming, we can look at other articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="c-implementation-for-counting-binary-tree-configurations">C++
Implementation for Counting Binary Tree Configurations</h2>
<p>We can count how many ways to build binary trees from a given inorder
traversal using dynamic programming in C++. The main idea is to use the
rules of binary trees and some math.</p>
<h3 id="dynamic-programming-approach-1">Dynamic Programming
Approach</h3>
<ol type="1">
<li><strong>Understanding the problem</strong>: We have an inorder
traversal of a binary tree. We want to count how many different binary
trees we can create with those nodes in that order.</li>
<li><strong>Key concepts</strong>:
<ul>
<li>We can find the number of different binary trees with <code>n</code>
nodes from smaller trees.</li>
<li>For each node we pick as the root, the left and right subtrees can
make their own binary trees.</li>
</ul></li>
</ol>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li><strong>Precompute Factorials</strong>: We need to calculate
factorials and modular inverses. This helps us compute combinations
faster.</li>
<li><strong>DP Table</strong>: We create a DP table. Here
<code>dp[i]</code> shows how many unique binary trees we can make with
<code>i</code> nodes.</li>
<li><strong>Building the DP Table</strong>:
<ul>
<li>For each <code>i</code> from 1 to <code>n</code>, we calculate the
number of unique trees. We do this by choosing every possible root and
adding the counts of the left and right subtrees.</li>
</ul></li>
</ol>
<h3 id="c-code">C++ Code</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="at">const</span> <span class="dt">int</span> MOD <span class="op">=</span> <span class="fl">1e9</span> <span class="op">+</span> <span class="dv">7</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">// Function to calculate factorial and inverse factorial</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">long</span> <span class="dt">long</span> modInverse<span class="op">(</span><span class="dt">long</span> <span class="dt">long</span> a<span class="op">,</span> <span class="dt">long</span> <span class="dt">long</span> m<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">long</span> m0 <span class="op">=</span> m<span class="op">,</span> y <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> x <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>a <span class="op">&gt;</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> q <span class="op">=</span> a <span class="op">/</span> m<span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">long</span> <span class="dt">long</span> t <span class="op">=</span> m<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> a <span class="op">%</span> m<span class="op">,</span> a <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        t <span class="op">=</span> y<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> x <span class="op">-</span> q <span class="op">*</span> y<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        x <span class="op">=</span> t<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>x <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> x <span class="op">+=</span> m0<span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x<span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> countBinaryTrees<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">long</span> <span class="dt">long</span><span class="op">&gt;</span> fact<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Precompute factorials</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>        fact<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> fact<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> i <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// One way to create a tree with 0 nodes</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> nodes <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> nodes <span class="op">&lt;=</span> n<span class="op">;</span> <span class="op">++</span>nodes<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> root <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> root <span class="op">&lt;</span> nodes<span class="op">;</span> <span class="op">++</span>root<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>nodes<span class="op">]</span> <span class="op">=</span> <span class="op">(</span>dp<span class="op">[</span>nodes<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>root<span class="op">]</span> <span class="op">*</span> dp<span class="op">[</span>nodes <span class="op">-</span> <span class="dv">1</span> <span class="op">-</span> root<span class="op">])</span> <span class="op">%</span> MOD<span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of unique binary trees with &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; nodes: &quot;</span> <span class="op">&lt;&lt;</span> dp<span class="op">[</span>n<span class="op">]</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Example: Number of nodes</span></span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a>    countBinaryTrees<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li><strong>modInverse</strong>: This function finds the modular inverse
of a number. We use this for combination math.</li>
<li><strong>countBinaryTrees</strong>: This function sets up the DP
table. It calculates factorials and fills the DP table using loops.
Finally, it shows the result. It says how many unique binary trees we
can make with <code>n</code> nodes.</li>
</ul>
<p>This C++ code counts the ways to create binary trees from a given
inorder traversal. For more about dynamic programming, you can read
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>
<h2
id="optimizing-space-complexity-in-dynamic-programming-solutions">Optimizing
Space Complexity in Dynamic Programming Solutions</h2>
<p>In dynamic programming, we often use multi-dimensional arrays to keep
intermediate results. This can lead to high space complexity. We need to
optimize this space usage, especially when we deal with large input
sizes. Here are some ways we can reduce space complexity in dynamic
programming solutions:</p>
<ol type="1">
<li><p><strong>State Compression</strong>: Instead of keeping a full 2D
array, we can reduce it to a single row or a single column. This works
well when the state only depends on the previous state.</p>
<p>For example, in the Fibonacci sequence calculation:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">fib</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> n<span class="op">;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>Iterative Approach</strong>: We can replace recursive
calls with loops. This often reduces the stack space that recursion
uses.</p></li>
<li><p><strong>In-Place Updates</strong>: We can change the input array
or data directly instead of making copies. This helps in problems like
the “House Robber.” We can keep only the results we need.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rob(nums):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    prev, curr <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        prev, curr <span class="op">=</span> curr, <span class="bu">max</span>(curr, prev <span class="op">+</span> num)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> curr</span></code></pre></div></li>
<li><p><strong>Divide and Conquer with Memoization</strong>: We should
only store results that we need for later calculations. We can discard
those that we do not need anymore.</p></li>
<li><p><strong>Using Rolling Arrays</strong>: For problems with grid
paths or similar, we can use a rolling array. We only keep track of the
last two rows or columns we need.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPaths<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
</ol>
<p>By using these techniques, we can reduce space complexity in dynamic
programming solutions. This makes our algorithms more efficient and
scalable. For more discussions on dynamic programming techniques, we can
check articles like the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2
id="comparison-of-different-approaches-for-binary-tree-counting">Comparison
of Different Approaches for Binary Tree Counting</h2>
<p>When we try to count how many ways we can build a binary tree from an
inorder traversal, we can use several methods. Each method has its own
pros and cons. Some are more complex, while others are easier to use.
Below, we compare the most common ways.</p>
<h3 id="recursive-approach">1. Recursive Approach</h3>
<ul>
<li><strong>Complexity</strong>: Exponential time complexity, O(2^n),
where n is the number of nodes.</li>
<li><strong>Description</strong>: This method counts the valid binary
trees by choosing each node as the root. Then we count the left and
right subtrees again.</li>
</ul>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">countTrees</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">&lt;=</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> total <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> root <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> root <span class="op">&lt;=</span> n<span class="op">;</span> root<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> left <span class="op">=</span> <span class="fu">countTrees</span><span class="op">(</span>root <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> right <span class="op">=</span> <span class="fu">countTrees</span><span class="op">(</span>n <span class="op">-</span> root<span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        total <span class="op">+=</span> left <span class="op">*</span> right<span class="op">;</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> total<span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="dynamic-programming-approach-2">2. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Complexity</strong>: O(n^2) time and O(n) space
complexity.</li>
<li><strong>Description</strong>: This method uses a DP array. Here,
<code>dp[i]</code> shows how many unique binary trees can be made with
<code>i</code> nodes.</li>
</ul>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">countBinaryTrees</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base cases</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> nodes <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> nodes <span class="op">&lt;=</span> n<span class="op">;</span> nodes<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> root <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> root <span class="op">&lt;=</span> nodes<span class="op">;</span> root<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>nodes<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>root <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> dp<span class="op">[</span>nodes <span class="op">-</span> root<span class="op">];</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="combinatorial-approach">3. Combinatorial Approach</h3>
<ul>
<li><strong>Complexity</strong>: O(n) time.</li>
<li><strong>Description</strong>: This method uses the Catalan number
formula. It directly calculates the number of unique binary trees for
<code>n</code> nodes using the binomial coefficient.</li>
</ul>
<div class="sourceCode" id="cb12"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">catalan</span><span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> C <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    C<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> C<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> i<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>            C<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> C<span class="op">[</span>j<span class="op">]</span> <span class="op">*</span> C<span class="op">[</span>i <span class="op">-</span> j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> C<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="optimized-dp-approach">4. Optimized DP Approach</h3>
<ul>
<li><strong>Complexity</strong>: O(n^2) time and O(n) space
complexity.</li>
<li><strong>Description</strong>: This approach is like the basic
dynamic programming method. It tries to use less space by saving only
the results we need.</li>
</ul>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<ul>
<li><strong>Recursive</strong>: It is simple but not good for big
<code>n</code>.</li>
<li><strong>Dynamic Programming</strong>: It works well for medium
<code>n</code> and needs extra space.</li>
<li><strong>Combinatorial</strong>: This is the fastest for large
<code>n</code> and uses math directly.</li>
</ul>
<p>For more information on similar dynamic programming methods, we can
look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-significance-of-inorder-traversal-in-counting-binary-trees">1.
What is the significance of inorder traversal in counting binary
trees?</h3>
<p>We think inorder traversal is very important for counting how many
ways we can build a binary tree. It shows the order of nodes. By knowing
this order, we can clearly see the left and right subtrees of each node.
With dynamic programming, we can find the number of different binary
tree shapes that match the given inorder traversal.</p>
<h3 id="how-can-dynamic-programming-be-applied-to-count-binary-trees">2.
How can dynamic programming be applied to count binary trees?</h3>
<p>We can use dynamic programming to count the number of different
binary trees we can make from a given inorder traversal. We store
results of earlier problems, like how many trees we can make with
certain node ranges. This way, we can quickly find the total number of
shapes, and it helps us save time and effort.</p>
<h3
id="what-are-the-time-and-space-complexities-involved-in-counting-binary-trees">3.
What are the time and space complexities involved in counting binary
trees?</h3>
<p>The time complexity for counting binary trees from inorder traversal
using dynamic programming is O(n^2). Here, n is the number of nodes.
This happens because we have nested loops for subtree combinations. The
space complexity is O(n) because we need to store results in a DP array.
This helps us avoid doing the same calculations more than once.</p>
<h3
id="can-you-explain-the-recursive-approach-versus-the-dynamic-programming-approach">4.
Can you explain the recursive approach versus the dynamic programming
approach?</h3>
<p>The recursive way of counting binary trees tries to look at every
possible way to arrange the subtrees for each node. This leads to a lot
of time, which can be exponential. On the other hand, the dynamic
programming way breaks the problem down into smaller parts. It saves
results so we do not have to calculate them again. This makes it much
faster and helps us work with bigger inputs.</p>
<h3
id="are-there-any-optimization-techniques-for-space-complexity-in-dynamic-programming">5.
Are there any optimization techniques for space complexity in dynamic
programming?</h3>
<p>Yes, we can make space usage better by using math formulas or
combinatorial methods instead of keeping all the results. For example,
using the Catalan number formula can help us use only constant space
while still finding the number of different binary trees quickly. This
method is very useful when we have larger inputs.</p>
<p>For more reading about dynamic programming, we can check out articles
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Count
Ways to Climb Stairs</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Numbers</a>. These articles give us more ideas
about dynamic programming skills and how we can use them.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            