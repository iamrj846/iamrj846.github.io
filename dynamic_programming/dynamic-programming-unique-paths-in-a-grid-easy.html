
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Unique Paths in a Grid - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Unique Paths problem using dynamic programming. Master grid navigation with our easy guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Unique Paths in a Grid - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Unique Paths problem is a well-known challenge in dynamic
programming. It asks us to find how many different paths we can take to
go from the top-left corner to the bottom-right corner of a grid. We can
only move to the right or down.</p>
<p>We can use dynamic programming methods to solve this. These methods
help us find the number of ways to reach each cell in the grid. We base
this on values we have already calculated. This approach is much better
than using a simple recursive way.</p>
<p>In this article, we will talk about the Unique Paths problem in
detail. We will look at different solutions, including dynamic
programming methods in Java, Python, and C++. We will also look at
solutions that use less space and a recursive method with memoization.
By the end, we will understand the Unique Paths problem and how to solve
it. The sections we will cover are:</p>
<ul>
<li>[Dynamic Programming] Unique Paths in a Grid - Easy Solutions
Overview</li>
<li>Understanding the Unique Paths Problem</li>
<li>Dynamic Programming Approach to Unique Paths in Java</li>
<li>Dynamic Programming Approach to Unique Paths in Python</li>
<li>Dynamic Programming Approach to Unique Paths in C++</li>
<li>Optimized Space Complexity Solution in Java</li>
<li>Optimized Space Complexity Solution in Python</li>
<li>Optimized Space Complexity Solution in C++</li>
<li>Recursive Approach to Unique Paths with Memoization</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to learn more about dynamic programming ideas, we can read
articles on similar topics. For example, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a> for more insights.</p>
<h2 id="understanding-the-unique-paths-problem">Understanding the Unique
Paths Problem</h2>
<p>The Unique Paths problem is a well-known challenge in dynamic
programming. It asks us how many different ways we can move through a
grid. We start from the top-left corner and go to the bottom-right
corner. We can only move down or right. Given an <code>m x n</code>
grid, our goal is to find out how many unique paths lead to the
destination cell.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li>We start at position <code>(0, 0)</code> and need to reach position
<code>(m-1, n-1)</code>.</li>
<li>We can only move down or right.</li>
<li>The grid size is <code>m</code> rows and <code>n</code>
columns.</li>
</ul>
<h3 id="example">Example</h3>
<p>For a grid of size <code>3 x 2</code>:</p>
<pre><code>1 2
3 4
5 6</code></pre>
<p>The unique paths from the top-left to the bottom-right are: 1. Down
-&gt; Down -&gt; Right 2. Down -&gt; Right -&gt; Down 3. Right -&gt;
Down -&gt; Down 4. Right -&gt; Right -&gt; Down</p>
<p>So, the total number of unique paths is <code>3</code>.</p>
<h3 id="mathematical-insight">Mathematical Insight</h3>
<p>We can also find the number of unique paths using math. The total
moves we need to reach the destination is
<code>(m - 1) + (n - 1)</code>. We can think of this problem as choosing
<code>m - 1</code> down moves from a total of <code>m + n - 2</code>
moves. We can write this as: [ C(m+n-2, m-1) = ]</p>
<h3 id="key-points">Key Points</h3>
<ul>
<li>We can solve the problem using different methods. These include
recursive, dynamic programming, and combinatorial.</li>
<li>The dynamic programming method builds a solution step-by-step. It
stores results of smaller problems in a 2D array or even in a 1D array
to save space.</li>
<li>We can also make the solution better to use less space while keeping
the time it takes the same at (O(m n)).</li>
</ul>
<p>This problem is important for learning dynamic programming. It
connects to other problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs</a> and similar ones.</p>
<h2 id="dynamic-programming-approach-to-unique-paths-in-java">Dynamic
Programming Approach to Unique Paths in Java</h2>
<p>We can solve the Unique Paths problem using dynamic programming in
Java. We will create a 2D array <code>dp</code>. In this array,
<code>dp[i][j]</code> shows the number of unique paths to get to the
cell <code>(i, j)</code> in an <code>m x n</code> grid. We can reach a
cell from the cell above it <code>(i-1, j)</code> or from the cell to
the left <code>(i, j-1)</code>.</p>
<p>Here is the simple approach step by step:</p>
<ol type="1">
<li><p><strong>Initialization</strong>: We set <code>dp[0][j] = 1</code>
for all <code>j</code> in the first row. We also set
<code>dp[i][0] = 1</code> for all <code>i</code> in the first column.
There is only one way to reach any cell in the first row or
column.</p></li>
<li><p><strong>Filling the DP Array</strong>: For each cell
<code>(i, j)</code>, the number of unique paths is the sum of the unique
paths from the cell above and the cell to the left:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span></code></pre></div></li>
<li><p><strong>Return the Result</strong>: The value at
<code>dp[m-1][n-1]</code> tells us the total unique paths from the
top-left to the bottom-right of the grid.</p></li>
</ol>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UniquePaths <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePaths</span><span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first row and first column</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Only one way to reach any cell in the first column</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Only one way to reach any cell in the first row</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the dp array</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Return the number of unique paths to the bottom-right corner</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        UniquePaths up <span class="op">=</span> <span class="kw">new</span> <span class="fu">UniquePaths</span><span class="op">();</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Unique Paths: &quot;</span> <span class="op">+</span> up<span class="op">.</span><span class="fu">uniquePaths</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">));</span> <span class="co">// Example usage</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code helps us find the number of unique paths in an
<code>m x n</code> grid by using dynamic programming. For more advanced
problems in dynamic programming, we can look at related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="dynamic-programming-approach-to-unique-paths-in-python">Dynamic
Programming Approach to Unique Paths in Python</h2>
<p>The Unique Paths problem is about finding how many ways we can reach
the bottom-right corner of a grid. We start from the top-left corner and
can only move down or right. We can solve this problem well using
dynamic programming.</p>
<h3 id="dynamic-programming-implementation">Dynamic Programming
Implementation</h3>
<p>In our dynamic programming approach, we use a 2D array called
<code>dp</code>. Here, <code>dp[i][j]</code> shows the number of unique
paths to reach the cell <code>(i, j)</code>. We can find this value by
looking at the cells above and to the left:</p>
<ul>
<li><p><strong>Base Case</strong>: The first row and the first column
can only be reached in one way. We can either move all the way right or
all the way down.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div></li>
</ul>
<p>Here is a simple implementation in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePaths(m: <span class="bu">int</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">1</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(uniquePaths(<span class="dv">3</span>, <span class="dv">7</span>))  <span class="co"># Output: 28</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>We start by making a 2D list <code>dp</code> with size
<code>m x n</code>, and we fill it with 1s.</li>
<li>We go through the grid starting from <code>(1, 1)</code> to fill in
the number of unique paths for each cell.</li>
<li>At the end, we return the value at <code>dp[m-1][n-1]</code>. This
value shows the total unique paths from the top-left to the bottom-right
corner.</li>
</ul>
<p>This method has a time complexity of O(m<em>n) and a space complexity
of O(m</em>n).</p>
<h3 id="related-articles">Related Articles</h3>
<p>For more dynamic programming challenges and solutions, we can check
out these articles: - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number - Easy</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs - Easy</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-min-cost-climbing-stairs-easy.html">Dynamic
Programming Minimum Cost Climbing Stairs - Easy</a></p>
<h2 id="dynamic-programming-approach-to-unique-paths-in-c">Dynamic
Programming Approach to Unique Paths in C++</h2>
<p>We can solve the Unique Paths problem using the Dynamic Programming
method in C++. This method builds a 2D DP table. This table helps us
keep track of how many ways we can reach each cell in a grid. The grid
has size <code>m x n</code>. Here, <code>m</code> is the number of rows
and <code>n</code> is the number of columns. Our goal is to find how
many unique paths there are from the top-left corner (0,0) to the
bottom-right corner (m-1,n-1). We can only move to the right or
down.</p>
<h3 id="algorithm">Algorithm</h3>
<ol type="1">
<li><strong>Initialize a DP Table</strong>: We create a 2D vector
<code>dp</code> of size <code>m x n</code>. The value
<code>dp[i][j]</code> shows the number of unique paths to reach cell
<code>(i, j)</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0][0] = 1</code>. There
is one way to reach the starting cell.</li>
<li><strong>Fill the DP Table</strong>: We go through each cell. For
each cell, the number of ways to reach it is the sum of the number of
ways to reach the cell above it and the cell to the left:
<ul>
<li><code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> (if i &gt; 0 and j
&gt; 0).</li>
</ul></li>
<li><strong>Return the Result</strong>: The value at
<code>dp[m-1][n-1]</code> gives the total unique paths to the
bottom-right corner.</li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> uniquePaths<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize the first row and first column</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Only one way to reach any cell in the first column</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Only one way to reach any cell in the first row</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP table</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). We go through each cell
in the grid one time.</li>
<li><strong>Space Complexity</strong>: O(m * n). We need a 2D array to
keep the number of paths.</li>
</ul>
<p>This Dynamic Programming approach helps us find the number of unique
paths in a grid. It works well even for larger grid sizes. If we want to
learn more about dynamic programming, we can check related problems like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="optimized-space-complexity-solution-in-java">Optimized Space
Complexity Solution in Java</h2>
<p>We can solve the Unique Paths problem in Java with a better space
usage. This solution cuts the space from O(m * n) to O(n) by using a 1D
array. We do not need a 2D array to keep track of paths. Instead, we
only use one row to hold the results for the current and previous
rows.</p>
<h3 id="implementation">Implementation</h3>
<p>We will go through each cell of the grid. We update our array based
on the paths from the top and left cells. Here is the code:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UniquePaths <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePaths</span><span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Starting point</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Update current cell based on the top and left cells</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// The number of unique paths to the bottom-right corner</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        UniquePaths up <span class="op">=</span> <span class="kw">new</span> <span class="fu">UniquePaths</span><span class="op">();</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> up<span class="op">.</span><span class="fu">uniquePaths</span><span class="op">(</span><span class="dv">3</span><span class="op">,</span> <span class="dv">7</span><span class="op">);</span> <span class="co">// Example for a 3x7 grid</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Unique Paths: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We start with an array
<code>dp</code> that has size <code>n</code> (the number of columns).
The first element is 1, which shows the starting position.</li>
<li><strong>Nested Loop</strong>: The outer loop goes through each row.
The inner loop updates the <code>dp</code> array.</li>
<li><strong>Update Rule</strong>: We update each cell at
<code>dp[j]</code> by adding the value from the left cell
(<code>dp[j - 1]</code>).</li>
<li><strong>Result</strong>: The last element of the <code>dp</code>
array gives the total number of unique paths to reach the bottom-right
corner.</li>
</ul>
<p>This method cuts down the space we use, while the time complexity
stays at O(m * n). For more insights into dynamic programming, check out
articles about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Climbing
Stairs</a>.</p>
<h2 id="optimized-space-complexity-solution-in-python">Optimized Space
Complexity Solution in Python</h2>
<p>To solve the Unique Paths problem in Python with better space use, we
can keep track of only the current and previous row. We know that to
find the number of unique paths to a cell, we only need the values from
the current row and the row above.</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is the Python code for the optimized space complexity
solution:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePaths(m: <span class="bu">int</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a 1D array to store the number of ways to reach each cell in the current row</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>            dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># Update the current cell using values from the previous row</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># The last cell contains the total unique paths to reach the bottom-right corner</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(uniquePaths(<span class="dv">3</span>, <span class="dv">7</span>))  <span class="co"># Output: 28</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We start with a list
<code>dp</code> that has size <code>n</code> (the number of columns).
All values in this list are <code>1</code>. This shows the number of
unique paths to each cell in the first row.</li>
<li><strong>Row Iteration</strong>: For each next row, we go through
each cell starting from the second column.</li>
<li><strong>Path Calculation</strong>: We update each cellâ€™s value. We
add the value from the cell on its left (from the current row) and the
value from the cell above it (from the previous row). This counts the
unique paths to that cell.</li>
<li><strong>Space Complexity</strong>: This method cuts down the space
needed from O(m * n) to O(n). We only keep one row of results at a
time.</li>
</ul>
<p>This way is good and keeps the performance high for solving the
Unique Paths problem in a grid. It also saves a lot of memory compared
to using a full 2D array.</p>
<h2 id="optimized-space-complexity-solution-in-c">Optimized Space
Complexity Solution in C++</h2>
<p>To solve the Unique Paths problem with better space usage in C++, we
use a single array. This array helps us track how many unique paths go
to each cell in the grid. Instead of using a full 2D array, we update
our array in-place. This change reduces the space needed from O(m*n) to
O(n).</p>
<h3 id="c-code-implementation-1">C++ Code Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> uniquePaths<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span> <span class="co">// We create a 1D array of size n, filled with 1</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>j<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// We update the current cell with paths from top and left</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// The last element gives the number of unique paths</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-2">Explanation</h3>
<ul>
<li><strong>Initialization</strong>: We start by making a 1D vector
called <code>dp</code> that has size <code>n</code>. All elements are
set to 1. This shows the number of ways to reach each cell in the first
row. There is only one way to reach any cell in that row.</li>
<li><strong>Dynamic Programming Update</strong>: For each row after the
first, we go through the columns and update the <code>dp</code> array.
The value at <code>dp[j]</code> is updated to be the sum of paths from
the cell above (<code>dp[j]</code>) and the cell to the left
(<code>dp[j - 1]</code>).</li>
<li><strong>Final Output</strong>: After we finish all rows,
<code>dp[n - 1]</code> has the total number of unique paths from the
top-left to the bottom-right of the grid.</li>
</ul>
<p>This way is smart and uses less space. It is good for bigger grids.
If we want to learn more about dynamic programming, we can check out the
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a> article.</p>
<h2 id="recursive-approach-to-unique-paths-with-memoization">Recursive
Approach to Unique Paths with Memoization</h2>
<p>We can solve the unique paths problem using a recursive method with
memoization. This helps us to avoid recalculating results for problems
we already solved. So, it makes our solution much faster.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have a grid of size <code>m x n</code>. From the top-left corner
(0, 0), we can only move down or to the right. Our goal is to find how
many unique paths we have to reach the bottom-right corner (m-1,
n-1).</p>
<h3 id="recursive-function-with-memoization">Recursive Function with
Memoization</h3>
<p>The recursive function checks where we are and adds the unique paths
from the cell below and the cell to the right. We use memoization to
store results we have already calculated in a cache.</p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UniquePaths <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePaths</span><span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">countPaths</span><span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;());</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">countPaths</span><span class="op">(</span><span class="dt">int</span> row<span class="op">,</span> <span class="dt">int</span> col<span class="op">,</span> <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">String</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> col <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> col <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> key <span class="op">=</span> row <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> col<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span><span class="fu">containsKey</span><span class="op">(</span>key<span class="op">))</span> <span class="cf">return</span> memo<span class="op">.</span><span class="fu">get</span><span class="op">(</span>key<span class="op">);</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> paths <span class="op">=</span> <span class="fu">countPaths</span><span class="op">(</span>row <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> col<span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> <span class="fu">countPaths</span><span class="op">(</span>row<span class="op">,</span> col <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">.</span><span class="fu">put</span><span class="op">(</span>key<span class="op">,</span> paths<span class="op">);</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> paths<span class="op">;</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unique_paths(m: <span class="bu">int</span>, n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count_paths(m <span class="op">-</span> <span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>, memo)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_paths(row: <span class="bu">int</span>, col: <span class="bu">int</span>, memo: <span class="bu">dict</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> col <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> row <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> col <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>    key <span class="op">=</span> (row, col)</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> key <span class="kw">in</span> memo:</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[key]</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    memo[key] <span class="op">=</span> count_paths(row <span class="op">-</span> <span class="dv">1</span>, col, memo) <span class="op">+</span> count_paths(row, col <span class="op">-</span> <span class="dv">1</span>, memo)</span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> memo[key]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> uniquePaths<span class="op">(</span><span class="dt">int</span> m<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> memo<span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> countPaths<span class="op">(</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a><span class="kw">private</span><span class="op">:</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countPaths<span class="op">(</span><span class="dt">int</span> row<span class="op">,</span> <span class="dt">int</span> col<span class="op">,</span> <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="bu">std::</span>string<span class="op">,</span> <span class="dt">int</span><span class="op">&gt;&amp;</span> memo<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">||</span> col <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>row <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> col <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>string<span class="op"> </span>key <span class="op">=</span> <span class="bu">std::</span>to_string<span class="op">(</span>row<span class="op">)</span> <span class="op">+</span> <span class="st">&quot;,&quot;</span> <span class="op">+</span> <span class="bu">std::</span>to_string<span class="op">(</span>col<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>memo<span class="op">.</span>find<span class="op">(</span>key<span class="op">)</span> <span class="op">!=</span> memo<span class="op">.</span>end<span class="op">())</span> <span class="cf">return</span> memo<span class="op">[</span>key<span class="op">];</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        memo<span class="op">[</span>key<span class="op">]</span> <span class="op">=</span> countPaths<span class="op">(</span>row <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> col<span class="op">,</span> memo<span class="op">)</span> <span class="op">+</span> countPaths<span class="op">(</span>row<span class="op">,</span> col <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> memo<span class="op">);</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo<span class="op">[</span>key<span class="op">];</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Base Case</strong>: When we reach the position
<code>(0, 0)</code>, we have one unique path. If we go out of bounds, we
return 0.</li>
<li><strong>Memoization</strong>: We use a hashmap or dictionary to keep
the results of paths we computed before for specific grid points.</li>
<li><strong>Recursive Calls</strong>: The function calls itself for the
cell below and the cell to the right, and we add the results.</li>
</ul>
<p>This method cuts down the time it takes compared to a simple
recursive solution. It makes it possible to work with bigger grids. For
more details about dynamic programming, we can check other articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-unique-paths-problem-in-dynamic-programming">1. What
is the Unique Paths problem in dynamic programming?</h3>
<p>The Unique Paths problem is a well-known challenge in dynamic
programming. The goal is to count how many different ways we can get to
the bottom-right corner of a grid from the top-left corner. We can only
move down or right. We can solve this problem well using dynamic
programming. This helps us see how we can use recursive relationships
and changes in state for problems that use grids.</p>
<h3
id="how-can-i-solve-unique-paths-using-dynamic-programming-in-java">2.
How can I solve Unique Paths using dynamic programming in Java?</h3>
<p>To solve the Unique Paths problem in Java, we can make a 2D array.
This array will keep track of how many ways we can reach each cell. We
will start by setting the first row and the first column to 1. This is
because there is only one way to reach those cells. Next, we fill in the
rest of the array. We do this by adding the paths from the cell above
and the cell to the left. For more details, look at our section on the
<a href="#">Dynamic Programming Approach to Unique Paths in
Java</a>.</p>
<h3
id="is-there-an-optimized-space-complexity-solution-for-unique-paths-in-python">3.
Is there an optimized space complexity solution for Unique Paths in
Python?</h3>
<p>Yes, we can find a better space solution for the Unique Paths problem
in Python. Instead of using a 2D array, we can use a 1D array. By
keeping track of only the current and previous rows, we can lower the
space needed from O(m*n) to O(n). This method uses the connection
between the current position and the ones before it. For more
information, check our section on the <a href="#">Optimized Space
Complexity Solution in Python</a>.</p>
<h3
id="can-i-implement-the-unique-paths-algorithm-using-recursion-and-memoization">4.
Can I implement the Unique Paths algorithm using recursion and
memoization?</h3>
<p>Yes, we can also solve the Unique Paths problem with a recursive
method and memoization to make it faster. This way, we explore all
possible paths to the bottom-right corner. We store the results of
smaller problems so we do not repeat calculations. For a complete
explanation, see our section on the <a href="#">Recursive Approach to
Unique Paths with Memoization</a>.</p>
<h3
id="how-does-the-unique-paths-problem-relate-to-other-dynamic-programming-problems">5.
How does the Unique Paths problem relate to other dynamic programming
problems?</h3>
<p>The Unique Paths problem is similar to other dynamic programming
problems. For example, it is like the Fibonacci sequence or the Climbing
Stairs problem. Knowing these connections helps us understand dynamic
programming better. For example, in the Climbing Stairs problem, we can
take one or two steps at a time. For more on related topics, see our
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            