
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Distinct Subsequences - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Learn about Dynamic Programming and how to solve the Distinct Subsequences problem with our in-depth Medium guide. ">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Distinct Subsequences - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The <strong>Dynamic Programming Distinct Subsequences</strong>
problem is about finding how many unique subsequences we can form from
string <code>T</code> using the characters in another string
<code>S</code>. This problem is common in combinatorial algorithms. The
solution counts the ways to create one sequence from another. We can use
dynamic programming to find the number of distinct subsequences. We
build a table that shows the connections between the characters of
<code>S</code> and <code>T</code>.</p>
<p>In this article, we will look at different ways to solve the Distinct
Subsequences problem. We will talk about a recursive method, memoization
techniques, and three bottom-up methods in Java, Python, and C++. We
will also discuss how to save space and analyze the complexity to see
how efficient our solutions are. Here is what we will cover:</p>
<ul>
<li>Dynamic Programming Distinct Subsequences Problem Overview</li>
<li>Dynamic Programming Distinct Subsequences Recursive Approach</li>
<li>Dynamic Programming Distinct Subsequences Memoization Technique</li>
<li>Dynamic Programming Distinct Subsequences Bottom Up Approach in
Java</li>
<li>Dynamic Programming Distinct Subsequences Bottom Up Approach in
Python</li>
<li>Dynamic Programming Distinct Subsequences Bottom Up Approach in
C++</li>
<li>Dynamic Programming Distinct Subsequences Space Optimization
Techniques</li>
<li>Dynamic Programming Distinct Subsequences Complexity Analysis</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on similar dynamic programming problems, we can
check out articles about <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming Longest Common Subsequence</a>.</p>
<h2
id="dynamic-programming-distinct-subsequences-recursive-approach">Dynamic
Programming Distinct Subsequences Recursive Approach</h2>
<p>The <strong>Distinct Subsequences</strong> problem is to find how
many different subsequences of string <code>S</code> equal string
<code>T</code>. We can solve this problem by breaking it down into
smaller problems using recursion.</p>
<h3 id="recursive-function-definition">Recursive Function
Definition</h3>
<p>We define a recursive function called
<code>countDistinctSubsequences(S, T, m, n)</code>. Here: -
<code>m</code> is the length of <code>S</code> - <code>n</code> is the
length of <code>T</code></p>
<h4 id="base-cases">Base Cases</h4>
<ol type="1">
<li>If <code>n</code> is 0, which means <code>T</code> is an empty
string, there is one subsequence of <code>S</code> that matches
<code>T</code>. This subsequence is the empty subsequence. So, we return
1.</li>
<li>If <code>m</code> is 0 and <code>n</code> is more than 0, we return
0. This is because we cannot make a non-empty <code>T</code> from an
empty <code>S</code>.</li>
</ol>
<h4 id="recursive-cases">Recursive Cases</h4>
<ul>
<li>If the last characters of <code>S</code> and <code>T</code> match
(if <code>S[m-1] == T[n-1]</code>):
<ul>
<li>We count the subsequences by including the last character:
<code>countDistinctSubsequences(S, T, m-1, n-1)</code></li>
<li>We also count the subsequences by not including the last character
of <code>S</code>:
<code>countDistinctSubsequences(S, T, m-1, n)</code></li>
</ul></li>
</ul>
<p>The total count is the sum of these two counts.</p>
<ul>
<li>If the last characters do not match (if
<code>S[m-1] != T[n-1]</code>):
<ul>
<li>We only count the subsequences by not including the last character
of <code>S</code>:
<code>countDistinctSubsequences(S, T, m-1, n)</code></li>
</ul></li>
</ul>
<h3 id="recursive-implementation">Recursive Implementation</h3>
<p>Here is a simple code in Python:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countDistinctSubsequences(S, T, m, n):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> S[m<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> T[n<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (countDistinctSubsequences(S, T, m<span class="op">-</span><span class="dv">1</span>, n<span class="op">-</span><span class="dv">1</span>) <span class="op">+</span> </span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                countDistinctSubsequences(S, T, m<span class="op">-</span><span class="dv">1</span>, n))</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> countDistinctSubsequences(S, T, m<span class="op">-</span><span class="dv">1</span>, n)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Example Usage</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>S <span class="op">=</span> <span class="st">&quot;rabbbit&quot;</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="st">&quot;rabbit&quot;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>count <span class="op">=</span> countDistinctSubsequences(S, T, <span class="bu">len</span>(S), <span class="bu">len</span>(T))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count)  <span class="co"># Output: 3</span></span></code></pre></div>
<p>This recursive way works but can be slow because of overlapping
subproblems. For big strings, we can think about using memoization or a
bottom-up dynamic programming way to make it faster.</p>
<h2
id="dynamic-programming-distinct-subsequences-memoization-technique">Dynamic
Programming Distinct Subsequences Memoization Technique</h2>
<p>We use the memoization technique to solve the “Distinct Subsequences”
problem in dynamic programming. This method helps us improve the
recursive approach. We store results of smaller problems so we do not
have to do the same calculations again.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have two strings <code>S</code> and <code>T</code>. Our goal is to
count how many distinct subsequences of <code>T</code> we can make by
deleting some characters from <code>S</code>.</p>
<h3 id="recursive-approach">Recursive Approach</h3>
<p>In the recursive way, we create a function
<code>countDistinctSubsequences(i, j)</code>. This function gives us the
number of distinct subsequences of <code>T[0..j-1]</code> in
<code>S[0..i-1]</code>.</p>
<h3 id="memoization-implementation">Memoization Implementation</h3>
<p>To use memoization, we need a 2D array <code>dp</code>. In this
array, <code>dp[i][j]</code> saves the result of
<code>countDistinctSubsequences(i, j)</code>. If we already calculated
<code>dp[i][j]</code>, we can just return its value.</p>
<p>Here is how we implement the memoization technique:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DistinctSubsequences <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numDistinct</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>s<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>t<span class="op">.</span><span class="fu">length</span><span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: An empty string T has one subsequence in any string S</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill dp array</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> t<span class="op">.</span><span class="fu">length</span><span class="op">();</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> t<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>s<span class="op">.</span><span class="fu">length</span><span class="op">()][</span>t<span class="op">.</span><span class="fu">length</span><span class="op">()];</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Base Case</strong>: If <code>T</code> is empty, there is one
subsequence of <code>T</code> in <code>S</code>. This is the empty
subsequence.</li>
<li><strong>Filling the DP Table</strong>:
<ul>
<li>If the characters match
(<code>s.charAt(i - 1) == t.charAt(j - 1)</code>), we add the count of
subsequences that include both characters and those that do not include
the current character of <code>S</code>.</li>
<li>If they do not match, we take the count from the previous character
of <code>S</code>.</li>
</ul></li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n) where m is the length of
<code>S</code> and n is the length of <code>T</code>.</li>
<li><strong>Space Complexity</strong>: O(m * n) because of the
<code>dp</code> array.</li>
</ul>
<p>This memoization method makes the recursive solution much faster. It
avoids repeating calculations for the same smaller problems. This makes
it good for larger inputs. For more about similar problems, we can look
at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2
id="dynamic-programming-distinct-subsequences-bottom-up-approach-in-java">Dynamic
Programming Distinct Subsequences Bottom Up Approach in Java</h2>
<p>We can solve the Distinct Subsequences problem using the Bottom Up
Approach. This method uses a 2D array to build the solutions to smaller
problems step by step. It avoids the extra cost of recursion. So, it
gives us a faster way to find the answer.</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>We have two strings <code>s</code> and <code>t</code>. Our goal is to
find how many distinct subsequences of <code>t</code> exist in
<code>s</code>. A subsequence means we can remove some characters from
<code>s</code> but we must keep the order of the remaining
characters.</p>
<h3 id="dynamic-programming-table-setup">Dynamic Programming Table
Setup</h3>
<ol type="1">
<li><p>We create a 2D array <code>dp</code>. Here, <code>dp[i][j]</code>
represents the number of distinct subsequences of <code>t[0..j-1]</code>
in <code>s[0..i-1]</code>.</p></li>
<li><p>We initialize:</p>
<ul>
<li><code>dp[0][0] = 1</code>: An empty string is a subsequence of
another empty string.</li>
<li><code>dp[i][0] = 1</code> for all <code>i</code>: An empty
<code>t</code> is a subsequence of any part of <code>s</code>.</li>
</ul></li>
</ol>
<h3 id="transition-formula">Transition Formula</h3>
<ul>
<li>If <code>s[i-1] == t[j-1]</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code></li>
</ul></li>
<li>If <code>s[i-1] != t[j-1]</code>:
<ul>
<li><code>dp[i][j] = dp[i-1][j]</code></li>
</ul></li>
</ul>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DistinctSubsequences <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numDistinct</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> t<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize dp table</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Empty t is a subsequence of any s</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill dp table</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> t<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span> <span class="co">// Result is in the bottom-right cell</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        DistinctSubsequences ds <span class="op">=</span> <span class="kw">new</span> <span class="fu">DistinctSubsequences</span><span class="op">();</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> s <span class="op">=</span> <span class="st">&quot;rabbbit&quot;</span><span class="op">;</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> t <span class="op">=</span> <span class="st">&quot;rabbit&quot;</span><span class="op">;</span></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of distinct subsequences: &quot;</span> <span class="op">+</span> ds<span class="op">.</span><span class="fu">numDistinct</span><span class="op">(</span>s<span class="op">,</span> t<span class="op">));</span> <span class="co">// Output: 3</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<p>The <code>numDistinct</code> function finds the number of distinct
subsequences of <code>t</code> in <code>s</code>. It uses the dynamic
programming table we created before.</p>
<p>In the main method, we show an example. We take
<code>s = "rabbbit"</code> and <code>t = "rabbit"</code>. The output is
<code>3</code>.</p>
<p>This Java code uses the Bottom Up Approach for the Distinct
Subsequences problem. It quickly finds the number of distinct
subsequences using dynamic programming. If you want to learn more about
dynamic programming, check topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a>.</p>
<h2
id="dynamic-programming-distinct-subsequences-bottom-up-approach-in-python">Dynamic
Programming Distinct Subsequences Bottom Up Approach in Python</h2>
<p>We can solve the distinct subsequences problem using a bottom-up
approach. This means we build a dynamic programming table to keep track
of results. This way, we do not need to use recursion or memoization.
Instead, we fill the DP table step by step using values we have already
calculated.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have two strings, <code>s</code> and <code>t</code>. Our goal is
to find how many distinct subsequences of <code>t</code> can be made
from <code>s</code>.</p>
<h3 id="dynamic-programming-table">Dynamic Programming Table</h3>
<ol type="1">
<li>We create a 2D DP array <code>dp</code>. Here, <code>dp[i][j]</code>
shows the number of distinct subsequences of <code>t[0:j]</code> in
<code>s[0:i]</code>.</li>
<li>We set <code>dp[0][0]</code> to 1. This means there is one way to
make an empty string.</li>
<li>For each character in <code>s</code> and <code>t</code>, we update
the table using these conditions:
<ul>
<li><p>If the characters match (<code>s[i-1] == t[j-1]</code>),
then:</p>
<pre><code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code></pre></li>
<li><p>If the characters do not match:</p>
<pre><code>dp[i][j] = dp[i-1][j]</code></pre></li>
</ul></li>
</ol>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> numDistinct(s: <span class="bu">str</span>, t: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># An empty string t has one subsequence in any prefix of s</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m][n]</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> <span class="st">&quot;rabbbit&quot;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="st">&quot;rabbit&quot;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(numDistinct(s, t))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<p>We start with the function <code>numDistinct</code>. It makes a DP
table with size <code>(m + 1) x (n + 1)</code>. Here <code>m</code> is
the length of <code>s</code>, and <code>n</code> is the length of
<code>t</code>.</p>
<p>We set the base case for when <code>t</code> is empty by filling the
first column with 1.</p>
<p>The loops go through each character in both strings. They fill the DP
table based on whether the characters match or not.</p>
<p>In the end, we return <code>dp[m][n]</code>. This value gives us the
total number of distinct subsequences of <code>t</code> in
<code>s</code>.</p>
<p>This bottom-up approach works well and does not use much memory. It
is good for bigger input sizes. If you want to learn more about dynamic
programming, we can check articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming Longest Common Subsequence</a>.</p>
<h2
id="dynamic-programming-distinct-subsequences-bottom-up-approach-in-c">Dynamic
Programming Distinct Subsequences Bottom Up Approach in C++</h2>
<p>The bottom-up way to solve the Distinct Subsequences problem in
dynamic programming is to build the solution step by step. We use a
table to keep the results of smaller problems.</p>
<h3 id="problem-statement-1">Problem Statement</h3>
<p>We have two strings <code>S</code> and <code>T</code>. Our job is to
find how many distinct subsequences of <code>S</code> match
<code>T</code>.</p>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: We create a 2D array
<code>dp</code> with size <code>(m+1) x (n+1)</code>. Here
<code>m</code> is the length of <code>S</code> and <code>n</code> is the
length of <code>T</code>. We set <code>dp[0][0]</code> to
<code>1</code>. This is because an empty string is a subsequence of
another empty string.</p></li>
<li><p><strong>Filling the DP Table</strong>:</p>
<ul>
<li>For each character in <code>S</code> (from 1 to m):
<ul>
<li>For each character in <code>T</code> (from 1 to n):
<ul>
<li>If <code>S[i-1] == T[j-1]</code>, we do:
<ul>
<li><code>dp[i][j] = dp[i-1][j-1] + dp[i-1][j]</code></li>
</ul></li>
<li>If not, we do:
<ul>
<li><code>dp[i][j] = dp[i-1][j]</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul></li>
<li><p><strong>Result</strong>: We will find the answer in
<code>dp[m][n]</code>.</p></li>
</ol>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numDistinct<span class="op">(</span><span class="bu">std::</span>string<span class="op"> </span>S<span class="op">,</span> <span class="bu">std::</span>string<span class="op"> </span>T<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> S<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> T<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// An empty T is a subsequence of any S</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>S<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> T<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>    Solution solution<span class="op">;</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>S <span class="op">=</span> <span class="st">&quot;rabbbit&quot;</span><span class="op">;</span></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>string<span class="op"> </span>T <span class="op">=</span> <span class="st">&quot;rabbit&quot;</span><span class="op">;</span></span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of distinct subsequences: &quot;</span> <span class="op">&lt;&lt;</span> solution<span class="op">.</span>numDistinct<span class="op">(</span>S<span class="op">,</span> T<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In the code: - We have a <code>Solution</code> class. It has a method
<code>numDistinct</code> that takes strings <code>S</code> and
<code>T</code>. - We use a dynamic programming table <code>dp</code> to
count distinct subsequences step by step. - The main function prints the
result.</p>
<p>This method is good. It avoids problems that come with recursion and
memoization. The bottom-up dynamic programming technique works well for
bigger inputs. For more on dynamic programming, we can read about
related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">longest
common subsequence</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">unique
paths</a>.</p>
<h2
id="dynamic-programming-distinct-subsequences-space-optimization-techniques">Dynamic
Programming Distinct Subsequences Space Optimization Techniques</h2>
<p>In the Dynamic Programming Distinct Subsequences problem, we can
improve performance by saving memory. The usual way uses a 2D DP array.
But we can make it better by using a 1D array. The solution at each step
only needs the previous step.</p>
<h3 id="space-optimization-using-a-1d-array">Space Optimization Using a
1D Array</h3>
<p>Instead of using a full 2D array, we can keep a single array. This
array will store results for the current and previous rows. Let’s see
how to do this in different programming languages.</p>
<h4 id="java-implementation-1">Java Implementation</h4>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> DistinctSubsequences <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">numDistinct</span><span class="op">(</span><span class="bu">String</span> s<span class="op">,</span> <span class="bu">String</span> t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s<span class="op">.</span><span class="fu">length</span><span class="op">(),</span> n <span class="op">=</span> t<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">1</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">==</span> t<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python-implementation-1">Python Implementation</h4>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> numDistinct(<span class="va">self</span>, s: <span class="bu">str</span>, t: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        m, n <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> m <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Base case</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> s[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[j <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>                    dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp[n]</span></code></pre></div>
<h4 id="c-implementation-1">C++ Implementation</h4>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> numDistinct<span class="op">(</span>string s<span class="op">,</span> string t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> s<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> t<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>m <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> n<span class="op">;</span> j <span class="op">&gt;=</span> <span class="dv">1</span><span class="op">;</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> t<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li><strong>Memory Reduction</strong>: Using the 1D array cuts space
needed from O(m * n) to O(n).</li>
<li><strong>Bottom-Up Dynamic Programming</strong>: This way fits with
the bottom-up method in dynamic programming. It uses memory well.</li>
<li><strong>Performance</strong>: The time needed is O(m * n), but the
space needed is now O(n).</li>
</ul>
<p>By using these space optimization techniques, we can solve the
Distinct Subsequences problem better. We save memory and can handle
larger inputs more easily.</p>
<h2
id="dynamic-programming-distinct-subsequences-complexity-analysis">Dynamic
Programming Distinct Subsequences Complexity Analysis</h2>
<p>The <strong>Distinct Subsequences</strong> problem is about finding
how many distinct subsequences of a string <code>S</code> match a target
string <code>T</code>. We need to look at the complexity analysis of
different ways to solve this problem. This helps us understand how
efficient the algorithms are.</p>
<h3 id="time-complexity">Time Complexity</h3>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li>The recursive solution takes a lot of time. It has an exponential
time complexity of <strong>O(2^(m + n))</strong>. Here, <code>m</code>
is the length of string <code>T</code> and <code>n</code> is the length
of string <code>S</code>. This happens because recursion looks at all
possible subsequences.</li>
</ul></li>
<li><strong>Memoization Technique</strong>:
<ul>
<li>With memoization, we store results of previous calculations. This
reduces the time complexity to <strong>O(m * n)</strong>. Each
subproblem gets solved just once, which is a big improvement over the
basic recursive way.</li>
</ul></li>
<li><strong>Bottom-Up Approach</strong>:
<ul>
<li>The bottom-up dynamic programming method also works in <strong>O(m *
n)</strong> time. It builds the solution step by step in a table. Each
subproblem is solved only one time.</li>
</ul></li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<ol type="1">
<li><strong>Recursive Approach</strong>:
<ul>
<li>The space complexity is <strong>O(m + n)</strong>. This is because
of the recursion stack, which can go deep up to the total length of
<code>S</code> and <code>T</code>.</li>
</ul></li>
<li><strong>Memoization Technique</strong>:
<ul>
<li>In memoization, the space complexity stays <strong>O(m *
n)</strong>. This is due to the extra space for the memoization
table.</li>
</ul></li>
<li><strong>Bottom-Up Approach</strong>:
<ul>
<li>For the bottom-up method, we can improve space complexity to
<strong>O(n)</strong>. We only keep the last row of the DP table instead
of the whole table.</li>
</ul></li>
</ol>
<h3 id="example-of-time-complexity-calculation">Example of Time
Complexity Calculation</h3>
<p>Let’s take an example where <code>S = "rabbbit"</code> and
<code>T = "rabbit"</code>:</p>
<ul>
<li>With the recursive approach, we check many combinations. This leads
to many repeated calculations.</li>
<li>Using memoization, we calculate each unique state only once. This
gives a linear relationship based on the lengths of <code>S</code> and
<code>T</code>.</li>
</ul>
<h3 id="conclusion-of-complexity-analysis">Conclusion of Complexity
Analysis</h3>
<p>In conclusion, the dynamic programming methods really help us solve
the Distinct Subsequences problem better than the simple recursive way.
By using memoization or a table method, we handle both time and space
complexity well. This makes them good for larger input sizes.</p>
<p>For more information on similar dynamic programming topics, you can
read about the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Longest
Common Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-distinct-subsequences-problem-in-dynamic-programming">1.
What is the distinct subsequences problem in dynamic programming?</h3>
<p>The distinct subsequences problem is a well-known challenge in
dynamic programming. We need to find how many different subsequences of
a string <code>S</code> match a target string <code>T</code>. This
problem is important in many areas, like string matching and
bioinformatics. To solve it well, we usually use methods like recursion,
memoization, or bottom-up approaches in programming languages like Java,
Python, or C++.</p>
<h3
id="how-do-i-approach-the-distinct-subsequences-problem-recursively">2.
How do I approach the distinct subsequences problem recursively?</h3>
<p>To solve this problem using recursion, we can make a function that
looks at two options for each character in the string <code>S</code>. We
can either include the character in the match against <code>T</code> or
leave it out. We keep exploring these options until we finish checking
the strings or find a complete match. This method is easy to understand
but can take a long time to run. So, we often use memoization to make it
faster.</p>
<h3 id="what-is-the-memoization-technique-for-distinct-subsequences">3.
What is the memoization technique for distinct subsequences?</h3>
<p>Memoization is a way to make dynamic programming faster. We save the
results we have already calculated. This helps us avoid doing the same
work again, which is good for the distinct subsequences problem. We can
store results in a 2D array or a dictionary, using the positions in
<code>S</code> and <code>T</code>. This method helps reduce the time it
takes to solve the problem to O(m*n), where <code>m</code> and
<code>n</code> are the lengths of <code>S</code> and <code>T</code>.</p>
<h3
id="can-you-explain-the-bottom-up-approach-for-distinct-subsequences-in-python">4.
Can you explain the bottom-up approach for distinct subsequences in
Python?</h3>
<p>In the bottom-up approach for this problem, we fill a 2D DP table
step by step, starting with the simplest cases. We create a table where
<code>dp[i][j]</code> shows how many distinct subsequences of the first
<code>i</code> characters of <code>S</code> match the first
<code>j</code> characters of <code>T</code>. By updating this table
based on whether we include or exclude characters, we can find the
answer without using recursion. This makes the solution faster and
clearer.</p>
<h3
id="what-are-the-space-optimization-techniques-for-the-distinct-subsequences-problem">5.
What are the space optimization techniques for the distinct subsequences
problem?</h3>
<p>Space optimization techniques for this problem usually cut down the
2D DP table to a 1D array. Instead of keeping a full table, we update
the array directly, using only the current and previous values. This
method greatly decreases the space we need from O(m*n) to O(n) while
keeping the time complexity the same. It is a good way to handle large
inputs.</p>
<p>For more insights on dynamic programming techniques, we can look at
related topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-common-subsequence-medium.html">Dynamic
Programming: Longest Common Subsequence</a>. These articles give more
examples and help us understand dynamic programming better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            