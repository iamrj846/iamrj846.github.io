
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of a Subsequence with No Adjacent Elements - Medium</title>
            <meta name="description" content="Discover how to solve the Maximum Sum of a Subsequence with No Adjacent Elements problem using Dynamic Programming techniques.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of a Subsequence with No Adjacent Elements - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The Maximum Sum of a Subsequence with No Adjacent Elements is a
well-known problem in dynamic programming. This problem is about picking
numbers from an array. We want to get the highest sum possible. But we
must make sure that we do not pick two numbers next to each other.</p>
<p>To find the best solution, we can create a dynamic programming array.
Each spot in this array at index <code>i</code> will show the biggest
sum we can get using numbers from the start of the array to the
<code>i</code>-th index. We decide to include or not include the current
number based on what we got from the previous spots.</p>
<p>In this article, we will look at different ways to solve the Maximum
Sum of a Subsequence with No Adjacent Elements problem. We will explain
the dynamic programming method using Java, Python, and C++. We will also
talk about a solution that saves space. There will be a recursive way
with memoization too. We will compare these methods. Also, we will point
out common mistakes that we should avoid. We will answer some questions
that people often ask about this problem.</p>
<ul>
<li>[Dynamic Programming] Maximum Sum of a Subsequence with No Adjacent
Elements - Medium Solution Overview</li>
<li>Understanding the Problem Statement for Maximum Sum of a Subsequence
with No Adjacent Elements</li>
<li>Dynamic Programming Approach to Maximum Sum of a Subsequence with No
Adjacent Elements in Java</li>
<li>Dynamic Programming Approach to Maximum Sum of a Subsequence with No
Adjacent Elements in Python</li>
<li>Dynamic Programming Approach to Maximum Sum of a Subsequence with No
Adjacent Elements in C++</li>
<li>Optimized Space Complexity Solution for Maximum Sum of a Subsequence
with No Adjacent Elements</li>
<li>Recursive Approach with Memoization for Maximum Sum of a Subsequence
with No Adjacent Elements</li>
<li>Comparative Analysis of Different Approaches for Maximum Sum of a
Subsequence with No Adjacent Elements</li>
<li>Common Mistakes to Avoid in Maximum Sum of a Subsequence with No
Adjacent Elements</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If you are curious about other dynamic programming topics, you can
read articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming: Maximum Sum of Non-Adjacent Elements</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber Problem</a>.</p>
<h2
id="understanding-the-problem-statement-for-maximum-sum-of-a-subsequence-with-no-adjacent-elements">Understanding
the Problem Statement for Maximum Sum of a Subsequence with No Adjacent
Elements</h2>
<p>We have a problem where we need to find the maximum sum of a
subsequence. This subsequence must not have any two numbers next to each
other in the original list.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We are given an integer array called <code>nums</code>. Our task is
to choose a subsequence that follows these rules:</p>
<ul>
<li>The selected numbers should not be next to each other in the
original array.</li>
<li>We want to make the sum of these selected numbers as big as
possible.</li>
</ul>
<h3 id="example">Example</h3>
<p>Letâ€™s look at an example:</p>
<pre class="plaintext"><code>Input: nums = [3, 2, 5, 10, 7]
Output: 15</code></pre>
<p><strong>Explanation:</strong> - We can get the maximum sum by picking
<code>3</code>, <code>10</code>, and <code>2</code> (or just
<code>5</code> and <code>10</code>). This gives us a maximum sum of
<code>15</code>.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The input array can have a length from <code>1</code> to
<code>1000</code>.</li>
<li>Each number in the array can be from <code>0</code> to
<code>1000</code>.</li>
</ul>
<h3 id="approach">Approach</h3>
<p>We can solve this problem well with a method called dynamic
programming. We will keep an array that remembers the maximum sums at
each position. We will also follow the rule that no two numbers can be
next to each other.</p>
<p>We define the rule like this:</p>
<ul>
<li><code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code></li>
</ul>
<p>Where: - <code>dp[i-1]</code> is the maximum sum if we do not take
the current number. - <code>nums[i] + dp[i-2]</code> is the maximum sum
if we include the current number.</p>
<p>This dynamic programming approach helps us find the maximum sum we
need while making sure no adjacent numbers are chosen.</p>
<p>For more help with dynamic programming, you can check the article on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="dynamic-programming-approach-to-maximum-sum-of-a-subsequence-with-no-adjacent-elements-in-java">Dynamic
Programming Approach to Maximum Sum of a Subsequence with No Adjacent
Elements in Java</h2>
<p>We can solve the problem of finding the maximum sum of a subsequence
with no adjacent elements using dynamic programming. This method uses an
array. Each element in this array shows the maximum sum we can get up to
that index without choosing adjacent elements.</p>
<h3 id="algorithm-steps">Algorithm Steps</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create an integer array
<code>dp</code>. Here, <code>dp[i]</code> will hold the maximum sum of a
subsequence considering elements up to index <code>i</code>.</li>
<li><strong>Base Cases</strong>:
<ul>
<li>If the array is empty, we return 0.</li>
<li>If the array has one element, we return that element.</li>
<li>If the array has two elements, we return the bigger of the two.</li>
</ul></li>
<li><strong>Recurrence Relation</strong>: For each element starting from
index 2, we update <code>dp[i]</code> with the maximum of:
<ul>
<li>Including the current element: <code>nums[i] + dp[i-2]</code></li>
<li>Excluding the current element: <code>dp[i-1]</code></li>
</ul></li>
<li><strong>Final Result</strong>: The last element of the
<code>dp</code> array will give us the maximum sum.</li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumSumSubsequence <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSumNonAdjacent</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">10</span><span class="op">,</span> <span class="dv">7</span><span class="op">};</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of non-adjacent elements: &quot;</span> <span class="op">+</span> <span class="fu">maxSumNonAdjacent</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The <code>maxSumNonAdjacent</code> method finds the maximum sum of
non-adjacent elements in an integer array.</li>
<li>The <code>main</code> method shows how the function works with a
sample input array.</li>
<li>The time complexity of this solution is O(n). The space complexity
is also O(n) because of the <code>dp</code> array.</li>
</ul>
<p>This method helps us use dynamic programming well to find the maximum
sum of a subsequence with no adjacent elements in Java. For more
information on dynamic programming methods, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming: Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="dynamic-programming-approach-to-maximum-sum-of-a-subsequence-with-no-adjacent-elements-in-python">Dynamic
Programming Approach to Maximum Sum of a Subsequence with No Adjacent
Elements in Python</h2>
<p>We can solve the problem of finding the maximum sum of a subsequence
with no adjacent elements in Python using a dynamic programming
approach. The main idea is to use an array called <code>dp</code>. In
this array, <code>dp[i]</code> shows the maximum sum we can get by
looking at the first <code>i</code> elements of the input array.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: First, if the array is empty, we
return 0. If it has only one element, we return that element.</p></li>
<li><p><strong>Dynamic Programming Relation</strong>: For each element
in the array, we need to decide if we include it in the sum or not:</p>
<ul>
<li>If we include it, we add the current element to the maximum sum from
<code>i-2</code> (to prevent selecting adjacent elements).</li>
<li>If we do not include it, we keep the maximum sum from
<code>i-1</code>.</li>
</ul>
<p>We can write this as: [ dp[i] = (dp[i-1], arr[i] + (dp[i-2] i &gt;= 2
0)) ]</p></li>
<li><p><strong>Final Result</strong>: The final answer will be in
<code>dp[n-1]</code> where <code>n</code> is the length of the input
array.</p></li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_no_adjacent(arr):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[<span class="dv">0</span>]</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize the dp array</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> arr[<span class="dv">0</span>]</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">1</span>] <span class="op">=</span> <span class="bu">max</span>(arr[<span class="dv">0</span>], arr[<span class="dv">1</span>])</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, n):</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        dp[i] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>], arr[i] <span class="op">+</span> dp[i<span class="op">-</span><span class="dv">2</span>])</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_no_adjacent(arr))  <span class="co"># Output: 15</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The function <code>max_sum_no_adjacent</code> takes an array as
input. It calculates the maximum sum of a subsequence with no adjacent
elements.</li>
<li>The <code>dp</code> array is filled step by step based on the
relation we mentioned before.</li>
<li>Finally, we return the maximum sum from the last position in the
<code>dp</code> array.</li>
</ul>
<p>This method has a time complexity of O(n) and a space complexity of
O(n). To save space, we can use two variables to keep track of the last
two maximum sums instead of the whole <code>dp</code> array.</p>
<p>For more problems and detailed explanations, we can check articles on
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming: Maximum Sum of Non-Adjacent Elements</a> and other dynamic
programming methods.</p>
<h2
id="dynamic-programming-approach-to-maximum-sum-of-a-subsequence-with-no-adjacent-elements-in-c">Dynamic
Programming Approach to Maximum Sum of a Subsequence with No Adjacent
Elements in C++</h2>
<p>To solve the problem of finding the maximum sum of a subsequence with
no adjacent elements using dynamic programming in C++, we can use a
simple method. The main idea is to keep an array <code>dp</code>. Each
element <code>dp[i]</code> shows the maximum sum we can get by looking
at elements from the start of the array to the <code>i</code>-th
index.</p>
<h3 id="steps-1">Steps:</h3>
<ol type="1">
<li><strong>Initialization</strong>:
<ul>
<li>If the input array is empty, we return 0.</li>
<li>If it has only one element, we return that element.</li>
<li>If it has two elements, we return the bigger one of the two.</li>
</ul></li>
<li><strong>Dynamic Programming Transition</strong>:
<ul>
<li><p>For each element starting from index 2, we have two options:</p>
<ul>
<li>Include the current element (<code>arr[i]</code>) and add it to the
maximum sum we got up to <code>i-2</code> (which is
<code>dp[i-2]</code>).</li>
<li>Exclude the current element and take the maximum sum we got up to
<code>i-1</code> (which is <code>dp[i-1]</code>).</li>
</ul></li>
<li><p>We can write the formula like this:</p>
<pre><code>dp[i] = max(dp[i-1], arr[i] + dp[i-2])</code></pre></li>
</ul></li>
<li><strong>Final Result</strong>:
<ul>
<li>The answer will be in <code>dp[n-1]</code>, where <code>n</code> is
the size of the input array.</li>
</ul></li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation:</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumWithoutAdjacent<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">std::</span>max<span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> arr<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>arr<span class="op">[</span><span class="dv">0</span><span class="op">],</span> arr<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">],</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">2</span><span class="op">]);</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Maximum sum of non-adjacent elements: &quot;</span> <span class="op">&lt;&lt;</span> maxSumWithoutAdjacent<span class="op">(</span>arr<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code:</h3>
<ul>
<li>We first check the special cases for arrays of sizes 0, 1, and
2.</li>
<li>We set up the <code>dp</code> array and fill it using the formula we
wrote.</li>
<li>Finally, we return the last element of the <code>dp</code> array.
This element shows the maximum sum of a subsequence without adjacent
elements.</li>
</ul>
<p>This code runs in O(n) time and uses O(n) space. To make it better,
we can reduce the space to O(1) by just keeping the last two values
instead of using a full <code>dp</code> array.</p>
<p>For more problems like this, you can check the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming: Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="optimized-space-complexity-solution-for-maximum-sum-of-a-subsequence-with-no-adjacent-elements">Optimized
Space Complexity Solution for Maximum Sum of a Subsequence with No
Adjacent Elements</h2>
<p>We can solve the problem of finding the maximum sum of a subsequence
without adjacent elements. We can do this with a space complexity of
O(1). We only need to remember a few previous states. We do not need a
full array to keep all the values we have calculated.</p>
<h3 id="approach-1">Approach</h3>
<p>Instead of using an array to store results for all indices, we can
use two simple variables: - <code>incl</code>: This is the maximum sum
that includes the current element. - <code>excl</code>: This is the
maximum sum that excludes the current element.</p>
<p>As we go through the elements of the array, we will calculate new
values for <code>incl</code> and <code>excl</code> based on the current
element.</p>
<h3 id="algorithm-steps-1">Algorithm Steps</h3>
<ol type="1">
<li>We start by setting <code>incl</code> to the first element and
<code>excl</code> to 0.</li>
<li>Then we go through the array from the second element:
<ul>
<li>We set <code>new_excl</code> to the maximum of <code>incl</code> and
<code>excl</code>.</li>
<li>We update <code>incl</code> to
<code>excl + current_element</code>.</li>
<li>We set <code>excl</code> to <code>new_excl</code>.</li>
</ul></li>
<li>At the end, the result will be the maximum of <code>incl</code> and
<code>excl</code>.</li>
</ol>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNoAdjacent <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> incl <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> excl <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> new_excl <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>incl<span class="op">,</span> excl<span class="op">);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            incl <span class="op">=</span> excl <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>            excl <span class="op">=</span> new_excl<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>incl<span class="op">,</span> excl<span class="op">);</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum(nums):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    incl <span class="op">=</span> nums[<span class="dv">0</span>]</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    excl <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        new_excl <span class="op">=</span> <span class="bu">max</span>(incl, excl)</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        incl <span class="op">=</span> excl <span class="op">+</span> nums[i]</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        excl <span class="op">=</span> new_excl</span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(incl, excl)</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> maxSum<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> incl <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> excl <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> new_excl <span class="op">=</span> max<span class="op">(</span>incl<span class="op">,</span> excl<span class="op">);</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            incl <span class="op">=</span> excl <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            excl <span class="op">=</span> new_excl<span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>incl<span class="op">,</span> excl<span class="op">);</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This smart solution finds the maximum sum of a subsequence without
adjacent elements. It also keeps a constant space complexity. This makes
it great for large input arrays. For more information about dynamic
programming, we can check related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="recursive-approach-with-memoization-for-maximum-sum-of-a-subsequence-with-no-adjacent-elements">Recursive
Approach with Memoization for Maximum Sum of a Subsequence with No
Adjacent Elements</h2>
<p>We can use the recursive approach with memoization to find the
maximum sum of a subsequence with no adjacent elements. The main idea is
to use recursion to decide whether to include or not include each
element. We also store results to avoid doing the same work again.</p>
<h3 id="problem-definition-1">Problem Definition</h3>
<p>We have an array of integers. Our goal is to find the maximum sum of
a subsequence where no two elements are next to each other. The
recursive function will look at two choices for each element:</p>
<ol type="1">
<li>Include the current element and skip to the next non-adjacent
element.</li>
<li>Exclude the current element and go to the next element.</li>
</ol>
<h3 id="recursive-function-with-memoization">Recursive Function with
Memoization</h3>
<p>Here is how we can write the recursive function with memoization in
Python:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_no_adjacent(arr):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(index):</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> index <span class="kw">in</span> memo:</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[index]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Include the current element</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> arr[index] <span class="op">+</span> helper(index <span class="op">-</span> <span class="dv">2</span>)</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Exclude the current element</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> helper(index <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        memo[index] <span class="op">=</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[index]</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> helper(<span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_no_adjacent(arr))  <span class="co"># Output: 15</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Base Case</strong>: If the index is less than 0, we return
0. There are no elements to look at.</li>
<li><strong>Memoization</strong>: We save the results for each index.
This helps us avoid doing the same calculations again.</li>
<li><strong>Recursive Calls</strong>: For each index, we find the
maximum sum by deciding to include or exclude the current element.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity for this approach is O(n) because of memoization.
The space complexity is also O(n) since we need space to store the
results.</p>
<p>This recursive approach with memoization is a strong way to solve the
problem of finding the maximum sum of a subsequence without adjacent
elements. If you want to learn more about dynamic programming, we can
check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="comparative-analysis-of-different-approaches-for-maximum-sum-of-a-subsequence-with-no-adjacent-elements">Comparative
Analysis of Different Approaches for Maximum Sum of a Subsequence with
No Adjacent Elements</h2>
<p>When we try to find the maximum sum of a subsequence with no adjacent
elements, we can use different methods. The three main ways are Dynamic
Programming, Recursive approach with memoization, and an optimized space
solution. Each method has its own good and bad sides based on time,
space, and how easy it is to use.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<p>We use a bottom-up dynamic programming method. Here, we keep an array
called <code>dp</code>. Each <code>dp[i]</code> will hold the maximum
sum we can get by looking at elements up to index <code>i</code>.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(n)</li>
</ul>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSumNoAdjacent</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">1</span><span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]</span> <span class="op">+</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="recursive-approach-with-memoization">2. Recursive Approach with
Memoization</h3>
<p>In this method, we use recursion to look at all subsequences. We
store results of already calculated states. This way, we do not
calculate the same thing again.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(n) for the memoization
array</li>
</ul>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_no_adjacent(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(i):</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> i <span class="kw">in</span> memo:</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[i]</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        memo[i] <span class="op">=</span> <span class="bu">max</span>(dfs(i <span class="op">-</span> <span class="dv">1</span>), nums[i] <span class="op">+</span> dfs(i <span class="op">-</span> <span class="dv">2</span>))</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[i]</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">7</span>]</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_no_adjacent(nums))  <span class="co"># Output: 15</span></span></code></pre></div>
<h3 id="optimized-space-complexity-solution">3. Optimized Space
Complexity Solution</h3>
<p>For this approach, we do not need to keep a big array for
<code>dp</code>. We just track the last two calculated values. This
reduces space usage to O(1).</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(1)</li>
</ul>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumNoAdjacent<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> prev2 <span class="op">=</span> max<span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">2</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> max<span class="op">(</span>prev2<span class="op">,</span> prev1 <span class="op">+</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> prev2<span class="op">;</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev2<span class="op">;</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="comparative-summary">Comparative Summary</h3>
<ul>
<li><strong>Dynamic Programming:</strong> Good for cases where space is
not a big issue. It is simple to use.</li>
<li><strong>Recursive with Memoization:</strong> Good for problems that
fit a recursive style, but it uses more space because of
memoization.</li>
<li><strong>Optimized Approach:</strong> Best for cases where we care
about performance and want to save space.</li>
</ul>
<p>All these methods solve the problem of finding the maximum sum of a
subsequence with no adjacent elements. Which one we choose depends on
the specific needs of the task. For more reading on similar dynamic
programming problems, we can check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadaneâ€™s Algorithm)</a>.</p>
<h2
id="common-mistakes-to-avoid-in-maximum-sum-of-a-subsequence-with-no-adjacent-elements">Common
Mistakes to Avoid in Maximum Sum of a Subsequence with No Adjacent
Elements</h2>
<p>When we solve the problem of finding the maximum sum of a subsequence
with no adjacent elements, we need to watch out for some common
mistakes.</p>
<ol type="1">
<li><strong>Not Enough Base Cases</strong>:
<ul>
<li>If we do not set the base cases right in our dynamic programming
solution, we can get wrong results. We must make sure to start our
dynamic programming array correctly:
<ul>
<li><code>dp[0]</code> should be <code>nums[0]</code> if
<code>nums</code> is not empty.</li>
<li><code>dp[1]</code> should be <code>max(nums[0], nums[1])</code> if
we have at least two elements.</li>
</ul></li>
</ul></li>
<li><strong>Wrong Recurrence Relation</strong>:
<ul>
<li><p>The recurrence relation must show the right choice at each
position. The correct relation is:</p>
<pre class="plaintext"><code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code></pre></li>
<li><p>This means for each element, we can either take it (add it to the
sum of non-adjacent elements) or leave it out.</p></li>
</ul></li>
<li><strong>Not Checking Array Length</strong>:
<ul>
<li>We should check for edge cases where the input array might be empty
or has just one element. For example:
<ul>
<li>If <code>nums</code> is empty, we return <code>0</code>.</li>
<li>If <code>nums</code> has one element, we return that element.</li>
</ul></li>
</ul></li>
<li><strong>Space Optimization Problems</strong>:
<ul>
<li><p>If we want to save space, we must be careful about changing
values in the dynamic programming array. Instead of using a full array,
we can use two variables to remember the last two values:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> temp <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    prev1 <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    prev2 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="cf">return</span> prev1<span class="op">;</span></span></code></pre></div></li>
</ul></li>
<li><strong>Not Handling Negative Numbers</strong>:
<ul>
<li>If the array has negative numbers, we need to make sure our logic
handles this. It can help to start our <code>dp</code> array values at
<code>0</code> when we find the maximum sum.</li>
</ul></li>
<li><strong>Not Looking at All Subsequences</strong>:
<ul>
<li>We must make sure our approach checks all possible subsequences.
This includes single elements and their pairs to find the best sum
without picking adjacent ones.</li>
</ul></li>
<li><strong>Limiting Test Cases</strong>:
<ul>
<li>When we test our solution, we should include edge cases like all
positive numbers, all negative numbers, and mixed numbers. This helps to
make sure our solution works well.</li>
</ul></li>
<li><strong>Confusing the Problem</strong>:
<ul>
<li>We should be careful not to mix this problem with similar ones, like
the â€œHouse Robberâ€ problem. Here, the focus is only on maximum sums
without choosing adjacent elements. This can lead to different choices
for the best answer.</li>
</ul></li>
</ol>
<p>By avoiding these mistakes, we can solve the problem of finding the
maximum sum of a subsequence with no adjacent elements using dynamic
programming. If we want to learn more about dynamic programming, we can
check out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadaneâ€™s Algorithm)</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-a-subsequence-with-no-adjacent-elements">What
is the maximum sum of a subsequence with no adjacent elements?</h3>
<p>The problem of finding the maximum sum of a subsequence with no
adjacent elements is about picking numbers from an array. We want to
pick numbers so that no two picked numbers are next to each other. Our
goal is to get the highest sum of the picked numbers while following
this rule. We can solve this problem well by using dynamic programming.
This method helps us build the solution based on results we already
have.</p>
<h3
id="how-do-you-implement-the-dynamic-programming-solution-for-this-problem-in-java">How
do you implement the dynamic programming solution for this problem in
Java?</h3>
<p>To implement the dynamic programming solution in Java, we can use an
array. Each entry at index <code>i</code> will hold the maximum sum we
can get from the start up to index <code>i</code>. The formula we use is
<code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code>. Here,
<code>nums</code> is our input array. This way, we can find the result
quickly in linear time.</p>
<h3
id="what-is-the-time-complexity-of-the-dynamic-programming-approach">What
is the time complexity of the dynamic programming approach?</h3>
<p>The time complexity of the dynamic programming approach for finding
the maximum sum of a subsequence with no adjacent elements is O(n).
Here, n is the number of elements in the input array. We get this
efficiency because we only need to go through the array once. This makes
it good for large input sizes. We can also reduce the space we use to
O(1) if we only keep the last two values instead of a whole array.</p>
<h3 id="can-this-problem-be-solved-using-recursion">Can this problem be
solved using recursion?</h3>
<p>Yes, we can solve the maximum sum of a subsequence with no adjacent
elements using recursion. In this method, we decide for each element if
we want to include it in the sum or not. But we have to make sure that
we do not include adjacent elements. However, this simple recursive
method has exponential time complexity because it has overlapping
subproblems. To make it better, we can use memoization to save results
of subproblems. This will help us a lot.</p>
<h3
id="what-common-mistakes-should-i-avoid-when-solving-this-problem">What
common mistakes should I avoid when solving this problem?</h3>
<p>When we solve the maximum sum of a subsequence with no adjacent
elements, we should avoid some common mistakes. One mistake is not
thinking about edge cases like empty arrays or arrays with just one
element. It is also very important to use the right indices in the
dynamic programming approach. Off-by-one errors can give us wrong
results. We need to understand the base cases well for both recursive
and iterative methods.</p>
<p>For more reading on related dynamic programming problems, we can
check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadaneâ€™s Algorithm)</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber I</a>. These articles can give us more ideas
on how to solve similar problems better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            