
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Subarray with k Swaps - Hard</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Sum of Subarray with k Swaps problem using dynamic programming techniques. Learn strategies now!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Subarray with k Swaps - Hard</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The problem of finding the maximum sum of a subarray with k swaps is
a tricky challenge. It mixes dynamic programming with smart choices. Our
goal is to find the highest sum of a continuous subarray after doing at
most k swaps between the elements in the array. We need to know how to
change the positions of elements to get a bigger sum. This makes it a
complex but interesting problem in dynamic programming.</p>
<p>In this article, we will look at the details of the maximum sum of a
subarray with k swaps. We will start by clearly saying what the problem
is. Then we will talk about the dynamic programming way to solve it. We
will also compare this method with a greedy approach to show how they
are different. At the end, we will give Java, Python, and C++ codes to
show how the ideas work in real life. We will also include some tips for
making it better and talk about complexity. Key topics we will cover
are:</p>
<ul>
<li>Understanding the Problem Statement for Maximum Sum of Subarray with
k Swaps</li>
<li>Dynamic Programming Approach to Maximum Sum of Subarray with k
Swaps</li>
<li>Greedy Approach vs Dynamic Programming for Maximum Sum of Subarray
with k Swaps</li>
<li>Java Implementation of Maximum Sum of Subarray with k Swaps</li>
<li>Python Implementation of Maximum Sum of Subarray with k Swaps</li>
<li>C++ Implementation of Maximum Sum of Subarray with k Swaps</li>
<li>Optimizing the Solution for Maximum Sum of Subarray with k
Swaps</li>
<li>Time and Space Complexity Analysis for Maximum Sum of Subarray with
k Swaps</li>
<li>Frequently Asked Questions</li>
</ul>
<p>This detailed look will help us understand the maximum sum of
subarray with k swaps using dynamic programming techniques well. If we
want to read more about dynamic programming basics, we can check
articles on the Fibonacci number and the climbing stairs problem.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="understanding-the-problem-statement-for-maximum-sum-of-subarray-with-k-swaps">Understanding
the Problem Statement for Maximum Sum of Subarray with k Swaps</h3>
<p>We want to find the maximum sum of a subarray when we can swap some
elements. We can swap at most <code>k</code> elements to make the sum of
a continuous subarray bigger.</p>
<p>Here are the key points: - <strong>Input</strong>: - An array of
integers <code>arr[]</code> with size <code>n</code>. - An integer
<code>k</code> that tells us the maximum swaps we can do. -
<strong>Output</strong>: - The biggest sum of any continuous subarray
after doing at most <code>k</code> swaps. -
<strong>Constraints</strong>: - We can swap any two elements in the
array. - We calculate the subarray sum after we do the swaps.</p>
<h3 id="example">Example</h3>
<p>Let’s look at the array <code>arr = [1, 2, 3, 4, 5]</code> and
<code>k = 2</code>. By swapping elements, we can get a bigger subarray
sum. For example, if we swap the first and last elements, we get
<code>arr = [5, 2, 3, 4, 1]</code>. The maximum subarray sum is
<code>5 + 4 + 3 = 12</code>.</p>
<p>We want to find a good way to get this maximum sum using dynamic
programming. We need to optimize the swaps and check all possible
subarrays.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ol type="1">
<li>Find continuous subarrays.</li>
<li>Calculate the sum of these subarrays.</li>
<li>See how doing up to <code>k</code> swaps changes these sums.</li>
<li>Keep the biggest sum we find during our calculations.</li>
</ol>
<p>This problem mixes sliding window methods and dynamic programming. We
need to think about how many swaps we use. We must also be careful when
<code>k</code> is larger than the number of elements in the array.</p>
<h3 id="references">References</h3>
<p>For more insight on similar dynamic programming problems, we can
check these resources: - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a> - <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-subarray-with-one-modification-medium.html">Dynamic
Programming - Maximum Sum of Subarray with One Modification</a></p>
<p>These articles can help us learn more about dynamic programming
methods that relate to this problem.</p>
<h2
id="dynamic-programming-approach-to-maximum-sum-of-subarray-with-k-swaps">Dynamic
Programming Approach to Maximum Sum of Subarray with k Swaps</h2>
<p>To find the maximum sum of a subarray with at most k swaps, we can
use dynamic programming. We will define a state and how it changes.</p>
<h3 id="state-definition">State Definition</h3>
<p>We can say <code>dp[i][j]</code> is the maximum sum of a subarray
that ends at index <code>i</code> with at most <code>j</code> swaps.</p>
<h3 id="transition">Transition</h3>
<ul>
<li>First, we set <code>dp[i][0]</code> to be the maximum subarray sum
that ends at index <code>i</code> without any swaps. We can find this
using Kadane’s algorithm.</li>
<li>To find <code>dp[i][j]</code> when <code>j</code> is more than 0, we
look at two situations:
<ol type="1">
<li>The subarray does not use a swap. This is just
<code>dp[i-1][j]</code>.</li>
<li>The subarray uses a swap. We check all previous indices
<code>m</code> (from 0 to <code>i-1</code>). We see if swapping the
element at <code>m</code> with <code>arr[i]</code> makes the sum bigger.
The new sum can be found as:</li>
</ol>
[ dp[i][j] = (dp[i][j], dp[m][j-1] + arr[i] - arr[m]) ]</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li>The time complexity is (O(n^2 k)) because we have nested loops to
calculate the sums with swaps.</li>
<li>The space complexity is (O(n k)) for the <code>dp</code> table.</li>
</ul>
<h3 id="example-code">Example Code</h3>
<p>Here is a simple Python code for the dynamic programming method:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumAfterKSwaps(arr, k):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize dp for 0 swaps</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    max_ending_here <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        max_ending_here <span class="op">=</span> <span class="bu">max</span>(arr[i], max_ending_here <span class="op">+</span> arr[i])</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> max_ending_here</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the DP table</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># No swap</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j], dp[m][j <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> arr[i] <span class="op">-</span> arr[m])</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get the maximum sum with at most k swaps</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="bu">max</span>(dp[i][k] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumAfterKSwaps(arr, k))  <span class="co"># Output: Maximum sum after k swaps</span></span></code></pre></div>
<p>This code finds the maximum sum of subarrays while allowing up to
<code>k</code> swaps. The dynamic programming method helps us track the
states and how they change to get the result we want. If you want to
learn more about dynamic programming, check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard-1">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="greedy-approach-vs-dynamic-programming-for-maximum-sum-of-subarray-with-k-swaps">Greedy
Approach vs Dynamic Programming for Maximum Sum of Subarray with k
Swaps</h3>
<p>When we try to find the maximum sum of a subarray with up to
<code>k</code> swaps, we can think about two main ways to solve it.
These are the Greedy Approach and the Dynamic Programming (DP) Approach.
Both ways have good and bad points, which we will explain below.</p>
<h4 id="greedy-approach">Greedy Approach</h4>
<p>The Greedy Approach tries to make the best choice at each step. We
hope that these good choices will help us find the best overall answer.
For the maximum sum of a subarray with <code>k</code> swaps, the greedy
method can include:</p>
<ul>
<li><strong>Finding the best items to swap:</strong> This means we look
for the smallest numbers in the chosen subarray. We can swap them with
bigger numbers outside the subarray.</li>
<li><strong>Doing the <code>k</code> swaps that give the biggest quick
gain in sum.</strong></li>
</ul>
<p>But, this method might not always give the best answer. Sometimes,
good local choices do not lead to the best global solution.</p>
<p>Example:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> greedy_max_sum_with_k_swaps(arr, k):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="bu">sum</span>(arr[:k])  <span class="co"># Initial sum of the first k elements</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Perform greedy swaps</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[j] <span class="op">&gt;</span> arr[i]:</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>                arr[i], arr[j] <span class="op">=</span> arr[j], arr[i]</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>                current_sum <span class="op">=</span> <span class="bu">sum</span>(arr[:k])</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                max_sum <span class="op">=</span> <span class="bu">max</span>(max_sum, current_sum)</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_sum</span></code></pre></div>
<h4 id="dynamic-programming-approach">Dynamic Programming Approach</h4>
<p>The Dynamic Programming Approach breaks the problem into smaller
parts. It saves results to not do the same work again. For the maximum
sum of a subarray with <code>k</code> swaps, the DP solution usually
includes:</p>
<ul>
<li><strong>State Definition:</strong> We define <code>dp[i][j]</code>
as the maximum sum of a subarray ending at index <code>i</code> with
<code>j</code> swaps allowed.</li>
<li><strong>Transition:</strong> We move from previous results by
deciding to swap an element or not. This builds the solution based on
what we got before.</li>
<li><strong>Optimal Substructure:</strong> This method uses the best
solutions of smaller problems to guarantee the best overall result.</li>
</ul>
<p>Example:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> dp_max_sum_with_k_swaps(arr, k):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> arr[<span class="dv">0</span>]  <span class="co"># Base case, with 0 swaps</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>            dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> arr[i], arr[i])  <span class="co"># Not swapping</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> m <span class="kw">in</span> <span class="bu">range</span>(i):  <span class="co"># Check all previous elements for a swap</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j], dp[m][j<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> arr[i])</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[n<span class="op">-</span><span class="dv">1</span>])</span></code></pre></div>
<h4 id="comparison">Comparison</h4>
<ul>
<li><strong>Complexity:</strong> The greedy method is usually faster.
But it may not always give the right answer. The DP approach is slower
because of its nested loops. Still, it guarantees the best
solution.</li>
<li><strong>Use Cases:</strong> The greedy way is good for simple cases
or when we just need a good guess. The DP way is better for problems
where we need the best answers. This is especially true in competitive
programming and algorithm challenges.</li>
</ul>
<p>In conclusion, deciding between the Greedy Approach and the Dynamic
Programming Approach for the Maximum Sum of Subarray with k Swaps
depends on what we need more. Is it accuracy or speed? To learn more
about dynamic programming techniques, we can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard-2">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="java-implementation-of-maximum-sum-of-subarray-with-k-swaps">Java
Implementation of Maximum Sum of Subarray with k Swaps</h3>
<p>We can solve the problem of finding the maximum sum of a subarray
with at most k swaps using dynamic programming. Here is a simple Java
example that shows how we can do this.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">Arrays</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumSubarrayKSwaps <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSumWithKSwaps</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">][</span>k <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Initialize dp array</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="bu">Arrays</span><span class="op">.</span><span class="fu">fill</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">],</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">);</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Iterate through each element</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Option 1: Not swapping the current element</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Option 2: Swapping with previous elements</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> l <span class="op">&lt;</span> i<span class="op">;</span> l<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">],</span> dp<span class="op">[</span>l<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Find the maximum sum from the last row</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxSum <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb4-31"><a href="#cb4-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;=</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-32"><a href="#cb4-32" aria-hidden="true" tabindex="-1"></a>            maxSum <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxSum<span class="op">,</span> dp<span class="op">[</span>n<span class="op">][</span>j<span class="op">]);</span></span>
<span id="cb4-33"><a href="#cb4-33" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-34"><a href="#cb4-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-35"><a href="#cb4-35" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxSum<span class="op">;</span></span>
<span id="cb4-36"><a href="#cb4-36" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-37"><a href="#cb4-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-38"><a href="#cb4-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-39"><a href="#cb4-39" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb4-40"><a href="#cb4-40" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> k <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-41"><a href="#cb4-41" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of subarray with &quot;</span> <span class="op">+</span> k <span class="op">+</span> <span class="st">&quot; swaps: &quot;</span> <span class="op">+</span> <span class="fu">maxSumWithKSwaps</span><span class="op">(</span>arr<span class="op">,</span> k<span class="op">));</span></span>
<span id="cb4-42"><a href="#cb4-42" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-43"><a href="#cb4-43" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ol type="1">
<li><p><strong>Dynamic Programming Table (dp)</strong>: We use a 2D
array <code>dp[i][j]</code> where <code>i</code> is the number of
elements we look at and <code>j</code> is the number of swaps we make.
The value in <code>dp[i][j]</code> shows the maximum sum we can get with
the first <code>i</code> elements and <code>j</code> swaps.</p></li>
<li><p><strong>Initialization</strong>: We set the <code>dp</code> array
to <code>Integer.MIN_VALUE</code> except for <code>dp[0][0]</code>,
which we set to <code>0</code>.</p></li>
<li><p><strong>Filling the DP Table</strong>:</p>
<ul>
<li>For each element, we can include it without swapping or swap it with
a previous element.</li>
<li>If we swap, we check all earlier elements to see if swapping gives
us a bigger sum.</li>
</ul></li>
<li><p><strong>Result Extraction</strong>: The highest value from the
last row of the <code>dp</code> table gives us the maximum sum of the
subarray with at most <code>k</code> swaps.</p></li>
</ol>
<p>This code runs with a time complexity of (O(n^2 k)) and space
complexity of (O(n k)). It works well for medium input sizes. For more
information on dynamic programming, we can check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard-3">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="python-implementation-of-maximum-sum-of-subarray-with-k-swaps">Python
Implementation of Maximum Sum of Subarray with k Swaps</h3>
<p>We want to find the maximum sum of a subarray with at most
<code>k</code> swaps. To do this, we can use a simple dynamic
programming approach. In our code, we will keep a table to store the
maximum sums we can get with different swap numbers.</p>
<p>Here is the Python code:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_with_k_swaps(arr, k):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> (k <span class="op">+</span> <span class="dv">1</span>) <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(n)]</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We start by filling the dp array with original sums</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> arr[i] <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="op">+</span> arr[i]</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> swaps <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            dp[i][swaps] <span class="op">=</span> dp[i][swaps <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i):</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                dp[i][swaps] <span class="op">=</span> <span class="bu">max</span>(dp[i][swaps], dp[j][swaps <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> arr[i])</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[n<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">2</span>, <span class="dv">8</span>]</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_sum_with_k_swaps(arr, k))  <span class="co"># Output: Maximum sum with k swaps</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Input</strong>: <code>arr</code> is the list we give, and
<code>k</code> is the number of swaps we can use.</li>
<li><strong>Dynamic Programming Table</strong>:
<code>dp[i][swaps]</code> shows the maximum sum we can get using the
first <code>i</code> elements with <code>swaps</code> allowed.</li>
<li><strong>Initialization</strong>: The first column of the DP table
starts with the sums of the array elements.</li>
<li><strong>Filling the DP Table</strong>: For each element and each
number of swaps, we look at the maximum sum we can get by checking
earlier elements and their sums with one swap less.</li>
<li><strong>Result</strong>: The function gives back the maximum sum we
can get with at most <code>k</code> swaps.</li>
</ul>
<p>This solution works well to find the answer while following the rules
from the problem. If you want to learn more about dynamic programming,
you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray - Kadane’s Algorithm</a>.</p>
<h2 id="c-implementation-of-maximum-sum-of-subarray-with-k-swaps">C++
Implementation of Maximum Sum of Subarray with k Swaps</h2>
<p>We will show how to find the maximum sum of a subarray with up to
<code>k</code> swaps in C++. We can use a simple dynamic programming
method. We will keep a DP table that tracks the best sum we can get with
a certain number of swaps.</p>
<p>Here is a simple C++ code:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumWithKSwaps<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate the prefix sum array</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> prefixSum<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> prefixSum<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> swaps <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> swaps <span class="op">&lt;=</span> k<span class="op">;</span> swaps<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                <span class="co">// Calculate the new sum if we swap arr[i] with arr[j - 1]</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> currentSum <span class="op">=</span> prefixSum<span class="op">[</span>j<span class="op">]</span> <span class="op">-</span> prefixSum<span class="op">[</span>i<span class="op">]</span> <span class="op">+</span> <span class="op">(</span>swaps <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">?</span> arr<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">-</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">:</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>swaps<span class="op">]</span> <span class="op">=</span> max<span class="op">(</span>dp<span class="op">[</span>swaps<span class="op">],</span> currentSum<span class="op">);</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>k<span class="op">];</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum Sum of Subarray with &quot;</span> <span class="op">&lt;&lt;</span> k <span class="op">&lt;&lt;</span> <span class="st">&quot; Swaps: &quot;</span> <span class="op">&lt;&lt;</span> maxSumWithKSwaps<span class="op">(</span>arr<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li><strong>Input:</strong> The function <code>maxSumWithKSwaps</code>
takes a list of integers <code>arr</code> and an integer <code>k</code>.
This <code>k</code> shows the most swaps we can do.</li>
<li><strong>Prefix Sum Calculation:</strong> We create a prefix sum
array. This helps to find the sum of any subarray easily.</li>
<li><strong>Dynamic Programming Loop:</strong> The outer loop goes
through the number of swaps we can make. The inner loops go through the
array to find possible sums based on swaps.</li>
<li><strong>Return Value:</strong> The function gives back the best sum
we can get with the allowed number of swaps.</li>
</ul>
<p>This code finds the maximum sum of a subarray with up to
<code>k</code> swaps using dynamic programming. If you want to learn
more about dynamic programming, you can check the article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray (Kadane’s Algorithm)</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard-4">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="optimizing-the-solution-for-maximum-sum-of-subarray-with-k-swaps">Optimizing
the Solution for Maximum Sum of Subarray with k Swaps</h3>
<p>We want to find the best way to get the maximum sum of a subarray
with <code>k</code> swaps. We can use dynamic programming and some smart
calculations to do this. Here’s how we can do it:</p>
<ol type="1">
<li><p><strong>Initial Calculations</strong>: First, we find the maximum
sum of the subarray without any swaps. For this, we use Kadane’s
algorithm. This step will give us a starting point to compare
later.</p></li>
<li><p><strong>Identify Swaps</strong>: For each element in the array,
we check the maximum sum we can get if we swap it with any other element
in the array.</p></li>
<li><p><strong>Dynamic Programming Table</strong>: We create a DP table
<code>dp[i][j]</code>. Here, <code>i</code> is the number of swaps we
use and <code>j</code> is the current index in the array. Each cell
holds the maximum sum we can get up to that index using <code>i</code>
swaps.</p></li>
<li><p><strong>Transition</strong>: For each element, we consider two
options:</p>
<ul>
<li>We do not swap. We keep the previous maximum.</li>
<li>We swap with a bigger element if it exists. This may increase the
sum.</li>
</ul></li>
<li><p><strong>Final Calculation</strong>: The maximum value in the last
row of the DP table gives us the answer we need.</p></li>
</ol>
<h3 id="example-code-in-python">Example Code in Python</h3>
<p>Here is a Python example of the above method:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> maxSumAfterKSwaps(arr, k):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 1: Calculate the initial maximum sum with Kadane&#39;s algorithm</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    max_sum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    current_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>        current_sum <span class="op">+=</span> num</span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_sum <span class="op">&gt;</span> max_sum:</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            max_sum <span class="op">=</span> current_sum</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> current_sum <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            current_sum <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Step 2: Dynamic Programming table initialization</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>)]</span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> arr[j] <span class="cf">if</span> j <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="bu">max</span>(dp[i][j <span class="op">-</span> <span class="dv">1</span>], arr[j])</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Swap logic</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> l <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> l <span class="op">!=</span> j:  <span class="co"># Ensure we swap with a different index</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                        dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j], dp[i <span class="op">-</span> <span class="dv">1</span>][l] <span class="op">+</span> arr[j] <span class="op">-</span> arr[l])</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The final result is the maximum in the last row of dp</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(dp[k])</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>]</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(maxSumAfterKSwaps(arr, k))  <span class="co"># Output: Maximum sum after k swaps</span></span></code></pre></div>
<h3 id="key-considerations">Key Considerations</h3>
<ul>
<li>This method combines dynamic programming with the power of swaps
well.</li>
<li>The code checks the best outcome after using <code>k</code> swaps in
the subarray.</li>
<li>The time complexity is O(n^2 * k). We can make it better by reducing
the swaps we check.</li>
</ul>
<p>Using this optimized strategy, we can find the maximum sum of a
subarray with <code>k</code> swaps in a good way. If you want to learn
more about dynamic programming, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">this
article on the Maximum Subarray using Kadane’s Algorithm</a>.</p>
<h2
id="dynamic-programming-maximum-sum-of-subarray-with-k-swaps---hard-5">[Dynamic
Programming] Maximum Sum of Subarray with k Swaps - Hard</h2>
<h3
id="time-and-space-complexity-analysis-for-maximum-sum-of-subarray-with-k-swaps">Time
and Space Complexity Analysis for Maximum Sum of Subarray with k
Swaps</h3>
<p>We can look at the time and space complexity of the Dynamic
Programming method to solve the “Maximum Sum of Subarray with k Swaps”
like this:</p>
<h4 id="time-complexity">Time Complexity</h4>
<ol type="1">
<li><strong>Dynamic Programming Table Building</strong>:
<ul>
<li>If <code>n</code> is how long the array is and <code>k</code> is the
most swaps we can do, we build a 2D table <code>dp[i][j]</code>. Here:
<ul>
<li><code>i</code> goes through the elements of the array (up to
<code>n</code>),</li>
<li><code>j</code> goes through the number of swaps we used (up to
<code>k</code>).</li>
</ul></li>
<li>So, the time needed to fill this table is (O(n k)).</li>
</ul></li>
<li><strong>Going Through Array Elements</strong>:
<ul>
<li>For each element, we might need to think about possible swaps with
other elements. This leads to more operations.</li>
<li>As a result, the total complexity can grow to (O(n^2 k)) based on
how we check the swaps.</li>
</ul></li>
</ol>
<h4 id="space-complexity">Space Complexity</h4>
<ol type="1">
<li><strong>DP Table Space</strong>:
<ul>
<li>The space for the DP table is (O(n k)) because we need to keep the
results for each mix of the elements we consider and the number of
swaps.</li>
</ul></li>
<li><strong>Extra Space</strong>:
<ul>
<li>We might need some extra space for temporary variables, but this is
usually (O(1)) if we do not use more data structures.</li>
</ul></li>
</ol>
<p>In short, the total complexity for the Dynamic Programming method to
solve the “Maximum Sum of Subarray with k Swaps” is:</p>
<ul>
<li><strong>Time Complexity</strong>: (O(n k)) or maybe (O(n^2 k)) based
on how we do it.</li>
<li><strong>Space Complexity</strong>: (O(n k)).</li>
</ul>
<p>This breakdown shows how efficient and practical this method is,
especially for moderate values of <code>n</code> and <code>k</code>. If
we want to read more about related dynamic programming problems, we can
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming: Maximum Subarray using Kadane’s Algorithm</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-maximum-sum-of-subarray-with-k-swaps-problem">1.
What is the Maximum Sum of Subarray with k Swaps problem?</h3>
<p>The Maximum Sum of Subarray with k Swaps problem is about finding the
biggest sum of a subarray with a fixed length. We can do this while
making up to k swaps between elements in the subarray and those outside
it. We can use dynamic programming to find the best swaps.</p>
<h3 id="how-can-dynamic-programming-be-applied-to-solve-this-problem">2.
How can Dynamic Programming be applied to solve this problem?</h3>
<p>Dynamic Programming (DP) helps us create a table. This table shows
the maximum sum we can get at each point, taking into account the number
of swaps we made. We look through the array and check possible swaps.
The algorithm then calculates the maximum sum of the subarray while
following the swap rules.</p>
<h3
id="what-are-the-differences-between-the-greedy-approach-and-dynamic-programming-for-this-problem">3.
What are the differences between the Greedy Approach and Dynamic
Programming for this problem?</h3>
<p>The Greedy approach tries to get quick local gains by swapping. But
it might miss better global solutions. On the other hand, Dynamic
Programming looks at all possible swaps. This way, we can be sure that
we find the maximum sum of the subarray with k swaps.</p>
<h3
id="can-you-provide-implementations-for-maximum-sum-of-subarray-with-k-swaps-in-different-programming-languages">4.
Can you provide implementations for Maximum Sum of Subarray with k Swaps
in different programming languages?</h3>
<p>Yes! We can implement the Maximum Sum of Subarray with k Swaps
problem in many programming languages like Java, Python, and C++. Each
version uses dynamic programming to find the maximum sum. For example,
check the <a
href="https://bestonlinetutorial.com/dynamic_programming/maximum-sum-of-subarray-with-one-swap-medium.html">Java
Implementation</a> for how to do it.</p>
<h3
id="what-are-the-time-and-space-complexities-associated-with-this-problem">5.
What are the time and space complexities associated with this
problem?</h3>
<p>The time complexity for the Maximum Sum of Subarray with k Swaps
problem is usually O(n^2 * k). This is because we have to loop through
for swaps, which can take a lot of time for big inputs. The space
complexity is O(n) because we store some results in the DP table. We can
improve this based on the way we solve it.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            