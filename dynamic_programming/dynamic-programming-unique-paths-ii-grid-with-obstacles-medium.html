
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Unique Paths II (Grid with Obstacles) - Medium</title>
            <meta name="description" content="Explore Dynamic Programming with Unique Paths II. Learn to navigate grids with obstacles efficiently. Tips and solutions inside!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Unique Paths II (Grid with Obstacles) - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>In dynamic programming, we have a problem called Unique Paths II.
This problem is about finding how many unique paths we can take from the
top-left to the bottom-right corner of a grid. The grid may have
obstacles in some cells. Each cell can be empty, marked as (0), or it
can have an obstacle, marked as (1). Our goal is to find a way to go
around the obstacles to reach the end. We need to think carefully about
the possible moves and use dynamic programming to find the number of
paths quickly.</p>
<p>In this article, we will look at different ways to solve the Unique
Paths II problem. First, we will understand the problem itself. Then, we
will explore dynamic programming and recursive approaches with
memoization. We will also show you how to use iterative dynamic
programming in Java, Python, and C++. We will discuss how to make space
use better and compare different methods. Lastly, we will answer some
common questions about Unique Paths II.</p>
<ul>
<li>[Dynamic Programming] Unique Paths II (Grid with Obstacles) - Medium
Solution Strategies</li>
<li>Understanding the Problem Statement of Unique Paths II</li>
<li>Dynamic Programming Approach for Unique Paths II</li>
<li>Recursive Approach with Memoization for Unique Paths II</li>
<li>Iterative Dynamic Programming Solution in Java for Unique Paths
II</li>
<li>Iterative Dynamic Programming Solution in Python for Unique Paths
II</li>
<li>Iterative Dynamic Programming Solution in C++ for Unique Paths
II</li>
<li>Optimizing Space Complexity for Unique Paths II</li>
<li>Comparative Analysis of Different Approaches for Unique Paths
II</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-of-unique-paths-ii">Understanding
the Problem Statement of Unique Paths II</h2>
<p>The “Unique Paths II” problem is about finding how many unique paths
we can take from the top-left corner to the bottom-right corner of a
grid while avoiding obstacles. The grid is shown as a 2D array
where:</p>
<ul>
<li><code>0</code> means an empty cell</li>
<li><code>1</code> means an obstacle.</li>
</ul>
<p>Our goal is to count all paths from the start position
<code>(0, 0)</code> to the end position <code>(m-1, n-1)</code>. Here,
<code>m</code> is the number of rows and <code>n</code> is the number of
columns in the grid.</p>
<h3 id="key-points">Key Points:</h3>
<ul>
<li>We can only move down or right.</li>
<li>If the starting cell or the ending cell has an obstacle, then the
number of unique paths is <code>0</code>.</li>
<li>We must carefully handle obstacles so we can count paths
correctly.</li>
</ul>
<h3 id="example">Example:</h3>
<p>Let’s look at this grid:</p>
<pre><code>[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]</code></pre>
<p>The unique paths from <code>(0, 0)</code> to <code>(2, 2)</code>
are:</p>
<ul>
<li>Down → Down → Right → Right</li>
<li>Right → Down → Down → Right</li>
<li>Right → Right → Down → Down</li>
</ul>
<p>In this case, we have <strong>2 unique paths</strong> that avoid the
obstacle at <code>(1, 1)</code>.</p>
<p>To solve this problem well, we often use a dynamic programming
approach. We create a table to track how many ways we can reach each
cell in the grid while considering obstacles.</p>
<p>This problem is a type of the <strong>Unique Paths</strong> problem.
We can learn more about it in related articles on dynamic programming
like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid - Easy</a>.</p>
<h2 id="dynamic-programming-approach-for-unique-paths-ii">Dynamic
Programming Approach for Unique Paths II</h2>
<p>The Unique Paths II problem is about finding how many unique ways we
can go from the top-left corner to the bottom-right corner of a grid. We
need to avoid obstacles on the way. The grid is a 2D array. Here,
<code>1</code> means there is an obstacle and <code>0</code> means the
cell is free.</p>
<h3 id="dynamic-programming-table-initialization">Dynamic Programming
Table Initialization</h3>
<p>To solve this with dynamic programming, we make a 2D array called
<code>dp</code>. In this array, <code>dp[i][j]</code> shows how many
unique paths lead to the cell <code>(i, j)</code>. Here are the main
steps:</p>
<ol type="1">
<li>If the starting cell <code>dp[0][0]</code> has an obstacle, we
return <code>0</code>.</li>
<li>If it is free, we set <code>dp[0][0] = 1</code>.</li>
<li>For each cell in the grid, if it is not an obstacle, we find the
number of paths by adding the paths from the top and left cells.</li>
</ol>
<h3 id="dynamic-programming-transition-formula">Dynamic Programming
Transition Formula</h3>
<p>We can write the transition formula like this: - If
<code>grid[i][j]</code> is <code>0</code>, then:
<code>dp[i][j] = dp[i-1][j] + dp[i][j-1]</code> - If
<code>grid[i][j]</code> is <code>1</code>, then:
<code>dp[i][j] = 0</code></p>
<h3 id="java-implementation">Java Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePathsWithObstacles</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(grid):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> grid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> grid[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> grid[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j]</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> uniquePathsWithObstacles<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> grid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> grid<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> grid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> grid<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>grid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">-</span><span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m<span class="op">-</span><span class="dv">1</span><span class="op">][</span>n<span class="op">-</span><span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This dynamic programming way helps us find the number of unique paths
around obstacles in the grid. We use results we found before to build
the solution step by step. For more reading on similar problems, check
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2
id="recursive-approach-with-memoization-for-unique-paths-ii">Recursive
Approach with Memoization for Unique Paths II</h2>
<p>We can use a recursive method with memoization to solve the Unique
Paths II problem. This method helps us break the problem into smaller
parts. We save the results to avoid doing the same work again. This is
really helpful when we have to move through a grid with obstacles.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have a 2D grid. Each cell can be 0 or 1. A cell with 0 is empty
and a cell with 1 is an obstacle. Our job is to find how many unique
paths there are from the top-left corner to the bottom-right corner. We
can only move down or to the right.</p>
<h3 id="recursive-function">Recursive Function</h3>
<p>The recursive function checks all possible paths from the current
cell to the destination. It also looks for obstacles. If a cell is out
of bounds or has an obstacle, it gives back 0. If we reach the
destination, it gives back 1.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(grid):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> grid <span class="kw">or</span> grid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> grid[<span class="op">-</span><span class="dv">1</span>][<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    rows, cols <span class="op">=</span> <span class="bu">len</span>(grid), <span class="bu">len</span>(grid[<span class="dv">0</span>])</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(x, y):</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="kw">in</span> memo:</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&gt;=</span> rows <span class="kw">or</span> y <span class="op">&gt;=</span> cols <span class="kw">or</span> grid[x][y] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">==</span> rows <span class="op">-</span> <span class="dv">1</span> <span class="kw">and</span> y <span class="op">==</span> cols <span class="op">-</span> <span class="dv">1</span>:</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        memo[(x, y)] <span class="op">=</span> dfs(x <span class="op">+</span> <span class="dv">1</span>, y) <span class="op">+</span> dfs(x, y <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(<span class="dv">0</span>, <span class="dv">0</span>)</span></code></pre></div>
<h3 id="function-explanation">Function Explanation</h3>
<ul>
<li><strong>Base Cases</strong>:
<ul>
<li>If the grid is empty or if the starting or ending cell has an
obstacle, we return 0.</li>
</ul></li>
<li><strong>Memoization</strong>:
<ul>
<li>We use a dictionary called <code>memo</code> to store results of the
smaller problems.</li>
</ul></li>
<li><strong>Recursive Calls</strong>:
<ul>
<li>The function calls itself for the cell below and the cell to the
right.</li>
</ul></li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). Here, m is the number of
rows, and n is the number of columns. This is because of
memoization.</li>
<li><strong>Space Complexity</strong>: O(m * n) for storing
memoization.</li>
</ul>
<p>This method makes the time needed much less compared to just using a
simple recursive approach. It avoids calculating the same paths again.
If you want to learn more about dynamic programming, you can check this
article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-with-memoization-easy.html">Dynamic
Programming - Fibonacci with Memoization</a>.</p>
<h2
id="iterative-dynamic-programming-solution-in-java-for-unique-paths-ii">Iterative
Dynamic Programming Solution in Java for Unique Paths II</h2>
<p>We will use an iterative dynamic programming method to solve the
Unique Paths II problem. This method needs a 2D array to keep track of
how many ways we can reach each cell in the grid. The grid can have
obstacles, shown by <code>1</code>, and free cells, shown by
<code>0</code>. Our aim is to find unique paths from the top-left corner
to the bottom-right corner of the grid.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<p>Here is a simple Java code for the Unique Paths II problem using
iterative dynamic programming:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> UniquePathsII <span class="op">{</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePathsWithObstacles</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// If the starting cell or the ending cell is an obstacle</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> obstacleGrid<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Create a DP array</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[][]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>m<span class="op">][</span>n<span class="op">];</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Start point</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Fill the DP array</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>                <span class="co">// If the cell has an obstacle</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a>                    <span class="co">// Sum paths from the top and left cells</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>                        dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>                    <span class="op">}</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// Return the bottom-right cell value</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ol type="1">
<li><strong>Initialization</strong>: We check if the starting or ending
cell has an obstacle. If yes, we return <code>0</code>.</li>
<li><strong>DP Array Setup</strong>: We make a <code>dp</code> array.
Here, <code>dp[i][j]</code> shows the number of unique paths to the cell
<code>(i, j)</code>.</li>
<li><strong>Filling the DP Array</strong>:
<ul>
<li>We go through each cell in the grid.</li>
<li>If the cell is an obstacle, we set <code>dp[i][j]</code> to
<code>0</code>.</li>
<li>If it is a free cell, we add the number of paths from the cell above
and the cell to the left.</li>
</ul></li>
<li><strong>Return Result</strong>: The value in
<code>dp[m-1][n-1]</code> gives the total unique paths to the
bottom-right corner.</li>
</ol>
<p>This method is good because it solves the problem in O(m<em>n) time
and uses O(m</em>n) space. It works well for medium-sized grids. For
more methods about dynamic programming, we can look at articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-simple-grid-path-sum-easy.html">Dynamic
Programming: Simple Grid Path Sum</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Unique
Paths in a Grid</a>.</p>
<h2
id="iterative-dynamic-programming-solution-in-python-for-unique-paths-ii">Iterative
Dynamic Programming Solution in Python for Unique Paths II</h2>
<p>In the Unique Paths II problem, we need to find the number of unique
paths from the top-left corner to the bottom-right corner of a grid. We
have to go around obstacles. This solution uses a 2D list to keep track
of how many ways we can reach each cell.</p>
<h3 id="python-implementation-1">Python Implementation</h3>
<p>Here is the Python code for the iterative dynamic programming
solution for Unique Paths II:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obstacleGrid <span class="kw">or</span> obstacleGrid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Starting point</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the first column</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        dp[i][<span class="dv">0</span>] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][<span class="dv">0</span>] <span class="cf">if</span> obstacleGrid[i][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the first row</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        dp[<span class="dv">0</span>][j] <span class="op">=</span> dp[<span class="dv">0</span>][j<span class="op">-</span><span class="dv">1</span>] <span class="cf">if</span> obstacleGrid[<span class="dv">0</span>][j] <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the rest of the dp array</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, m):</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># If no obstacle</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> dp[i<span class="op">-</span><span class="dv">1</span>][j] <span class="op">+</span> dp[i][j<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># If obstacle</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m<span class="op">-</span><span class="dv">1</span>][n<span class="op">-</span><span class="dv">1</span>]</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We check if the grid is empty or if
the starting point is blocked (value <code>1</code>). If one of these is
true, we return <code>0</code>.</li>
<li><strong>DP Table Setup</strong>: We make a 2D list <code>dp</code>
to store the number of paths to each cell.</li>
<li><strong>First Row and Column</strong>: We fill the first row and
first column separately. They can only be reached from one side.</li>
<li><strong>Filling the DP Table</strong>: For each cell in the grid, if
there is no obstacle, the number of ways to reach it is the sum of the
ways to reach the cell above it and the cell to the left.</li>
<li><strong>Final Result</strong>: The value at
<code>dp[m-1][n-1]</code> tells us how many unique paths there are to
the bottom-right corner.</li>
</ul>
<p>This iterative dynamic programming method has a time complexity of
(O(m n)) and a space complexity of (O(m n)). Here, (m) and (n) are the
sizes of the grid.</p>
<p>For more reading on dynamic programming, we can check articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>
<h2
id="iterative-dynamic-programming-solution-in-c-for-unique-paths-ii">Iterative
Dynamic Programming Solution in C++ for Unique Paths II</h2>
<p>We can solve the Unique Paths II problem using an Iterative Dynamic
Programming method. This method builds a 2D table, which we call the dp
array. Each cell in this table shows the number of unique paths to that
cell from the starting point. We start by setting up the table based on
where the obstacles are. Then, we fill it up step by step using the
values we calculated before.</p>
<h3 id="implementation-steps">Implementation Steps:</h3>
<ol type="1">
<li><strong>Initialize the dp array</strong>: First, we create a 2D
vector <code>dp</code> that is the same size as the input grid. We set
all cells to 0 at first.</li>
<li><strong>Set the starting point</strong>: If the starting cell (0, 0)
is not an obstacle, we set <code>dp[0][0] = 1</code>.</li>
<li><strong>Iterate through the grid</strong>: Next, for each cell, we
update the dp table:
<ul>
<li>If the cell is an obstacle, we skip to the next cell.</li>
<li>For cells not in the first row or column, the number of paths to
that cell is the sum of paths from the cell above and the cell to the
left.</li>
<li>For cells in the first row or first column, we only add paths from
one direction due to the edges.</li>
</ul></li>
<li><strong>Result</strong>: The value in the bottom-right corner of the
dp array (<code>dp[m-1][n-1]</code>) will show the total number of
unique paths.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> uniquePathsWithObstacles<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;</span> dp<span class="op">(</span>m<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">));</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Start point</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill dp array</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Obstacle cell</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>j<span class="op">];</span> <span class="co">// From above</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> dp<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i<span class="op">][</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// From left</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>m <span class="op">-</span> <span class="dv">1</span><span class="op">][</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-points-1">Key Points:</h3>
<ul>
<li>Time Complexity: O(m * n), where m is the number of rows and n is
the number of columns.</li>
<li>Space Complexity: O(m * n) for the dp array. We can make this better
to O(n) if we only keep the current and the previous row.</li>
<li>We need to think about edge cases like an obstacle at the starting
point or the ending point.</li>
</ul>
<p>This method helps us find the number of unique paths in a grid with
obstacles using an iterative dynamic programming way in C++. If we want
to learn more about dynamic programming, we can check out topics like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming - Unique Paths in a Grid</a>.</p>
<h2 id="optimizing-space-complexity-for-unique-paths-ii">Optimizing
Space Complexity for Unique Paths II</h2>
<p>In the Unique Paths II problem, we deal with a 2D grid. Some cells
have obstacles. Our goal is to find how many unique paths go from the
top-left corner to the bottom-right corner while avoiding obstacles. A
simple dynamic programming method uses a 2D array to keep results for
each cell. This can create high space usage.</p>
<p>To improve space usage, we can use a 1D array instead of a 2D array.
The number of unique paths to any cell only depends on the current row
and the row before it. So, we can lower the space needed from O(m * n)
to O(n), where n stands for the number of columns.</p>
<h3 id="space-optimized-dynamic-programming-approach">Space Optimized
Dynamic Programming Approach</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: We create a 1D array
<code>dp</code> with size <code>n</code> and set all to 0. We set
<code>dp[0]</code> to 1. There is one way to reach the first
cell.</p></li>
<li><p><strong>Iterate through the grid</strong>:</p>
<ul>
<li>For each row, we check if the cell has an obstacle.</li>
<li>If it has, we set <code>dp[j]</code> to 0. If it does not, we update
<code>dp[j]</code> like this:
<ul>
<li><code>dp[j] += dp[j-1]</code> for cells that are not in the first
column.</li>
</ul></li>
</ul></li>
<li><p><strong>Result</strong>: The last element of <code>dp</code>
holds the number of unique paths to the bottom-right corner.</p></li>
</ol>
<h3 id="example-code-in-java">Example Code in Java</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePathsWithObstacles</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obstacleGrid <span class="op">==</span> <span class="kw">null</span> <span class="op">||</span> obstacleGrid<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span><span class="fu">length</span><span class="op">,</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// obstacle found</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// update the dp array</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// result is in the last cell</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="example-code-in-python">Example Code in Python</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obstacleGrid <span class="kw">or</span> <span class="kw">not</span> obstacleGrid[<span class="dv">0</span>]: <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span> <span class="cf">if</span> obstacleGrid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">0</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">=</span> <span class="dv">0</span>  <span class="co"># obstacle found</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">elif</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>                dp[j] <span class="op">+=</span> dp[j <span class="op">-</span> <span class="dv">1</span>]  <span class="co"># update the dp array</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[<span class="op">-</span><span class="dv">1</span>]  <span class="co"># result is in the last cell</span></span></code></pre></div>
<h3 id="example-code-in-c">Example Code in C++</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> uniquePathsWithObstacles<span class="op">(</span>vector<span class="op">&lt;</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&gt;&amp;</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">.</span>empty<span class="op">()</span> <span class="op">||</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span>size<span class="op">(),</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span>size<span class="op">();</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">?</span> <span class="dv">1</span> <span class="op">:</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// obstacle found</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// update the dp array</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span> <span class="co">// result is in the last cell</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>By using a 1D array, we reduce space use while keeping our solution
fast. We can use this method for other dynamic programming problems too.
It helps save space without losing performance. For more reading on
dynamic programming, you can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming Unique Paths in a Grid</a>.</p>
<h2
id="comparative-analysis-of-different-approaches-for-unique-paths-ii">Comparative
Analysis of Different Approaches for Unique Paths II</h2>
<p>When we solve the Unique Paths II problem, which involves a grid with
obstacles, we can use different methods. Each method has its good and
bad points. We will look at three main methods: Dynamic Programming,
Recursive with Memoization, and Iterative Dynamic Programming.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n). Here, m is the number of
rows and n is the number of columns.</li>
<li><strong>Space Complexity</strong>: O(m * n) for the DP table.</li>
</ul>
<p>We use a 2D DP table to slowly build the number of unique paths to
each cell while considering obstacles.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> obstacleGrid <span class="kw">or</span> obstacleGrid[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">==</span> <span class="dv">1</span>: </span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [[<span class="dv">0</span>] <span class="op">*</span> n <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(m)]</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>][<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(m):</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> obstacleGrid[i][j] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>                dp[i][j] <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> i <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i <span class="op">-</span> <span class="dv">1</span>][j]</span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> j <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>                    dp[i][j] <span class="op">+=</span> dp[i][j <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[m <span class="op">-</span> <span class="dv">1</span>][n <span class="op">-</span> <span class="dv">1</span>]</span></code></pre></div>
<h3 id="recursive-approach-with-memoization">2. Recursive Approach with
Memoization</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n) because of
memoization.</li>
<li><strong>Space Complexity</strong>: O(m * n) for the recursion stack
and memoization table.</li>
</ul>
<p>This method uses recursion to check all paths. We save previous
results to avoid doing the same work again.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> uniquePathsWithObstacles(obstacleGrid):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    m, n <span class="op">=</span> <span class="bu">len</span>(obstacleGrid), <span class="bu">len</span>(obstacleGrid[<span class="dv">0</span>])</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    memo <span class="op">=</span> {}</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(x, y):</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> y <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> obstacleGrid[x][y] <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="op">==</span> (<span class="dv">0</span>, <span class="dv">0</span>):</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (x, y) <span class="kw">in</span> memo:</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>        memo[(x, y)] <span class="op">=</span> dfs(x <span class="op">-</span> <span class="dv">1</span>, y) <span class="op">+</span> dfs(x, y <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> memo[(x, y)]</span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dfs(m <span class="op">-</span> <span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span>)</span></code></pre></div>
<h3 id="iterative-dynamic-programming-solution">3. Iterative Dynamic
Programming Solution</h3>
<ul>
<li><strong>Time Complexity</strong>: O(m * n).</li>
<li><strong>Space Complexity</strong>: O(n) if we use only one row.</li>
</ul>
<p>This method fills a single array to show the current state of paths.
It saves space by using the same array again.</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">uniquePathsWithObstacles</span><span class="op">(</span><span class="dt">int</span><span class="op">[][]</span> obstacleGrid<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">][</span><span class="dv">0</span><span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> m <span class="op">=</span> obstacleGrid<span class="op">.</span><span class="fu">length</span><span class="op">,</span> n <span class="op">=</span> obstacleGrid<span class="op">[</span><span class="dv">0</span><span class="op">].</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> m<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>obstacleGrid<span class="op">[</span>i<span class="op">][</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>j <span class="op">&gt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>j<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>j <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="summary-of-approaches">Summary of Approaches</h3>
<ul>
<li><strong>Dynamic Programming</strong>: Good for clear understanding
but needs O(m * n) space.</li>
<li><strong>Recursive with Memoization</strong>: It is easy to
understand but may cause stack overflow for big grids.</li>
<li><strong>Iterative Solution</strong>: It uses less space, good for
big grids, and keeps O(m * n) time complexity.</li>
</ul>
<p>Each method fits different situations based on the problem’s needs.
For more knowledge about dynamic programming, we can check articles like
<a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and more topics related.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-unique-paths-ii-problem-in-dynamic-programming">1.
What is the Unique Paths II problem in dynamic programming?</h3>
<p>The Unique Paths II problem is about finding how many unique paths
are in a grid that can have obstacles. Each cell in the grid can be
empty or have an obstacle. We use 0 for empty cells and 1 for obstacles.
The goal is to find how many ways we can go from the top-left corner to
the bottom-right corner while avoiding the obstacles. We can solve this
problem well with dynamic programming.</p>
<h3
id="how-does-the-dynamic-programming-approach-work-for-unique-paths-ii">2.
How does the dynamic programming approach work for Unique Paths II?</h3>
<p>In the dynamic programming approach for Unique Paths II, we make a 2D
array. This array keeps track of the number of unique paths to each cell
in the grid. We calculate the value of each cell by looking at the paths
from the cell above it and the cell to its left. We also remember to
check for obstacles. This method helps us find the paths quickly and
does not make us calculate the same paths again. The time complexity is
O(m*n), where m and n are the grid dimensions.</p>
<h3 id="can-i-use-recursive-memoization-for-solving-unique-paths-ii">3.
Can I use recursive memoization for solving Unique Paths II?</h3>
<p>Yes, we can use a recursive method with memoization for Unique Paths
II. In this way, a recursive function finds the number of unique paths
from the current cell to the destination cell. We store results of paths
we already calculated in a cache. This helps us avoid calculating the
same paths again. So, we reduce the time complexity while we keep
recursion easy.</p>
<h3 id="how-can-i-optimize-space-complexity-in-unique-paths-ii">4. How
can I optimize space complexity in Unique Paths II?</h3>
<p>To make space complexity better in Unique Paths II, we can use a
one-dimensional array instead of a two-dimensional grid. We go through
the grid and update the values in the array based on the paths from the
previous row. This reduces the space needed from O(m*n) to O(n), where n
is the number of columns. This trick is helpful for large grids.</p>
<h3
id="what-are-the-common-mistakes-to-avoid-when-implementing-unique-paths-ii">5.
What are the common mistakes to avoid when implementing Unique Paths
II?</h3>
<p>When we implement the Unique Paths II solution, we should avoid some
common mistakes. One mistake is not handling edge cases like grids that
start or end with obstacles. Another mistake is not setting up the
dynamic programming array correctly. We must also check if the current
cell is an obstacle. It is important to check the grid’s size and where
the obstacles are before we run our algorithm. This way, we can avoid
errors while the program runs. For more related dynamic programming
tips, check our article on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-unique-paths-in-a-grid-easy.html">Dynamic
Programming: Unique Paths in a Grid</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            