
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Wiggle Subsequence - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content=""Explore the wiggle subsequence problem in dynamic programming! Learn strategies and solutions to optimize your coding skills."">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Wiggle Subsequence - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>A wiggle subsequence is a sequence of numbers. In this sequence, the
differences between the numbers change signs. Our goal with the Wiggle
Subsequence problem is to find the longest wiggle subsequence in a list
of integers. We can solve this problem well using dynamic programming.
This method helps us break the problem into smaller parts. Then, we
store the results so we can use them again.</p>
<p>In this article, we will look at how to use dynamic programming to
solve the Wiggle Subsequence problem. We will explain the problem
clearly. We will also talk about what wiggle subsequences are. We will
show code examples in Java, Python, and C++. We will also discuss how to
save space while solving this problem. We will compare different
methods. We will point out common mistakes. And we will share best
practices for writing solutions. Here are the topics we will cover:</p>
<ul>
<li>Explanation of Dynamic Programming Wiggle Subsequence Problem</li>
<li>Understanding Wiggle Subsequence Concept</li>
<li>Dynamic Programming Approach in Java for Wiggle Subsequence</li>
<li>Dynamic Programming Approach in Python for Wiggle Subsequence</li>
<li>Dynamic Programming Approach in C++ for Wiggle Subsequence</li>
<li>Optimizing Space Complexity for Wiggle Subsequence</li>
<li>Comparing Different Approaches for Wiggle Subsequence</li>
<li>Common Mistakes in Solving Wiggle Subsequence Problem</li>
<li>Best Practices for Implementing Wiggle Subsequence Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="understanding-the-concept-of-wiggle-subsequence">Understanding
the Concept of Wiggle Subsequence</h2>
<p>A Wiggle Subsequence is a list of numbers. In this list, the
differences between the numbers go up and down. For example, if we have
a list ( a_1, a_2, a_3, , a_n ), it is a wiggle sequence if:</p>
<ul>
<li>( (a_2 - a_1) (a_3 - a_2) &lt; 0 )</li>
<li>( (a_3 - a_2) (a_4 - a_3) &lt; 0 )</li>
<li>And this goes on…</li>
</ul>
<p>Our goal is to find the longest wiggle subsequence from a given
list.</p>
<h3 id="properties">Properties</h3>
<ul>
<li>A wiggle sequence has at least one number if the input list is not
empty.</li>
<li>We can find the longest wiggle subsequence using dynamic
programming. This means we will keep track of the peaks and valleys in
the list.</li>
</ul>
<h3 id="example">Example</h3>
<p>Let’s look at the list: [1, 7, 4, 9, 2, 5].</p>
<ul>
<li>The differences are: [6, -3, 5, -7, 3]</li>
<li>The longest wiggle subsequence in this case is [1, 7, 4, 9] and its
length is 4.</li>
</ul>
<h3 id="approach">Approach</h3>
<ol type="1">
<li><strong>Start</strong>: First, check if the list has at least two
numbers.</li>
<li><strong>Track Differences</strong>: We will keep counters for the
current length of the wiggle sequence and the previous difference.</li>
<li><strong>Loop</strong>: Go through the list and update the counters
based on the difference between the numbers.</li>
<li><strong>Update Length</strong>: If we find a valid wiggle (a
positive or negative difference), we increase the length counter.</li>
</ol>
<p>This way helps us find the longest wiggle subsequence in a good time,
about ( O(n) ).</p>
<h3 id="code-example-python">Code Example (Python)</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wiggleMaxLength(nums):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(nums)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    prev_diff <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        diff <span class="op">=</span> nums[i] <span class="op">-</span> nums[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (diff <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> prev_diff <span class="op">&lt;=</span> <span class="dv">0</span>) <span class="kw">or</span> (diff <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">and</span> prev_diff <span class="op">&gt;=</span> <span class="dv">0</span>):</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            prev_diff <span class="op">=</span> diff</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(wiggleMaxLength(nums))  <span class="co"># Output: 4</span></span></code></pre></div>
<p>This code shows how to find the wiggle subsequence. It is a simple
way to understand this concept.</p>
<h2
id="dynamic-programming-approach-in-java-for-wiggle-subsequence">Dynamic
Programming Approach in Java for Wiggle Subsequence</h2>
<p>We can solve the Wiggle Subsequence problem with dynamic programming
in Java. Our goal is to find the longest subsequence where the
differences between each element go up and down. Here are the steps to
follow:</p>
<ol type="1">
<li><p><strong>Define the State</strong>: We will use two arrays called
<code>up</code> and <code>down</code>.</p>
<ul>
<li><code>up[i]</code> shows the length of the longest wiggle
subsequence ending at index <code>i</code> where the difference is
positive.</li>
<li><code>down[i]</code> shows the length of the longest wiggle
subsequence ending at index <code>i</code> where the difference is
negative.</li>
</ul></li>
<li><p><strong>Initialization</strong>: We set both <code>up[0]</code>
and <code>down[0]</code> to 1. This is because the shortest wiggle
subsequence that includes the first element has a length of 1.</p></li>
<li><p><strong>Recurrence Relation</strong>:</p>
<ul>
<li>For each element from the second to the last, we compare it with the
previous element:
<ul>
<li>If <code>nums[i] &gt; nums[i-1]</code>, then:
<ul>
<li><code>up[i] = down[i-1] + 1</code></li>
<li><code>down[i] = down[i-1]</code> (it does not change)</li>
</ul></li>
<li>If <code>nums[i] &lt; nums[i-1]</code>, then:
<ul>
<li><code>down[i] = up[i-1] + 1</code></li>
<li><code>up[i] = up[i-1]</code> (it does not change)</li>
</ul></li>
<li>If they are the same, both <code>up[i]</code> and
<code>down[i]</code> stay the same.</li>
</ul></li>
</ul></li>
<li><p><strong>Final Result</strong>: The final answer is the bigger
value between the last elements of <code>up</code> and
<code>down</code>.</p></li>
</ol>
<p>Here is the Java code for this approach:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> WiggleSubsequence <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">wiggleMaxLength</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> up <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> down <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        up<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        down<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>                up<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> down<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>                down<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> down<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>                down<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> up<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>                up<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> up<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>                up<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> up<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>                down<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> down<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>up<span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">],</span> down<span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">]);</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>        WiggleSubsequence ws <span class="op">=</span> <span class="kw">new</span> <span class="fu">WiggleSubsequence</span><span class="op">();</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Length of Longest Wiggle Subsequence: &quot;</span> <span class="op">+</span> ws<span class="op">.</span><span class="fu">wiggleMaxLength</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This code creates a class <code>WiggleSubsequence</code>. It has a
method called <code>wiggleMaxLength</code> that uses the dynamic
programming approach to find the length of the longest wiggle
subsequence. The <code>main</code> method shows how to use this method
with an example array.</p>
<p>Using this dynamic programming method, we can find the solution in
O(n) time and O(n) space. We can also make it better to O(1) space by
only keeping track of the last lengths instead of using the full
arrays.</p>
<h2
id="dynamic-programming-approach-in-python-for-wiggle-subsequence">Dynamic
Programming Approach in Python for Wiggle Subsequence</h2>
<p>We will solve the Wiggle Subsequence problem with dynamic programming
in Python. We need to track two states. These states are the length of
the longest wiggle subsequence that ends with an upward wiggle and a
downward wiggle.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an integer array. Our goal is to find the length of the
longest subsequence that goes up and down.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><p><strong>Initialization</strong>: We create two arrays called
<code>up</code> and <code>down</code>. They are the same length as the
input array. Here:</p>
<ul>
<li><code>up[i]</code> shows the length of the longest wiggle
subsequence ending at index <code>i</code> with an upward wiggle.</li>
<li><code>down[i]</code> shows the length of the longest wiggle
subsequence ending at index <code>i</code> with a downward wiggle.</li>
</ul>
<p>At start, we set both <code>up[0]</code> and <code>down[0]</code> to
1 because a single element is a wiggle subsequence of length 1.</p></li>
<li><p><strong>State Transition</strong>:</p>
<ul>
<li>For each index from 1 to n-1, we compare the current element with
the previous one:
<ul>
<li>If <code>nums[i]</code> is greater than <code>nums[i-1]</code>:
<ul>
<li>We update <code>up[i]</code> to be <code>down[i-1] + 1</code></li>
<li>We keep <code>down[i]</code> the same as <code>down[i-1]</code></li>
</ul></li>
<li>If <code>nums[i]</code> is less than <code>nums[i-1]</code>:
<ul>
<li>We update <code>down[i]</code> to be <code>up[i-1] + 1</code></li>
<li>We keep <code>up[i]</code> the same as <code>up[i-1]</code></li>
</ul></li>
<li>If they are equal, both <code>up[i]</code> and <code>down[i]</code>
stay the same as before.</li>
</ul></li>
</ul></li>
<li><p><strong>Result</strong>: We get the result by finding the maximum
value between the last elements of <code>up</code> and
<code>down</code>.</p></li>
</ol>
<h3 id="python-code">Python Code</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wiggleMaxLength(nums):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> n</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    up <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    down <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n):</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            up[i] <span class="op">=</span> down[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>            down[i] <span class="op">=</span> down[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nums[i] <span class="op">&lt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            down[i] <span class="op">=</span> up[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            up[i] <span class="op">=</span> up[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>            up[i] <span class="op">=</span> up[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>            down[i] <span class="op">=</span> down[i <span class="op">-</span> <span class="dv">1</span>]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(up[<span class="op">-</span><span class="dv">1</span>], down[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(wiggleMaxLength(nums))  <span class="co"># Output: 6</span></span></code></pre></div>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n). Here n is the length of the
input array.</li>
<li><strong>Space Complexity</strong>: O(n) because of the
<code>up</code> and <code>down</code> arrays. We can make this O(1) by
using two variables to track the lengths instead of arrays.</li>
</ul>
<p>This way we compute the longest wiggle subsequence with dynamic
programming in Python. For more reading on similar dynamic programming
problems, look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a>.</p>
<h2
id="dynamic-programming-approach-in-c-for-wiggle-subsequence">Dynamic
Programming Approach in C++ for Wiggle Subsequence</h2>
<p>To solve the Wiggle Subsequence problem using Dynamic Programming in
C++, we need to keep track of two states. One state is for the length of
the longest wiggle subsequence ending with an upward movement. The other
state is for a downward movement. We will go through the array and
update these states based on the relationship between the numbers next
to each other.</p>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> wiggleMaxLength<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> up <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> down <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Start counts for ups and downs</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Update up count</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Update down count</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">(</span>up<span class="op">,</span> down<span class="op">);</span> <span class="co">// Return the biggest wiggle length</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">7</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">9</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Length of longest wiggle subsequence: &quot;</span> <span class="op">&lt;&lt;</span> wiggleMaxLength<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The function <code>wiggleMaxLength</code> takes a vector of integers
as input.</li>
<li>It starts two variables, <code>up</code> and <code>down</code>, to
keep track of the lengths of the longest wiggle subsequence. One is for
the upward and other is for downward movement.</li>
<li>The loop goes through the <code>nums</code> array starting from the
second element. It checks if the current number is bigger or smaller
than the previous one. Then it updates <code>up</code> or
<code>down</code>.</li>
<li>Finally, we return the maximum of <code>up</code> and
<code>down</code>. This tells us the length of the longest wiggle
subsequence.</li>
</ul>
<h3 id="complexity-analysis-1">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n), where n is the size of the
input array.</li>
<li><strong>Space Complexity</strong>: O(1), because we use just a fixed
amount of space.</li>
</ul>
<p>This way helps us find the longest wiggle subsequence in an efficient
way. For more reading on similar dynamic programming problems, we can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming - Longest Increasing Subsequence</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-subarray-kadanes-algorithm-easy.html">Dynamic
Programming - Maximum Subarray</a>.</p>
<h2 id="optimizing-space-complexity-for-wiggle-subsequence">Optimizing
Space Complexity for Wiggle Subsequence</h2>
<p>We can make the space needed for the Wiggle Subsequence problem
smaller. Instead of using O(n) space, we can change it to O(1). We do
this by keeping only the important variables that track the lengths of
the wiggle subsequence. We do not need a full dynamic programming array.
We just track the lengths of the last two wiggle subsequences while we
go through the array.</p>
<h3 id="code-example">Code Example</h3>
<p>Here is a space-saving way to do this in Java, Python, and C++.</p>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> WiggleSubsequence <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">wiggleMaxLength</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> up <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> down <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>                up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>                down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>up<span class="op">,</span> down<span class="op">);</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wiggleMaxLength(nums):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(nums)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    up, down <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nums[i] <span class="op">&lt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(up, down)</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> wiggleMaxLength<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> up <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> down <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>                up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>                down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>up<span class="op">,</span> down<span class="op">);</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Variables Used</strong>:
<ul>
<li><code>up</code>: This keeps the length of the longest wiggle
subsequence that ends with a “up” move.</li>
<li><code>down</code>: This keeps the length of the longest wiggle
subsequence that ends with a “down” move.</li>
</ul></li>
<li><strong>Time Complexity</strong>: O(n), where n is the size of the
input array.</li>
<li><strong>Space Complexity</strong>: O(1), because we use only a
constant amount of space.</li>
</ul>
<p>By using this better way, we lower the space needed a lot. We keep
the time efficiency the same. This makes our method good for bigger
input sizes.</p>
<h2 id="comparing-different-approaches-for-wiggle-subsequence">Comparing
Different Approaches for Wiggle Subsequence</h2>
<p>When we look at the Wiggle Subsequence problem, we can use different
methods. Each one has its own pros and cons. The main methods we can
think of are Dynamic Programming, Greedy, and a simple brute-force
method. Here is a comparison of these methods based on how complex they
are, how fast they work, and how easy they are to use.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n) where n is the length of the
input array.</li>
<li><strong>Space Complexity</strong>: O(n) but can be improved to
O(1).</li>
<li><strong>Description</strong>: This method builds a DP table. It
tracks the longest wiggle subsequence for each index. We keep two
states. One for when the last wiggle goes up. The other for when it goes
down.</li>
</ul>
<p><strong>Java Implementation</strong>:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">wiggleMaxLength</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> up <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> down <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>            up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>up<span class="op">,</span> down<span class="op">);</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="greedy-approach">2. Greedy Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n).</li>
<li><strong>Space Complexity</strong>: O(1).</li>
<li><strong>Description</strong>: This method goes through the array and
counts wiggles. It compares each pair of neighboring elements. We
increase the count when we see a wiggle, which means a change in
direction.</li>
</ul>
<p><strong>Python Implementation</strong>:</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wiggleMaxLength(nums):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(nums)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (nums[i] <span class="op">&gt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> (i <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> nums[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&lt;=</span> nums[i <span class="op">-</span> <span class="dv">2</span>])) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>           (nums[i] <span class="op">&lt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> (i <span class="op">==</span> <span class="dv">1</span> <span class="kw">or</span> nums[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&gt;=</span> nums[i <span class="op">-</span> <span class="dv">2</span>])):</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h3 id="brute-force-approach">3. Brute-Force Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(2^n) - exponential.</li>
<li><strong>Space Complexity</strong>: O(n).</li>
<li><strong>Description</strong>: This method makes all possible
subsequences. It checks each one to see if it is a wiggle. This method
is usually not useful for bigger inputs because it is slow.</li>
</ul>
<p><strong>C++ Implementation</strong>:</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> wiggleMaxLength<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">&lt;</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&lt;=</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">]))</span> <span class="op">||</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>i <span class="op">==</span> <span class="dv">1</span> <span class="op">||</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&gt;=</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">2</span><span class="op">])))</span> <span class="op">{</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="conclusion-of-approaches">Conclusion of Approaches</h3>
<ul>
<li>The <strong>Dynamic Programming</strong> method is good but takes
more space.</li>
<li>The <strong>Greedy</strong> method is fast and uses less space, but
we need to be careful with edge cases.</li>
<li>The <strong>Brute-Force</strong> method is not a good choice for
real use because it is too slow.</li>
</ul>
<p>Choosing the right method depends on what we need for the problem.
For most cases, we prefer the Greedy or Dynamic Programming methods
because they are more efficient.</p>
<h2 id="common-mistakes-in-solving-wiggle-subsequence-problem">Common
Mistakes in Solving Wiggle Subsequence Problem</h2>
<p>When we solve the Wiggle Subsequence problem with dynamic
programming, we can make some common mistakes. Knowing these mistakes
can help us to create a better solution.</p>
<ol type="1">
<li><strong>Incorrect Understanding of Wiggle Sequence</strong>:
<ul>
<li>One mistake is not understanding what a “wiggle” is. It should
switch between increasing and decreasing. We need to spot these changes
when we go through the sequence.</li>
</ul></li>
<li><strong>Mismanaging State Variables</strong>:
<ul>
<li>Some of us might not manage the state variables well. These
variables track the number of wiggles. We should keep separate counts
for wiggles that end with an upward or downward change.</li>
</ul></li>
<li><strong>Ignoring Edge Cases</strong>:
<ul>
<li>We should not forget edge cases like sequences that are 0 or 1 in
length. If we do, we can get wrong answers. We need to handle these
cases clearly by returning 0 or 1.</li>
</ul></li>
<li><strong>Improper Initialization</strong>:
<ul>
<li>It is very important to initialize dynamic programming arrays
correctly. We must set the first element based on whether it is part of
a wiggle sequence.</li>
</ul></li>
<li><strong>Inefficient Space Complexity</strong>:
<ul>
<li>Some solutions may use too much memory. It is better to use a
constant space solution when we can, using simple variables instead of
big arrays.</li>
</ul></li>
<li><strong>Looping Over Unnecessary Elements</strong>:
<ul>
<li>We should not check all pairs of elements. We need to look for
transitions directly. This will make our time complexity much
better.</li>
</ul></li>
<li><strong>Failure to Update States Properly</strong>:
<ul>
<li>We must update our states correctly after checking each transition.
If we do not, we can get the wrong count of the wiggle subsequence.</li>
</ul></li>
<li><strong>Not Considering Non-Adjacent Elements</strong>:
<ul>
<li>The wiggle subsequence can skip some elements. We must make sure our
logic allows for non-adjacent elements to cause a wiggle.</li>
</ul></li>
<li><strong>Overcomplicating the Logic</strong>:
<ul>
<li>Some solutions get too complicated with too many condition checks.
We should aim for a simple approach that meets the problem needs.</li>
</ul></li>
<li><strong>Neglecting to Optimize the Final Count</strong>:<br />
</li>
</ol>
<ul>
<li>After we process the array, we need to return the maximum count of
the wiggle subsequence. This is usually found in the last element of our
state variable.</li>
</ul>
<p>By paying attention to these common mistakes, we can create a
stronger and more efficient solution for the Wiggle Subsequence problem
with dynamic programming. For more reading on dynamic programming
techniques, we can look at related articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2
id="best-practices-for-implementing-wiggle-subsequence-solutions">Best
Practices for Implementing Wiggle Subsequence Solutions</h2>
<p>When we implement solutions for the Wiggle Subsequence problem using
dynamic programming, we need to follow some best practices. This helps
us make our code efficient, clear, and easy to maintain.</p>
<ol type="1">
<li><p><strong>Understand the Problem Statement</strong>: We must have a
clear idea of what a wiggle sequence is. A wiggle sequence is where the
differences between consecutive numbers switch between positive and
negative.</p></li>
<li><p><strong>Optimal Substructure</strong>: We can build the solution
from the solutions of smaller parts. For the Wiggle Subsequence, we
track two things:</p>
<ul>
<li><code>up[i]</code>: the length of the longest wiggle subsequence
ending at index <code>i</code> with a positive difference.</li>
<li><code>down[i]</code>: the length of the longest wiggle subsequence
ending at index <code>i</code> with a negative difference.</li>
</ul></li>
<li><p><strong>Iterative Approach</strong>: We should use an iterative
way instead of a recursive one. This helps us avoid problems like stack
overflow and makes our code faster. It also keeps our data flow
clear.</p></li>
<li><p><strong>Space Optimization</strong>: Instead of using arrays for
<code>up</code> and <code>down</code>, we can just use two variables.
This cuts down space usage from O(n) to O(1).</p></li>
<li><p><strong>Edge Cases</strong>: We need to think about edge cases
like:</p>
<ul>
<li>Arrays with less than two elements (no wiggle sequence is
possible).</li>
<li>Arrays where all elements are the same (the longest wiggle
subsequence is 1).</li>
</ul></li>
<li><p><strong>Code Readability</strong>: We should make sure our code
is easy to read. We can do this by adding comments and using clear
variable names. It is also good to keep formatting the same throughout
the code.</p></li>
</ol>
<h3 id="example-code-in-python">Example Code in Python</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wiggleMaxLength(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">len</span>(nums)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    up <span class="op">=</span> down <span class="op">=</span> <span class="dv">1</span>  <span class="co"># Start counters for up and down</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> nums[i] <span class="op">&gt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>            up <span class="op">=</span> down <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> nums[i] <span class="op">&lt;</span> nums[i <span class="op">-</span> <span class="dv">1</span>]:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            down <span class="op">=</span> up <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(up, down)</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">4</span>, <span class="dv">9</span>, <span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(wiggleMaxLength(nums))  <span class="co"># Output: 6</span></span></code></pre></div>
<ol start="7" type="1">
<li><p><strong>Testing</strong>: We should write good unit tests to
check many situations, including edge cases. This helps us make sure our
code works correctly.</p></li>
<li><p><strong>Performance Analysis</strong>: We need to check the time
and space usage of our solution. The best solution should run in O(n)
time and O(1) space. This makes it work well for big inputs.</p></li>
<li><p><strong>Documentation</strong>: We need to write documentation
for our code and give examples. This helps others understand what we did
quickly.</p></li>
</ol>
<p>By following these best practices, we can make a strong and efficient
solution for the Wiggle Subsequence problem. This way, our code will be
effective and easy to maintain. For more reading on dynamic programming
ideas, we can look at resources like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-a-wiggle-subsequence-in-dynamic-programming">What is a
wiggle subsequence in dynamic programming?</h3>
<p>A wiggle subsequence is a kind of sequence. In this sequence, the
differences between the numbers change direction. So, we can say it goes
up and down. For a sequence to be a wiggle subsequence, it needs to show
this up and down pattern. The dynamic programming method helps us find
the longest wiggle subsequence from a given list. It does this by
keeping track of increases and decreases.</p>
<h3
id="how-do-i-implement-a-dynamic-programming-solution-for-the-wiggle-subsequence-problem">How
do I implement a dynamic programming solution for the wiggle subsequence
problem?</h3>
<p>To make a dynamic programming solution for the wiggle subsequence
problem, we can use two variables. One variable will hold the longest
wiggle subsequence that ends with an upward movement. The other will
hold the one that ends with a downward movement. We will go through the
input array and update these values based on how the current number
relates to the previous one. This way, we can find the longest
subsequence in O(n) time.</p>
<h3
id="what-is-the-time-complexity-of-the-wiggle-subsequence-dynamic-programming-solution">What
is the time complexity of the wiggle subsequence dynamic programming
solution?</h3>
<p>The time complexity of the dynamic programming solution for the
wiggle subsequence problem is O(n). Here, n is the length of the input
array. We get this efficiency by making one pass through the array.
While we do this, we update the counts of the longest wiggle subsequence
based on the increases and decreases.</p>
<h3
id="how-can-i-optimize-space-complexity-for-the-wiggle-subsequence-solution">How
can I optimize space complexity for the wiggle subsequence
solution?</h3>
<p>To make the space complexity better in the wiggle subsequence
solution, we can use just two variables instead of using separate
arrays. By tracking the lengths of the longest wiggle subsequences that
end in up and down states, we can achieve a space complexity of O(1).
This is the best we can do for this problem.</p>
<h3
id="what-are-common-mistakes-when-solving-the-wiggle-subsequence-problem">What
are common mistakes when solving the wiggle subsequence problem?</h3>
<p>Some common mistakes when solving the wiggle subsequence problem are
misunderstanding what wiggle subsequences are, not managing the up and
down state changes well, and not considering special cases. For example,
we need to think about sequences with no elements or where all elements
are the same. It is very important to track the alternating pattern
correctly to avoid these mistakes.</p>
<p>For more reading about similar dynamic programming problems, you can
check out articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-longest-increasing-subsequence-medium.html">Dynamic
Programming: Longest Increasing Subsequence</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            