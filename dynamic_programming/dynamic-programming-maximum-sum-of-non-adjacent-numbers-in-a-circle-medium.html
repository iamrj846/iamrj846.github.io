
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Maximum Sum of Non-Adjacent Numbers in a Circle - Medium</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to solve the Maximum Sum of Non-Adjacent Numbers in a Circle problem using dynamic programming techniques.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Maximum Sum of Non-Adjacent Numbers in a Circle - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The problem of finding the biggest sum of non-adjacent numbers in a
circle is about getting the highest possible sum from a list of numbers.
We cannot pick two numbers that are next to each other. We usually solve
this using dynamic programming. This method helps us to break the
problem into smaller parts. But since we have a circle, we must pay
special attention to the first and last numbers in the list.</p>
<p>In this article, we will look at the best ways to find the biggest
sum of non-adjacent numbers in a circle. We will explain the problem in
detail, show a dynamic programming method, and give examples in Java,
Python, and C++. We will also compare different methods, try to make the
space we use smaller, and check different test cases and edge cases. At
the end, we will answer some common questions about this topic.</p>
<ul>
<li>[Dynamic Programming] Maximum Sum of Non-Adjacent Numbers in a
Circle - Optimal Solutions</li>
<li>Understanding the Problem Statement for Maximum Sum of Non-Adjacent
Numbers in a Circle</li>
<li>Dynamic Programming Approach for Maximum Sum of Non-Adjacent
Numbers</li>
<li>Java Implementation of Maximum Sum of Non-Adjacent Numbers in a
Circle</li>
<li>Python Code Example for Maximum Sum of Non-Adjacent Numbers</li>
<li>C++ Solution for Maximum Sum of Non-Adjacent Numbers in a
Circle</li>
<li>Comparative Analysis of Different Approaches for Maximum Sum of
Non-Adjacent Numbers</li>
<li>Optimizing Space Complexity in the Dynamic Programming Solution</li>
<li>Test Cases and Edge Cases for Maximum Sum of Non-Adjacent
Numbers</li>
<li>Frequently Asked Questions</li>
</ul>
<h2
id="understanding-the-problem-statement-for-maximum-sum-of-non-adjacent-numbers-in-a-circle">Understanding
the Problem Statement for Maximum Sum of Non-Adjacent Numbers in a
Circle</h2>
<p>The problem of finding the <strong>Maximum Sum of Non-Adjacent
Numbers in a Circle</strong> is like the classic “House Robber” problem.
The main difference is that the numbers are in a circle. This makes it
harder to decide which numbers we can pick without being next to each
other.</p>
<h3 id="problem-definition">Problem Definition</h3>
<p>We have an array of integers. These integers show amounts of money
and they are arranged in a circle. Our job is to find the maximum sum we
can get by picking numbers that are not next to each other. The main
rules are:</p>
<ul>
<li>We cannot take two adjacent numbers (houses).</li>
<li>The first and last numbers are next to each other because they are
in a circle.</li>
</ul>
<h3 id="input-and-output">Input and Output</h3>
<ul>
<li><strong>Input</strong>: An array <code>nums</code> of integers where
<code>1 &lt;= nums.length &lt;= 100</code>.</li>
<li><strong>Output</strong>: An integer that shows the maximum sum of
non-adjacent numbers.</li>
</ul>
<h3 id="example">Example</h3>
<p>For the input array <code>nums = [2, 3, 2]</code>: - The maximum sum
can be <code>3</code> (we do not pick the <code>2</code> next to it) or
<code>2</code> (not the first <code>2</code>). - The maximum sum here is
<code>3</code>.</p>
<p>For another input <code>nums = [1, 2, 3, 1]</code>: - We can pick
<code>1</code> and <code>3</code> to get a maximum sum of
<code>4</code>.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem well, we can use a dynamic programming method.
We will compute the maximum sums for two cases: 1. Exclude the first
element. 2. Exclude the last element.</p>
<p>This helps us look at all possible ways while following the rules
about adjacency.</p>
<h3 id="dynamic-programming-recurrence-relation">Dynamic Programming
Recurrence Relation</h3>
<p>Let <code>dp[i]</code> be the maximum sum we can get from the first
<code>i</code> elements. We can write the relation like this:</p>
<ul>
<li><code>dp[i] = max(dp[i-1], nums[i] + dp[i-2])</code></li>
</ul>
<p>In this, <code>dp[i-1]</code> means we do not take the current
element. While <code>nums[i] + dp[i-2]</code> means we take it, so we
skip the adjacent element.</p>
<h3 id="constraints-handling">Constraints Handling</h3>
<ul>
<li>If the input array has only one element, we return that
element.</li>
<li>If there are two elements, we return the bigger one.</li>
</ul>
<p>This way of working makes sure we cover all special cases while
finding the maximum sum in a circle.</p>
<h2
id="dynamic-programming-approach-for-maximum-sum-of-non-adjacent-numbers">Dynamic
Programming Approach for Maximum Sum of Non-Adjacent Numbers</h2>
<p>We will solve the problem of finding the maximum sum of non-adjacent
numbers in a circle. We use a dynamic programming approach. The circular
way the numbers are arranged makes adjacency tricky.</p>
<h3 id="problem-breakdown">Problem Breakdown</h3>
<ol type="1">
<li><p><strong>Linear vs Circular</strong>: First, we treat the circular
array as two separate linear problems. If we pick the first element, we
can’t take the last one. And if we take the last one, we can’t take the
first one.</p></li>
<li><p><strong>Dynamic Programming State</strong>: We define the state
<code>dp[i]</code> as the maximum sum from the first <code>i</code>
numbers. We need to ensure no two selected numbers are next to each
other.</p></li>
<li><p><strong>Transition Formula</strong>: We define the transition
like this:</p>
<ul>
<li><code>dp[i] = max(dp[i-1], dp[i-2] + nums[i])</code></li>
<li>This means for each number, we can either:
<ul>
<li>Skip it (take the maximum sum up to the previous number).</li>
<li>Include it (add it to the maximum sum two numbers before).</li>
</ul></li>
</ul></li>
<li><p><strong>Base Cases</strong>:</p>
<ul>
<li><code>dp[0] = nums[0]</code></li>
<li><code>dp[1] = max(nums[0], nums[1])</code></li>
</ul></li>
</ol>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li>We will implement the logic for the two cases:
<ul>
<li>Case 1: Exclude the last number.</li>
<li>Case 2: Exclude the first number.</li>
</ul></li>
<li>Then we compute the maximum of both cases to get the final
answer.</li>
</ol>
<h3 id="java-implementation">Java Implementation</h3>
<p>Here is how we can do this in Java:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNonAdjacent <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">robLinear</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">copyOfRange</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)),</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">robLinear</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">copyOfRange</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">)));</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">robLinear</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-code-example">Python Code Example</h3>
<p>Here is the same logic in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> rob(nums):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> rob_linear(nums):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        prev1, prev2 <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>            temp <span class="op">=</span> prev1</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> <span class="bu">max</span>(prev1, prev2 <span class="op">+</span> num)</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> temp</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(rob_linear(nums[:<span class="op">-</span><span class="dv">1</span>]), rob_linear(nums[<span class="dv">1</span>:]))</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>]</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(rob(nums))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="c-solution">C++ Solution</h3>
<p>Here is how we can do this in C++:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rob<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>robLinear<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)),</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>                   robLinear<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;(</span>nums<span class="op">.</span>begin<span class="op">()</span> <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> nums<span class="op">.</span>end<span class="op">())));</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> robLinear<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> max<span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> num<span class="op">);</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>These implementations help us find the maximum sum of non-adjacent
numbers in a circle using dynamic programming. It is clear and works
well. For more on dynamic programming, you can check articles on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming: Maximum Sum of Non-Adjacent Elements</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-house-robber-i-easy.html">Dynamic
Programming: House Robber Problem</a>.</p>
<h2
id="java-implementation-of-maximum-sum-of-non-adjacent-numbers-in-a-circle">Java
Implementation of Maximum Sum of Non-Adjacent Numbers in a Circle</h2>
<p>To solve the problem of finding the maximum sum of non-adjacent
numbers in a circle using Java, we can use dynamic programming. We need
to think about the circle by looking at two cases. One case is when we
do not take the first number. The other case is when we do not take the
last number.</p>
<p>Here is the Java code:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaximumSumNonAdjacentCircle <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSumNonAdjacent</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">maxSumLinear</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">copyOfRange</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">)),</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">maxSumLinear</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">copyOfRange</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">)));</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">maxSumLinear</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newExclude <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>            include <span class="op">=</span> exclude <span class="op">+</span> num<span class="op">;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>            exclude <span class="op">=</span> newExclude<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Maximum sum of non-adjacent numbers in a circle: &quot;</span> <span class="op">+</span> <span class="fu">maxSumNonAdjacent</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li><strong>maxSumNonAdjacent</strong>: This method splits the problem
into two smaller problems by ignoring either the first or the last
number.</li>
<li><strong>maxSumLinear</strong>: This helper method uses a simple
dynamic programming method to find the maximum sum of non-adjacent
numbers in a straight array.</li>
<li><strong>Variables <code>include</code> and
<code>exclude</code></strong> keep track of sums when we include or
exclude the current number we are looking at.</li>
</ul>
<h3 id="example-1">Example:</h3>
<p>For the input array <code>[2, 3, 2]</code>, the output is
<code>3</code>. This is because the maximum sum of non-adjacent numbers
comes from picking <code>3</code>.</p>
<p>This code efficiently finds the maximum sum while keeping the
adjacency rule in mind. It also works well with the circular nature of
the input array. If we want to learn more about dynamic programming, we
can look at similar problems like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Maximum
Sum of Non-Adjacent Elements</a>.</p>
<h2
id="python-code-example-for-maximum-sum-of-non-adjacent-numbers">Python
Code Example for Maximum Sum of Non-Adjacent Numbers</h2>
<p>We will solve the problem of finding the maximum sum of non-adjacent
numbers in a circular array using Python. We can use dynamic programming
for this. The main idea is to think about two choices: including the
first element or not including it. This is like the “House Robber”
problem but a bit more tricky because the array is circular.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_non_adjacent_sum(arr):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> arr:</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> arr[<span class="dv">0</span>]</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> n <span class="op">==</span> <span class="dv">2</span>:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(arr[<span class="dv">0</span>], arr[<span class="dv">1</span>])</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Helper function to calculate the maximum sum in a linear array</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> linear_max_sum(nums):</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            new_exclude <span class="op">=</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>            include <span class="op">=</span> exclude <span class="op">+</span> num</span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            exclude <span class="op">=</span> new_exclude</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exclude the last element and include the first</span></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>    case1 <span class="op">=</span> linear_max_sum(arr[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Exclude the first element and include the last</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a>    case2 <span class="op">=</span> linear_max_sum(arr[<span class="dv">1</span>:])</span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(case1, case2)</span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">2</span>]</span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(max_non_adjacent_sum(arr))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<p>The function <code>max_non_adjacent_sum</code> takes an array as
input. It checks some special cases for arrays of size 0, 1, and 2.</p>
<p>The helper function <code>linear_max_sum</code> finds the maximum sum
of non-adjacent numbers in a regular array using dynamic
programming.</p>
<p>We look at two situations. One is where we take the first element and
skip the last element. The other is where we skip the first element and
take the last element.</p>
<p>In the end, we return the highest value from these two
situations.</p>
<p>This Python code shows a dynamic programming method to find the
maximum sum of non-adjacent numbers in a circular array. It helps us
manage the rules of not picking adjacent numbers.</p>
<h2
id="c-solution-for-maximum-sum-of-non-adjacent-numbers-in-a-circle">C++
Solution for Maximum Sum of Non-Adjacent Numbers in a Circle</h2>
<p>We have a problem. We want to find the maximum sum of non-adjacent
numbers in a circular array with C++. We can use a simple method called
dynamic programming. The circular shape of the array makes it tricky. We
need to think about two cases. One is when we include the first element.
The other is when we don’t include it.</p>
<h3 id="approach-1">Approach</h3>
<ol type="1">
<li><strong>Base Cases</strong>:
<ul>
<li>If the array length is 0, we return 0.</li>
<li>If the array length is 1, we return the first element.</li>
<li>If the array length is 2, we return the bigger of the two
elements.</li>
</ul></li>
<li><strong>Dynamic Programming Logic</strong>:
<ul>
<li>We will use a helper function. This function will find the maximum
sum for a normal linear array. We think about two scenarios:
<ul>
<li>We include the first element and we exclude the last element.</li>
<li>We exclude the first element and we include the last element.</li>
</ul></li>
</ul></li>
<li><strong>Dynamic Programming Array</strong>:
<ul>
<li>We keep a <code>dp</code> array. Here <code>dp[i]</code> stores the
maximum sum of non-adjacent numbers up to index <code>i</code>.</li>
</ul></li>
</ol>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maximumNonAdjacentSum<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;</span> end<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> temp <span class="op">=</span> max<span class="op">(</span>prev1<span class="op">,</span> prev2 <span class="op">+</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> maxSumNonAdjacentInCircle<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>n <span class="op">==</span> <span class="dv">2</span><span class="op">)</span> <span class="cf">return</span> max<span class="op">(</span>nums<span class="op">[</span><span class="dv">0</span><span class="op">],</span> nums<span class="op">[</span><span class="dv">1</span><span class="op">]);</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Case 1: Include the first element, exclude the last</span></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> case1 <span class="op">=</span> maximumNonAdjacentSum<span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Case 2: Exclude the first element, include the last</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> case2 <span class="op">=</span> maximumNonAdjacentSum<span class="op">(</span>nums<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> n<span class="op">);</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max<span class="op">(</span>case1<span class="op">,</span> case2<span class="op">);</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Maximum sum of non-adjacent numbers in a circle: &quot;</span> </span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a>         <span class="op">&lt;&lt;</span> maxSumNonAdjacentInCircle<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Function <code>maximumNonAdjacentSum</code></strong>:
<ul>
<li>This function takes a part of the array. It finds the maximum sum of
non-adjacent elements using dynamic programming.</li>
</ul></li>
<li><strong>Function <code>maxSumNonAdjacentInCircle</code></strong>:
<ul>
<li>This function calls <code>maximumNonAdjacentSum</code> two times. It
handles both cases of the circular array. Then it returns the biggest
result.</li>
</ul></li>
</ul>
<p>This C++ solution works well. It finds the maximum sum of
non-adjacent numbers in a circular array. It takes time O(n) and uses
space O(1). It does not need much extra space.</p>
<p>For more learning about dynamic programming, you can look at <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="comparative-analysis-of-different-approaches-for-maximum-sum-of-non-adjacent-numbers">Comparative
Analysis of Different Approaches for Maximum Sum of Non-Adjacent
Numbers</h2>
<p>We want to find the maximum sum of non-adjacent numbers in a circle.
There are many ways to do this. Each way has its own pros and cons.
These include time complexity, space complexity, and how hard they are
to implement. Here, we look at some popular methods.</p>
<h3 id="dynamic-programming-approach">1. Dynamic Programming
Approach</h3>
<p>We often use the dynamic programming method for this problem. It
breaks the problem into smaller pieces. We store results to avoid doing
the same work again.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(n) or O(1) if we make it
better</li>
</ul>
<p>We treat the array as circular. We can change our dynamic programming
method to fit this shape. We have two cases to solve:</p>
<ul>
<li>Skip the first element</li>
<li>Skip the last element</li>
</ul>
<p>This gives us two separate linear problems that we can combine
later.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNonAdjacent <span class="op">{</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span><span class="fu">maxSumNonAdjacent</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">2</span><span class="op">),</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>                        <span class="fu">maxSumNonAdjacent</span><span class="op">(</span>nums<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> nums<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="kw">private</span> <span class="dt">int</span> <span class="fu">maxSumNonAdjacent</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> curr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> temp <span class="op">=</span> curr<span class="op">;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>prev <span class="op">+</span> nums<span class="op">[</span>i<span class="op">],</span> curr<span class="op">);</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> curr<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_sum_non_adjacent(nums):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> helper(start, end):</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        prev, curr <span class="op">=</span> <span class="dv">0</span>, <span class="dv">0</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>            new_curr <span class="op">=</span> <span class="bu">max</span>(prev <span class="op">+</span> nums[i], curr)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            prev <span class="op">=</span> curr</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            curr <span class="op">=</span> new_curr</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> curr</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(helper(<span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">2</span>), helper(<span class="dv">1</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>))</span></code></pre></div>
<h3 id="c-implementation">C++ Implementation</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> rob<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="kw">auto</span> helper <span class="op">=</span> <span class="op">[](</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">,</span> <span class="dt">int</span> start<span class="op">,</span> <span class="dt">int</span> end<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> prev <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> curr <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> start<span class="op">;</span> i <span class="op">&lt;=</span> end<span class="op">;</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>                <span class="dt">int</span> temp <span class="op">=</span> curr<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>                curr <span class="op">=</span> max<span class="op">(</span>prev <span class="op">+</span> nums<span class="op">[</span>i<span class="op">],</span> curr<span class="op">);</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>                prev <span class="op">=</span> temp<span class="op">;</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> curr<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">};</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>helper<span class="op">(</span>nums<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">2</span><span class="op">),</span> helper<span class="op">(</span>nums<span class="op">,</span> <span class="dv">1</span><span class="op">,</span> nums<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">));</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="recursive-approach-with-memoization">2. Recursive Approach with
Memoization</h3>
<p>We can also use recursion with memoization. This means we save
results of states we have already solved. This makes things quicker.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(n) because of the recursion
stack</li>
</ul>
<p>This method can be slower in real life. This is because of the extra
work needed for recursive calls. But it helps us understand the problem
better.</p>
<h3 id="iterative-approach">3. Iterative Approach</h3>
<p>We can use an iterative way too. It is like dynamic programming but
with less focus on past states. This method keeps only the last two sums
we calculated.</p>
<ul>
<li><strong>Time Complexity:</strong> O(n)</li>
<li><strong>Space Complexity:</strong> O(1)</li>
</ul>
<p>This method is great when we need to save memory.</p>
<h3 id="conclusion">Conclusion</h3>
<p>When we want to solve the maximum sum of non-adjacent numbers in a
circle, we suggest using the dynamic programming method. It is efficient
and clear. If you want to learn more about dynamic programming, check
out <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2
id="optimizing-space-complexity-in-the-dynamic-programming-solution">Optimizing
Space Complexity in the Dynamic Programming Solution</h2>
<p>When we solve the problem of finding the maximum sum of non-adjacent
numbers in a circular array using dynamic programming, it is important
to optimize space complexity. This helps improve performance, especially
when the input size is large.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>The usual dynamic programming solution keeps an array to store
results. But we only need the last two values at any time. So we can cut
down the space complexity from O(n) to O(1).</p>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is how we can implement the space-optimized solution in Java,
Python, and C++:</p>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MaxSumNonAdjacent <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">getMaxSum</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span><span class="fu">length</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span> <span class="co">// Max sum including the previous number</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Max sum excluding the previous number</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> newInclude <span class="op">=</span> exclude <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span> <span class="co">// Include current number</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            exclude <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span> <span class="co">// Update exclude</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            include <span class="op">=</span> newInclude<span class="op">;</span> <span class="co">// Update include</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span> <span class="co">// Return max of include or exclude</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_max_sum(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> nums:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> nums[<span class="dv">0</span>]</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    include <span class="op">=</span> nums[<span class="dv">0</span>]</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    exclude <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums[<span class="dv">1</span>:]:</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        new_include <span class="op">=</span> exclude <span class="op">+</span> num</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        exclude <span class="op">=</span> <span class="bu">max</span>(include, exclude)</span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        include <span class="op">=</span> new_include</span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">max</span>(include, exclude)</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getMaxSum<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>empty<span class="op">())</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">.</span>size<span class="op">()</span> <span class="op">==</span> <span class="dv">1</span><span class="op">)</span> <span class="cf">return</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> include <span class="op">=</span> nums<span class="op">[</span><span class="dv">0</span><span class="op">];</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> exclude <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> new_include <span class="op">=</span> exclude <span class="op">+</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            exclude <span class="op">=</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>            include <span class="op">=</span> new_include<span class="op">;</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max<span class="op">(</span>include<span class="op">,</span> exclude<span class="op">);</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<h3 id="key-points">Key Points</h3>
<ul>
<li><strong>Space Complexity</strong>: The optimized solution runs in
O(1) space. It uses only a few variables to track current include and
exclude values.</li>
<li><strong>Time Complexity</strong>: The time complexity stays O(n).
Here, n is the number of elements in the array. This ensures fast
computation.</li>
<li><strong>Applicability</strong>: This optimization is very helpful in
competitive programming and situations with limited memory.</li>
</ul>
<p>For more reading on similar dynamic programming problems, we can
check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">this
article on the maximum sum of non-adjacent elements</a>.</p>
<h2
id="test-cases-and-edge-cases-for-maximum-sum-of-non-adjacent-numbers">Test
Cases and Edge Cases for Maximum Sum of Non-Adjacent Numbers</h2>
<p>To check if our solution for finding the maximum sum of non-adjacent
numbers in a circular array works well, we need to look at many test
cases and edge cases. These cases help us to see if our solution can
handle different situations correctly.</p>
<h3 id="basic-test-cases">Basic Test Cases</h3>
<ol type="1">
<li><strong>Simple Case</strong>
<ul>
<li><strong>Input:</strong> <code>[2, 4, 6, 2]</code></li>
<li><strong>Expected Output:</strong> <code>8</code> (We select 2 and
6)</li>
</ul></li>
<li><strong>Single Element</strong>
<ul>
<li><strong>Input:</strong> <code>[5]</code></li>
<li><strong>Expected Output:</strong> <code>5</code> (There is only one
element)</li>
</ul></li>
<li><strong>Two Elements</strong>
<ul>
<li><strong>Input:</strong> <code>[1, 2]</code></li>
<li><strong>Expected Output:</strong> <code>2</code> (We can only choose
one)</li>
</ul></li>
<li><strong>Three Elements</strong>
<ul>
<li><strong>Input:</strong> <code>[1, 2, 3]</code></li>
<li><strong>Expected Output:</strong> <code>4</code> (We pick 1 and
3)</li>
</ul></li>
<li><strong>All Negative Numbers</strong>
<ul>
<li><strong>Input:</strong> <code>[-1, -2, -3, -4]</code></li>
<li><strong>Expected Output:</strong> <code>-1</code> (We choose the
least negative number)</li>
</ul></li>
</ol>
<h3 id="edge-cases">Edge Cases</h3>
<ol type="1">
<li><strong>Empty Array</strong>
<ul>
<li><strong>Input:</strong> <code>[]</code></li>
<li><strong>Expected Output:</strong> <code>0</code> (No elements to
choose)</li>
</ul></li>
<li><strong>Large Numbers</strong>
<ul>
<li><strong>Input:</strong> <code>[1000, 2000, 3000, 4000]</code></li>
<li><strong>Expected Output:</strong> <code>6000</code> (We pick 2000
and 4000)</li>
</ul></li>
<li><strong>Alternating High-Low Values</strong>
<ul>
<li><strong>Input:</strong> <code>[5, 1, 5, 1, 5]</code></li>
<li><strong>Expected Output:</strong> <code>15</code> (We choose all
<code>5</code>s)</li>
</ul></li>
<li><strong>High Values with Low Non-Adjacent</strong>
<ul>
<li><strong>Input:</strong> <code>[10, 1, 10, 1, 10]</code></li>
<li><strong>Expected Output:</strong> <code>30</code> (We select all
<code>10</code>s)</li>
</ul></li>
<li><strong>Circular Case</strong>
<ul>
<li><strong>Input:</strong> <code>[1, 2, 3, 1]</code></li>
<li><strong>Expected Output:</strong> <code>4</code> (We take 1 and 3,
not 2)</li>
</ul></li>
</ol>
<h3 id="performance-testing">Performance Testing</h3>
<ol type="1">
<li><strong>Large Array</strong>
<ul>
<li><strong>Input:</strong>
<code>[i for i in range(1, 10001)]</code></li>
<li><strong>Expected Output:</strong> Should work fast without
timeouts.</li>
</ul></li>
<li><strong>Maximum Size Input with Randomized Values</strong>
<ul>
<li><strong>Input:</strong> Randomly made array of size 10^6.</li>
<li><strong>Expected Output:</strong> Check performance and
correctness.</li>
</ul></li>
</ol>
<h3 id="implementation-considerations">Implementation
Considerations</h3>
<ul>
<li>We must make sure that the algorithm deals with circular references
well. This is important when the first and last elements have a
conflict.</li>
<li>We need to check that the dynamic programming method uses
memoization or tabulation correctly to make it fast.</li>
</ul>
<p>These test cases and edge cases are very important to check how
strong and correct our algorithm is for the <strong>maximum sum of
non-adjacent numbers in a circle</strong> problem. For more information
on similar dynamic programming tasks, you can visit <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">Dynamic
Programming - Maximum Sum of Non-Adjacent Elements</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-maximum-sum-of-non-adjacent-numbers-in-a-circular-array">1.
What is the maximum sum of non-adjacent numbers in a circular
array?</h3>
<p>We want to find the maximum sum of numbers in a circle. We can only
pick numbers that are not next to each other. This means we need to be
careful with the first and last numbers in the array. They can change
what numbers we can pick. For more details and answers, look at our
guide on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">maximum
sum of non-adjacent numbers</a>.</p>
<h3
id="how-does-dynamic-programming-help-solve-the-maximum-sum-of-non-adjacent-numbers-problem">2.
How does dynamic programming help solve the maximum sum of non-adjacent
numbers problem?</h3>
<p>Dynamic programming helps us solve the maximum sum of non-adjacent
numbers by breaking the problem into smaller parts. We keep track of the
best sum we can get at each step. We also make sure that we do not pick
adjacent numbers. For a full explanation, check our section on the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">dynamic
programming approach for maximum sums</a>.</p>
<h3
id="can-you-provide-a-python-solution-for-the-maximum-sum-of-non-adjacent-numbers-in-a-circle">3.
Can you provide a Python solution for the maximum sum of non-adjacent
numbers in a circle?</h3>
<p>Sure! A common Python solution uses dynamic programming to save the
best sums at each spot. The algorithm looks at two cases: one that does
not take the last number and one that does not take the first number.
For full code, you can see our Python code example section <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">here</a>.</p>
<h3
id="what-are-the-key-differences-between-the-linear-and-circular-versions-of-the-maximum-sum-problem">4.
What are the key differences between the linear and circular versions of
the maximum sum problem?</h3>
<p>In the linear version, we can pick from a straight list. But in the
circular version, we must think about the first and last numbers because
they are next to each other. In the circular case, we find the maximum
sums in two ways: one without the first number and one without the last
number. A good comparison can help us understand this dynamic
programming problem better.</p>
<h3
id="what-are-some-test-cases-for-the-maximum-sum-of-non-adjacent-numbers-in-a-circle">5.
What are some test cases for the maximum sum of non-adjacent numbers in
a circle?</h3>
<p>We should test this problem with different cases. This includes all
positive numbers, a mix of positive and negative numbers, and small
arrays like those with 2 or 3 elements. Testing with a circular array
makes sure we check both ends well. You can find more test cases and
examples in our section on <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-maximum-sum-of-non-adjacent-elements-medium.html">maximum
sum of non-adjacent numbers</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            