
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Dynamic Programming] Count Ways to Reach a Score (Basic) - Easy</title>
            <meta name="description" content="Discover how to use dynamic programming to count ways to reach a score in this easy-to-follow guide. Boost your coding skills!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Dynamic Programming] Count Ways to Reach a Score (Basic) - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Dynamic programming is a key method we use to solve problems. This
technique works by breaking down problems into simpler parts. When we
want to count the ways to reach a certain score, our goal is to find how
many different ways we can get to that score using a set of moves or
scores. We can solve this problem well with both recursive and dynamic
programming methods. These methods help us to reduce the amount of work
we need to do by using memoization or tabulation.</p>
<p>In this article, we will look closely at how to count the ways to
reach a score. First, we will understand the problem clearly. Then, we
will show a recursive approach in Java, Python, and C++. After that, we
will explain the dynamic programming approach for those same languages.
We will also talk about how to make the space we use smaller for this
problem. Finally, we will answer some common questions.</p>
<ul>
<li>[Dynamic Programming] Count Ways to Reach a Score Using Dynamic
Programming Techniques</li>
<li>Understanding the Problem Statement for Count Ways to Reach a
Score</li>
<li>Recursive Approach to Count Ways to Reach a Score in Java</li>
<li>Dynamic Programming Approach to Count Ways to Reach a Score in
Java</li>
<li>Recursive Approach to Count Ways to Reach a Score in Python</li>
<li>Dynamic Programming Approach to Count Ways to Reach a Score in
Python</li>
<li>Recursive Approach to Count Ways to Reach a Score in C++</li>
<li>Dynamic Programming Approach to Count Ways to Reach a Score in
C++</li>
<li>Optimizing Space Complexity for Count Ways to Reach a Score</li>
<li>Frequently Asked Questions</li>
</ul>
<p>If we want to find more challenges in dynamic programming, we can
check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming: Climbing Stairs</a>. These articles will help us understand
dynamic programming better and how we can use it.</p>
<h2
id="understanding-the-problem-statement-for-count-ways-to-reach-a-score">Understanding
the Problem Statement for Count Ways to Reach a Score</h2>
<p>In the “Count Ways to Reach a Score” problem, we want to find how
many different ways we can get to a specific score. We do this using a
set of scoring options. This problem often comes up in games where
players score points in different ways.</p>
<h3 id="problem-definition">Problem Definition</h3>
<ul>
<li><strong>Input</strong>:
<ul>
<li>An integer <code>score</code> that is the target score.</li>
<li>An array <code>points</code> with the different scoring options we
can use.</li>
</ul></li>
<li><strong>Output</strong>:
<ul>
<li>An integer that shows the total number of different ways to get to
the target score.</li>
</ul></li>
</ul>
<h3 id="example">Example</h3>
<p>If our target score is 4 and our scoring options are [1, 2, 3], we
can reach the score in these ways:</p>
<ol type="1">
<li>1 + 1 + 1 + 1</li>
<li>1 + 1 + 2</li>
<li>1 + 2 + 1</li>
<li>2 + 1 + 1</li>
<li>2 + 2</li>
<li>1 + 3</li>
<li>3 + 1</li>
</ol>
<p>So, we have 7 different ways to reach the score of 4.</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The score will be a non-negative integer.</li>
<li>The scoring options will be positive integers.</li>
</ul>
<p>We can solve this problem well using dynamic programming. We break
the problem into simpler parts. The dynamic programming method helps us
build solutions from the results we already found.</p>
<p>If you want to learn more about dynamic programming, you can check
articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming Climbing Stairs</a>.</p>
<h2
id="recursive-approach-to-count-ways-to-reach-a-score-in-java">Recursive
Approach to Count Ways to Reach a Score in Java</h2>
<p>To count the ways to reach a score using a recursive method in Java,
we can create a function. This function will look at all the possible
score combinations we can make with fixed values. For example, if we
have scores of 1, 2, and 3, the function will keep reducing the score by
these values to find the total ways to reach the target.</p>
<p>Here is a simple Java code using the recursive method:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountWaysToReachScore <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recursive function to count ways to reach a score</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: one way to reach score 0 (by not scoring)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Base case: no way to reach negative score</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Recursive calls for each possible score increment</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fu">countWays</span><span class="op">(</span>score <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>score <span class="op">-</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>score <span class="op">-</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> targetScore <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Example target score</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> ways <span class="op">=</span> <span class="fu">countWays</span><span class="op">(</span>targetScore<span class="op">);</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">+</span> targetScore <span class="op">+</span> <span class="st">&quot; is: &quot;</span> <span class="op">+</span> ways<span class="op">);</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>countWays</code> method checks two main cases. First, if
the score is zero, there is one way to reach it. Second, if the score is
negative, there are no ways to reach it.</li>
<li>The method calls itself again by taking away 1, 2, or 3 from the
current score. It adds the results together to find the total ways to
reach the target.</li>
<li>The <code>main</code> method shows how we can use this function. It
prints out how many ways we can reach the target score we set.</li>
</ul>
<p>This recursive way has a high time complexity. It can take a lot of
time if the score is big. If we need a better solution, we can look at
dynamic programming methods. For a faster way, we can check the <a
href="#">Dynamic Programming Approach to Count Ways to Reach a Score in
Java</a>.</p>
<h2
id="dynamic-programming-approach-to-count-ways-to-reach-a-score-in-java">Dynamic
Programming Approach to Count Ways to Reach a Score in Java</h2>
<p>We can solve the problem of counting ways to reach a score using
dynamic programming in Java. We will use a bottom-up approach. This
means we will create an array to store how many ways we can reach each
score up to the target score.</p>
<h3 id="code-implementation">Code Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ScoreCounter <span class="op">{</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Array to store the number of ways to reach each score</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> dp <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>score <span class="op">+</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case: there is one way to reach score 0</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Loop through all possible scores from 1 to the target score</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> score<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;=</span> <span class="dv">3</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span> <span class="co">// Assuming scores can be 1, 2, or 3</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> j <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>                    dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> j<span class="op">];</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> dp<span class="op">[</span>score<span class="op">];</span> <span class="co">// Return the number of ways to reach the target score</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> score <span class="op">=</span> <span class="dv">4</span><span class="op">;</span> <span class="co">// Example score</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">+</span> score <span class="op">+</span> <span class="st">&quot;: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>score<span class="op">));</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><p><strong>Initialization</strong>: We start with an array
<code>dp</code> that is size <code>score + 1</code>. Here,
<code>dp[i]</code> shows how many ways we can reach score
<code>i</code>. We set <code>dp[0]</code> to 1 because there is one way
to reach score 0. This is doing nothing.</p></li>
<li><p><strong>Filling the DP Array</strong>: We go through each score
from 1 to the target score. For each score, we check the possible last
moves. The moves can be 1, 2, or 3 points. If the last move does not go
over the current score, we add the number of ways to reach the score
minus the last move to the count of the current score.</p></li>
<li><p><strong>Result</strong>: At the end, we return
<code>dp[score]</code>. This value shows the total number of ways to
reach the given score.</p></li>
</ul>
<p>This dynamic programming method counts the ways to reach a score
quickly. It helps to reduce repeated calculations. If you want to learn
more, you can look at similar dynamic programming problems. You might
check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming: Count Ways to Climb Stairs</a> or the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming: Fibonacci Number</a>.</p>
<h2
id="recursive-approach-to-count-ways-to-reach-a-score-in-python">Recursive
Approach to Count Ways to Reach a Score in Python</h2>
<p>We can solve the problem of counting the ways to reach a specific
score using a recursive method in Python. We need to create a function
that checks all combinations of scores we can get. The main idea is to
keep subtracting possible scores until we reach zero or go below.</p>
<p>Here is how the recursive approach works:</p>
<ol type="1">
<li><strong>Base Cases</strong>:
<ul>
<li>If the score is exactly zero, we have one way to achieve it. This is
by not scoring at all.</li>
<li>If the score is negative, we can say there are no ways to achieve
it.</li>
</ul></li>
<li><strong>Recursive Case</strong>:
<ul>
<li>For each possible score like 1, 2, and 3, we call the function again
with the remaining score after we subtract the current score.</li>
</ul></li>
</ol>
<p>Here is the Python code for this recursive approach:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways_recursive(score):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: If score is 0, there is 1 way to achieve it</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> score <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case: If score is less than 0, there are no ways</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> score <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Recursive call for scores of 1, 2, and 3</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (count_ways_recursive(score <span class="op">-</span> <span class="dv">1</span>) <span class="op">+</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>            count_ways_recursive(score <span class="op">-</span> <span class="dv">2</span>) <span class="op">+</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>            count_ways_recursive(score <span class="op">-</span> <span class="dv">3</span>))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>score <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of ways to reach a score of&quot;</span>, score, <span class="st">&quot;is:&quot;</span>, count_ways_recursive(score))</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ul>
<li>The function <code>count_ways_recursive</code> takes a number
<code>score</code> as input.</li>
<li>It checks for base cases. It returns 1 if <code>score</code> is 0
and returns 0 if <code>score</code> is less than 0.</li>
<li>It then adds up the ways to reach the score by calling itself with
lower values (1, 2, and 3).</li>
</ul>
<p>This method has an exponential time complexity (O(3^n)) due to many
recursive calls. It can be slow for big scores. But it helps us
understand the problem better before we try faster methods like dynamic
programming.</p>
<p>For a better solution, we can look at the <strong>Dynamic Programming
Approach</strong> to count ways to reach a score. This method will save
the results of smaller problems and stop us from calculating the same
thing again. You can check the <strong><a href="#">Dynamic Programming
Approach to Count Ways to Reach a Score in Python</a></strong> for more
ways to improve.</p>
<h2
id="dynamic-programming-approach-to-count-ways-to-reach-a-score-in-python">Dynamic
Programming Approach to Count Ways to Reach a Score in Python</h2>
<p>We can solve the problem of counting the ways to reach a score using
a dynamic programming approach in Python. We define our problem like
this:</p>
<p>We have a score <code>n</code> and a list of scores that we can take
in one step. For example, we can take steps of 1, 2, or 3 points. Our
goal is to find how many ways we can reach the score <code>n</code>
using these steps.</p>
<h3 id="dynamic-programming-solution">Dynamic Programming Solution</h3>
<ol type="1">
<li><strong>Define the DP Array</strong>: We create a list called
<code>dp</code>. In this list, <code>dp[i]</code> will hold the number
of ways to reach the score <code>i</code>.</li>
<li><strong>Base Case</strong>: We set <code>dp[0]</code> to 1. This
means there is one way to reach a score of 0, which is to take no
steps.</li>
<li><strong>Fill the DP Array</strong>: For each score from 1 to
<code>n</code>, we calculate how many ways we can reach that score using
our possible steps.</li>
</ol>
<h3 id="python-code-implementation">Python Code Implementation</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> countWaysToReachScore(n, scores):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create a DP array to store the number of ways to reach each score</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    dp <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> (n <span class="op">+</span> <span class="dv">1</span>)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Base case</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    dp[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fill the dp array</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, n <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> score <span class="kw">in</span> scores:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> i <span class="op">-</span> score <span class="op">&gt;=</span> <span class="dv">0</span>:</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                dp[i] <span class="op">+=</span> dp[i <span class="op">-</span> score]</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp[n]</span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="dv">4</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>scores <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]  <span class="co"># Possible scores in one step</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(countWaysToReachScore(n, scores))  <span class="co"># Output: 7</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<p>The function <code>countWaysToReachScore</code> takes the total score
<code>n</code> and a list of possible scores as input.</p>
<p>We start by making a list <code>dp</code> with size
<code>n + 1</code>. We set all values to 0, but we set
<code>dp[0]</code> to 1.</p>
<p>Next, we loop through each score from 1 to <code>n</code>. For each
score, we check each possible score step. If the current score minus the
step is not negative, we add the ways to reach that score to
<code>dp[i]</code>.</p>
<p>At the end, we return <code>dp[n]</code>. This value tells us the
total number of ways to reach the score <code>n</code>.</p>
<p>This dynamic programming method helps us count the ways to reach a
score. We build on the results we calculated before, which makes it
efficient. For more related problems, we can check out the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming - Count Ways to Climb Stairs</a>.</p>
<h2
id="recursive-approach-to-count-ways-to-reach-a-score-in-c">Recursive
Approach to Count Ways to Reach a Score in C++</h2>
<p>To count ways to reach a score using a recursive method in C++, we
can define the problem in a simple way. We think that we can reach the
score by using three possible scores: 1, 2, and 3. We can write the
recursive formula like this:</p>
<pre><code>ways(score) = ways(score - 1) + ways(score - 2) + ways(score - 3)</code></pre>
<p>We also have base cases:</p>
<ul>
<li>If the score is 0, we have 1 way to reach it. This is by not scoring
at all.</li>
<li>If the score is negative, we have 0 ways to reach it.</li>
</ul>
<p>Here is the C++ code for this:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Base cases</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Recursive calls</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> countWays<span class="op">(</span>score <span class="op">-</span> <span class="dv">1</span><span class="op">)</span> <span class="op">+</span> countWays<span class="op">(</span>score <span class="op">-</span> <span class="dv">2</span><span class="op">)</span> <span class="op">+</span> countWays<span class="op">(</span>score <span class="op">-</span> <span class="dv">3</span><span class="op">);</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> score<span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Enter the score: &quot;</span><span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>    cin <span class="op">&gt;&gt;</span> score<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to reach the score: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>score<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-1">Explanation:</h3>
<ul>
<li>The <code>countWays</code> function counts how many ways we can
reach the score we give.</li>
<li>The function calls itself with lower scores (score - 1, score - 2,
score - 3) to find all possible combinations.</li>
<li>We get the input score from the user. Then we print how many ways we
can reach that score.</li>
</ul>
<p>This recursive method is simple but it has exponential time
complexity due to overlapping problems. If we have larger scores, we
should think about using dynamic programming to make it faster. For more
information about dynamic programming, you can check <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> or <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2
id="dynamic-programming-approach-to-count-ways-to-reach-a-score-in-c">Dynamic
Programming Approach to Count Ways to Reach a Score in C++</h2>
<p>To count ways to reach a specific score using dynamic programming in
C++, we can set up the problem like this:</p>
<ol type="1">
<li><p><strong>Problem Statement</strong>: We have a score
<code>n</code>. We know the points we can score in one move (like
<code>x1, x2, ..., xk</code>). We need to find how many ways we can
reach the score <code>n</code>.</p></li>
<li><p><strong>Dynamic Programming Table</strong>: We will use a DP
array called <code>dp</code>. Here, <code>dp[i]</code> shows how many
ways we can reach the score <code>i</code>.</p></li>
<li><p><strong>Base Case</strong>: There is one way to get a score of 0.
This is by not scoring at all. So, we set
<code>dp[0] = 1</code>.</p></li>
<li><p><strong>Recurrence Relation</strong>: For each score
<code>i</code> from <code>1</code> to <code>n</code>, we will update
<code>dp[i]</code> by going through each possible score. The relation
is:</p>
<pre><code>dp[i] += dp[i - score] for each score in possible_scores</code></pre></li>
</ol>
<h3 id="c-implementation">C++ Implementation</h3>
<p>Here is how we can write the dynamic programming approach in C++.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> n<span class="op">,</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> dp<span class="op">(</span>n <span class="op">+</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    dp<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Base case</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Fill the DP table</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;=</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> score <span class="op">:</span> scores<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>i <span class="op">-</span> score <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>                dp<span class="op">[</span>i<span class="op">]</span> <span class="op">+=</span> dp<span class="op">[</span>i <span class="op">-</span> score<span class="op">];</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dp<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> <span class="dv">5</span><span class="op">;</span> <span class="co">// Desired score</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> scores <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span> <span class="co">// Possible scores in a single move</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> ways <span class="op">=</span> countWays<span class="op">(</span>n<span class="op">,</span> scores<span class="op">);</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Number of ways to reach score &quot;</span> <span class="op">&lt;&lt;</span> n <span class="op">&lt;&lt;</span> <span class="st">&quot; is &quot;</span> <span class="op">&lt;&lt;</span> ways <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code</h3>
<ul>
<li><p><strong>Input Parameters</strong>:</p>
<ul>
<li><code>n</code>: This is the target score.</li>
<li><code>scores</code>: This is a vector that has the possible scores
for each move.</li>
</ul></li>
<li><p><strong>DP Array Initialization</strong>: We make a DP array that
is size <code>n + 1</code>. We set all values to 0. But
<code>dp[0]</code> is 1.</p></li>
<li><p><strong>Nested Loops</strong>: The outer loop goes through all
scores from <code>1</code> to <code>n</code>. The inner loop goes
through each possible score to update the <code>dp</code>
array.</p></li>
<li><p><strong>Output</strong>: The program will print the total number
of ways to reach the score <code>n</code>.</p></li>
</ul>
<p>This dynamic programming way helps us to find out how many ways we
can get to the target score. The time we need is O(n * k), where
<code>k</code> is how many possible scores we have. For more related
dynamic programming problems, we can check out articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-count-ways-to-climb-stairs-easy.html">Dynamic
Programming - Count Ways to Climb Stairs</a>.</p>
<h2
id="optimizing-space-complexity-for-count-ways-to-reach-a-score">Optimizing
Space Complexity for Count Ways to Reach a Score</h2>
<p>When we solve the problem of counting ways to reach a score, we can
make space better. This helps a lot, especially for big scores. The
simple dynamic programming method usually uses a 1D array for keeping
results. But we can just use two variables instead.</p>
<h3 id="space-optimization-technique">Space Optimization Technique</h3>
<p>Instead of keeping an array for all scores, we only need to keep the
last two values we calculated. This is because the ways to reach the
current score only depends on the last two scores.</p>
<h3 id="implementation-in-java">Implementation in Java</h3>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ScoreCounter <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countWays</span><span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>score <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Ways to reach score 0</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Ways to reach score -1 (not real)</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> score<span class="op">;</span> s<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span> <span class="co">// Ways to reach current score</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            prev2 <span class="op">=</span> prev1<span class="op">;</span> <span class="co">// Update prev2 for next time</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            prev1 <span class="op">=</span> current<span class="op">;</span> <span class="co">// Update prev1 for next time</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> score <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Ways to reach score &quot;</span> <span class="op">+</span> score <span class="op">+</span> <span class="st">&quot;: &quot;</span> <span class="op">+</span> <span class="fu">countWays</span><span class="op">(</span>score<span class="op">));</span></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="implementation-in-python">Implementation in Python</h3>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_ways(score):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> score <span class="op">&lt;</span> <span class="dv">0</span>:</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> score <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    prev1, prev2 <span class="op">=</span> <span class="dv">1</span>, <span class="dv">0</span>  <span class="co"># Ways to reach score 0 and -1</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> s <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, score <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        current <span class="op">=</span> prev1 <span class="op">+</span> prev2</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    score <span class="op">=</span> <span class="dv">5</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Ways to reach score </span><span class="sc">{</span>score<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>count_ways(score)<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<h3 id="implementation-in-c">Implementation in C++</h3>
<div class="sourceCode" id="cb11"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countWays<span class="op">(</span><span class="dt">int</span> score<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">&lt;</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>score <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> prev1 <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> prev2 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> <span class="co">// Ways to reach score 0 and -1</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> s <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> s <span class="op">&lt;=</span> score<span class="op">;</span> <span class="op">++</span>s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> current <span class="op">=</span> prev1 <span class="op">+</span> prev2<span class="op">;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>        prev2 <span class="op">=</span> prev1<span class="op">;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>        prev1 <span class="op">=</span> current<span class="op">;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> prev1<span class="op">;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-18"><a href="#cb11-18" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb11-19"><a href="#cb11-19" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> score <span class="op">=</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb11-20"><a href="#cb11-20" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Ways to reach score &quot;</span> <span class="op">&lt;&lt;</span> score <span class="op">&lt;&lt;</span> <span class="st">&quot;: &quot;</span> <span class="op">&lt;&lt;</span> countWays<span class="op">(</span>score<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb11-21"><a href="#cb11-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb11-22"><a href="#cb11-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>With this better way, we have a space complexity of O(1) and keep the
time complexity at O(n). This helps a lot for big scores and makes using
memory smart. For more information about dynamic programming, we can
check articles like <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Dynamic
Programming - Fibonacci Number</a> and <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">Dynamic
Programming - Climbing Stairs</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-dynamic-programming-approach-for-counting-ways-to-reach-a-score">1.
What is the dynamic programming approach for counting ways to reach a
score?</h3>
<p>We use the dynamic programming approach to count ways to reach a
score by breaking the problem into smaller parts. We store results of
these parts. This saves us from doing the same work over and over. By
using an array, we keep track of how many ways we can reach each score.
This helps us reach the desired score faster. This method is much better
than a basic recursive solution.</p>
<h3
id="how-can-i-implement-the-recursive-method-to-count-ways-to-reach-a-score-in-java">2.
How can I implement the recursive method to count ways to reach a score
in Java?</h3>
<p>To use the recursive method in Java to count ways to reach a score,
we need to create a function. This function calls itself for each score
we want to reduce. Each call checks different ways to reach the current
score by looking at lower scores. We should remember to handle base
cases like when we reach a score of zero. This shows one way to succeed.
This method is easy, but it can be slow without memoization.</p>
<h3
id="is-it-possible-to-optimize-space-complexity-in-the-dynamic-programming-solution-for-the-score-problem">3.
Is it possible to optimize space complexity in the dynamic programming
solution for the score problem?</h3>
<p>Yes, we can optimize space in the dynamic programming solution for
counting ways to reach a score. Instead of using an array for all
previous scores, we can use a rolling array or just two variables. These
will keep track of only the last two scores we need. This change reduces
space from O(n) to O(1). So, our solution becomes more efficient while
still working well.</p>
<h3
id="what-is-the-difference-between-the-recursive-and-dynamic-programming-approaches-to-solving-the-score-problem">4.
What is the difference between the recursive and dynamic programming
approaches to solving the score problem?</h3>
<p>The main difference between recursive and dynamic programming methods
is how efficient they are. The recursive method can take a long time
because it has overlapping parts. On the other hand, dynamic programming
uses results we already found to be faster. This makes dynamic
programming better for larger inputs. It avoids doing the same
calculations many times.</p>
<h3
id="are-there-similar-dynamic-programming-problems-i-can-practice-after-learning-to-count-ways-to-reach-a-score">5.
Are there similar dynamic programming problems I can practice after
learning to count ways to reach a score?</h3>
<p>Of course! After we learn the dynamic programming technique for
counting ways to reach a score, we can try other related problems. Some
good ones are the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-fibonacci-number-easy.html">Fibonacci
sequence</a>, the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-climbing-stairs-easy.html">climbing
stairs problem</a>, and the <a
href="https://bestonlinetutorial.com/dynamic_programming/dynamic-programming-simple-0-1-knapsack-small-instance-easy.html">0-1
knapsack problem</a>. These problems will help us understand dynamic
programming better and improve our problem-solving skills.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            