
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Minimum Recolors to Get K Consecutive Black Blocks - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover the minimum recolors needed to achieve K consecutive black blocks in an array. Simplified solutions and tips await!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Minimum Recolors to Get K Consecutive Black Blocks - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>To solve the problem of finding the least number of recolors to get K
black blocks in a row in an array, we look at how the blocks are
arranged. We can think of this as a binary array. In this array, ‘1’
means a black block and ‘0’ means a white block. Our goal is to find out
how many white blocks we need to change to black to have K ’1’s in a
row. We can use a sliding window technique to do this well. This way, we
can check parts of the array without doing extra work.</p>
<p>In this article, we will look at different ways to solve the problem
of minimum recolors for K consecutive black blocks. First, we will
explain the problem statement. Then, we will show an optimal sliding
window method in Java, Python, and C++. After that, we will give a brute
force solution for all three programming languages. We will also check
the time and space complexity for each method. Finally, we will answer
some common questions about this problem.</p>
<ul>
<li>Array Minimum Recolors to Obtain K Consecutive Black Blocks -
Easy</li>
<li>Understanding the Problem Statement for Minimum Recolors</li>
<li>Optimal Sliding Window Approach for Minimum Recolors in Java</li>
<li>Sliding Window Implementation in Python for Minimum Recolors</li>
<li>C++ Solution Using Sliding Window Technique for Minimum
Recolors</li>
<li>Brute Force Approach for Minimum Recolors in Java</li>
<li>Brute Force Approach for Minimum Recolors in Python</li>
<li>Brute Force Approach for Minimum Recolors in C++</li>
<li>Time and Space Complexity Analysis of Solutions</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more context and similar problems, you can check out resources
like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2
id="understanding-the-problem-statement-for-minimum-recolors">Understanding
the Problem Statement for Minimum Recolors</h2>
<p>We want to find the least number of recolors needed to get
<code>K</code> black blocks in a row. We have a string of blocks. Each
block is either black (‘B’) or white (‘W’). Our goal is to figure out
how many white blocks we need to change to black to have at least
<code>K</code> black blocks together.</p>
<h3 id="problem-definition">Problem Definition:</h3>
<ul>
<li>We get a string called <code>blocks</code>. It has characters ‘B’
and ‘W’.</li>
<li>We have an integer <code>K</code>. This tells us how many black
blocks we want in a row.</li>
<li>We need to find the smallest number of ’W’s to change to ’B’s in any
part of the string that is <code>K</code> long.</li>
</ul>
<h3 id="example">Example:</h3>
<ul>
<li>Input: <code>blocks = "WBBWWBB"</code>, <code>K = 3</code></li>
<li>Output: <code>1</code>
<ul>
<li>Explanation: If we change one ‘W’ in “WBB” to ‘B’, we get
“BBB”.</li>
</ul></li>
</ul>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>The length of <code>blocks</code> is not too long. So, we can use
the sliding window method to solve it fast.</li>
</ul>
<p>We can solve this problem well using different methods. One good way
is the sliding window technique. This method helps us keep track of how
many white blocks are in the current window of size <code>K</code>. This
way, we can make the recoloring faster.</p>
<p>By understanding the problem clearly, we can write good algorithms in
different programming languages.</p>
<h2
id="optimal-sliding-window-approach-for-minimum-recolors-in-java">Optimal
Sliding Window Approach for Minimum Recolors in Java</h2>
<p>We can find the minimum number of recolors needed to get
<code>K</code> consecutive black blocks using the sliding window method.
This way, we can solve the problem quickly with a time of O(N). Here, N
is the length of the array. This method works well for big input
sizes.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li>First, we set a variable to count the white blocks
(<code>whiteCount</code>) in the current window of size
<code>K</code>.</li>
<li>Next, we use the sliding window to go through the array:
<ul>
<li>For the first <code>K</code> blocks, we count how many white blocks
there are.</li>
<li>Then we slide the window one block at a time:
<ul>
<li>We take away the block that is leaving the window.</li>
<li>We add the block that is coming into the window.</li>
</ul></li>
</ul></li>
<li>We keep track of the smallest number of white blocks we find while
going through the array.</li>
</ol>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumRecolors <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minimumRecolors</span><span class="op">(</span><span class="bu">String</span> blocks<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> blocks<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> whiteCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Count white blocks in the first window of size K</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> K<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                whiteCount<span class="op">++;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> minRecolors <span class="op">=</span> whiteCount<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Slide the window across the blocks</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> K<span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Remove the block going out of window</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i <span class="op">-</span> K<span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>                whiteCount<span class="op">--;</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Add the new block coming into the window</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>i<span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>                whiteCount<span class="op">++;</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Update the minimum recolors needed</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a>            minRecolors <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>minRecolors<span class="op">,</span> whiteCount<span class="op">);</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> minRecolors<span class="op">;</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a>        MinimumRecolors solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MinimumRecolors</span><span class="op">();</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> blocks <span class="op">=</span> <span class="st">&quot;WBBWWBB&quot;</span><span class="op">;</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> K <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum recolors needed: &quot;</span> <span class="op">+</span> solution<span class="op">.</span><span class="fu">minimumRecolors</span><span class="op">(</span>blocks<span class="op">,</span> K<span class="op">));</span> <span class="co">// Output: 2</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this code: - The <code>minimumRecolors</code> method finds the
minimum number of recolors needed to have <code>K</code> consecutive
black blocks (‘B’). - The <code>main</code> method shows how to use this
function with an example input.</p>
<p>This sliding window method works well and is easy to understand. We
can manage bigger datasets easily. If we want to learn more about array
problems, we can check out <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a> or <a
href="https://bestonlinetutorial.com/array/array-best-time-to-buy-and-sell-stock-easy.html">Array
Best Time to Buy and Sell Stock</a>.</p>
<h2
id="sliding-window-implementation-in-python-for-minimum-recolors">Sliding
Window Implementation in Python for Minimum Recolors</h2>
<p>We can use the sliding window method to find out how many white
blocks we need to change to black blocks. We want to get <code>K</code>
black blocks in a row from an array that shows colors as <code>B</code>
(black) and <code>W</code> (white).</p>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a string that shows blocks of colors, we need to find the least
number of white blocks (<code>W</code>) we must change to black
(<code>B</code>) so that we have at least <code>K</code> black blocks
together.</p>
<h3 id="python-implementation">Python Implementation</h3>
<p>Here is how we can use the sliding window approach in Python:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimumRecolors(blocks: <span class="bu">str</span>, k: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(blocks)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    min_recolors <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    current_white_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initial count of white blocks in the first window of size k</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> blocks[i] <span class="op">==</span> <span class="st">&#39;W&#39;</span>:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            current_white_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    min_recolors <span class="op">=</span> current_white_count</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Slide the window across the blocks</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(k, n):</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> blocks[i] <span class="op">==</span> <span class="st">&#39;W&#39;</span>:</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            current_white_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> blocks[i <span class="op">-</span> k] <span class="op">==</span> <span class="st">&#39;W&#39;</span>:</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>            current_white_count <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>        min_recolors <span class="op">=</span> <span class="bu">min</span>(min_recolors, current_white_count)</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_recolors</span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>:
<ul>
<li><code>n</code> is the length of the blocks string.</li>
<li>We set <code>min_recolors</code> to infinity. This helps us find the
minimum.</li>
<li><code>current_white_count</code> counts how many white blocks are in
the current window.</li>
</ul></li>
<li><strong>First Window Calculation</strong>:
<ul>
<li>The first loop counts white blocks in the first <code>K</code>
blocks.</li>
</ul></li>
<li><strong>Sliding the Window</strong>:
<ul>
<li>The second loop moves the window one block at a time.</li>
<li>If a new block comes in the window (right side), we check if it is
white and add to the count.</li>
<li>We also check if the block that goes out of the window (left side)
is white and take it away from the count.</li>
</ul></li>
<li><strong>Update Minimum</strong>:
<ul>
<li>After we adjust the count for the current window, we update the
minimum recolors needed.</li>
</ul></li>
</ul>
<p>This method finds the minimum number of recolors in O(n) time. It is
good for large inputs.</p>
<p>For more about similar array problems, we can see <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2
id="c-solution-using-sliding-window-technique-for-minimum-recolors">C++
Solution Using Sliding Window Technique for Minimum Recolors</h2>
<p>We want to find the least number of recolors needed to get
<code>K</code> black blocks in a row from an array of blocks. The blocks
are either ‘B’ for black or ‘W’ for white. We can use the sliding window
technique in C++. This method helps us go through the array while
counting the white blocks in a window of size <code>K</code>.</p>
<h3 id="c-code-implementation">C++ Code Implementation</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;string&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minimumRecolors<span class="op">(</span>string blocks<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minRecolors <span class="op">=</span> k<span class="op">;</span> <span class="co">// Max recolors if all are white</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> whiteCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span>  <span class="co">// Count of white blocks in current window</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Set up the first window</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> k<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>            whiteCount<span class="op">++;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    minRecolors <span class="op">=</span> min<span class="op">(</span>minRecolors<span class="op">,</span> whiteCount<span class="op">);</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Slide the window across the blocks</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> k<span class="op">;</span> i <span class="op">&lt;</span> blocks<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Remove the leftmost block from the previous window</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">[</span>i <span class="op">-</span> k<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>            whiteCount<span class="op">--;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Add the new block to the current window</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>            whiteCount<span class="op">++;</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        minRecolors <span class="op">=</span> min<span class="op">(</span>minRecolors<span class="op">,</span> whiteCount<span class="op">);</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> minRecolors<span class="op">;</span></span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    string blocks <span class="op">=</span> <span class="st">&quot;WBWBBBW&quot;</span><span class="op">;</span></span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum recolors needed: &quot;</span> <span class="op">&lt;&lt;</span> minimumRecolors<span class="op">(</span>blocks<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code</h3>
<ul>
<li><strong>Function Definition</strong>: The function
<code>minimumRecolors</code> takes a string <code>blocks</code> and an
integer <code>k</code>. These represent the blocks and the number of
consecutive blocks we need.</li>
<li><strong>Initial Window Setup</strong>: We check the first
<code>k</code> blocks to count how many are white.</li>
<li><strong>Sliding Mechanism</strong>: When the window slides, we take
out the left block from the count if it is white. We add the new right
block into the count if it is white.</li>
<li><strong>Minimum Calculation</strong>: As we slide, we keep track of
the least number of recolors needed.</li>
</ul>
<h3 id="example-usage">Example Usage</h3>
<p>If we have the string <code>blocks = "WBWBBBW"</code> and
<code>k = 3</code>, the output will be:</p>
<pre><code>Minimum recolors needed: 1</code></pre>
<p>This shows that we need to change at least one block to get three
black blocks together.</p>
<p>Using the sliding window technique helps us make the time needed go
down to O(n). This is good for larger input sizes. If you want to
explore more about similar array problems, check out the article on <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a>.</p>
<h2 id="brute-force-approach-for-minimum-recolors-in-java">Brute Force
Approach for Minimum Recolors in Java</h2>
<p>In the brute force method to find the minimum recolors needed to get
<code>K</code> black blocks in a row from a string of blocks made of ‘B’
(black) and ‘W’ (white), we will check every possible segment of length
<code>K</code>. For each segment, we will count the white blocks and
remember the smallest count we find.</p>
<h3 id="java-implementation-1">Java Implementation</h3>
<p>Here is how we can do the brute force method in Java:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> MinimumRecolors <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span> <span class="fu">minimumRecolors</span><span class="op">(</span><span class="bu">String</span> blocks<span class="op">,</span> <span class="dt">int</span> K<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> minRecolors <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MAX_VALUE</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> blocks<span class="op">.</span><span class="fu">length</span><span class="op">();</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check each starting point for segments of length K</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> K<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> recolors <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Count the white blocks in the current segment</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i<span class="op">;</span> j <span class="op">&lt;</span> i <span class="op">+</span> K<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">.</span><span class="fu">charAt</span><span class="op">(</span>j<span class="op">)</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                    recolors<span class="op">++;</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Update the minimum recolors needed</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>            minRecolors <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">min</span><span class="op">(</span>minRecolors<span class="op">,</span> recolors<span class="op">);</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> minRecolors<span class="op">;</span></span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-23"><a href="#cb5-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-24"><a href="#cb5-24" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-25"><a href="#cb5-25" aria-hidden="true" tabindex="-1"></a>        MinimumRecolors solution <span class="op">=</span> <span class="kw">new</span> <span class="fu">MinimumRecolors</span><span class="op">();</span></span>
<span id="cb5-26"><a href="#cb5-26" aria-hidden="true" tabindex="-1"></a>        <span class="bu">String</span> blocks <span class="op">=</span> <span class="st">&quot;WBBWWBB&quot;</span><span class="op">;</span></span>
<span id="cb5-27"><a href="#cb5-27" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> K <span class="op">=</span> <span class="dv">4</span><span class="op">;</span></span>
<span id="cb5-28"><a href="#cb5-28" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> solution<span class="op">.</span><span class="fu">minimumRecolors</span><span class="op">(</span>blocks<span class="op">,</span> K<span class="op">);</span></span>
<span id="cb5-29"><a href="#cb5-29" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Minimum recolors needed: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb5-30"><a href="#cb5-30" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-31"><a href="#cb5-31" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-2">Explanation of the Code</h3>
<ul>
<li>The outer loop goes through each starting point <code>i</code> for
the segments of length <code>K</code>.</li>
<li>The inner loop counts the number of ‘W’ blocks in the current
segment starting at <code>i</code>.</li>
<li>We keep a variable <code>minRecolors</code> to track the lowest
number of recolors needed for any segment we check.</li>
<li>At the end, the method gives back the minimum recolors we need.</li>
</ul>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: O(N * K), where N is the length of
the blocks string. Each segment of length K is checked one by one.</li>
<li><strong>Space Complexity</strong>: O(1), because we use a fixed
amount of space for the variables.</li>
</ul>
<p>This brute force method is simple but might not be the best for large
inputs. A sliding window method could work better for big sizes. For
better solutions, look at the section on Optimal Sliding Window Approach
for Minimum Recolors in Java.</p>
<h2 id="brute-force-approach-for-minimum-recolors-in-python">Brute Force
Approach for Minimum Recolors in Python</h2>
<p>To find how many recolors we need to get <code>K</code> black blocks
next to each other in an array, we can use a brute force method. This
way, we look at every possible part of the array that is <code>K</code>
long. Then we count how many blocks need to change color in each
part.</p>
<h3 id="implementation">Implementation</h3>
<p>The brute force solution goes through the array. It checks every part
that is <code>K</code> long. For each part, it counts the number of
white blocks (which we show as <code>0</code>) and finds the smallest
count from all parts.</p>
<p>Here is the Python code for this brute force method:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> minimumRecolors(blocks, k):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(blocks)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    min_recolors <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)  <span class="co"># Start with a big number</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> k <span class="op">+</span> <span class="dv">1</span>):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        recolors <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Count the number of white blocks in the current part of length k</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, i <span class="op">+</span> k):</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> blocks[j] <span class="op">==</span> <span class="st">&#39;0&#39;</span>:  <span class="co"># 0 means a white block</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>                recolors <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>        min_recolors <span class="op">=</span> <span class="bu">min</span>(min_recolors, recolors)  <span class="co"># Update minimum recolors</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> min_recolors</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>blocks <span class="op">=</span> <span class="st">&quot;WBBWWBB&quot;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(minimumRecolors(blocks, k))  <span class="co"># Output: 1</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Input</strong>: The function takes a string called
<code>blocks</code>. Here ‘B’ means a black block and ‘W’ means a white
block. The integer <code>k</code> shows how many black blocks we want
together.</li>
<li><strong>Loop</strong>: The outer loop goes through the
<code>blocks</code> array. The inner loop counts white blocks in each
part that is <code>k</code> long.</li>
<li><strong>Result</strong>: The function gives back the smallest number
of recolors needed from all parts.</li>
</ul>
<p>This brute force way is simple but it has a time cost of O(n * k).
Here, <code>n</code> is the length of the blocks string. This makes it
slower for bigger inputs. If you want faster ways, you can look at the
sliding window method in other sections.</p>
<p>For more information on how to work with arrays, check out the
article on <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2 id="brute-force-approach-for-minimum-recolors-in-c">Brute Force
Approach for Minimum Recolors in C++</h2>
<p>The brute force method to solve the problem of minimum recolors for
<code>K</code> consecutive black blocks checks every possible starting
point in the blocks array. We look at each segment of length
<code>K</code> and count how many white blocks we need to change to get
<code>K</code> black blocks in a row.</p>
<h3 id="implementation-steps">Implementation Steps:</h3>
<ol type="1">
<li>We loop through the array from index <code>0</code> to
<code>n - K</code>.</li>
<li>For each starting index, we count the white blocks in the segment of
length <code>K</code>.</li>
<li>We keep track of the smallest number of recolors needed.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> minimumRecolors<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;&amp;</span> blocks<span class="op">,</span> <span class="dt">int</span> k<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> blocks<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> minRecolors <span class="op">=</span> INT_MAX<span class="op">;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;=</span> n <span class="op">-</span> k<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> recolors <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> j <span class="op">&lt;</span> k<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>blocks<span class="op">[</span>i <span class="op">+</span> j<span class="op">]</span> <span class="op">==</span> <span class="ch">&#39;W&#39;</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>                recolors<span class="op">++;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>        minRecolors <span class="op">=</span> min<span class="op">(</span>minRecolors<span class="op">,</span> recolors<span class="op">);</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> minRecolors<span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">char</span><span class="op">&gt;</span> blocks <span class="op">=</span> <span class="op">{</span><span class="ch">&#39;W&#39;</span><span class="op">,</span> <span class="ch">&#39;B&#39;</span><span class="op">,</span> <span class="ch">&#39;B&#39;</span><span class="op">,</span> <span class="ch">&#39;W&#39;</span><span class="op">,</span> <span class="ch">&#39;B&#39;</span><span class="op">,</span> <span class="ch">&#39;W&#39;</span><span class="op">,</span> <span class="ch">&#39;W&#39;</span><span class="op">,</span> <span class="ch">&#39;B&#39;</span><span class="op">};</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> k <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Minimum Recolors: &quot;</span> <span class="op">&lt;&lt;</span> minimumRecolors<span class="op">(</span>blocks<span class="op">,</span> k<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span> <span class="co">// Output: 1</span></span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-3">Explanation of the Code:</h3>
<ul>
<li>We have a function called <code>minimumRecolors</code>. It takes a
vector of characters (<code>blocks</code>) and an integer
<code>k</code>.</li>
<li>We start by setting <code>minRecolors</code> to a big number.</li>
<li>For each starting index <code>i</code>, we count the white blocks in
the next <code>k</code> blocks.</li>
<li>If the current count of recolors is less than what we had before, we
update <code>minRecolors</code>.</li>
<li>In the end, the function gives back the minimum number of recolors
we need.</li>
</ul>
<p>This brute force method has a time complexity of O(n * k). It is not
very efficient for big arrays when we compare with faster methods like
the sliding window approach. For other array problems, we can find
helpful tips in articles like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2 id="time-and-space-complexity-analysis-of-solutions">Time and Space
Complexity Analysis of Solutions</h2>
<p>When we solve the problem of finding the minimum recolors to get K
consecutive black blocks, we can look at the time and space complexity
of different methods.</p>
<h3 id="sliding-window-approach">Sliding Window Approach</h3>
<ol type="1">
<li><strong>Time Complexity</strong>:
<ul>
<li>The sliding window method goes through the array one time. It keeps
a window of size K. So, the time complexity is O(N). Here, N is the
length of the array.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>The space complexity is O(1) because we only use a few extra
variables to track the state of the current window.</li>
</ul></li>
</ol>
<h3 id="brute-force-approach">Brute Force Approach</h3>
<ol type="1">
<li><strong>Time Complexity</strong>:
<ul>
<li>The brute force method checks every possible starting point for K
consecutive blocks. This means it checks around N-K+1 windows. So, the
time complexity is O(N * K). Here, N is the length of the array and K is
the size of the blocks we want to check.</li>
</ul></li>
<li><strong>Space Complexity</strong>:
<ul>
<li>The space complexity is O(1) because it uses a fixed amount of extra
space for temporary variables.</li>
</ul></li>
</ol>
<h3 id="summary-of-complexities">Summary of Complexities</h3>
<table>
<thead>
<tr class="header">
<th>Approach</th>
<th>Time Complexity</th>
<th>Space Complexity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Sliding Window</td>
<td>O(N)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>Brute Force</td>
<td>O(N * K)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<p>We prefer the sliding window approach for its speed, especially with
larger arrays. The brute force method can be easier for small
inputs.</p>
<p>For more related problems, we can check these articles: <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a>, <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>, and <a
href="https://bestonlinetutorial.com/array/array-best-time-to-buy-and-sell-stock-easy.html">Array
Best Time to Buy and Sell Stock</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-minimum-recolors-to-get-k-consecutive-black-blocks-problem">1.
What is the Minimum Recolors to Get K Consecutive Black Blocks
problem?</h3>
<p>The Minimum Recolors to Get K Consecutive Black Blocks is a problem.
You get a string that shows blocks of colors. ‘B’ means black and ‘W’
means white. The goal is to find out how many white blocks we need to
repaint. We need at least K black blocks in a row. We can solve this
problem well using sliding window methods.</p>
<h3
id="how-can-the-sliding-window-technique-optimize-the-solution-for-minimum-recolors">2.
How can the Sliding Window Technique optimize the solution for Minimum
Recolors?</h3>
<p>The Sliding Window Technique helps us make the solution better for
the Minimum Recolors to Get K Consecutive Black Blocks problem. It does
this by keeping a window that is size K. As we move the window across
the string, we can count the white blocks fast. We do not need to check
the whole window again. This way, we make the time it takes much less to
O(N).</p>
<h3
id="what-are-the-time-and-space-complexities-for-the-sliding-window-solution">3.
What are the time and space complexities for the Sliding Window
solution?</h3>
<p>The time complexity for the Sliding Window solution is O(N). Here, N
is the number of blocks. The space complexity is O(1). This is because
we only need a few variables to keep track of the white blocks and the
window size.</p>
<h3
id="can-a-brute-force-approach-solve-the-minimum-recolors-problem">4.
Can a Brute Force approach solve the Minimum Recolors problem?</h3>
<p>Yes, a Brute Force approach can solve the Minimum Recolors to Get K
Consecutive Black Blocks problem. It checks every possible substring
that is K long. Then it counts the white blocks in each substring. But
this way is not very good. It has a time complexity of O(N*K), which is
slower than the sliding window method.</p>
<h3
id="are-there-any-variations-of-the-minimum-recolors-problem-in-coding-interviews">5.
Are there any variations of the Minimum Recolors problem in coding
interviews?</h3>
<p>Yes, we can find variations of the Minimum Recolors to Get K
Consecutive Black Blocks problem in coding interviews. These variations
may have different rules about colors. They may also ask for different
lengths for the sequence or other rules like maximizing black blocks
while minimizing recolors. Knowing about the sliding window and brute
force can help a lot in solving these variations well.</p>
<p>For more problems and solutions that are related, check out <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            