
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Count Hills and Valleys in an Array - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to easily count hills and valleys in an array with our step-by-step guide. Perfect for beginners and experts!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Count Hills and Valleys in an Array - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Counting hills and valleys in an array means we find elements that
are local maxima or local minima. A hill is when an element is bigger
than its neighbors. A valley is when an element is smaller than its
neighbors. To solve this, we need to go through the array and use this
definition to count the hills and valleys.</p>
<p>In this article, we will look at how to count hills and valleys in an
array. We will talk about different ways to solve it in the best way. We
will show how to do this in Java, Python, and C++. We will also check
how well different methods work. We will talk about time and space
complexity too. Also, we will point out edge cases, give tips for
testing our code, and answer common questions about this topic.</p>
<ul>
<li>Understanding the Problem of Counting Hills and Valleys in an
Array</li>
<li>Optimal Approach to Count Hills and Valleys in an Array</li>
<li>Java Implementation to Count Hills and Valleys in an Array</li>
<li>Python Code to Count Hills and Valleys in an Array</li>
<li>C++ Solution for Counting Hills and Valleys in an Array</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Time Complexity and Space Complexity of Counting Hills and
Valleys</li>
<li>Edge Cases in Counting Hills and Valleys</li>
<li>Tips for Testing Your Implementation</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="optimal-approach-to-count-hills-and-valleys-in-an-array">Optimal
Approach to Count Hills and Valleys in an Array</h2>
<p>We can count hills and valleys in an array with a simple method. This
method checks each number to see if it is a hill or a valley. A hill is
a number that is bigger than its neighbors. A valley is a number that is
smaller than its neighbors.</p>
<h3 id="steps-for-the-optimal-approach">Steps for the Optimal
Approach:</h3>
<ol type="1">
<li>Start with a counter set to zero.</li>
<li>Go through the array from the second number to the second last
number.</li>
<li>For each number, check:
<ul>
<li>If it is a hill:
<code>arr[i] &gt; arr[i-1] &amp;&amp; arr[i] &gt; arr[i+1]</code></li>
<li>If it is a valley:
<code>arr[i] &lt; arr[i-1] &amp;&amp; arr[i] &lt; arr[i+1]</code></li>
</ul></li>
<li>Add one to the counter for every hill or valley we find.</li>
<li>Finally, return the count.</li>
</ol>
<h3 id="time-complexity">Time Complexity:</h3>
<ul>
<li>The time complexity is O(n). This means we check each number only
once. Here n is the number of numbers in the array.</li>
</ul>
<h3 id="space-complexity">Space Complexity:</h3>
<ul>
<li>The space complexity is O(1). We only use a fixed amount of extra
space for the counter.</li>
</ul>
<h3 id="example-code-implementation">Example Code Implementation:</h3>
<h4 id="java">Java:</h4>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountHillsAndValleys <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countHillsAndValleys</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> arr<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">||</span> </span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>                <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]))</span> ) <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="python">Python:</h4>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_hills_and_valleys(arr):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (arr[i] <span class="op">&gt;</span> arr[i <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> arr[i] <span class="op">&gt;</span> arr[i <span class="op">+</span> <span class="dv">1</span>]) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>           (arr[i] <span class="op">&lt;</span> arr[i <span class="op">-</span> <span class="dv">1</span>] <span class="kw">and</span> arr[i] <span class="op">&lt;</span> arr[i <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h4 id="c">C++:</h4>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Solution <span class="op">{</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span><span class="op">:</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> countHillsAndValleys<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> arr<span class="op">.</span>size<span class="op">()</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">||</span> </span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>                <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a><span class="op">};</span></span></code></pre></div>
<p>This method counts hills and valleys in the array fast. We only check
the numbers once and use a small amount of space. This makes the
algorithm good for big datasets. For more examples and problems about
arrays, look at <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array:
Two Sum</a>.</p>
<h2 id="java-implementation-to-count-hills-and-valleys-in-an-array">Java
Implementation to Count Hills and Valleys in an Array</h2>
<p>To count hills and valleys in an array, we look for elements that
make a peak or a trough. A hill is an element that is bigger than its
neighboring elements. A valley is an element that is smaller than its
neighbors.</p>
<h3 id="java-code-implementation">Java Code Implementation</h3>
<p>Here is a simple Java code to count the number of hills and valleys
in an array:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> HillsAndValleys <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> array <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="fu">countHillsAndValleys</span><span class="op">(</span>array<span class="op">);</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Number of hills and valleys: &quot;</span> <span class="op">+</span> count<span class="op">);</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countHillsAndValleys</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> arr<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">((</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">||</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]))</span> ) <span class="op">{</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<p>The <code>countHillsAndValleys</code> function goes through the
array. It starts at the second element and stops at the second-to-last
element.</p>
<p>We check if the current element is either a hill or a valley. We do
this by comparing it with its neighbors. If it meets the condition of
being a hill or a valley, we add one to the count.</p>
<h3 id="example-execution">Example Execution</h3>
<p>For the input array <code>{2, 4, 1, 3, 5}</code>, the output will
be:</p>
<pre><code>Number of hills and valleys: 3</code></pre>
<p>This shows that we have three hills and valleys in the given
array.</p>
<p>This Java implementation is simple and clear. It works well for
counting hills and valleys in an array. If you want to learn more about
similar topics, check out <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
- Maximum Subarray - Easy</a>.</p>
<h2 id="python-code-to-count-hills-and-valleys-in-an-array">Python Code
to Count Hills and Valleys in an Array</h2>
<p>We can count hills and valleys in an array. A hill is a position
<code>i</code> where <code>arr[i-1] &lt; arr[i] &gt; arr[i+1]</code>. A
valley is where <code>arr[i-1] &gt; arr[i] &lt; arr[i+1]</code>. The
Python code below shows how to do this in a simple way.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_hills_and_valleys(arr):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (arr[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&lt;</span> arr[i] <span class="op">&gt;</span> arr[i <span class="op">+</span> <span class="dv">1</span>]) <span class="kw">or</span> (arr[i <span class="op">-</span> <span class="dv">1</span>] <span class="op">&gt;</span> arr[i] <span class="op">&lt;</span> arr[i <span class="op">+</span> <span class="dv">1</span>]):</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>array <span class="op">=</span> [<span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_hills_and_valleys(array)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Number of hills and valleys:&quot;</span>, result)</span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<p>We make a function called <code>count_hills_and_valleys</code>. It
takes an array <code>arr</code> as input. We start a counter
<code>count</code> at zero.</p>
<p>We go through the array from the second element to the second-to-last
element. For each element, we check if it is a hill or a valley by
looking at its neighbors. If we find a hill or a valley, we add one to
the <code>count</code>.</p>
<p>At the end, the function gives back the total count of hills and
valleys.</p>
<p>This Python code counts hills and valleys fast. It uses a linear time
of O(n). It also does not need extra space. This makes it good for this
problem. If you want to read more about array problems, you can check <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">this
article on array two sum</a>.</p>
<h2 id="c-solution-for-counting-hills-and-valleys-in-an-array">C++
Solution for Counting Hills and Valleys in an Array</h2>
<p>We can count hills and valleys in an array by going through the array
and checking each element with its neighbors. A hill is an element that
is bigger than both of its neighbors. A valley is an element that is
smaller than both of its neighbors.</p>
<p>Here is a simple C++ code for the solution:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countHillsAndValleys<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for a hill</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Check for a valley</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span> <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">};</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> countHillsAndValleys<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Number of hills and valleys: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-c-code">Explanation of the C++ Code:</h3>
<p>We define the function <code>countHillsAndValleys</code>. This
function takes a vector of integers as input.</p>
<p>First, we set a counter called <code>count</code> to zero. This
counter will keep track of how many hills and valleys we find.</p>
<p>Next, we loop through the array starting from the second element. We
stop at the second to last element. For each element, we check if it is
bigger than both neighbors. If it is, we have a hill. If it is smaller
than both neighbors, we have a valley. We increase the count when we
find a hill or a valley.</p>
<p>In the end, we return the total count.</p>
<p>This method runs in O(n) time. Here n is the number of elements in
the array. We only go through the array one time. The space we use is
O(1). We do not need extra space.</p>
<p>This code counts hills and valleys in an array well. It gives a clear
and easy solution for the problem. If you want to know more similar
topics, you can check articles like <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
- Maximum Subarray</a>.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we count hills and valleys in an array, we can use different
methods. Each method has its own pros and cons about how complex it is
and how fast it works. Here is a simple comparison of the most common
ways:</p>
<ol type="1">
<li><strong>Brute Force Approach</strong>:
<ul>
<li><strong>Description</strong>: We check each element in the array
against its neighbors.</li>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
<li><strong>Pros</strong>: Easy to understand and use.</li>
<li><strong>Cons</strong>: Not good for large datasets because it needs
many comparisons.</li>
</ul>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countHillsAndValleys</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> arr<span class="op">.</span><span class="fu">length</span> <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">((</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">])</span> <span class="op">||</span> </span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>            <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">&lt;</span> arr<span class="op">[</span>i <span class="op">+</span> <span class="dv">1</span><span class="op">]))</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>            count<span class="op">++;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><strong>Single Pass Approach</strong>:
<ul>
<li><strong>Description</strong>: We go through the array once and
remember the last two elements and the current one.</li>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
<li><strong>Pros</strong>: Works better than brute force; less repeated
checks.</li>
<li><strong>Cons</strong>: A bit harder to implement.</li>
</ul>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_hills_and_valleys(arr):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">&lt;</span> <span class="dv">3</span>:</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    prev <span class="op">=</span> arr[<span class="dv">0</span>]</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    curr <span class="op">=</span> arr[<span class="dv">1</span>]</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(arr)):</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        next_elem <span class="op">=</span> arr[i]</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (curr <span class="op">&gt;</span> prev <span class="kw">and</span> curr <span class="op">&gt;</span> next_elem) <span class="kw">or</span> (curr <span class="op">&lt;</span> prev <span class="kw">and</span> curr <span class="op">&lt;</span> next_elem):</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        prev, curr <span class="op">=</span> curr, next_elem</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div></li>
<li><strong>Using Stack or List</strong>:
<ul>
<li><strong>Description</strong>: We use a stack to remember the hills
and valleys while going through the array.</li>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) in the worst case.</li>
<li><strong>Pros</strong>: Good for when we need to keep the structure
of hills and valleys.</li>
<li><strong>Cons</strong>: Takes more space because of the stack.</li>
</ul></li>
<li><strong>Dynamic Programming</strong>:
<ul>
<li><strong>Description</strong>: We save results of small problems to
avoid doing the same work again.</li>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(n) for saving results.</li>
<li><strong>Pros</strong>: Works well for large datasets.</li>
<li><strong>Cons</strong>: Needs extra work to keep a DP table.</li>
</ul></li>
<li><strong>Optimal Approach</strong>:
<ul>
<li><strong>Description</strong>: We mix the single pass and state
management to do fewer comparisons.</li>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
<li><strong>Pros</strong>: Very efficient and uses little space.</li>
<li><strong>Cons</strong>: May need a better understanding of how arrays
work.</li>
</ul></li>
</ol>
<p>In real life, the method we choose depends on the problem’s limits.
This includes how big the input array is and how important speed is
compared to space. If we want to learn more about similar array
problems, we can check out <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2
id="time-complexity-and-space-complexity-of-counting-hills-and-valleys">Time
Complexity and Space Complexity of Counting Hills and Valleys</h2>
<p>When we look at the time and space complexity of counting hills and
valleys in an array, we think about how we go through the elements of
the array. We want to find peaks, which we call hills, and troughs,
which we call valleys.</p>
<h3 id="time-complexity-1">Time Complexity</h3>
<p>The time complexity for the algorithm is O(n). Here, n is the number
of elements in the array. We go through the array one time. We check
each element to see if it is a hill or a valley.</p>
<ul>
<li>For each element at index <code>i</code> (from 1 to n-2), we check:
<ul>
<li>If <code>arr[i] &gt; arr[i-1]</code> and
<code>arr[i] &gt; arr[i+1]</code>, then it is a hill.</li>
<li>If <code>arr[i] &lt; arr[i-1]</code> and
<code>arr[i] &lt; arr[i+1]</code>, then it is a valley.</li>
</ul></li>
</ul>
<p>This means we do a constant amount of work for each of the n-2
elements. So, we have O(n) time complexity.</p>
<h3 id="space-complexity-1">Space Complexity</h3>
<p>The space complexity for counting hills and valleys is O(1). We do
not need extra space that grows with the size of the input array. We
only need a little extra space for some counters and temporary
values.</p>
<h3 id="summary">Summary</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)</li>
<li><strong>Space Complexity</strong>: O(1)</li>
</ul>
<p>This algorithm works well. It helps us count hills and valleys in an
array without needing extra data structures. This makes it good for
large input sizes.</p>
<h2 id="edge-cases-in-counting-hills-and-valleys">Edge Cases in Counting
Hills and Valleys</h2>
<p>When we count hills and valleys in an array, we need to think about
some special cases. These cases can change the results. Here are some
important edge cases we should remember:</p>
<ul>
<li><p><strong>Minimum Length Array</strong>: If an array has less than
three elements, it can’t have any hills or valleys.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> <span class="fu">countHillsAndValleys</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>arr<span class="op">.</span><span class="fu">length</span> <span class="op">&lt;</span> <span class="dv">3</span><span class="op">)</span> <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Continue with counting logic...</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div></li>
<li><p><strong>All Elements Same</strong>: If all elements in the array
are equal, it will have zero hills and valleys. For example, if we have
<code>[2, 2, 2]</code>, the result is <code>0</code>.</p></li>
<li><p><strong>Strictly Increasing or Decreasing Array</strong>: If an
array is only increasing or only decreasing, it will also have no hills
or valleys. For example, <code>[1, 2, 3]</code> or
<code>[3, 2, 1]</code> both result in <code>0</code>.</p></li>
<li><p><strong>Plateau Cases</strong>: An array that has plateaus, like
<code>[1, 2, 2, 2, 1]</code>, can be confusing. The plateaus do not
count as hills or valleys. In this example, we have <code>1 hill</code>
and <code>1 valley</code>.</p></li>
<li><p><strong>Alternating Highs and Lows</strong>: If an array changes
between high and low values, it can have many hills and valleys. For
example, <code>[1, 3, 1, 3, 1]</code> gives us <code>2 hills</code> and
<code>2 valleys</code>.</p></li>
<li><p><strong>Boundary Elements</strong>: The first and last elements
of the array cannot be counted as hills or valleys. They do not have two
neighbors to compare with.</p></li>
<li><p><strong>Negative and Positive Values</strong>: The sign of the
numbers does not change the counting of hills and valleys. What matters
is their position. For example, <code>[-1, 1, -1]</code> has
<code>1 hill</code> and <code>1 valley</code>.</p></li>
<li><p><strong>Single Peak or Valley</strong>: Arrays like
<code>[1, 3, 2]</code> have <code>1 hill</code> but no valleys. On the
other hand, <code>[2, 1, 3]</code> has <code>1 valley</code> but no
hills.</p></li>
</ul>
<p>By keeping these edge cases in mind, we can make sure our counting of
hills and valleys is correct. We should also add tests for these cases
in our unit tests to check our solution well.</p>
<h2 id="tips-for-testing-your-implementation">Tips for Testing Your
Implementation</h2>
<p>When we make a solution to count hills and valleys in an array, we
need to test it well. This helps us make sure it works right and is
reliable. Here are some important tips for testing our
implementation:</p>
<ol type="1">
<li><strong>Basic Test Cases</strong>:
<ul>
<li><p>We should start with simple arrays to check if the basic function
works. For example:</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> array1 <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Expected Output: 4 (hills: 2, valleys: 2)</span></span></code></pre></div></li>
</ul></li>
<li><strong>Edge Cases</strong>:
<ul>
<li><p>We need to test with edge cases like arrays that have fewer than
three elements:</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>array2 <span class="op">=</span> [<span class="dv">1</span>]</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Expected Output: 0 </span></span></code></pre></div></li>
<li><p>Arrays where all elements are the same should also give us
zero:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> array3<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Expected Output: 0</span></span></code></pre></div></li>
</ul></li>
<li><strong>Large Arrays</strong>:
<ul>
<li>We can use large arrays to check if our solution performs well. It
should handle a lot of data without slowing down.</li>
</ul>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>large_array <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>] <span class="op">*</span> <span class="dv">1000</span></span></code></pre></div></li>
<li><strong>Randomly Generated Arrays</strong>:
<ul>
<li>We can create random arrays to see how well our implementation works
with different patterns:</li>
</ul>
<div class="sourceCode" id="cb15"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> randomArray <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">};</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Manually count hills and valleys to check output.</span></span></code></pre></div></li>
<li><strong>Arrays with Multiple Peaks and Valleys</strong>:
<ul>
<li>We should test arrays that have many hills and valleys. This helps
us make sure the counting logic is strong:</li>
</ul>
<div class="sourceCode" id="cb16"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> testArray<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">5</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">};</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="co">// Expected Output: Check manually for hills and valleys.</span></span></code></pre></div></li>
<li><strong>Negative and Positive Values</strong>:
<ul>
<li>We need to confirm our implementation works well with both negative
and positive numbers:</li>
</ul>
<div class="sourceCode" id="cb17"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>array_with_negatives <span class="op">=</span> [<span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="op">-</span><span class="dv">1</span>]<span class="op">;</span></span></code></pre></div></li>
<li><strong>Debugging Outputs</strong>:
<ul>
<li>We can add logging or print statements to our code. This helps us
track how the code runs and how the variables change at different
times.</li>
</ul></li>
<li><strong>Unit Tests</strong>:
<ul>
<li>We should make unit tests with tools like JUnit for Java, unittest
for Python, or Google Test for C++. This helps us automate testing and
find any problems quickly.</li>
</ul></li>
<li><strong>Check for Off-By-One Errors</strong>:
<ul>
<li>We need to be careful with the edges of our loops. Sometimes, we can
miss hills and valleys if the loop does not check the right
indexes.</li>
</ul></li>
<li><strong>Compare Outputs</strong>:
<ul>
<li>If we have different implementations, we can compare their outputs
for the same input arrays. This helps us check if they are consistent
and correct.</li>
</ul></li>
</ol>
<p>By using these tips for testing our implementation of the hills and
valleys counting algorithm, we can make sure our solution is strong,
works fast, and has no major errors.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-are-hills-and-valleys-in-an-array">1. What are hills and
valleys in an array?</h3>
<p>Hills and valleys in an array are like the peaks and dips we can see
if we draw the elements. A hill happens when one number is bigger than
the ones next to it. A valley is when one number is smaller than its
neighbors. It is important to know how to count these hills and valleys.
This helps us with trends and patterns in data analysis.</p>
<h3 id="how-can-i-efficiently-count-hills-and-valleys-in-an-array">2.
How can I efficiently count hills and valleys in an array?</h3>
<p>To count hills and valleys fast in an array, we can go through the
array starting from the second element. We compare each number with the
ones next to it. This way works in O(n) time, which is good for big sets
of data. We can write this logic in programming languages like Java,
Python, or C++. It will work well.</p>
<h3
id="what-is-the-time-complexity-for-counting-hills-and-valleys-in-an-array">3.
What is the time complexity for counting hills and valleys in an
array?</h3>
<p>The time complexity for counting hills and valleys is O(n). Here, n
is the number of elements in the array. This efficiency comes from
checking each number with its neighbors just once. We do this in one go
through the array. This way, we get the best performance.</p>
<h3
id="can-you-provide-an-example-of-counting-hills-and-valleys-in-python">4.
Can you provide an example of counting hills and valleys in Python?</h3>
<p>Sure! Here is a simple Python code to count hills and valleys in an
array:</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_hills_and_valleys(arr):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(arr) <span class="op">-</span> <span class="dv">1</span>):</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> (arr[i] <span class="op">&gt;</span> arr[i<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> arr[i] <span class="op">&gt;</span> arr[i<span class="op">+</span><span class="dv">1</span>]) <span class="kw">or</span> (arr[i] <span class="op">&lt;</span> arr[i<span class="op">-</span><span class="dv">1</span>] <span class="kw">and</span> arr[i] <span class="op">&lt;</span> arr[i<span class="op">+</span><span class="dv">1</span>]):</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>array <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">1</span>]</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(count_hills_and_valleys(array))  <span class="co"># Output: 3</span></span></code></pre></div>
<h3
id="are-there-edge-cases-to-consider-when-counting-hills-and-valleys">5.
Are there edge cases to consider when counting hills and valleys?</h3>
<p>Yes, we must think about edge cases when counting hills and valleys.
For example, if the array has less than three elements, it cannot have
hills or valleys. Also, if all elements are the same or if the numbers
only go up or down, we should check this too, as it might give us a
count of zero. Handling these cases makes our code stronger.</p>
<p>For more reading on related array problems, please look at articles
on <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Two
Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-best-time-to-buy-and-sell-stock-easy.html">Best
Time to Buy and Sell Stock</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            