
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Squares of a Sorted Array - Easy</title>
            <meta name="description" content="Discover how to efficiently compute the squares of a sorted array with our easy guide. Perfect for beginners and coding enthusiasts!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Squares of a Sorted Array - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The “Squares of a Sorted Array” problem is about changing an array of
integers. This array is sorted in non-decreasing order. We need to
create a new array. Each element in the new array will be the square of
the original elements. This new array also needs to be sorted in
non-decreasing order. We can do this task easily using different
methods. We can take advantage of the fact that the input array is
already sorted. This helps us to make the squaring and sorting
faster.</p>
<p>In this article, we will look at different ways to solve the “Squares
of a Sorted Array” problem. We will check the best method using two
pointers in Java, Python, and C++. We will also see a simple method for
each of these programming languages. After that, we will compare these
methods. We will also look at their time and space complexities.
Finally, we will answer some common questions about this topic.</p>
<ul>
<li>Understanding Array Squares of a Sorted Array Easy Problem</li>
<li>Optimal Approach Using Two Pointers in Java</li>
<li>Optimal Approach Using Two Pointers in Python</li>
<li>Optimal Approach Using Two Pointers in C++</li>
<li>Naive Approach for Array Squares in Java</li>
<li>Naive Approach for Array Squares in Python</li>
<li>Naive Approach for Array Squares in C++</li>
<li>Comparative Analysis of Approaches for Array Squares</li>
<li>Time Complexity and Space Complexity Analysis</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more information on array manipulation, we can check related
topics like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2 id="optimal-approach-using-two-pointers-in-java">Optimal Approach
Using Two Pointers in Java</h2>
<p>We can solve the problem of squaring a sorted array by using the
two-pointer technique. This method helps us arrange the squares in
non-decreasing order. We do not need to sort again since the original
array is already sorted.</p>
<h3 id="implementation-steps">Implementation Steps</h3>
<ol type="1">
<li><strong>Initialize Pointers</strong>: We start with two pointers.
One pointer is at the beginning (<code>left</code>) and the other is at
the end (<code>right</code>) of the array.</li>
<li><strong>Create Result Array</strong>: We make a new array to hold
the squared values.</li>
<li><strong>Fill Result Array</strong>: We go from the end of the result
array to the beginning. We compare the absolute values at the
<code>left</code> and <code>right</code> pointers:
<ul>
<li>If the absolute value at <code>left</code> is bigger, we square it.
Then we put this value in the current position of the result array.
After that, we move the <code>left</code> pointer to the right.</li>
<li>If not, we square the value at the <code>right</code> pointer, put
it in the result array, and move the <code>right</code> pointer to the
left.</li>
</ul></li>
<li><strong>Continue Until Pointers Meet</strong>: We repeat this until
the <code>left</code> pointer goes beyond the <code>right</code>
pointer.</li>
</ol>
<h3 id="java-code-example">Java Code Example</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SquaresOfSortedArray <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">sortedSquares</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> left <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> right <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span><span class="bu">Math</span><span class="op">.</span><span class="fu">abs</span><span class="op">(</span>nums<span class="op">[</span>left<span class="op">])</span> <span class="op">&gt;</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">abs</span><span class="op">(</span>nums<span class="op">[</span>right<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>left<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>left<span class="op">];</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                left<span class="op">++;</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>                result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>right<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>right<span class="op">];</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>                right<span class="op">--;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li>The <code>sortedSquares</code> method takes an integer array
<code>nums</code> as input.</li>
<li>We create the result array with the same size as
<code>nums</code>.</li>
<li>We use a for loop to fill the <code>result</code> array from the end
to the start. We do this based on the comparison of squared values from
the <code>left</code> and <code>right</code> pointers.</li>
<li>In the end, we return the sorted array of squares.</li>
</ul>
<p>This method helps us calculate the squares of a sorted array quickly.
We get a time complexity of O(n) and a space complexity of O(n). This
makes it a good choice for solving this problem.</p>
<h2 id="optimal-approach-using-two-pointers-in-python">Optimal Approach
Using Two Pointers in Python</h2>
<p>We can solve the “Squares of a Sorted Array” problem in Python by
using the two-pointer technique. This method helps us handle the sorted
array well. We can find the squares in one go while keeping them in
order.</p>
<h3 id="algorithm-steps">Algorithm Steps:</h3>
<ol type="1">
<li>We start with two pointers. One pointer is at the start
(<code>left</code>) and the other is at the end (<code>right</code>) of
the array.</li>
<li>We make an output array to keep the squares in sorted order.</li>
<li>We will loop while <code>left</code> is less than or equal to
<code>right</code>:
<ul>
<li>We compare the absolute values of the numbers at both pointers.</li>
<li>We square the bigger absolute value and put it at the end of the
output array.</li>
<li>We move the pointer that had the bigger value inward.</li>
</ul></li>
<li>We keep going until we process all the numbers.</li>
</ol>
<h3 id="python-code">Python Code:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sortedSquares(nums):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    left, right <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="bu">len</span>(nums)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    position <span class="op">=</span> <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&lt;=</span> right:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">abs</span>(nums[left]) <span class="op">&gt;</span> <span class="bu">abs</span>(nums[right]):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>            result[position] <span class="op">=</span> nums[left] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>            left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>            result[position] <span class="op">=</span> nums[right] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>            right <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        position <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<h3 id="example">Example:</h3>
<p>If we have an input array <code>nums = [-4, -1, 0, 3, 10]</code>, the
output will be:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(sortedSquares([<span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">10</span>]))  <span class="co"># Output: [0, 1, 9, 16, 100]</span></span></code></pre></div>
<p>This way runs in O(n) time, where n is the number of items in the
array. It also uses O(n) space for the result array. This method is good
because it lets us handle the squares of a sorted array well while
keeping the order in the results.</p>
<p>For more reading on similar problems, check <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2 id="optimal-approach-using-two-pointers-in-c">Optimal Approach Using
Two Pointers in C++</h2>
<p>We can solve the problem of finding the squares of a sorted array
using the two-pointer method. This way is simple and it helps us create
a new array with the squares of the original numbers while keeping the
order. Here’s how we do it:</p>
<ol type="1">
<li><strong>Initialization</strong>: We set two pointers. One pointer is
at the start (<code>left</code>) and the other is at the end
(<code>right</code>) of the input array.</li>
<li><strong>Comparison</strong>: We compare the absolute values of the
numbers at both pointers. We will place the bigger square at the end of
the result array.</li>
<li><strong>Placement</strong>: We move the pointer closer (we can move
the <code>left</code> pointer up or the <code>right</code> pointer down)
based on which value is bigger.</li>
<li><strong>Result Construction</strong>: We fill the result array from
the end to the start.</li>
</ol>
<p>Here’s the C++ code for this method:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sortedSquares<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> right <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> <span class="op">--</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span><span class="bu">std::</span>abs<span class="op">(</span>nums<span class="op">[</span>left<span class="op">])</span> <span class="op">&gt;</span> <span class="bu">std::</span>abs<span class="op">(</span>nums<span class="op">[</span>right<span class="op">]))</span> <span class="op">{</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>left<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>left<span class="op">];</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>            left<span class="op">++;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>right<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>right<span class="op">];</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            right<span class="op">--;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-points">Key Points:</h3>
<ul>
<li>The time complexity is O(n). Here, n is the number of items in the
input array.</li>
<li>The space complexity is also O(n) because we need the output
array.</li>
<li>This method makes sure the squares are sorted without needing to
sort again.</li>
</ul>
<p>We can use this fast two-pointer technique in other problems too. For
example, we can look at problems like <a
href="https://bestonlinetutorial.com/array/array-best-time-to-buy-and-sell-stock-easy.html">Array
Best Time to Buy and Sell Stock</a> to learn more about working with
arrays.</p>
<h2 id="naive-approach-for-array-squares-in-java">Naive Approach for
Array Squares in Java</h2>
<p>We can solve the “Squares of a Sorted Array” problem in Java using a
simple way. This method looks at each number in the input array. We
square each number and save the results in a new array. This way does
not use the fact that the array is sorted. It has a time complexity of
O(n). Here n is the number of elements in the input array.</p>
<p>Here is how we can write the naive approach in Java:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> SquaresOfSortedArray <span class="op">{</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">sortedSquares</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>result<span class="op">);</span> <span class="co">// Sorting the squared values</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> input <span class="op">=</span> <span class="op">{-</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> output <span class="op">=</span> <span class="fu">sortedSquares</span><span class="op">(</span>input<span class="op">);</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="bu">Arrays</span><span class="op">.</span><span class="fu">toString</span><span class="op">(</span>output<span class="op">));</span> <span class="co">// Output: [0, 1, 9, 16, 100]</span></span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-points-1">Key Points:</h3>
<ul>
<li>We square each number and then sort the new array.</li>
<li>This way is easy to understand but not fast for big lists because of
the sorting.</li>
<li>The total time complexity is O(n log n) because we need to sort the
data.</li>
</ul>
<p>This naive way can be a good start. But if we want to make it better,
we can use other methods, like the two-pointer technique.</p>
<h2 id="naive-approach-for-array-squares-in-python">Naive Approach for
Array Squares in Python</h2>
<p>We can use the naive approach to square a sorted array. This means we
go through the array. We square each number. Then, we return a new
array. This method does not use the fact that the input array is sorted.
So, we get a time complexity of O(n) for squaring. Then, we have O(n log
n) for sorting the new array.</p>
<p>Here is how we can do it in Python:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sortedSquares(nums):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Square each number in the array</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    squared <span class="op">=</span> [x <span class="op">*</span> x <span class="cf">for</span> x <span class="kw">in</span> nums]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Sort the squared numbers</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    squared.sort()</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> squared</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="op">-</span><span class="dv">4</span>, <span class="op">-</span><span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">3</span>, <span class="dv">10</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> sortedSquares(nums)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: [0, 1, 9, 16, 100]</span></span></code></pre></div>
<p>In this code, we use a list comprehension to square each number. Then
we use the <code>sort()</code> function to sort the squared numbers.
This method is simple. But it is not the best for big datasets. The
extra sorting step is not needed when we can use better methods.</p>
<p>For better ways to handle arrays, we can check out the two-pointer
technique. This is in the sections about optimal approaches. If we want
to see similar problems, we can read articles like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2 id="naive-approach-for-array-squares-in-c">Naive Approach for Array
Squares in C++</h2>
<p>The naive way to find the squares of a sorted array is to go through
each item in the array. We square the number and then put the squared
numbers in a new array. This way is simple but not very good in time and
space when we compare it to better methods.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is a simple C++ code for the naive approach:</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sortedSquares<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">(</span>nums<span class="op">.</span>size<span class="op">());</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>result<span class="op">.</span>begin<span class="op">(),</span> result<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{-</span><span class="dv">4</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">10</span><span class="op">};</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> squared <span class="op">=</span> sortedSquares<span class="op">(</span>nums<span class="op">);</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> squared<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> num <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li>First, the algorithm makes a result vector that is the same size as
the input array.</li>
<li>Then, it goes through each number in the input array, squares it,
and puts that in the same place in the result vector.</li>
<li>After we square all the numbers, we sort the result vector to keep
the order.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li>The time complexity is O(n log n) because of the sorting step. Here,
n is the number of items in the input array.</li>
</ul>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li>The space complexity is O(n) since we use another array to keep the
squared numbers.</li>
</ul>
<p>This naive way works fine for small arrays but is not the best for
bigger data sets. For a better solution, we can use the two-pointer
method which can get O(n) time complexity.</p>
<p>For more related problems, we can look at <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2
id="comparative-analysis-of-approaches-for-array-squares">Comparative
Analysis of Approaches for Array Squares</h2>
<p>When we solve the problem of squaring a sorted array, we can use two
main ways. One is the optimal two-pointer technique. The other is the
naive approach. Let us look at both methods.</p>
<h3 id="optimal-approach-using-two-pointers">Optimal Approach Using Two
Pointers</h3>
<p>The two-pointer technique is good for this problem. It uses the
sorted nature of the array. One pointer starts at the beginning (left)
and the other at the end (right) of the array. We compute squares from
both ends. The larger squared value goes into the result array from the
end to the beginning.</p>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">sortedSquares</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> right <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> index <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>left <span class="op">&lt;=</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftSquare <span class="op">=</span> nums<span class="op">[</span>left<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>left<span class="op">];</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightSquare <span class="op">=</span> nums<span class="op">[</span>right<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>right<span class="op">];</span></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>leftSquare <span class="op">&gt;</span> rightSquare<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>index<span class="op">--]</span> <span class="op">=</span> leftSquare<span class="op">;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            left<span class="op">++;</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>index<span class="op">--]</span> <span class="op">=</span> rightSquare<span class="op">;</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            right<span class="op">--;</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sortedSquares(nums):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    result <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> n</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    left, right, index <span class="op">=</span> <span class="dv">0</span>, n <span class="op">-</span> <span class="dv">1</span>, n <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> left <span class="op">&lt;=</span> right:</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        leftSquare <span class="op">=</span> nums[left] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        rightSquare <span class="op">=</span> nums[right] <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> leftSquare <span class="op">&gt;</span> rightSquare:</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>            result[index] <span class="op">=</span> leftSquare</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>            left <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>            result[index] <span class="op">=</span> rightSquare</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>            right <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>        index <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sortedSquares<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">(</span>n<span class="op">);</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> left <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> right <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> index <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(</span>left <span class="op">&lt;=</span> right<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> leftSquare <span class="op">=</span> nums<span class="op">[</span>left<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>left<span class="op">];</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightSquare <span class="op">=</span> nums<span class="op">[</span>right<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>right<span class="op">];</span></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>leftSquare <span class="op">&gt;</span> rightSquare<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>index<span class="op">--]</span> <span class="op">=</span> leftSquare<span class="op">;</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>            left<span class="op">++;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>            result<span class="op">[</span>index<span class="op">--]</span> <span class="op">=</span> rightSquare<span class="op">;</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            right<span class="op">--;</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="naive-approach">Naive Approach</h3>
<p>The naive approach squares each element in the original array. Then
we sort the new array. This method is easier but not as efficient,
especially for big arrays.</p>
<p><strong>Java Implementation:</strong></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">sortedSquares</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        nums<span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>nums<span class="op">);</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nums<span class="op">;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p><strong>Python Implementation:</strong></p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sortedSquares(nums):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sorted</span>(x <span class="op">*</span> x <span class="cf">for</span> x <span class="kw">in</span> nums)</span></code></pre></div>
<p><strong>C++ Implementation:</strong></p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> sortedSquares<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span><span class="op">&amp;</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>        num <span class="op">*=</span> num<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    sort<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> nums<span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Time Complexity:</strong>
<ul>
<li>Optimal Approach: O(n) because we make one pass through the array
with two pointers.</li>
<li>Naive Approach: O(n log n) because we need to sort the squared
values.</li>
</ul></li>
<li><strong>Space Complexity:</strong>
<ul>
<li>Both ways need O(n) space for the output array.</li>
</ul></li>
</ul>
<p>We prefer the two-pointer technique because it has linear time
complexity. This makes it better for larger datasets than the naive
sorting method. For more about array manipulation, we can read articles
like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2 id="time-complexity-and-space-complexity-analysis">Time Complexity
and Space Complexity Analysis</h2>
<p>We can solve the problem of finding the squares of a sorted array in
different ways. Each way has its own time and space complexity.</p>
<h3 id="optimal-approach-using-two-pointers-1">Optimal Approach Using
Two Pointers</h3>
<ul>
<li><p><strong>Time Complexity</strong>: O(n)<br />
We go through the array one time to fill the result array. This means it
takes linear time.</p></li>
<li><p><strong>Space Complexity</strong>: O(n)<br />
We create a separate result array to keep the squares of the
elements.</p></li>
</ul>
<h3 id="naive-approach-1">Naive Approach</h3>
<ul>
<li><p><strong>Time Complexity</strong>: O(n)<br />
The naive way also goes through the input array one time. It calculates
and stores each square.</p></li>
<li><p><strong>Space Complexity</strong>: O(n)<br />
Like the optimal way, it needs extra space for the results.</p></li>
</ul>
<h3 id="comparative-analysis">Comparative Analysis</h3>
<p>For both the optimal and naive ways, the time complexity stays linear
(O(n)). This shows good performance even with bigger arrays. But we may
choose a method based on things like space limits or how easy it is to
do.</p>
<p>In short, both ways can do the job of squaring elements in a sorted
array. They keep a linear time complexity and need linear space for the
output.</p>
<p>For more reading on similar array problems, we can check these
articles: - <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray - Easy</a> - <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array - Easy</a></p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-problem-statement-for-squares-of-a-sorted-array">1.
What is the problem statement for Squares of a Sorted Array?</h3>
<p>The “Squares of a Sorted Array” problem is about changing a sorted
integer array. We need to replace each number with its square. Then we
return a new array that is also sorted. This task is important for
working with sorted data. It is a common problem for beginners. Knowing
this problem helps us understand more complex tasks with arrays.</p>
<h3
id="how-can-i-solve-the-squares-of-a-sorted-array-problem-using-the-two-pointer-technique">2.
How can I solve the Squares of a Sorted Array problem using the
two-pointer technique?</h3>
<p>To solve the “Squares of a Sorted Array” problem well, we can use a
two-pointer method. We start with one pointer at the start of the array
and another at the end. We compare the squares of the numbers at both
pointers. Then we fill a new result array from the back to the front.
This way, we keep a good time complexity of O(n). This makes it a good
solution.</p>
<h3
id="what-is-the-time-complexity-of-the-optimal-solution-for-this-problem">3.
What is the time complexity of the optimal solution for this
problem?</h3>
<p>The best solution for the “Squares of a Sorted Array” problem uses
the two-pointer method. Its time complexity is O(n). Each element in the
array is processed once. On the other hand, the simple method has a
higher time complexity because it needs to sort again. This makes the
best method much better for bigger datasets.</p>
<h3
id="can-you-give-an-example-of-the-naive-approach-to-solve-this-problem">4.
Can you give an example of the naive approach to solve this
problem?</h3>
<p>In the simple approach for the “Squares of a Sorted Array” problem,
we first square each element of the array. Then we sort the new array.
Here is a simple Java example:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span><span class="op">[]</span> <span class="fu">sortedSquares</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span><span class="op">[]</span> squares <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>nums<span class="op">.</span><span class="fu">length</span><span class="op">];</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>        squares<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> nums<span class="op">[</span>i<span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Arrays</span><span class="op">.</span><span class="fu">sort</span><span class="op">(</span>squares<span class="op">);</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> squares<span class="op">;</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This method works, but it is not as good as the two-pointer
method.</p>
<h3 id="where-can-i-find-more-resources-on-similar-array-problems">5.
Where can I find more resources on similar array problems?</h3>
<p>If we want to learn more about array problems and algorithms, we can
look at articles on related topics. For example, we can check out the <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
- Two Sum</a> problem. This is another basic challenge that uses similar
ideas. These resources can help us see more about how to work with
arrays.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            