
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Largest Positive Integer That Exists With Its Negative - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover the largest positive integer that exists with its negative in our easy guide. Learn insights and examples now!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Largest Positive Integer That Exists With Its Negative - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>To find the biggest positive number in an array that has a negative
version, we can use a simple and fast method. We look through the array.
We check if both the number and its negative are there. This way, we can
find the highest number that fits this rule. This method helps us solve
the problem quickly.</p>
<p>In this article, we will look closely at the problem. We will talk
about different ways to solve it. We will use HashSet in Java. We will
show how to do it in Python too. We will also use C++ with unordered
sets. We will explain how to make the solution faster. We will discuss
how to handle special cases. We will analyze the complexity of different
methods. Finally, we will share some good tips for working with arrays.
By the end, we will understand how to find the biggest positive number
that has its negative in an array.</p>
<ul>
<li>[Array] Finding Largest Positive Integer With Its Negative -
Easy</li>
<li>Understanding the Problem Statement</li>
<li>Approach Using HashSet in Java</li>
<li>Implementing the Solution in Python</li>
<li>C++ Solution Using Unordered Set</li>
<li>Optimizing the Solution for Performance</li>
<li>Handling Edge Cases in Arrays</li>
<li>Complexity Analysis of Different Approaches</li>
<li>Best Practices for Array Manipulation</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on similar array problems, we can check these
articles: <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a>, <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate</a>, and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2 id="understanding-the-problem-statement">Understanding the Problem
Statement</h2>
<p>We need to find the biggest positive number in an array. This number
should have its negative version also in the same array. For example, in
the array <code>[-1, 2, 3, -2]</code>, we see that <code>2</code> is
valid because <code>-2</code> is also there. We can explain the task
like this:</p>
<ul>
<li><strong>Input</strong>: An array of numbers (both positive and
negative).</li>
<li><strong>Output</strong>: The biggest positive number that has its
negative version in the array. If there is no such number, we return
0.</li>
</ul>
<h3 id="example-cases">Example Cases</h3>
<ol type="1">
<li><strong>Input</strong>: <code>[3, 2, -3, 4, -4]</code>
<ul>
<li><strong>Output</strong>: <code>4</code> (We have both <code>4</code>
and <code>-4</code>)</li>
</ul></li>
<li><strong>Input</strong>: <code>[1, -1, 2, -2, 3]</code>
<ul>
<li><strong>Output</strong>: <code>3</code> (Only <code>1</code> and
<code>-1</code>, <code>2</code> and <code>-2</code> are there)</li>
</ul></li>
<li><strong>Input</strong>: <code>[1, 2, 3]</code>
<ul>
<li><strong>Output</strong>: <code>0</code> (No negative versions)</li>
</ul></li>
</ol>
<p>We can solve this problem in a good way using different data
structures and methods. We will look at these in the next sections.</p>
<h2 id="approach-using-hashset-in-java">Approach Using HashSet in
Java</h2>
<p>To find the largest positive number that has its negative in an
array, we can use a <code>HashSet</code> in Java. This way helps us to
look up values quickly.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><strong>Create a HashSet</strong> to keep the absolute values of
numbers from the array.</li>
<li><strong>Go through the array</strong> and add the absolute values to
the HashSet.</li>
<li><strong>For each positive number</strong> in the HashSet, check if
its negative version exists.</li>
<li><strong>Keep track of the largest positive number</strong> that has
its negative.</li>
</ol>
<h3 id="code-implementation">Code Implementation:</h3>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashSet</span><span class="op">;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LargestPositiveInteger <span class="op">{</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">findLargestPositiveInteger</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HashSet</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> set <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> maxPositive <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>            set<span class="op">.</span><span class="fu">add</span><span class="op">(</span><span class="bu">Math</span><span class="op">.</span><span class="fu">abs</span><span class="op">(</span>num<span class="op">));</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> set<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> set<span class="op">.</span><span class="fu">contains</span><span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>                maxPositive <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>maxPositive<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> maxPositive <span class="op">==</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> maxPositive<span class="op">;</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Largest Positive Integer with its Negative: &quot;</span> <span class="op">+</span> <span class="fu">findLargestPositiveInteger</span><span class="op">(</span>nums<span class="op">));</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation:</h3>
<ul>
<li>We use <code>Math.abs(num)</code> to deal with both positive and
negative numbers.</li>
<li><code>set.contains(-num)</code> checks if the negative version
exists.</li>
<li>We update the maximum positive number during the loop.</li>
</ul>
<p>This method is fast and works in O(n) time, where n is how many
elements are in the array. The space needed is also O(n) because of the
HashSet.</p>
<p>This way is good when we need quick access to numbers. It is great
for problems with array handling. For more on array methods, look at <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum - Easy</a>.</p>
<h2 id="implementing-the-solution-in-python">Implementing the Solution
in Python</h2>
<p>To find the largest positive number in an array that has its matching
negative number, we can use a simple way in Python. We will use a set
for fast lookups. This helps us to check if both the positive and
negative numbers are there quickly.</p>
<h3 id="python-implementation">Python Implementation</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> findLargestInteger(arr):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    num_set <span class="op">=</span> <span class="bu">set</span>(arr)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    largest_positive <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> num_set:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">-</span>num <span class="kw">in</span> num_set:</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>            largest_positive <span class="op">=</span> <span class="bu">max</span>(largest_positive, num)</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest_positive <span class="cf">if</span> largest_positive <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">else</span> <span class="va">None</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">1</span>, <span class="op">-</span><span class="dv">3</span>, <span class="dv">2</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">2</span>, <span class="dv">5</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> findLargestInteger(arr)</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 3</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ul>
<li>We start by making a set from the input array <code>arr</code>. This
gives O(1) average time for lookups.</li>
<li>We go through the set and check if a positive number has its
negative number in the set too.</li>
<li>We keep track of the biggest positive number we find that fits the
rule.</li>
<li>In the end, we return the largest positive number or
<code>None</code> if we do not find any.</li>
</ul>
<p>This way is quick with a time cost of O(n) and space cost of O(n).
Here n is the size of the input array.</p>
<p>For more problems about arrays, you can look at <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array:
Contains Duplicate - Easy</a>.</p>
<h2 id="c-solution-using-unordered-set">C++ Solution Using Unordered
Set</h2>
<p>We want to find the largest positive number in an array that has its
negative version. We can do this using an <code>unordered_set</code> in
C++. This way is fast and helps us get a good solution.</p>
<h3 id="implementation-steps">Implementation Steps:</h3>
<ol type="1">
<li>We go through the array and put each number into an
<code>unordered_set</code>.</li>
<li>For each positive number, we check if its negative version is in the
set.</li>
<li>We keep track of the largest positive number that fits this
rule.</li>
</ol>
<h3 id="c-code-example">C++ Code Example:</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> findLargestIntegerWithNegative<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>    unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> numSet<span class="op">;</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> largest <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Insert all elements into the unordered_set</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        numSet<span class="op">.</span>insert<span class="op">(</span>num<span class="op">);</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Check for the largest positive integer with its negative</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> numSet<span class="op">.</span>count<span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> max<span class="op">(</span>largest<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest<span class="op">;</span></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">3</span><span class="op">,</span> <span class="op">-</span><span class="dv">3</span><span class="op">,</span> <span class="dv">1</span><span class="op">,</span> <span class="op">-</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="op">-</span><span class="dv">2</span><span class="op">};</span></span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Largest integer with its negative: &quot;</span> <span class="op">&lt;&lt;</span> findLargestIntegerWithNegative<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-2">Explanation:</h3>
<p>We start with an <code>unordered_set</code> to keep the elements from
the array. We first add all numbers to this set. Then, we check for the
largest positive number that has its negative.</p>
<p>The time it takes is O(n). Here n is the number of elements in the
array. This is because the <code>unordered_set</code> works fast on
average.</p>
<p>This way not only gives us a good answer but also meets the needs of
the problem. We find the largest positive number with its negative in
C++. For more on similar tasks with arrays, we can look at <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a>.</p>
<h2 id="optimizing-the-solution-for-performance">Optimizing the Solution
for Performance</h2>
<p>We want to make the solution better for finding the largest positive
number that has its negative in an array. We can do this by lowering
time and memory use. Here are some simple ideas:</p>
<ol type="1">
<li><p><strong>Use a HashSet</strong>: This helps us check for numbers
quickly. We can look for a number in O(1) time on average.</p></li>
<li><p><strong>Single Pass</strong>: We can solve the problem by going
through the array just once. We will put each number into a HashSet and
check for its negative at the same time.</p></li>
<li><p><strong>Avoid Duplicates</strong>: When we add numbers to the
HashSet, we should only add unique numbers. This way, we do not do extra
work.</p></li>
</ol>
<h3 id="java-implementation-example">Java Implementation Example</h3>
<p>Here is how we can write this in Java:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashSet</span><span class="op">;</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LargestPositiveInteger <span class="op">{</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">findLargestPositiveInteger</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HashSet</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> set <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> largest <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            set<span class="op">.</span><span class="fu">add</span><span class="op">(</span>num<span class="op">);</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> set<span class="op">.</span><span class="fu">contains</span><span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>                largest <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>largest<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> largest <span class="op">==</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> largest<span class="op">;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation-example">Python Implementation
Example</h3>
<p>We can use the same logic in Python:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_positive_integer(arr):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    num_set <span class="op">=</span> <span class="bu">set</span>(arr)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    largest <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">-</span>num <span class="kw">in</span> num_set:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> <span class="bu">max</span>(largest, num)</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest <span class="cf">if</span> largest <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">else</span> <span class="dv">0</span></span></code></pre></div>
<h3 id="c-implementation-example">C++ Implementation Example</h3>
<p>In C++, we use <code>unordered_set</code> for good performance:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> findLargestPositiveInteger<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> numSet<span class="op">(</span>arr<span class="op">.</span>begin<span class="op">(),</span> arr<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> largest <span class="op">=</span> INT_MIN<span class="op">;</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> numSet<span class="op">.</span>count<span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>largest<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest <span class="op">==</span> INT_MIN <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> largest<span class="op">;</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="key-performance-considerations">Key Performance
Considerations</h3>
<ul>
<li><strong>Time Complexity</strong>: We go through the array in O(n)
time and look up numbers in O(1) time in the HashSet. So the total is
O(n).</li>
<li><strong>Space Complexity</strong>: We need O(n) space for storing
numbers in the HashSet.</li>
</ul>
<p>By using these tips, we can make our method for finding the largest
positive number with its negative fast and ready for big data.</p>
<p>For more about array tricks, check out things like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate</a>.</p>
<h2 id="handling-edge-cases-in-arrays">Handling Edge Cases in
Arrays</h2>
<p>When we work with arrays, especially to find the largest positive
number that has its negative, we need to handle some edge cases. Here
are the important edge cases we should think about:</p>
<ul>
<li><p><strong>Empty Array</strong>: If the input array is empty, we
should return a value like <code>0</code>. This shows that there are no
integers available.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> arr:</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We will continue with more logic...</span></span></code></pre></div></li>
<li><p><strong>All Negative or All Positive Numbers</strong>: If the
array only has negative numbers or only positive numbers, we should also
return <code>0</code>. There are no valid pairs in this case.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">all</span>(x <span class="op">&lt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> arr) <span class="kw">or</span> <span class="bu">all</span>(x <span class="op">&gt;</span> <span class="dv">0</span> <span class="cf">for</span> x <span class="kw">in</span> arr):</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span></span></code></pre></div></li>
<li><p><strong>Duplicates</strong>: We need to think about how
duplicates change the result. For example, in the array
<code>1, -1, 1</code>, the largest positive number with its negative is
<code>1</code>.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    unique_numbers <span class="op">=</span> <span class="bu">set</span>(arr)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We will continue with more logic...</span></span></code></pre></div></li>
<li><p><strong>Mixed Signs with No Valid Pair</strong>: If the array has
negative and positive numbers but no positive number has its negative
(like <code>2, 3, -4</code>), we should return <code>0</code>.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    positives <span class="op">=</span> {x <span class="cf">for</span> x <span class="kw">in</span> arr <span class="cf">if</span> x <span class="op">&gt;</span> <span class="dv">0</span>}</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    negatives <span class="op">=</span> {x <span class="cf">for</span> x <span class="kw">in</span> arr <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>}</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We will continue with more logic...</span></span></code></pre></div></li>
<li><p><strong>Single Element Cases</strong>: If the array has only one
element, we should return <code>0</code> if that element is not
<code>0</code> or does not have a negative pair.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(arr) <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">0</span> <span class="cf">if</span> arr[<span class="dv">0</span>] <span class="op">!=</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">-</span>arr[<span class="dv">0</span>] <span class="kw">not</span> <span class="kw">in</span> arr <span class="cf">else</span> arr[<span class="dv">0</span>]</span></code></pre></div></li>
<li><p><strong>Zero Handling</strong>: If we have <code>0</code> in the
array, it does not count as a positive number. But we should note it in
the output logic if its pair is there.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> find_largest_with_negative(arr):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    has_zero <span class="op">=</span> <span class="dv">0</span> <span class="kw">in</span> arr</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Logic to find the largest positive with its negative...</span></span></code></pre></div></li>
</ul>
<p>By thinking carefully about these edge cases, we can make sure our
solution to find the largest positive integer that has its negative is
strong. This way, we can handle many different situations well.</p>
<h2 id="complexity-analysis-of-different-approaches">Complexity Analysis
of Different Approaches</h2>
<p>When we solve the problem of finding the largest positive integer
that has its negative in an array, we see that different methods have
different time and space complexities. Here is a simple look at the
complexities for the most common methods.</p>
<h3 id="hashset-approach">1. HashSet Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)
<ul>
<li>We process each element one time.</li>
</ul></li>
<li><strong>Space Complexity</strong>: O(n)
<ul>
<li>We need extra space to store elements in the HashSet.</li>
</ul></li>
</ul>
<p><strong>Example Code (Java)</strong>:</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashSet</span><span class="op">;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> LargestPositiveInteger <span class="op">{</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">findLargest</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HashSet</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">&gt;</span> set <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashSet</span><span class="op">&lt;&gt;();</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> max <span class="op">=</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span><span class="op">;</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>            set<span class="op">.</span><span class="fu">add</span><span class="op">(</span>num<span class="op">);</span></span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> set<span class="op">.</span><span class="fu">contains</span><span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a>                max <span class="op">=</span> <span class="bu">Math</span><span class="op">.</span><span class="fu">max</span><span class="op">(</span>max<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb13-18"><a href="#cb13-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> max <span class="op">==</span> <span class="bu">Integer</span><span class="op">.</span><span class="fu">MIN_VALUE</span> <span class="op">?</span> <span class="dv">0</span> <span class="op">:</span> max<span class="op">;</span></span>
<span id="cb13-19"><a href="#cb13-19" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb13-20"><a href="#cb13-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="using-a-loop-with-set">2. Using a Loop with Set</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)
<ul>
<li>We access each element in the array one time.</li>
</ul></li>
<li><strong>Space Complexity</strong>: O(n)
<ul>
<li>We need storage for the set of elements.</li>
</ul></li>
</ul>
<p><strong>Example Code (Python)</strong>:</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> findLargest(nums):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    num_set <span class="op">=</span> <span class="bu">set</span>(nums)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    max_positive <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">-</span>num <span class="kw">in</span> num_set:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>            max_positive <span class="op">=</span> <span class="bu">max</span>(max_positive, num)</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_positive <span class="cf">if</span> max_positive <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">else</span> <span class="dv">0</span></span></code></pre></div>
<h3 id="sorting-approach">3. Sorting Approach</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n log n)
<ul>
<li>We need to sort the array first.</li>
</ul></li>
<li><strong>Space Complexity</strong>: O(1) or O(n)
<ul>
<li>It depends on the sorting method we use (in-place or not).</li>
</ul></li>
</ul>
<p><strong>Example Code (C++)</strong>:</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> findLargest<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>sort<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> max_num <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">size_t</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span>size<span class="op">();</span> <span class="op">++</span>i<span class="op">)</span> <span class="op">{</span></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> <span class="bu">std::</span>find<span class="op">(</span>nums<span class="op">.</span>begin<span class="op">(),</span> nums<span class="op">.</span>end<span class="op">(),</span> <span class="op">-</span>nums<span class="op">[</span>i<span class="op">])</span> <span class="op">!=</span> nums<span class="op">.</span>end<span class="op">())</span> <span class="op">{</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true" tabindex="-1"></a>            max_num <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>max_num<span class="op">,</span> nums<span class="op">[</span>i<span class="op">]);</span></span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> max_num<span class="op">;</span></span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="optimized-search-with-two-pointers">4. Optimized Search with Two
Pointers</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n)
<ul>
<li>We go through the array in a straight line.</li>
</ul></li>
<li><strong>Space Complexity</strong>: O(1)
<ul>
<li>We do not use extra space except for some variables.</li>
</ul></li>
</ul>
<p>This way can be better when the array is already sorted. We can use a
two-pointer method.</p>
<h3 id="summary-of-complexities">Summary of Complexities</h3>
<ul>
<li><strong>HashSet</strong>: O(n) time, O(n) space</li>
<li><strong>Loop with Set</strong>: O(n) time, O(n) space</li>
<li><strong>Sorting</strong>: O(n log n) time, O(1) or O(n) space</li>
<li><strong>Two Pointers</strong>: O(n) time, O(1) space</li>
</ul>
<p>We need to understand the complexity of these methods. This helps us
choose the best solution based on what the problem needs. For more
reading on similar topics, we can check <a
href="https://bestonlinetutorial.com/array/array-check-if-n-and-its-double-exist-easy.html">Array
- Check if N and its Double Exist</a>.</p>
<h2 id="best-practices-for-array-manipulation">Best Practices for Array
Manipulation</h2>
<p>When we work with arrays, it is important to follow some best
practices. This helps us make our code better and easier to manage. Here
are some simple tips:</p>
<ol type="1">
<li><strong>Choose the Right Data Structure</strong>:
<ul>
<li>We should use arrays when we have a fixed size of elements.</li>
<li>For collections that can change size, we can use lists or
vectors.</li>
</ul></li>
<li><strong>Minimize Space Complexity</strong>:
<ul>
<li>We should avoid making extra copies of arrays. Instead, we can use
references or pointers when we send arrays to functions.</li>
<li>If we can, lets use in-place algorithms to save memory.</li>
</ul></li>
<li><strong>Utilize Built-in Functions</strong>:
<ul>
<li>We can use built-in functions and libraries that help us work with
arrays faster. For example, we can use <code>Arrays.sort()</code> in
Java or <code>sorted()</code> in Python.</li>
</ul></li>
<li><strong>Loop Efficiently</strong>:
<ul>
<li>We should try to use enhanced for-loops or built-in methods to go
through arrays. This makes our code easier to read and helps avoid
mistakes.</li>
<li>In Python, we can use list comprehensions for quick and clear
looping.</li>
</ul></li>
<li><strong>Avoid Nested Loops</strong>:
<ul>
<li>We should limit using nested loops. They can slow down our code to
O(n^2) complexity. Instead, we can use hashmap or set structures to get
O(n) complexity when we look for pairs.</li>
</ul></li>
<li><strong>Handle Edge Cases</strong>:
<ul>
<li>We must check for empty arrays or null values before we do
anything.</li>
<li>It is important to check input data to make sure it is correct
before processing.</li>
</ul></li>
<li><strong>Optimize for Performance</strong>:
<ul>
<li>If we know the size of the array before we start, we should create
it with a fixed size. This helps us avoid extra costs.</li>
<li>We should use algorithms that have the lowest time complexity that
fits the problem. For example, O(n log n) is good for sorting.</li>
</ul></li>
<li><strong>Document Your Code</strong>:
<ul>
<li>We should add comments to explain parts of the code that are tricky
or not obvious. This helps others understand our work.</li>
<li>It is good to clearly state what functions do, including what they
take in and what they give back.</li>
</ul></li>
<li><strong>Test for Correctness</strong>:
<ul>
<li>We can use unit tests to check that our array functions work
correctly in different situations, including edge cases.</li>
<li>Lets use automated testing tools to keep checking as our code
changes.</li>
</ul></li>
<li><strong>Follow Coding Standards</strong>:
<ul>
<li>We should keep naming for variables and functions about arrays
consistent.</li>
<li>It is helpful to organize our code well. We can group related
functions together to make it clearer.</li>
</ul></li>
</ol>
<p>By following these best practices for array manipulation, we can
improve our codes quality and speed. For more on handling array
problems, we can check out articles like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
- Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
- Contains Duplicate</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-largest-positive-integer-that-exists-with-its-negative-in-an-array">1.
What is the largest positive integer that exists with its negative in an
array?</h3>
<p>The largest positive integer with its negative is a common problem in
working with arrays. We need to find the biggest number in the array
that also has its negative. We can solve this problem easily by using
data structures like hash tables or sets. These help us check for
numbers quickly, which is good for performance.</p>
<h3
id="how-can-i-implement-the-solution-to-find-the-largest-integer-with-its-negative-in-python">2.
How can I implement the solution to find the largest integer with its
negative in Python?</h3>
<p>To solve this problem in Python, we can use a set to keep the
elements of the array. Then we go through the array to see if both the
number and its negative are there. Here is a simple example:</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> findLargestInteger(arr):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    num_set <span class="op">=</span> <span class="bu">set</span>(arr)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    largest <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;</span> <span class="dv">0</span> <span class="kw">and</span> <span class="op">-</span>num <span class="kw">in</span> num_set:</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> <span class="bu">max</span>(largest, num)</span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest <span class="cf">if</span> largest <span class="op">!=</span> <span class="bu">float</span>(<span class="st">&#39;-inf&#39;</span>) <span class="cf">else</span> <span class="va">None</span></span></code></pre></div>
<h3
id="what-is-the-time-complexity-of-finding-the-largest-positive-integer-with-its-negative">3.
What is the time complexity of finding the largest positive integer with
its negative?</h3>
<p>The time complexity for this method is O(n). Here n is the number of
elements in the array. We make one pass to fill the set. Then we make
another pass to find the largest integer. This makes it good for big
datasets in array tasks.</p>
<h3
id="can-the-problem-of-finding-the-largest-positive-integer-with-its-negative-be-solved-in-c">4.
Can the problem of finding the largest positive integer with its
negative be solved in C++?</h3>
<p>Yes, we can solve this problem in C++ using unordered_set from the
Standard Template Library (STL). This gives us O(1) average time for
lookups. Here is a short example:</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_set&gt;</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;algorithm&gt;</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> findLargestInteger<span class="op">(</span><span class="at">const</span> <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_set<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> numSet<span class="op">(</span>arr<span class="op">.</span>begin<span class="op">(),</span> arr<span class="op">.</span>end<span class="op">());</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> largest <span class="op">=</span> INT_MIN<span class="op">;</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>num <span class="op">&gt;</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> numSet<span class="op">.</span>count<span class="op">(-</span>num<span class="op">))</span> <span class="op">{</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>            largest <span class="op">=</span> <span class="bu">std::</span>max<span class="op">(</span>largest<span class="op">,</span> num<span class="op">);</span></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> largest <span class="op">==</span> INT_MIN <span class="op">?</span> <span class="op">-</span><span class="dv">1</span> <span class="op">:</span> largest<span class="op">;</span></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3
id="are-there-any-edge-cases-to-consider-when-solving-this-problem">5.
Are there any edge cases to consider when solving this problem?</h3>
<p>Yes, there are edge cases to think about. These include empty arrays,
arrays without positive integers, or arrays with only negative integers.
We should also make sure our solution can handle duplicate numbers. For
example, an array like <code>[-1, 1, 1]</code> should give
<code>1</code> as the largest positive integer that has its negative. It
is very important to handle these edge cases for good array
solutions.</p>
<p>For more articles on array techniques, you can check out <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            