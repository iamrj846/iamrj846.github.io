
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Product of Array Except Self - Medium</title>
            <meta name="description" content="Discover how to solve the "Product of Array Except Self" problem with efficient solutions and clear explanations in our guide.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Product of Array Except Self - Medium</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>The “Product of Array Except Self” is a popular coding challenge. We
need to find the product of all elements in an array except for the one
at the current index. This means that for each index, we should get the
product of all other elements. We can solve this problem well without
using division. This way, we keep the solution fast and use less
space.</p>
<p>In this article, we will look into the “Product of Array Except Self”
problem closely. We will explain the problem and what we need to do. We
will also find a good solution that does not use division. Then, we will
show how to implement it in Java, Python, and C++. We will check the
space and time complexity of our solutions. We will also look at common
edge cases and answer some questions that people often ask about this
topic.</p>
<ul>
<li>Understanding Array Product of Array Except Self - Medium</li>
<li>Problem Statement and Requirements</li>
<li>Optimal Solution Without Division</li>
<li>Java Implementation of Product of Array Except Self</li>
<li>Python Implementation of Product of Array Except Self</li>
<li>C++ Implementation of Product of Array Except Self</li>
<li>Space Complexity Analysis of the Solution</li>
<li>Time Complexity Analysis of the Solution</li>
<li>Common Edge Cases and Their Handling</li>
<li>Frequently Asked Questions</li>
</ul>
<h2 id="problem-statement-and-requirements">Problem Statement and
Requirements</h2>
<p>The “Product of Array Except Self” problem asks us to create an
output array. Each element at index <code>i</code> in this output array
should be equal to the product of all the numbers in the input array
except the number at <code>i</code>.</p>
<h3 id="requirements">Requirements:</h3>
<ol type="1">
<li>We must solve the problem without using division.</li>
<li>Our solution should be good in both time and space.</li>
<li>The input is an array of integers. We need to return an array that
has the same length as the input.</li>
</ol>
<h3 id="example">Example:</h3>
<p>If we have an input array <code>nums = [1, 2, 3, 4]</code>, the
output should be:</p>
<pre><code>Output: [24, 12, 8, 6]</code></pre>
<ul>
<li>Explanation:
<ul>
<li>For <code>output[0]</code>: the product is
<code>nums[1] * nums[2] * nums[3]</code> which is <code>2 * 3 * 4</code>
= <code>24</code></li>
<li>For <code>output[1]</code>: the product is
<code>nums[0] * nums[2] * nums[3]</code> which is <code>1 * 3 * 4</code>
= <code>12</code></li>
<li>For <code>output[2]</code>: the product is
<code>nums[0] * nums[1] * nums[3]</code> which is <code>1 * 2 * 4</code>
= <code>8</code></li>
<li>For <code>output[3]</code>: the product is
<code>nums[0] * nums[1] * nums[2]</code> which is <code>1 * 2 * 3</code>
= <code>6</code></li>
</ul></li>
</ul>
<h3 id="constraints">Constraints:</h3>
<ul>
<li>The input array length must be at least 1 and no more than
10^5.</li>
<li>Each number in the input array must be between -30,000 and
30,000.</li>
</ul>
<p>We can solve this problem well by going through the array two times.
We will keep two separate arrays for the left and right products. It is
very important to follow the constraints. We should also make our
solution fast to work with bigger input sizes.</p>
<h2 id="optimal-solution-without-division">Optimal Solution Without
Division</h2>
<p>To solve the “Product of Array Except Self” problem without using
division, we can use two passes through the array. This helps us keep
the product of all elements to the left and right of each index. This
way, we can get the result in O(n) time and use O(1) space, not counting
the output array.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><strong>Initialize an output array</strong> for the product
results.</li>
<li><strong>First pass (left products)</strong>:
<ul>
<li>We go through the array from left to right.</li>
<li>We keep a variable to store the product of elements to the left of
the current index.</li>
<li>We update the output array with the left product for each
index.</li>
</ul></li>
<li><strong>Second pass (right products)</strong>:
<ul>
<li>Now, we go through the array from right to left.</li>
<li>We keep another variable for the product of elements to the right of
the current index.</li>
<li>We multiply the current value in the output array by the right
product.</li>
</ul></li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is a Python code for the optimal solution:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> product_except_self(nums):</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> length</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># First pass: calculate left products</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    left_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length):</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">=</span> left_product</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        left_product <span class="op">*=</span> nums[i]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Second pass: calculate right products</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    right_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">*=</span> right_product</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>        right_product <span class="op">*=</span> nums[i]</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<h3 id="example-usage">Example Usage</h3>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> product_except_self(nums)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: [24, 12, 8, 6]</span></span></code></pre></div>
<p>This solution helps us find the product of all elements except the
one at the current index. It does this without using division. This is
good for cases where we can’t or don’t want to use division.</p>
<p>We can use this method in many situations. It is like other problems
with arrays. For example, problems like <a
href="https://bestonlinetutorial.com/array/array-rotate-array-medium.html">Array
Rotate</a> or <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Maximum
Subarray</a> need good array processing.</p>
<h2 id="java-implementation-of-product-of-array-except-self">Java
Implementation of Product of Array Except Self</h2>
<p>We will show how to implement the “Product of Array Except Self” in
Java. We will create a function that finds the product of all elements
in an array except the one at each index. This solution does not use
division. It works in linear time and has O(1) space complexity, not
counting the output array.</p>
<p>Here is our step-by-step approach:</p>
<ol type="1">
<li>First, we create an output array to store the result.</li>
<li>Then, we go through the input array from left to right. We fill the
output array with the products of all elements to the left of each
index.</li>
<li>Next, we go through the input array from right to left. We multiply
the products in the output array by the products of all elements to the
right of each index.</li>
</ol>
<h3 id="java-code-example">Java Code Example</h3>
<div class="sourceCode" id="cb4"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> ProductOfArrayExceptSelf <span class="op">{</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span><span class="op">[]</span> <span class="fu">productExceptSelf</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> output <span class="op">=</span> <span class="kw">new</span> <span class="dt">int</span><span class="op">[</span>n<span class="op">];</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 1: Calculate products of elements to the left of each index</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>        output<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// First element has no left products</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>            output<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> output<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Step 2: Calculate products of elements to the right of each index</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> rightProduct <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> <span class="co">// Start with no right products</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>            output<span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> rightProduct<span class="op">;</span> <span class="co">// Multiply with the right product</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>            rightProduct <span class="op">*=</span> nums<span class="op">[</span>i<span class="op">];</span> <span class="co">// Update the right product</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> output<span class="op">;</span></span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-21"><a href="#cb4-21" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb4-22"><a href="#cb4-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-23"><a href="#cb4-23" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb4-24"><a href="#cb4-24" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> result <span class="op">=</span> <span class="fu">productExceptSelf</span><span class="op">(</span>nums<span class="op">);</span></span>
<span id="cb4-25"><a href="#cb4-25" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">print</span><span class="op">(</span><span class="st">&quot;Product of Array Except Self: &quot;</span><span class="op">);</span></span>
<span id="cb4-26"><a href="#cb4-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> value <span class="op">:</span> result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb4-27"><a href="#cb4-27" aria-hidden="true" tabindex="-1"></a>            <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">print</span><span class="op">(</span>value <span class="op">+</span> <span class="st">&quot; &quot;</span><span class="op">);</span></span>
<span id="cb4-28"><a href="#cb4-28" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb4-29"><a href="#cb4-29" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb4-30"><a href="#cb4-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code</h3>
<ul>
<li><strong>Initialization</strong>: We make an array called
<code>output</code> to store the results.</li>
<li><strong>Left Product Calculation</strong>: In the first loop, we
fill the <code>output</code> array with products of all elements to the
left of each index.</li>
<li><strong>Right Product Calculation</strong>: The second loop updates
the <code>output</code> array by multiplying it with products of all
elements to the right of each index.</li>
</ul>
<p>This method gives us the result without using division. It also keeps
good time and space performance.</p>
<p>If we want to learn more about array techniques, we can check
articles like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> and <a
href="https://bestonlinetutorial.com/array/array-rotate-array-medium.html">Array
Rotate Array</a>.</p>
<h2 id="python-implementation-of-product-of-array-except-self">Python
Implementation of Product of Array Except Self</h2>
<p>To do the “Product of Array Except Self” in Python, we can use a
two-step method. This helps us get the right answer without division. We
want to make an output array. Each element at index <code>i</code>
should be the product of all numbers in the input array, except the
number at <code>i</code>.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is a simple Python code for this solution:</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> product_except_self(nums):</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>    length <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> length</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate products of elements to the left of each index</span></span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    left_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length):</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">=</span> left_product</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>        left_product <span class="op">*=</span> nums[i]</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate products of elements to the right of each index</span></span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>    right_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(length <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">*=</span> right_product</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a>        right_product <span class="op">*=</span> nums[i]</span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-20"><a href="#cb5-20" aria-hidden="true" tabindex="-1"></a>nums <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb5-21"><a href="#cb5-21" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> product_except_self(nums)</span>
<span id="cb5-22"><a href="#cb5-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: [24, 12, 8, 6]</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><p><strong>Left Product Calculation</strong>: We go through the
array from left to right. For each index, we keep the product of all the
numbers before it.</p></li>
<li><p><strong>Right Product Calculation</strong>: We go through the
array from right to left. For each index, we multiply the current value
in the output array with the product of all elements after it.</p></li>
</ul>
<p>This method works in O(n) time and uses O(1) space. We do not use any
extra arrays to keep temporary results, except for the output array.</p>
<p>If you want to learn more about similar problems, you can look at the
article on <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a>. It gives more tips on how to work with arrays.</p>
<h2 id="c-implementation-of-product-of-array-except-self">C++
Implementation of Product of Array Except Self</h2>
<p>To solve the “Product of Array Except Self” problem in C++, we can
make a good solution without using division. The main idea is to use two
passes to get the result.</p>
<p>Here is the code:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> productExceptSelf<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> nums<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result<span class="op">(</span>n<span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate prefix products</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> result<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">]</span> <span class="op">*</span> nums<span class="op">[</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">];</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Calculate suffix products and multiply with prefix products</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> suffix <span class="op">=</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">;</span> i<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        result<span class="op">[</span>i<span class="op">]</span> <span class="op">*=</span> suffix<span class="op">;</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        suffix <span class="op">*=</span> nums<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> result<span class="op">;</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code-1">Explanation of the Code:</h3>
<ol type="1">
<li><strong>Initialization</strong>: We create a result vector and set
it to 1.</li>
<li><strong>First Pass (Prefix Products)</strong>:
<ul>
<li>We go through the array and save the product of all previous
elements in the result array.</li>
</ul></li>
<li><strong>Second Pass (Suffix Products)</strong>:
<ul>
<li>We start from the end of the array. We keep a running product of
elements after the current index and multiply it with the value in the
result array.</li>
</ul></li>
</ol>
<h3 id="example-usage-1">Example Usage:</h3>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> result <span class="op">=</span> productExceptSelf<span class="op">(</span>nums<span class="op">);</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> r <span class="op">:</span> result<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>        cout <span class="op">&lt;&lt;</span> r <span class="op">&lt;&lt;</span> <span class="st">&quot; &quot;</span><span class="op">;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="output">Output:</h3>
<p>For the input <code>{1, 2, 3, 4}</code>, the output will be:</p>
<pre><code>24 12 8 6</code></pre>
<p>This solution runs in O(n) time and uses O(1) extra space, not
counting the output array. The code solves the “Product of Array Except
Self” problem in C++. If we want to read more about similar array
problems, we can check <a
href="https://bestonlinetutorial.com/array/array-rotate-array-medium.html">Array
Rotate Array - Medium</a>.</p>
<h2 id="space-complexity-analysis-of-the-solution">Space Complexity
Analysis of the Solution</h2>
<p>The space complexity of the “Product of Array Except Self” problem
can change based on how we solve it.</p>
<ol type="1">
<li><strong>Optimal Solution Without Division</strong>:
<ul>
<li>The best solution needs O(1) extra space if we think about the
output array as part of the input. But if we cannot change the input
array, we must think about the space used for the output array. In this
case, it would be O(n). Here, n is the length of the input array.</li>
</ul></li>
<li><strong>Intermediate Arrays</strong>:
<ul>
<li>If we use extra arrays to keep intermediate results, like left
products and right products, the space complexity becomes O(n). This is
because we have two extra arrays.</li>
</ul></li>
</ol>
<h3 id="space-complexity-breakdown">Space Complexity Breakdown:</h3>
<ul>
<li>Using <strong>output array</strong> only: O(n) to store
results.</li>
<li>Using <strong>two extra arrays</strong> (left and right products):
O(n) for both arrays, so total is O(n).</li>
<li>Using <strong>in-place modification</strong> with little extra
space: O(1) if we do not count the output array.</li>
</ul>
<h3 id="example-1">Example:</h3>
<p>For an input array <code>nums = [1, 2, 3, 4]</code>: - The output
array would be <code>[24, 12, 8, 6]</code> if we store results. This
needs O(n) space.</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> productExceptSelf(nums):</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(nums)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    output <span class="op">=</span> [<span class="dv">1</span>] <span class="op">*</span> n</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    left_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">=</span> left_product</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        left_product <span class="op">*=</span> nums[i]</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    right_product <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n <span class="op">-</span> <span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a>        output[i] <span class="op">*=</span> right_product</span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>        right_product <span class="op">*=</span> nums[i]</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> output</span></code></pre></div>
<p>In this example, the output array needs O(n) space. The extra
variables <code>left_product</code> and <code>right_product</code> only
need O(1).</p>
<p>In summary, the space complexity analysis of the “Product of Array
Except Self” solution depends on if we see the output array as part of
the input and if we use extra storage. The best way for space is to
calculate the products in-place. This gives O(1) extra space complexity
when we include the output array in the input.</p>
<h2 id="time-complexity-analysis-of-the-solution">Time Complexity
Analysis of the Solution</h2>
<p>We can look at the time complexity of the “Product of Array Except
Self” problem by looking at the steps in the algorithm we use to find
the output array.</p>
<ol type="1">
<li><strong>Initial Pass to Calculate Prefix Products</strong>:
<ul>
<li>First, we go through the array one time to find the prefix products.
This takes O(n) time. Here, n is the length of the input array.</li>
</ul></li>
<li><strong>Second Pass to Calculate Suffix Products</strong>:
<ul>
<li>Next, we go through the array again to find the suffix products. At
the same time, we calculate the final product for each index. This also
takes O(n) time.</li>
</ul></li>
</ol>
<p>So, since we do both passes one after the other, the total time
complexity is:</p>
<ul>
<li><strong>O(n)</strong></li>
</ul>
<p>We get this good time complexity without using division. This makes
our method work well even if the array has zeros. The algorithm quickly
finds the product of all elements except itself for each index in linear
time.</p>
<h2 id="common-edge-cases-and-their-handling">Common Edge Cases and
Their Handling</h2>
<p>When we implement the “Product of Array Except Self” algorithm, we
need to think about some edge cases. These cases can change if our
solution is correct or not. Here are some common edge cases and how we
can handle them:</p>
<ol type="1">
<li><strong>Single Element Array</strong>:
<ul>
<li>Input: <code>[1]</code></li>
<li>Output: <code>[1]</code> (The product of an empty array is usually
1).</li>
<li>Handling: We return an array of the same size filled with 1.</li>
</ul></li>
<li><strong>Array with Zeros</strong>:
<ul>
<li>Input: <code>[0, 1, 2, 3]</code></li>
<li>Output: <code>[6, 0, 0, 0]</code> (Only the product of non-zero
numbers).</li>
<li>Handling: We count how many zeros are in the input array. If we have
more than one zero, we give an array of zeros. If we have one zero, all
places except the zero’s position should be zero. The zero’s position
will have the product of all non-zero numbers.</li>
</ul></li>
<li><strong>Array with All Zeros</strong>:
<ul>
<li>Input: <code>[0, 0, 0]</code></li>
<li>Output: <code>[0, 0, 0]</code>.</li>
<li>Handling: Like the last case, we return an array of zeros.</li>
</ul></li>
<li><strong>Large Numbers</strong>:
<ul>
<li>Input: <code>[100000, 200000, 300000]</code></li>
<li>Output: <code>[60000000000, 30000000000, 20000000000]</code> (We
need to be careful of large integer overflow).</li>
<li>Handling: We use data types that can handle large numbers like
<code>long</code> in Java or <code>int</code> in Python which handles
large integers automatically.</li>
</ul></li>
<li><strong>Negative Numbers</strong>:
<ul>
<li>Input: <code>[-1, -2, -3, -4]</code></li>
<li>Output: <code>[24, 12, 8, 6]</code> (Negative numbers give a
positive product).</li>
<li>Handling: Our algorithm should work the same no matter the sign of
the numbers.</li>
</ul></li>
<li><strong>Mixed Positive and Negative Numbers</strong>:
<ul>
<li>Input: <code>[1, -2, 3, -4]</code></li>
<li>Output: <code>[-24, 12, -8, 6]</code>.</li>
<li>Handling: We make sure the algorithm calculates products correctly
with mixed signs.</li>
</ul></li>
<li><strong>Performance Considerations</strong>:
<ul>
<li>Inputs with a very big size (for example,
<code>Array length = 10^5</code>).</li>
<li>Handling: Our solution must be O(n) in time and O(1) in space (not
counting the output array) to work well with large inputs.</li>
</ul></li>
</ol>
<p>By taking care of these edge cases, we make the “Product of Array
Except Self” implementation much stronger. A good function should handle
these cases without issues.</p>
<p>For more insights on problems with arrays, you can check the <a
href="https://bestonlinetutorial.com/array/array-rotate-array-medium.html">Array
Rotate Array - Medium</a> article.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-product-of-array-except-self-problem-in-arrays">1.
What is the “Product of Array Except Self” problem in arrays?</h3>
<p>The “Product of Array Except Self” problem asks us to create an
output array. Each element at index <code>i</code> in this array is the
product of all numbers in the input array except <code>nums[i]</code>.
We often see this problem in coding interviews. It shows the need for
good solutions that do not use division.</p>
<h3
id="how-can-i-solve-the-product-of-array-except-self-problem-without-using-division">2.
How can I solve the “Product of Array Except Self” problem without using
division?</h3>
<p>To solve the “Product of Array Except Self” problem without division,
we can do two passes over the input array. In the first pass, we keep a
running product of all elements to the left of each index. In the second
pass, we multiply this product with another running product of elements
to the right. This way we get an output array with the products we
want.</p>
<h3
id="what-is-the-time-complexity-of-the-optimal-solution-for-the-product-of-array-except-self">3.
What is the time complexity of the optimal solution for the “Product of
Array Except Self”?</h3>
<p>The best solution for the “Product of Array Except Self” problem runs
in O(n) time. Here, n is the length of the input array. We do this by
making two passes through the array. One pass calculates left products
and the other for right products. This makes our solution fast and able
to handle large inputs.</p>
<h3
id="can-you-explain-the-space-complexity-of-the-product-of-array-except-self-solution">4.
Can you explain the space complexity of the “Product of Array Except
Self” solution?</h3>
<p>The space complexity for the best solution to the “Product of Array
Except Self” problem is O(1), not counting the output array. We only
need a small amount of extra space for variables that hold the running
products. This makes our algorithm space-efficient.</p>
<h3
id="what-are-some-common-edge-cases-to-consider-when-implementing-the-product-of-array-except-self">5.
What are some common edge cases to consider when implementing the
“Product of Array Except Self”?</h3>
<p>When we implement the “Product of Array Except Self,” we should think
about edge cases. This includes arrays with zeros, negative numbers, or
arrays with just one element. For example, if the input array has one
zero, the output should show that all other products are zero. If there
are many zeros, the output will be all zeros too.</p>
<p>For more challenges about arrays, check out the <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array:
Two Sum - Easy</a> or look at the <a
href="https://bestonlinetutorial.com/array/array-best-time-to-buy-and-sell-stock-easy.html">Array:
Best Time to Buy and Sell Stock - Easy</a> for more practice.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            