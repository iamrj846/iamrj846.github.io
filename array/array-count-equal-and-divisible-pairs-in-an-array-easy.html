
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            
            <title>[Array] Count Equal and Divisible Pairs in an Array - Easy</title>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebSite",
      "name": "BestOnlineTutorial",
      "url": "https://www.bestonlinetutorial.com/"
    }
    </script>

<!-- Common CSS & Icons -->
<link rel="icon" href="/favicon.ico" type="image/x-icon">
<link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
<link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
<link rel="stylesheet" href="/assets/css/post.css">
            <meta name="description" content="Discover how to count equal and divisible pairs in an array easily. Boost your coding skills with our step-by-step guide!">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">[Array] Count Equal and Divisible Pairs in an Array - Easy</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>Counting equal and divisible pairs in an array is a simple problem.
It needs us to find pairs of elements that are the same and where one
element can divide the other. We can solve this problem in different
ways. We can use brute force methods or better solutions with data
structures like HashMaps. We want to count the valid pairs in the array
efficiently.</p>
<p>In this article, we will look at counting equal and divisible pairs
closely. First, we will understand the problem statement. After that, we
will talk about the brute force method to solve this in Java. Next, we
will look at a better solution using HashMaps in Java. We will also show
a Python version of the same idea, using collections and list
comprehensions. Then, we will give a C++ solution and show how to use
the Standard Template Library (STL) well. Finally, we will compare the
different methods and answer common questions about this topic.</p>
<ul>
<li>[Array] Count Equal and Divisible Pairs in an Array - Easy
Tutorial</li>
<li>Understanding the Problem Statement for Count Equal and Divisible
Pairs</li>
<li>Brute Force Approach to Count Equal and Divisible Pairs in Java</li>
<li>Optimized Approach Using HashMap in Java</li>
<li>Python Implementation of Count Equal and Divisible Pairs</li>
<li>Using Collections and List Comprehensions in Python</li>
<li>C++ Solution for Counting Equal and Divisible Pairs</li>
<li>Efficient Use of STL for Counting in C++</li>
<li>Comparative Analysis of Different Approaches</li>
<li>Frequently Asked Questions</li>
</ul>
<p>For more reading on related topics, we can find these articles
helpful: <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum - Easy</a>, <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate - Easy</a>, and <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray - Easy</a>.</p>
<h2
id="understanding-the-problem-statement-for-count-equal-and-divisible-pairs">Understanding
the Problem Statement for Count Equal and Divisible Pairs</h2>
<p>We want to count equal and divisible pairs in an array. We need to
find pairs of indices ((i, j)) that follow these rules:</p>
<ol type="1">
<li>The elements at these indices are the same: ( [i] = [j] )</li>
<li>The index ( j ) is bigger than ( i ): ( j &gt; i )</li>
<li>The element at index ( j ) can be divided by the element at index (
i ): ( [j] [i] = 0 )</li>
</ol>
<h3 id="input-and-output">Input and Output</h3>
<ul>
<li><strong>Input</strong>: We have an array of integers.</li>
<li><strong>Output</strong>: We need to give the count of pairs that
meet the rules above.</li>
</ul>
<h3 id="example">Example</h3>
<p>Letâ€™s look at an example with the array ([1, 2, 1, 4, 2]):</p>
<ul>
<li>The valid pairs are:
<ul>
<li>( (0, 2) ): ( [0] = 1 ), ( [2] = 1 )</li>
<li>( (1, 4) ): ( [1] = 2 ), ( [4] = 2 ) and ( 2 = 0 )</li>
</ul></li>
</ul>
<p>So, we can say the output for this example is (2).</p>
<h3 id="constraints">Constraints</h3>
<ul>
<li>The size of the array can be big, so using a brute-force method may
not work well.</li>
<li>We should think about time and space complexity when we make a
solution.</li>
</ul>
<p>This problem is useful in data analysis. It helps us find connections
between elements based on specific rules.</p>
<h2
id="brute-force-approach-to-count-equal-and-divisible-pairs-in-java">Brute
Force Approach to Count Equal and Divisible Pairs in Java</h2>
<p>We can use a brute force method to count equal and divisible pairs in
an array. This means we check each possible pair of elements. For each
pair, we see if the elements are equal or if one can divide the other.
This way of doing things takes time of (O(n^2)), where (n) is the size
of the array.</p>
<h3 id="implementation">Implementation</h3>
<p>Here is a simple code in Java:</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountPairs <span class="op">{</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countEqualAndDivisiblePairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span><span class="fu">length</span><span class="op">;</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> <span class="op">(</span>arr<span class="op">[</span>j<span class="op">]</span> <span class="op">!=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">%</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>                    count<span class="op">++;</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> array <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">};</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> result <span class="op">=</span> <span class="fu">countEqualAndDivisiblePairs</span><span class="op">(</span>array<span class="op">);</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Count of Equal and Divisible Pairs: &quot;</span> <span class="op">+</span> result<span class="op">);</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation">Explanation</h3>
<ul>
<li><strong>Outer Loop</strong>: This goes through each element in the
array.</li>
<li><strong>Inner Loop</strong>: This compares the current element with
all the next elements.</li>
<li><strong>Condition Check</strong>:
<ul>
<li>First, it checks if the two elements are equal.</li>
<li>Then, it checks if the first element can be divided by the second
one. We make sure the second element is not zero to avoid division by
zero.</li>
</ul></li>
</ul>
<h3 id="example-1">Example</h3>
<p>For the input array <code>{1, 2, 3, 4, 2, 2}</code>: - Pairs counted:
- (2, 2) are equal. - (4, 2) since 4 can be divided by 2.</p>
<p>The output will be
<code>Count of Equal and Divisible Pairs: 4</code>.</p>
<p>This brute force way is easy to understand. But it can be slow for
larger arrays because it takes a lot of time. If we want better speed,
we can look for better methods like using a HashMap.</p>
<h2 id="optimized-approach-using-hashmap-in-java">Optimized Approach
Using HashMap in Java</h2>
<p>To count equal and divisible pairs in an array, we can use a
<code>HashMap</code>. It helps us store how many times each number
appears. This way is much faster than using the brute force method.</p>
<h3 id="steps">Steps:</h3>
<ol type="1">
<li><strong>Initialize a HashMap</strong>: This will keep each number in
the array as a key. The value will be how many times that number
appears.</li>
<li><strong>Iterate through the array</strong>: For each number, we will
find out how many pairs we can make. We check both conditions: equal and
divisible.</li>
<li><strong>Count pairs</strong>: For each unique number, we will see
how many pairs we can make based on how many times it appears.</li>
</ol>
<h3 id="java-implementation">Java Implementation:</h3>
<div class="sourceCode" id="cb2"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">import</span> <span class="im">java</span><span class="op">.</span><span class="im">util</span><span class="op">.</span><span class="im">HashMap</span><span class="op">;</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="kw">class</span> CountPairs <span class="op">{</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">int</span> <span class="fu">countEqualAndDivisiblePairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>        <span class="bu">HashMap</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> frequencyMap <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Store frequency of each number</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>            frequencyMap<span class="op">.</span><span class="fu">put</span><span class="op">(</span>num<span class="op">,</span> frequencyMap<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>num<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>        <span class="co">// Calculate pairs</span></span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> key <span class="op">:</span> frequencyMap<span class="op">.</span><span class="fu">keySet</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>            <span class="dt">int</span> freq <span class="op">=</span> frequencyMap<span class="op">.</span><span class="fu">get</span><span class="op">(</span>key<span class="op">);</span></span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Count pairs (nC2) for equal elements</span></span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>            count <span class="op">+=</span> <span class="op">(</span>freq <span class="op">*</span> <span class="op">(</span>freq <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span></span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>            <span class="co">// Count pairs with divisibility</span></span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> otherKey <span class="op">:</span> frequencyMap<span class="op">.</span><span class="fu">keySet</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="op">(</span>key <span class="op">!=</span> otherKey <span class="op">&amp;&amp;</span> otherKey <span class="op">%</span> key <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true" tabindex="-1"></a>                    count <span class="op">+=</span> freq <span class="op">*</span> frequencyMap<span class="op">.</span><span class="fu">get</span><span class="op">(</span>otherKey<span class="op">);</span></span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true" tabindex="-1"></a>                <span class="op">}</span></span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-27"><a href="#cb2-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb2-28"><a href="#cb2-28" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-29"><a href="#cb2-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-30"><a href="#cb2-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">public</span> <span class="dt">static</span> <span class="dt">void</span> <span class="fu">main</span><span class="op">(</span><span class="bu">String</span><span class="op">[]</span> args<span class="op">)</span> <span class="op">{</span></span>
<span id="cb2-31"><a href="#cb2-31" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span><span class="op">[]</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">};</span></span>
<span id="cb2-32"><a href="#cb2-32" aria-hidden="true" tabindex="-1"></a>        <span class="bu">System</span><span class="op">.</span><span class="fu">out</span><span class="op">.</span><span class="fu">println</span><span class="op">(</span><span class="st">&quot;Count of equal and divisible pairs: &quot;</span> <span class="op">+</span> <span class="fu">countEqualAndDivisiblePairs</span><span class="op">(</span>arr<span class="op">));</span></span>
<span id="cb2-33"><a href="#cb2-33" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb2-34"><a href="#cb2-34" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-the-code">Explanation of the Code:</h3>
<ul>
<li>The <code>countEqualAndDivisiblePairs</code> method starts a
<code>HashMap</code> to keep track of how many times each element
appears.</li>
<li>It goes through the array to fill the <code>HashMap</code>.</li>
<li>After that, it counts pairs. First, it counts pairs of equal
numbers. Then, it checks if the unique numbers can divide each
other.</li>
<li>Finally, we return the total count.</li>
</ul>
<p>This method makes the process faster and reduces the time to about
O(n^2) in the worst case. The <code>HashMap</code> helps us count
frequencies easily.</p>
<h2 id="python-implementation-of-count-equal-and-divisible-pairs">Python
Implementation of Count Equal and Divisible Pairs</h2>
<p>We can count equal and divisible pairs in an array using Python. One
simple way is to use a nested loop. This is easy to understand but may
not be the best for large data sets. Here is the Python code:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_equal_and_divisible_pairs(arr, k):</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> <span class="bu">len</span>(arr)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, n):</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> arr[i] <span class="op">==</span> arr[j] <span class="kw">and</span> arr[i] <span class="op">%</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">12</span>]</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_equal_and_divisible_pairs(arr, k)</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Count of equal and divisible pairs:&quot;</span>, result)</span></code></pre></div>
<p>In this function: - <code>arr</code> is the input array. -
<code>k</code> is the number we check for divisibility. - The function
goes through each pair of indices <code>(i, j)</code> where
<code>i is less than j</code>. It checks if the elements are equal and
if they can be divided by <code>k</code>.</p>
<p>If we want to make it faster, we can use a dictionary. This way, we
store how many times each number that can be divided by <code>k</code>
appears. This will help us a lot:</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> optimized_count_equal_and_divisible_pairs(arr, k):</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>    frequency <span class="op">=</span> {}</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> arr:</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">%</span> k <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> num <span class="kw">in</span> frequency:</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> frequency[num]</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>                frequency[num] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>            <span class="cf">else</span>:</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>                frequency[num] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">6</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">12</span>]</span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> optimized_count_equal_and_divisible_pairs(arr, k)</span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Count of equal and divisible pairs:&quot;</span>, result)</span></code></pre></div>
<p>In this better version: - We use a dictionary to track how many times
each number that can divide by <code>k</code> appears. - For each
number, if it is already in the dictionary, we add the current count to
our total count of pairs.</p>
<p>This method works better for big arrays. If you want to learn more,
you can look at other array problems like <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate</a> or <a
href="https://bestonlinetutorial.com/array/array-maximum-subarray-easy.html">Array
Maximum Subarray</a>.</p>
<h2 id="using-collections-and-list-comprehensions-in-python">Using
Collections and List Comprehensions in Python</h2>
<p>In Python, we can use collections and list comprehensions to count
equal and divisible pairs in an array. This way lets us solve the
problem in a simple and effective method.</p>
<h3 id="implementation-using-collections">Implementation Using
Collections</h3>
<p>To count pairs of indices ( (i, j) ) where ( i &lt; j ), the values
are equal ( A[i] = A[j] ), and ( A[j] ) is divisible by ( A[i] ), we can
use the <code>Counter</code> class from the <code>collections</code>
module.</p>
<div class="sourceCode" id="cb5"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> collections <span class="im">import</span> Counter</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_equal_divisible_pairs(arr):</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>    freq <span class="op">=</span> Counter(arr)</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> freq:</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">==</span> <span class="dv">0</span>:  <span class="co"># We skip zero to avoid division by zero</span></span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>            <span class="cf">continue</span></span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Here we calculate pairs where A[j] is divisible by A[i]</span></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key <span class="kw">in</span> freq:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> key <span class="op">%</span> num <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-13"><a href="#cb5-13" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> freq[num] <span class="op">*</span> freq[key]  <span class="co"># We count pairs</span></span>
<span id="cb5-14"><a href="#cb5-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span>
<span id="cb5-15"><a href="#cb5-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-16"><a href="#cb5-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb5-17"><a href="#cb5-17" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>]</span>
<span id="cb5-18"><a href="#cb5-18" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_equal_divisible_pairs(arr)</span>
<span id="cb5-19"><a href="#cb5-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 5</span></span></code></pre></div>
<h3 id="list-comprehensions-for-a-compact-solution">List Comprehensions
for a Compact Solution</h3>
<p>We can also use list comprehensions to count pairs. This way filters
and counts valid pairs directly. Here is how we can do it:</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_equal_divisible_pairs(arr):</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">sum</span>(<span class="dv">1</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(arr)) <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i <span class="op">+</span> <span class="dv">1</span>, <span class="bu">len</span>(arr))</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>               <span class="cf">if</span> arr[i] <span class="op">==</span> arr[j] <span class="kw">and</span> arr[j] <span class="op">%</span> arr[i] <span class="op">==</span> <span class="dv">0</span>)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Example usage</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>arr <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">4</span>]</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>result <span class="op">=</span> count_equal_divisible_pairs(arr)</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(result)  <span class="co"># Output: 5</span></span></code></pre></div>
<p>This method checks all pairs and looks at the conditions. It uses
Pythonâ€™s clear syntax to keep things easy to read and understand.</p>
<p>Using collections and list comprehensions in Python helps us make our
solution clear and also follows Pythonâ€™s style. This makes our code
better and easier to work with.</p>
<h2 id="c-solution-for-counting-equal-and-divisible-pairs">C++ Solution
for Counting Equal and Divisible Pairs</h2>
<p>We can count equal and divisible pairs in an array using C++. We will
use a simple method that goes through the array to find pairs that meet
the conditions.</p>
<h3 id="implementation-1">Implementation</h3>
<p>Here is a C++ solution that counts the number of pairs
<code>(i, j)</code> where <code>arr[i] == arr[j]</code>,
<code>i &lt; j</code>, and also checks if <code>arr[i]</code> is
divisible by <code>arr[j]</code> or the other way around.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countEqualAndDivisiblePairs<span class="op">(</span><span class="at">const</span> vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> arr<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> n <span class="op">=</span> arr<span class="op">.</span>size<span class="op">();</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> n<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> n<span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">&amp;&amp;</span> <span class="op">(</span>arr<span class="op">[</span>i<span class="op">]</span> <span class="op">%</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> arr<span class="op">[</span>j<span class="op">]</span> <span class="op">%</span> arr<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a>    vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> arr <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">8</span><span class="op">};</span></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> result <span class="op">=</span> countEqualAndDivisiblePairs<span class="op">(</span>arr<span class="op">);</span></span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    cout <span class="op">&lt;&lt;</span> <span class="st">&quot;Count of equal and divisible pairs: &quot;</span> <span class="op">&lt;&lt;</span> result <span class="op">&lt;&lt;</span> endl<span class="op">;</span></span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-1">Explanation</h3>
<ul>
<li><strong>Function Definition</strong>: The function
<code>countEqualAndDivisiblePairs</code> takes a list of integers as
input.</li>
<li><strong>Nested Loops</strong>: We use a nested loop to check each
pair of indices <code>(i, j)</code> where <code>i &lt; j</code>.</li>
<li><strong>Condition Check</strong>: The if statement checks if the
numbers are equal and if one is divisible by the other.</li>
<li><strong>Count Variable</strong>: Each time we find a valid pair, we
increase the count.</li>
<li><strong>Output</strong>: We print the result in the main
function.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: O(n^2) because of the nested
loops.</li>
<li><strong>Space Complexity</strong>: O(1) since we use a fixed amount
of space.</li>
</ul>
<p>This C++ code shows well how to count equal and divisible pairs in an
array. It meets the problem needs. For more information on array work
and related problems, we can look at <a
href="https://bestonlinetutorial.com/array/array-remove-duplicates-from-sorted-array-easy.html">Array
Remove Duplicates from Sorted Array</a>.</p>
<h2 id="efficient-use-of-stl-for-counting-in-c">Efficient Use of STL for
Counting in C++</h2>
<p>In C++, we can use the Standard Template Library (STL) to count equal
and divisible pairs in an array. STL helps us solve the problem easier
and faster.</p>
<h3 id="steps-to-implement">Steps to Implement</h3>
<ol type="1">
<li><strong>Count Frequencies</strong>: We will use a
<code>std::unordered_map</code> to keep track of how many times each
element appears in the array.</li>
<li><strong>Count Divisible Pairs</strong>: Next, we will go through the
array. For each element, we will check how many pairs we can make based
on its frequency and divisibility.</li>
</ol>
<h3 id="code-implementation">Code Implementation</h3>
<p>Here is a simple code example in C++:</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;iostream&gt;</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countPairs<span class="op">(</span><span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> freqMap<span class="op">;</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> pairCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Count frequencies of each number</span></span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        freqMap<span class="op">[</span>num<span class="op">]++;</span></span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Count pairs</span></span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>num<span class="op">,</span> count<span class="op">]</span> <span class="op">:</span> freqMap<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>otherNum<span class="op">,</span> otherCount<span class="op">]</span> <span class="op">:</span> freqMap<span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">!=</span> otherNum <span class="op">&amp;&amp;</span> num <span class="op">%</span> otherNum <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>                pairCount <span class="op">+=</span> count <span class="op">*</span> otherCount<span class="op">;</span></span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> pairCount<span class="op">;</span></span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;</span> nums <span class="op">=</span> <span class="op">{</span><span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">6</span><span class="op">};</span></span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a>    <span class="bu">std::</span>cout<span class="op"> &lt;&lt;</span> <span class="st">&quot;Count of equal and divisible pairs: &quot;</span> <span class="op">&lt;&lt;</span> countPairs<span class="op">(</span>nums<span class="op">)</span> <span class="op">&lt;&lt;</span> <span class="bu">std::</span>endl<span class="op">;</span></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="explanation-of-code">Explanation of Code</h3>
<ul>
<li><strong>Frequency Map</strong>: The <code>unordered_map</code>
<code>freqMap</code> holds each number and how many times it
appears.</li>
<li><strong>Nested Iteration</strong>: The first loop goes through each
unique number. The second loop looks for pairs that fit the divisibility
rule.</li>
<li><strong>Count Calculation</strong>: If we find a divisible pair, we
add the product of their frequencies to the total pair count.</li>
</ul>
<h3 id="benefits-of-using-stl">Benefits of Using STL</h3>
<ul>
<li><strong>Efficiency</strong>: It helps us avoid using too many nested
loops. This makes our code run faster.</li>
<li><strong>Simplicity</strong>: The code is easier to read and
manage.</li>
<li><strong>Flexibility</strong>: It can work with different data types
and conditions easily.</li>
</ul>
<p>Using STL in C++ to count equal and divisible pairs in an array helps
us make the solution better and faster.</p>
<h2 id="comparative-analysis-of-different-approaches">Comparative
Analysis of Different Approaches</h2>
<p>When we solve the problem of counting equal and divisible pairs in an
array, we can use different methods. Each method has its own pros and
cons, especially in time complexity and how easy it is to use. Here, we
will look at the brute force method and the optimized method using
HashMap in Java. We will also see how to do this in Python and C++.</p>
<h3 id="brute-force-approach">Brute Force Approach</h3>
<p>The brute force way uses two loops. Each loop checks every pair of
elements in the array. This method has a time complexity of O(n^2).</p>
<div class="sourceCode" id="cb9"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countEqualDivisiblePairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> j <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> j <span class="op">&lt;</span> nums<span class="op">.</span><span class="fu">length</span><span class="op">;</span> j<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> nums<span class="op">[</span>j<span class="op">]</span> <span class="op">||</span> <span class="op">(</span>nums<span class="op">[</span>i<span class="op">]</span> <span class="op">%</span> nums<span class="op">[</span>j<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span> <span class="op">||</span> <span class="op">(</span>nums<span class="op">[</span>j<span class="op">]</span> <span class="op">%</span> nums<span class="op">[</span>i<span class="op">]</span> <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>                count<span class="op">++;</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="optimized-approach-using-hashmap">Optimized Approach Using
HashMap</h3>
<p>The HashMap method is better. It lowers the time complexity to O(n)
by keeping track of counts of elements. Then we check pairs based on
their counts. This works much better for larger arrays.</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode java"><code class="sourceCode java"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">public</span> <span class="dt">int</span> <span class="fu">countEqualDivisiblePairs</span><span class="op">(</span><span class="dt">int</span><span class="op">[]</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="bu">Map</span><span class="op">&lt;</span><span class="bu">Integer</span><span class="op">,</span> <span class="bu">Integer</span><span class="op">&gt;</span> map <span class="op">=</span> <span class="kw">new</span> <span class="bu">HashMap</span><span class="op">&lt;&gt;();</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>        map<span class="op">.</span><span class="fu">put</span><span class="op">(</span>num<span class="op">,</span> map<span class="op">.</span><span class="fu">getOrDefault</span><span class="op">(</span>num<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">+</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> map<span class="op">.</span><span class="fu">keySet</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> freq <span class="op">=</span> map<span class="op">.</span><span class="fu">get</span><span class="op">(</span>num<span class="op">);</span></span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="op">(</span>freq <span class="op">*</span> <span class="op">(</span>freq <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Count equal pairs</span></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> key <span class="op">:</span> map<span class="op">.</span><span class="fu">keySet</span><span class="op">())</span> <span class="op">{</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">!=</span> key <span class="op">&amp;&amp;</span> <span class="op">(</span>num <span class="op">%</span> key <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> key <span class="op">%</span> num <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> freq <span class="op">*</span> map<span class="op">.</span><span class="fu">get</span><span class="op">(</span>key<span class="op">);</span> <span class="co">// Count divisible pairs</span></span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="python-implementation">Python Implementation</h3>
<p>In Python, we use dictionaries. The logic is similar to the HashMap
method in Java.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_equal_divisible_pairs(nums):</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>    freq_map <span class="op">=</span> {}</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num <span class="kw">in</span> nums:</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>        freq_map[num] <span class="op">=</span> freq_map.get(num, <span class="dv">0</span>) <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> num, freq <span class="kw">in</span> freq_map.items():</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> (freq <span class="op">*</span> (freq <span class="op">-</span> <span class="dv">1</span>)) <span class="op">//</span> <span class="dv">2</span>  <span class="co"># Equal pairs</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> key, key_freq <span class="kw">in</span> freq_map.items():</span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> num <span class="op">!=</span> key <span class="kw">and</span> (num <span class="op">%</span> key <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> key <span class="op">%</span> num <span class="op">==</span> <span class="dv">0</span>):</span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> freq <span class="op">*</span> key_freq  <span class="co"># Divisible pairs</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count</span></code></pre></div>
<h3 id="c-solution">C++ Solution</h3>
<p>The C++ version also uses unordered_map for speed.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;unordered_map&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;vector&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> std<span class="op">;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> countEqualDivisiblePairs<span class="op">(</span>vector<span class="op">&lt;</span><span class="dt">int</span><span class="op">&gt;&amp;</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>    unordered_map<span class="op">&lt;</span><span class="dt">int</span><span class="op">,</span> <span class="dt">int</span><span class="op">&gt;</span> freq_map<span class="op">;</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> num <span class="op">:</span> nums<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>        freq_map<span class="op">[</span>num<span class="op">]++;</span></span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-13"><a href="#cb12-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>num<span class="op">,</span> freq<span class="op">]</span> <span class="op">:</span> freq_map<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-14"><a href="#cb12-14" aria-hidden="true" tabindex="-1"></a>        count <span class="op">+=</span> <span class="op">(</span>freq <span class="op">*</span> <span class="op">(</span>freq <span class="op">-</span> <span class="dv">1</span><span class="op">))</span> <span class="op">/</span> <span class="dv">2</span><span class="op">;</span> <span class="co">// Equal pairs</span></span>
<span id="cb12-15"><a href="#cb12-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> <span class="op">(</span><span class="kw">auto</span><span class="op">&amp;</span> <span class="op">[</span>key<span class="op">,</span> key_freq<span class="op">]</span> <span class="op">:</span> freq_map<span class="op">)</span> <span class="op">{</span></span>
<span id="cb12-16"><a href="#cb12-16" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="op">(</span>num <span class="op">!=</span> key <span class="op">&amp;&amp;</span> <span class="op">(</span>num <span class="op">%</span> key <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> key <span class="op">%</span> num <span class="op">==</span> <span class="dv">0</span><span class="op">))</span> <span class="op">{</span></span>
<span id="cb12-17"><a href="#cb12-17" aria-hidden="true" tabindex="-1"></a>                count <span class="op">+=</span> freq <span class="op">*</span> key_freq<span class="op">;</span> <span class="co">// Divisible pairs</span></span>
<span id="cb12-18"><a href="#cb12-18" aria-hidden="true" tabindex="-1"></a>            <span class="op">}</span></span>
<span id="cb12-19"><a href="#cb12-19" aria-hidden="true" tabindex="-1"></a>        <span class="op">}</span></span>
<span id="cb12-20"><a href="#cb12-20" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb12-21"><a href="#cb12-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-22"><a href="#cb12-22" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> count<span class="op">;</span></span>
<span id="cb12-23"><a href="#cb12-23" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h3 id="performance-comparison">Performance Comparison</h3>
<ul>
<li><strong>Brute Force</strong>: O(n^2) time complexity. It is easy to
use but slow for large arrays.</li>
<li><strong>HashMap/Dictionary</strong>: O(n) time complexity. It is
much faster by counting frequencies.</li>
<li><strong>Language Performance</strong>: All methods are similar in
logic. But speed can change based on how each language works and what
data structure we use.</li>
</ul>
<p>This analysis shows that using a HashMap is better than brute force
methods for counting equal and divisible pairs in an array. This
knowledge helps us choose the right method based on our needs and the
input size.</p>
<p>For more insights on array problems, check out <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum - Easy</a> and <a
href="https://bestonlinetutorial.com/array/array-contains-duplicate-easy.html">Array
Contains Duplicate - Easy</a>.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3
id="what-is-the-problem-of-counting-equal-and-divisible-pairs-in-an-array">1.
What is the problem of counting equal and divisible pairs in an
array?</h3>
<p>Counting equal and divisible pairs in an array means we find pairs of
indices <code>(i, j)</code>. Here, <code>array[i]</code> is equal to
<code>array[j]</code> and <code>i</code> is not the same as
<code>j</code>. Also, <code>array[i]</code> must divide
<code>array[j]</code> without any remainder. This problem is common in
coding challenges. It can help us understand how to work with arrays and
count pairs better.</p>
<h3
id="how-can-i-optimize-counting-equal-and-divisible-pairs-in-java">2.
How can I optimize counting equal and divisible pairs in Java?</h3>
<p>To make counting equal and divisible pairs faster in Java, we can use
a <code>HashMap</code>. This helps us keep track of how many times each
number appears in the array. With this, we can get counts quickly and
check for divisibility fast. This method works better than a simple
brute-force way, especially when we have big data sets.</p>
<h3
id="is-there-a-python-implementation-for-counting-equal-and-divisible-pairs">3.
Is there a Python implementation for counting equal and divisible
pairs?</h3>
<p>Yes, we can count equal and divisible pairs in Python. We can use
list comprehensions and the <code>collections</code> module. By using
Pythonâ€™s built-in tools, we can make a solution that is simple and
quick. Using a dictionary to count can also help us make the code even
faster.</p>
<h3
id="what-are-common-approaches-to-solve-the-equal-and-divisible-pairs-problem-in-c">4.
What are common approaches to solve the equal and divisible pairs
problem in C++?</h3>
<p>In C++, we can use the Standard Template Library (STL) to solve the
equal and divisible pairs problem well. Data structures like
<code>unordered_map</code> let us look up and count quickly. By
combining STL algorithms and data structures, we can make our solution
better. It will be more elegant and faster.</p>
<h3
id="how-does-the-brute-force-approach-compare-to-optimized-methods-for-this-problem">5.
How does the brute force approach compare to optimized methods for this
problem?</h3>
<p>The brute force approach for counting equal and divisible pairs uses
nested loops. This gives us a time complexity of O(nÂ²). This is not good
for big arrays. On the other hand, optimized methods with hash maps can
reduce the complexity to O(n). This makes them better for programs that
need speed. We need to understand these differences for good coding
practices.</p>
<p>Feel free to look at related ideas and problems, like <a
href="https://bestonlinetutorial.com/array/array-two-sum-easy.html">Array
Two Sum</a> or <a
href="https://bestonlinetutorial.com/array/array-majority-element-easy.html">Finding
the Majority Element</a>. This will help us learn more about arrays and
how to make them work better.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            