
    
            <!DOCTYPE html>
        <html lang="en">

        <head>
            <!-- Google tag (gtag.js) -->
            <script async src="https://www.googletagmanager.com/gtag/js?id=G-TFCQEJR7TD"></script>
            <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', 'G-TFCQEJR7TD');
            </script>
            <meta charset="utf-8">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            
            <meta property="og:title" content="How Do SCAN and KEYS Perform in Redis?" />
            <meta property="og:description" content="Discover how SCAN and KEYS commands work in Redis, their performance impact, and best practices for efficient data retrieval." />
            <meta property="og:url" content="https://www.bestonlinetutorial.com/redis/how-do-scan-and-keys-perform-in-redis.html" />
            <link rel="canonical" href="https://www.bestonlinetutorial.com/redis/how-do-scan-and-keys-perform-in-redis.html">
            <meta property="og:type" content="article" />
            <meta property="og:site_name" content=“BestOnlineTutorial” />
            <meta name="twitter:title" content="How Do SCAN and KEYS Perform in Redis?" />
            <meta name="twitter:description" content="Discover how SCAN and KEYS commands work in Redis, their performance impact, and best practices for efficient data retrieval." />
            <meta name="pinterest-rich-pin" content="true" />

            <script type="application/ld+json">
                {
                "@context": "https://schema.org",
                "@type": "WebSite",
                "name": "BestOnlineTutorial",
                "url": "https://www.bestonlinetutorial.com/"
                }
            </script>
            <!-- Common CSS & Icons -->
            <link rel="icon" href="/favicon.ico" type="image/x-icon">
            <link rel="stylesheet" href="/assets/plugins/highlight/styles/monokai-sublime.css">
            <link id="theme-style" rel="stylesheet" href="/assets/css/theme-8.css">
            <link rel="stylesheet" href="/assets/css/post.css">
            <title>How Do SCAN and KEYS Perform in Redis?</title>
            <meta name="description" content="Discover how SCAN and KEYS commands work in Redis, their performance impact, and best practices for efficient data retrieval.">
            <script src="https://code.jquery.com/jquery-3.6.0.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
	        <script src="/assets/js/blog.js"></script>
        </head>

        <body>

            <div id="header-placeholder"></div>

            <div class="main-wrapper">

                <article class="blog-post px-3 py-5 p-md-5">
                    <div class="container single-col-max-width">
                        <header class="blog-post-header">
                            <h1 class="title mb-2">How Do SCAN and KEYS Perform in Redis?</h1>
                        </header>

                        <div class="blog-post-body">
                            <p>In Redis, the SCAN and KEYS commands have different purposes when we
want to get keys from the database. The SCAN command helps us
efficiently get keys without stopping the server. This makes it a good
choice for production environments. On the other hand, the KEYS command
gets all keys that match a certain pattern. But it can cause performance
issues, especially with large datasets because it blocks the server. So,
it is important for us to know how SCAN and KEYS work in Redis. This
helps us improve our data retrieval methods.</p>
<p>In this article, we will look at the performance differences between
SCAN and KEYS in Redis. We will explain how the SCAN command works. We
will also talk about the problems that come with using KEYS. We will
guide you on when to pick SCAN over KEYS. Additionally, we will share
tips on how to use SCAN better in your Redis setup. Here is what we will
cover:</p>
<ul>
<li>Performance differences between SCAN and KEYS in Redis</li>
<li>How the SCAN command works in Redis</li>
<li>Problems with using KEYS in Redis</li>
<li>When to use SCAN instead of KEYS in Redis</li>
<li>Tips for using SCAN in Redis</li>
<li>Common questions about SCAN and KEYS in Redis</li>
</ul>
<h2
id="understanding-the-performance-differences-between-scan-and-keys-in-redis">Understanding
the Performance Differences Between SCAN and KEYS in Redis</h2>
<p>In Redis, we use both the <code>SCAN</code> and <code>KEYS</code>
commands to get keys from the database. But these two commands work very
differently, especially when we have a lot of data.</p>
<h3 id="keys-command">KEYS Command</h3>
<ul>
<li><strong>Functionality</strong>: The <code>KEYS</code> command gets
all keys that match a pattern we choose.</li>
<li><strong>Performance</strong>: It checks all keys in the database.
This can be slow and can block other tasks. If we have a big dataset, it
can slow down the system and stop other commands from running.</li>
<li><strong>Example</strong>: <code>bash     KEYS pattern*</code></li>
</ul>
<h3 id="scan-command">SCAN Command</h3>
<ul>
<li><strong>Functionality</strong>: The <code>SCAN</code> command looks
through the keys bit by bit and gives us a few keys at a time.</li>
<li><strong>Performance</strong>: It does not block the system. Redis
can keep working on other commands while using <code>SCAN</code>. This
is better for big datasets. We can use it many times to get results in
smaller parts.</li>
<li><strong>Example</strong>:
<code>bash     SCAN 0 MATCH pattern* COUNT 100</code></li>
</ul>
<h3 id="key-differences">Key Differences</h3>
<ul>
<li><strong>Blocking vs. Non-blocking</strong>: <code>KEYS</code> can
block the Redis instance and freeze it. But <code>SCAN</code> does not
block.</li>
<li><strong>Memory Usage</strong>: <code>KEYS</code> uses a lot of
memory because it gives us all matching keys at once. On the other hand,
<code>SCAN</code> uses less memory since it returns only some keys.</li>
<li><strong>Use Case</strong>: We can use <code>KEYS</code> for small
datasets or when we do maintenance. It is better to use
<code>SCAN</code> in production where performance and quick response are
very important.</li>
</ul>
<p>For more about using Redis commands and learning about its data
types, we can check <a
href="https://bestonlinetutorial.com/redis/what-are-redis-data-types.html">this
article</a>.</p>
<h2 id="how-does-the-scan-command-work-in-redis">How Does the SCAN
Command Work in Redis?</h2>
<p>The SCAN command in Redis helps us go through a collection of keys in
the database without stopping the server. This command is helpful for
large datasets. Using the KEYS command to get all keys at once can be
slow and hurt performance.</p>
<h3 id="basic-usage">Basic Usage</h3>
<p>The SCAN command has this syntax:</p>
<pre><code>SCAN cursor [MATCH pattern] [COUNT count]</code></pre>
<p><strong>Parameters:</strong> - <code>cursor</code>: This is a number
that shows our position in the iteration. We start with <code>0</code>.
The next call will use the cursor we got from the last call. -
<code>MATCH pattern</code>: This is an optional part. It helps us filter
the keys we want. We can use glob-style patterns like
<code>user:*</code>. - <code>COUNT count</code>: This is also optional.
It tells Redis how many keys to return each time (default is 10).</p>
<h3 id="example">Example</h3>
<p>Here is a simple example of using the SCAN command in Redis:</p>
<div class="sourceCode" id="cb2"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Initial scan</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="ex">127.0.0.1:6379</span><span class="op">&gt;</span> SCAN 0</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="ex">1</span><span class="er">)</span> <span class="st">&quot;cursor_value&quot;</span>  <span class="co"># This cursor is for the next time we scan</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="ex">2</span><span class="er">)</span> <span class="ex">1</span><span class="er">)</span> <span class="st">&quot;key1&quot;</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>   <span class="ex">2</span><span class="er">)</span> <span class="st">&quot;key2&quot;</span></span></code></pre></div>
<p>To keep going, we use the cursor we received:</p>
<div class="sourceCode" id="cb3"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Continue scanning using the cursor returned</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="ex">127.0.0.1:6379</span><span class="op">&gt;</span> SCAN cursor_value</span></code></pre></div>
<h3 id="performance-characteristics">Performance Characteristics</h3>
<ul>
<li><strong>Non-blocking</strong>: SCAN does not lock the Redis server.
This way, other commands can run at the same time.</li>
<li><strong>Incremental</strong>: It might give us fewer keys than we
asked for. This is a “best effort” method, and we can change it with the
COUNT parameter.</li>
</ul>
<h3 id="important-notes">Important Notes</h3>
<ul>
<li>The SCAN command can show the same key more than once if the dataset
changes while we are scanning.</li>
<li>We should always check the cursor we get back. If it returns to
<code>0</code>, it means the scan is done.</li>
</ul>
<h3 id="when-to-use-scan">When to Use SCAN</h3>
<p>We use SCAN when we need to get keys from a large dataset without
slowing down our Redis server. SCAN is good for:</p>
<ul>
<li>Background tasks that need to work on keys in groups.</li>
<li>Applications that want to load keys only when needed.</li>
</ul>
<p>For more details about Redis commands and how they work, we can look
at the <a
href="https://bestonlinetutorial.com/redis/what-is-redis.html">Redis
documentation</a>.</p>
<h2 id="what-are-the-limitations-of-using-keys-in-redis">What Are the
Limitations of Using KEYS in Redis?</h2>
<p>The <code>KEYS</code> command in Redis helps us find keys that match
a certain pattern. But it has some limits and problems. These make it
not so good for real use, especially when we have a lot of data.</p>
<ol type="1">
<li><p><strong>Performance Issues</strong>:<br />
The <code>KEYS</code> command looks at all keys and gives back the ones
that match. This can make the system slow, especially when we have many
keys. It can stop the server for a long time and cause delays.</p>
<div class="sourceCode" id="cb4"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ex">KEYS</span> pattern<span class="pp">*</span></span></code></pre></div></li>
<li><p><strong>Blocking Nature</strong>:<br />
Because <code>KEYS</code> checks everything, it can stop other tasks
from running. This can make things slow and might cause timeouts for
other users who want to use the Redis server while it is
scanning.</p></li>
<li><p><strong>Memory Consumption</strong>:<br />
When we have many keys, Redis uses a lot of memory to keep all matching
keys before it sends them back. If we have too much data, this can cause
out-of-memory errors.</p></li>
<li><p><strong>Not Suitable for Production</strong>:<br />
Because of its slow performance and blocking nature, we usually do not
use <code>KEYS</code> in real environments. It is better to use commands
like <code>SCAN</code>, which look through keys step by step without
stopping the server.</p></li>
<li><p><strong>Limited Use Case</strong>:<br />
The <code>KEYS</code> command is mostly good for debugging or managing
tasks. It is not so good for getting keys in applications. Using
<code>KEYS</code> in active apps can cause problems with
growth.</p></li>
<li><p><strong>Lack of Pagination</strong>:<br />
Unlike <code>SCAN</code>, the <code>KEYS</code> command does not have
pagination. This makes it hard to work with big sets of results in a
good way.</p></li>
</ol>
<p>In short, while the <code>KEYS</code> command can help in some
situations, its limits make it not the best choice for apps that need to
be fast and grow. For better and safer key retrieval, we should think
about using the <code>SCAN</code> command. For more details about Redis
commands and how to use them, check <a
href="https://bestonlinetutorial.com/redis/what-is-redis.html">what is
Redis</a>.</p>
<h2 id="when-should-you-use-scan-instead-of-keys-in-redis">When Should
You Use SCAN Instead of KEYS in Redis?</h2>
<p>We should use <code>SCAN</code> instead of <code>KEYS</code> in Redis
when we have large datasets. It helps us keep performance and stability
in our applications. The <code>KEYS</code> command gets all keys that
match a pattern. But it does this in a blocking way. This can slow down
performance and stop other operations from running, especially in
production.</p>
<h3 id="use-cases-for-scan">Use Cases for SCAN</h3>
<ul>
<li><p><strong>Large Datasets</strong>: When we have a large dataset,
like millions of keys, <code>SCAN</code> is better. It gives us a small
number of keys at a time. This way, it does not block the
server.</p></li>
<li><p><strong>Non-blocking Operations</strong>: <code>SCAN</code> lets
other commands run while it works. This is good for places where we need
low latency.</p></li>
<li><p><strong>Incremental Processing</strong>: If we want to process
keys a few at a time without loading all of them into memory,
<code>SCAN</code> is perfect.</p></li>
</ul>
<h3 id="example-usage">Example Usage</h3>
<div class="sourceCode" id="cb5"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">SCAN</span> 0 MATCH user:<span class="pp">*</span> COUNT 100</span></code></pre></div>
<p>This command starts scanning from cursor <code>0</code>. It looks for
keys that begin with <code>user:</code> and gives us up to
<code>100</code> keys each time.</p>
<h3 id="performance-considerations">Performance Considerations</h3>
<ol type="1">
<li><p><strong>Cursor-based Iteration</strong>: <code>SCAN</code> uses a
cursor that comes back with each call. This helps us continue scanning
from where we stopped.</p></li>
<li><p><strong>Memory Efficiency</strong>: Because <code>SCAN</code>
does not load all keys at once, it uses much less memory. This is very
important in busy systems.</p></li>
<li><p><strong>Avoiding Blocking</strong>: Unlike <code>KEYS</code>,
which can block the server for a long time, <code>SCAN</code> reduces
the effect on other operations.</p></li>
</ol>
<p>For more details about Redis commands and how to use them, we can
check <a
href="https://bestonlinetutorial.com/redis/what-are-redis-data-types.html">this
guide on Redis data types</a>.</p>
<h2 id="how-can-you-optimize-scan-usage-in-redis">How Can You Optimize
SCAN Usage in Redis?</h2>
<p>Optimizing the SCAN command in Redis is very important for keeping
good performance. This is especially true when we work with big
datasets. Here are some simple tips to make SCAN work better:</p>
<ol type="1">
<li><p><strong>Batch Processing</strong>: We should not fetch all keys
at once. Instead, we can use the count option to decide how many keys we
want to get each time. This helps to lower the load on the Redis
server.</p>
<div class="sourceCode" id="cb6"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="ex">SCAN</span> 0 COUNT 100</span></code></pre></div></li>
<li><p><strong>Use Cursor Properly</strong>: It is important to always
use the cursor that the SCAN command gives us. This way, we can continue
scanning from where we stopped last time. This stops us from missing
keys or getting the same keys again.</p>
<div class="sourceCode" id="cb7"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="bu">let</span> <span class="va">cursor</span> <span class="op">=</span> <span class="dv">0</span><span class="kw">;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="cf">do</span> <span class="kw">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">const</span> result = redis.scan<span class="er">(</span><span class="ex">cursor,</span> <span class="st">&#39;MATCH&#39;</span>, <span class="st">&#39;pattern:*&#39;</span>, <span class="st">&#39;COUNT&#39;</span>, 100<span class="kw">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>    <span class="ex">cursor</span> = result<span class="pp">[</span><span class="ss">0</span><span class="pp">]</span><span class="kw">;</span> <span class="ex">//</span> update cursor for next time</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">const</span> keys = result<span class="pp">[</span><span class="ss">1</span><span class="pp">]</span><span class="kw">;</span> <span class="ex">//</span> process keys</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="kw">}</span> <span class="cf">while</span> <span class="kw">(</span><span class="ex">cursor</span> !== <span class="st">&#39;0&#39;</span><span class="kw">);</span></span></code></pre></div></li>
<li><p><strong>Limit Result Set</strong>: We can use the
<code>MATCH</code> option to find keys that fit a specific pattern. This
way, we scan fewer keys and make the operation faster.</p>
<div class="sourceCode" id="cb8"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ex">SCAN</span> 0 MATCH user:<span class="pp">*</span> COUNT 100</span></code></pre></div></li>
<li><p><strong>Parallel SCAN</strong>: If our dataset is big, we can run
several SCAN commands at the same time with different cursors. This will
make getting keys faster.</p></li>
<li><p><strong>Avoid SCAN in Production</strong>: If our app needs to
look up keys often, we should think about keeping a list of keys or
using sets or hashes to manage data. Relying only on SCAN is not always
the best choice.</p></li>
<li><p><strong>Monitor Performance</strong>: We can use Redis monitoring
tools. These tools help us see how SCAN commands affect performance. We
should adjust our usage based on what we find.</p></li>
<li><p><strong>Use Redis Modules</strong>: We can check out Redis
modules like RediSearch. These special tools can help us query big
datasets more efficiently.</p></li>
<li><p><strong>Configuration Optimization</strong>: We should tune Redis
settings like <code>maxmemory-policy</code> and
<code>active-expire-effort</code>. This helps ensure that memory
management does not slow down SCAN.</p></li>
</ol>
<p>By using these tips, we can make SCAN work better in Redis. This
helps us find keys efficiently while keeping the server load and delay
low. For more information about Redis, we can look at <a
href="https://bestonlinetutorial.com/redis/how-do-i-monitor-redis-performance.html">how
to monitor Redis performance</a>. This can help us improve our Redis
operations.</p>
<h2 id="frequently-asked-questions">Frequently Asked Questions</h2>
<h3 id="what-is-the-difference-between-scan-and-keys-in-redis">1. What
is the difference between SCAN and KEYS in Redis?</h3>
<p>We use SCAN and KEYS to get keys from a Redis database. KEYS gets all
keys that match a pattern all at once. This can slow things down if we
have a lot of data. On the other hand, SCAN uses a cursor to get keys
little by little. This way, it does not block other tasks. So, SCAN is
better for production situations. For more details, see our guide on <a
href="https://bestonlinetutorial.com/redis/how-do-i-optimize-redis-performance.html">Redis
performance optimization</a>.</p>
<h3 id="when-should-i-prefer-scan-over-keys-in-redis">2. When should I
prefer SCAN over KEYS in Redis?</h3>
<p>You should use SCAN instead of KEYS when you work with big datasets
or in production settings where speed and stability matter. SCAN lets us
look at keys in small groups. This helps to save memory and stops long
waiting times that can happen with KEYS. SCAN is great for apps that
need to be fast and always available.</p>
<h3 id="are-there-any-limitations-to-using-the-keys-command-in-redis">3.
Are there any limitations to using the KEYS command in Redis?</h3>
<p>Yes, KEYS can cause issues in Redis. It gets all keys that match a
pattern in one go. This can slow down performance a lot, especially if
there are many keys. KEYS blocks other tasks while it runs. So, it is
better to use SCAN to keep performance good and avoid downtime.</p>
<h3 id="how-can-i-optimize-the-usage-of-the-scan-command-in-redis">4.
How can I optimize the usage of the SCAN command in Redis?</h3>
<p>To make SCAN work better in Redis, we should use a good increment
value. This helps balance performance and memory use. We can change the
COUNT setting to control how many keys we get each time. Also, we should
add logic in our app to handle partial results well and to manage the
cursor that SCAN gives us. For more tips, check our article on <a
href="https://bestonlinetutorial.com/redis/how-do-i-optimize-redis-performance.html">optimizing
Redis performance</a>.</p>
<h3 id="can-i-use-scan-to-delete-keys-in-redis">5. Can I use SCAN to
delete keys in Redis?</h3>
<p>SCAN does not delete keys by itself. But we can use it with the DEL
command to remove keys one by one. We can use SCAN to find keys that
match and then use DEL for each key. This way, we can delete keys
without blocking the Redis server. But we need to be careful about race
conditions and make sure our app logic handles this right. For more on
key management, see our guide on <a
href="https://bestonlinetutorial.com/redis/how-do-i-delete-everything-in-redis-redis.html">clearing
keys in Redis</a>.</p>

                        </div>

                    </div>
                    <!--//container-->
                </article>

            </div>
            <!--//main-wrapper-->

            <div id="footer-placeholder"></div>

            <!-- Javascript -->
            <script src="/assets/plugins/popper.min.js" defer></script>
            <script src="/assets/plugins/bootstrap/js/bootstrap.min.js" defer></script>
            <script src="/assets/fontawesome/js/all.min.js" defer></script>
        </body>

        </html>
            
            